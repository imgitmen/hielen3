{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"HIELEN Prototipazione degli elementi prototypes Api dedicata alle tipologie di elementi e alle azioni (di input) specifiche. Le azioni sono statiche, nel senso che devono essere approntate in modo programmatico. Attualmente sono: config feed Ci\u00f2 che \u00e8 dinaminco \u00e8 il modo in cui le singole tipologie implementano queste azioni. Questa api serve a conoscere i campi da presentare in front-end all'utente per comporre la maschera di azione. POST {uri}/prototypes GET {uri}/prototypes GET {uri}/prototypes/{type} GET {uri}/prototypes/{type}/forms GET {uri}/prototypes/{type}/forms/{form} tutte le UI create in questo modo saranno aperte su uno specifico elemento del sistema il cui codice \u00e8 noto. Il submit della form invier\u00e0 le informazioni ad una url di questo genere: {uri}/actions/{el}/{action} con un mimetype di tipo multipart/form-data Manipolazione elenco elementi elements Api dedicata agli elementi del sistema: il succo della faccenda. Considerazione: gli elementi sono oggetti che producono \"elaborazioni\" nel tempo con un caratteristico grado dimensionale (dato, mappe, nuvole). E' sempre possibile \"proiettare\" una \"elaborazione\" con grado maggiore su una di grado inferiore. Cos\u00ec da una nuvola pu\u00f2 generare mappe e dalla nuvola o dalle mappe possono essere estratte delle serie storiche. nota 1 : Nelle api di input/output non viene mai specificato il tipo dell'elemento. Questo perch\u00e8: 1. Ad ogni elemento DEVE corrispondere Uno ed Un solo tipo. Questa non \u00e8 una restrizione troppo forzata perch\u00e8 \u00e8 sempre possibile definiere elementi nuovi spazialmente coincidenti. 2. Per il motivo precedente il back-end \u00e8 sempre in grado di recuperare il tipo dell'elemento. nota 2 : La \"mappa degli strumenti\" pu\u00f2 essere considerata essa stessa un elemento di tipo mappa... POST {uri}/elements/ GET {uri}/elements/ GET {uri}/elements/{el} DELETE {uri}/elements/{el} PUT {uri}/elements/{el} Interrogazione elementi: operazioni di output L'interrogazione pu\u00f2 riguardare pi\u00f9 di un elemento contemporaneamente ed \u00e8 rivolta in questo modo: sitema --> utente Per questo motivo la struttura della richiesta prevede di specificare prima l'azione ( base , timeline , series , map , cloud ) e poi eventualmente l'elemento. nota 1 : non tutte queste api saranno disponibili per tutti gli elementi. Per ogni elemento sar\u00e0 noto l'elenco a disposizone tramite backend (presumibilemnte attraverso GET {uri}/elements/[{el}]) series GET {uri}/data GET {uri}/data/{el} GET {uri}/data/{el}/{param} bases GET {uri}/bases GET {uri}/bases/{el} timelines GET {uri}/timelines GET {uri}/timelines/{el} maps GET {uri}/maps/[/z/x/y] GET {uri}/maps/{el}/[z/x/y] clouds GET {uri}/clouds GET {uri}/clouds/{el} Azioni sugli elementi: operazioni di input In questo caso le azioni servono a modificare lo stato di un elemento: sistema <-- utente la richiesta viene composta specificando necessariamente l'elemento prima dell'azione. nota 1 : queste trovano riscontro nell'endpoint forms dell'api prototypes. actions Le due azioni attualemente previste sono: config POST {uri}/actions/{el}/config GET {uri}/actions/{el}/config PUT {uri}/actions/{el}/config feed POST {uri}/actions/{el}/feed GET {uri}/actions/{el}/feed PUT {uri}/actions/{el}/feed/{time}","title":"Home"},{"location":"#hielen","text":"","title":"HIELEN"},{"location":"#prototipazione-degli-elementi","text":"","title":"Prototipazione degli elementi"},{"location":"#prototypes","text":"Api dedicata alle tipologie di elementi e alle azioni (di input) specifiche. Le azioni sono statiche, nel senso che devono essere approntate in modo programmatico. Attualmente sono: config feed Ci\u00f2 che \u00e8 dinaminco \u00e8 il modo in cui le singole tipologie implementano queste azioni. Questa api serve a conoscere i campi da presentare in front-end all'utente per comporre la maschera di azione. POST {uri}/prototypes GET {uri}/prototypes GET {uri}/prototypes/{type} GET {uri}/prototypes/{type}/forms GET {uri}/prototypes/{type}/forms/{form} tutte le UI create in questo modo saranno aperte su uno specifico elemento del sistema il cui codice \u00e8 noto. Il submit della form invier\u00e0 le informazioni ad una url di questo genere: {uri}/actions/{el}/{action} con un mimetype di tipo multipart/form-data","title":"prototypes"},{"location":"#manipolazione-elenco-elementi","text":"","title":"Manipolazione elenco elementi"},{"location":"#elements","text":"Api dedicata agli elementi del sistema: il succo della faccenda. Considerazione: gli elementi sono oggetti che producono \"elaborazioni\" nel tempo con un caratteristico grado dimensionale (dato, mappe, nuvole). E' sempre possibile \"proiettare\" una \"elaborazione\" con grado maggiore su una di grado inferiore. Cos\u00ec da una nuvola pu\u00f2 generare mappe e dalla nuvola o dalle mappe possono essere estratte delle serie storiche. nota 1 : Nelle api di input/output non viene mai specificato il tipo dell'elemento. Questo perch\u00e8: 1. Ad ogni elemento DEVE corrispondere Uno ed Un solo tipo. Questa non \u00e8 una restrizione troppo forzata perch\u00e8 \u00e8 sempre possibile definiere elementi nuovi spazialmente coincidenti. 2. Per il motivo precedente il back-end \u00e8 sempre in grado di recuperare il tipo dell'elemento. nota 2 : La \"mappa degli strumenti\" pu\u00f2 essere considerata essa stessa un elemento di tipo mappa... POST {uri}/elements/ GET {uri}/elements/ GET {uri}/elements/{el} DELETE {uri}/elements/{el} PUT {uri}/elements/{el}","title":"elements"},{"location":"#interrogazione-elementi-operazioni-di-output","text":"L'interrogazione pu\u00f2 riguardare pi\u00f9 di un elemento contemporaneamente ed \u00e8 rivolta in questo modo: sitema --> utente Per questo motivo la struttura della richiesta prevede di specificare prima l'azione ( base , timeline , series , map , cloud ) e poi eventualmente l'elemento. nota 1 : non tutte queste api saranno disponibili per tutti gli elementi. Per ogni elemento sar\u00e0 noto l'elenco a disposizone tramite backend (presumibilemnte attraverso GET {uri}/elements/[{el}])","title":"Interrogazione elementi: operazioni di output"},{"location":"#series","text":"GET {uri}/data GET {uri}/data/{el} GET {uri}/data/{el}/{param}","title":"series"},{"location":"#bases","text":"GET {uri}/bases GET {uri}/bases/{el}","title":"bases"},{"location":"#timelines","text":"GET {uri}/timelines GET {uri}/timelines/{el}","title":"timelines"},{"location":"#maps","text":"GET {uri}/maps/[/z/x/y] GET {uri}/maps/{el}/[z/x/y]","title":"maps"},{"location":"#clouds","text":"GET {uri}/clouds GET {uri}/clouds/{el}","title":"clouds"},{"location":"#azioni-sugli-elementi-operazioni-di-input","text":"In questo caso le azioni servono a modificare lo stato di un elemento: sistema <-- utente la richiesta viene composta specificando necessariamente l'elemento prima dell'azione. nota 1 : queste trovano riscontro nell'endpoint forms dell'api prototypes.","title":"Azioni sugli elementi: operazioni di input"},{"location":"#actions","text":"Le due azioni attualemente previste sono: config POST {uri}/actions/{el}/config GET {uri}/actions/{el}/config PUT {uri}/actions/{el}/config feed POST {uri}/actions/{el}/feed GET {uri}/actions/{el}/feed PUT {uri}/actions/{el}/feed/{time}","title":"actions"},{"location":"CHANGELOG/","text":"CHANGELOG v2.0.5 19 Gennaio 2021 Revisione concettuale sulle api e modifiche: GET /parametes lo schema di ritorno \u00e8 il seguente: { ..., \"data\": { \"ARCCE01\": [ { \"series\": \"ARCCE01_Rotazione_X\", \"param\" : \"Rotazione X\", \"unit\": \"mm/m\"}, ..... } ] } semplicemente \"param\" al posto di \"name\" actionSchemata \u00e8 l'api che fornir\u00e0 gli schemi per le azioni e va a sostituire quella che era \"prototypes\". Questa esiste ancora (forse per poco) ma pi\u00f9 che altro le informazioni che stanno nella relativa tabella mi servono per il back-end si chiama cos\u00ec (in pratica come prototypes): GET ../actionschemata[/{prototypes}[/{actions}]] action come prima, \u00e8 l'api che gestisce le azioni La versione POST nella sostanza non \u00e8 cambiata a parte il fatto che per default un'azione dichiarer\u00e0 sempre un timestamp per default. Ma questa cosa al front-end non interessa dal momento che le info le recupera da actionSchemanta. E' invece importante nella scrittura dei plugin perch\u00e9 in questo modo le azioni possono essere gestite temporalmente. La versione GET , invece cambia sostanzialmente: non fornir\u00e0 pi\u00f9 i default per la post MA potr\u00e0 fornire una serie temporale di azioni associate a dei valori di elaborazione che danno informazioni all'utente. in questo formato: GET ../actions[/{feature}[/{action}]] ritorna: [ { \"timestamp\":....,\"value\":.... }, { \"timestamp\":...., \"value\":.... }, .... ] esempio: GET .. / actions / ciaociaociao4 / config { \"meta\" : { \"response\" : \"ok\" , \"message\" : \"\" , \"data_type\" : \"GET /actions/ciaociaociao4/config\" } , \"data\" : [ [ { \"timestamp\" : \"2020-12-30 01:00:05\" , \"value\" : { \"master_image\" : \"TIFF image data, little-endian, direntries=14, height=1842, bps=16, compression=none, PhotometricIntepretation=BlackIsZero, width=3545\" , \"step_size\" : \"35\" , \"window_size_change\" : \"10\" , \"transform\" : [ 15 . 0 , 0 . 0 , 464947 . 5 , 0 . 0 , - 15 . 0 , 7977067 . 5 ], \"cache\" : \"20201230010005\" , \"crs\" : null } } , { \"timestamp\" : \"2020-12-30 01:00:07\" , \"value\" : { \"master_image\" : \"TIFF image data, little-endian, direntries=16, height=1842, bps=16, compression=none, PhotometricIntepretation=BlackIsZero, width=3545\" , \"timestamp\" : \"2020-12-30 01:00:07\" , \"step_size\" : \"35\" , \"window_size_change\" : \"10\" , \"transform\" : [ 15 . 0 , 0 . 0 , 464947 . 5 , 0 . 0 , - 15 . 0 , 7977067 . 5 ], \"cache\" : \"20201230010007\" , \"crs\" : \"EPSG:32622\" } } ] ] } 15 Gennaio 2021 rimodellato il db: dalla tabella \"features\" sono state eliminate le colonne \"a priori\" delle azioni. Queste ultime sono state inserite in una nuova tabella \"actions\" con chiave multipla (\"feature\",\"action\",\"timestamp\"). Rivista l'interfaccia db per permettere l'interrogazione su chiave multipla 10 Gennaio 2021 Progettazione della gestione temporale delle azioni e separazione del concetto di form da quello di risultato della azione: ogni azione ha uno schema di input e dei risultati in output con uno schema non necessariamente coincidente. Quello che viene fornito alle form sono i dati necessari ad intraprendere un'azione. I risultati dell'azione devono essere registrati con una marcatura temporale. In questo modo ogni azione \u00e8 univocamente determinata e gestibile con un modello del tipo (\"feature\",\"action\",\"timestamp\"), con una cardinalit\u00e0 1-a-molti tra features e azioni Portata a termine la migrazione della gestione delle azioni che vengono ora completamente affidate ai singoli moduli. L'iterfaccia di alto livello \u00e8 ora in grado di gestire agonsticamente le chiamate ad azioni arbitrarie purch\u00e8 ben definite all'interno dei moduli. In questo modo cade il vincolo di definizione do azione \"a priori\" 30 Dicembre 2020 sviluppo (non completo) di config hielen2.ext.PhotoMonitoring: Implementato il metodo di recupero e settaggio delle informazioni geometriche/geografiche dell'immagine in ingresso Aggancio del codice originale per la gesgione del netcdf (in debug) 22 Dicembre 20202 Delineata la gestione di mappa delle immagini prodotte: Ogni immagine prodotta sar\u00e0 sempre associata al suo crs e la matrice di trasformazione affine, anche nele caso in cui queste informazioni non dovessero essere passate in configurazione. In questo caso si assume un piano cartesiano con udm in m e una matrice identit\u00e0 per le trasformazioni affini. Sar\u00e0 dunque sempre possibile gestire le immagini come mappe (slippy maps) e sfruttare la tassellazione, il cacheing dei tasselli. 20 Dicembre 2020 Modificata l'api POST /actions/{feature}/{form} in modo da interrogare la Source (per ora solo PhotoMonitoring) sulla definizione delle azioni: Implementate le classi di Schema per config e feed per il modulo hielen2.ext.PhotoMonitoring . ATTENZIONE per config : introdotto il campo \"timestamp\", eliminati i campi espliciti relativi al word_file ( word_file mantenuto), modificato il campo epsg in csr . 15 Dicembre 2020 Delineato il modello di scrittura dei Source plugin secondo un template univoco. Ogni plugin potr\u00e0 essere un modulo python definito come segue: deve definire tante classi marshmallow.Schema quante sono le azioni che vengono prese in carico dal Template. Marsmallow \u00e8 un serializzatore di oggetti python. Lo schema definito servir\u00e0 per definire i campi in ingresso per ogni azione e fare i check dei valori in ingresso. Il nome delle classi Schema deve seguire questa sintassi: class {Action}Schema(marshmallow.Schema) dove {Action} \u00e8 il nome dell'azione (es.: config, feed, ..) con l'iniziale maiuscola . Nella classe vengono definiti i tipi dei campi ( marshmallow.fields cfr. https://marshmallow.readthedocs.io/en/stable/ ). ATTENZIONE: in caso fosse necessario l'ingresso di file o comunque oggetti blob dovr\u00e0 essere utilizzato come field la classe hielen2.utils.LocalFile . In questo modo il sistema risolver\u00e0 la chiamata API salvando in locale lo stream dei dati associato a quel determinato field, il quale sar\u00e0 accessibile al template attraverso un path che verr\u00e0 fornito insieme agli altri campi al momento della chiamata del metodo di gestione dell'azione (vedi sotto). deve implementare una classe Source(hielen2.datalink.HielenSource) che esponga tanti metodi quante sono le dichiarazioni di Schema seguendo questa sintassi: il metodo di gestione dell'azione deve chiamarsi come l'azione stessa ( tutto in minuscolo ). Le classi estese sfrutteranno il metodo __init__ della superclasse in modo da avere a disposizione tutto quello di cui necessitano. Questo modello permette di svincolare i template dalla necessit\u00e0 di conoscere a priori le azioni ammmissibili per il sistema. Infatti, facendo introspezione su un template che segua le regole di sintassi sar\u00e0 sempre possibile conoscere le azioni definite ed esternalizzarle al front-end che in base alle definizioni delle classi di Schema delle azioni, sar\u00e0 sempre in grado di instanziare una form adeguata. v2.0.5 9 Dicembre 2020 Implementata working POST /actions/{feature}/{form} tramite content-type/multipart dinamico definito dal prototipo: L'api \u00e8 collegata ai moduli reali delle tipologie definiti come templates, con la funzionalit\u00e0 minima di salvare i parametri in ingresso. I moduli sono in fase di sviluppo e man mano che vengono implementati le funzionalit\u00e0 aumenteranno. Implementato Loading dinamico dei moduli di elaborazione definiti come estensioni di hielen2.datalink.HielenSource Implementata working GET /actions/{feature}[/{form}] : Per ogni form richiesta, risponde con tutti i parametri definiti nel relativo prototipo, riempiti con i valori definiti tramite la POST della stessa api. I valori non precedentemente forniti vengono impostati a null Riveduta e corretta GET prototypes/{prototype}/forms[/form] : ATTENZIONE adesso risponde con TUTTI i campi dentro il dizionario \"args\" e comunica i campi obbligatori attraverso l'array \"mandatory\". Questa struttura \u00e8 pi\u00f9 versatile in quanto, una volta definito il set completo degli argomenti, \u00e8 possibile definire un numero arbitrario di sottoinsiemi predicativi non necessariamente distiniti: Oltre al sottoinsieme \"mandatory\" si potrebbe, ad esempio, definire un sottoinsieme di immutabili. Qui sotto una struttura di esempio: { \"data\": { \"args\": { \"epsg\": \"string\", \"master_image\": \"file\", \"negative_pixel_y_size\": \"string\", \"pixel_x_size\": \"string\", \"rotation_about_the_x_axis\": \"string\", \"rotation_about_the_y_axis\": \"string\", \"step_size\": \"string\", \"window_size_change\": \"string\", \"world_file\": \"file\", \"x_coordinate_of_upper_left_pixel_center\": \"string\", \"y_coordinate_of_upper_left_pixel_center\": \"string\" }, \"mandatory\": [ \"master_image\", \"step_size\", \"window_size_change\" ] }, \"meta\": { \"data_type\": \"GET /prototypes/PhotoMonitoring/forms/config\", \"message\": \"\", \"response\": \"ok\" } } 7 Dicembre 2020 Rimodellato il feature db per contenere gli argomenti delle actions Riveduto il feature_proto db: Inserito il modulo di riferimento tra le info del prototipo (il modulo contenete la classe estesa di hielen2.datalink.HielenSource ) Definita la superclasse hielen2.datalink.HielenSource con definizione univoca di __init__ con questo footprint: (self,featureobject,environment) . La classe definisce inotre i metodi astratti che vengono utilizzati dal sistema che ogni estensione di questa dovr\u00e0 implementare. 2 Dicembre 2020 Struttura definitiva delle features: { \"properties\":\"...\" \"parameters\":\"...\" \"geometry\":\"...\" } dove: properties mantiene tutte le info della feature. Quelle di base: uid , type , classification , location , description e quelle definite per le specifiche azioni definite per la tipologia. In particolare quella di configurzione. parameters mantiene la struttura di accesso alle info e ai dati dei parametri definiti per la feature. geometry fornisce le informazioni geometriche della feature. Rivedute le api /actions , /parameters , /features ( /data da rivedere) 24 Novembre 2020 Implementate dummy /actions/{feature}/ e /actions/{feature}/{form} 23 Novembre 2020 Riorganizzato il db delle features per permettere una gestione pi\u00f9 razionale 19 Novembre 2020 riorganizzata la struttura per la gestione delle classi estese che necessitano di dynamic loading: nel modulo himada2.ext (cartella) vengono raccoliti per comodit\u00e0 gli oggetti che saranno implementati man mano come estensione di superclassi astratte appositamente definite: per ora hielen2.datalink.Source e hielen2.datalink.DB e hielen2.datalink.DataCache. Oltre alle classi in hielen2.ext, il sitema potr\u00e0 utilizzare moduli esterni che estendano le superclassi elencate. inserito 'timestamp' nello schema json accettato da POST /feature e PUT /feature . risolto bug minore di incoerenza su GET /data/{feature} e /data/{feature}/{parameter} . Quest'ultima continua ad accettare uno tra i nomi dei parametri della feature. Entrambe rispondo intestando le colonne in uscita con lo uid della serie, come GET /data/ . 17 Novembre 2020 Implementata dummy POST /actions/{feature}/{form} : v2.0.4 16 Novembre 2020 per coerenza rivisti i parametri di POST /feature : uid:<string> prototype:<string> properties:<json schema Properties> geometry:<json schema GeoJson> analogo discorso per PUT /feature/{uid} : properties:<json schema Properties> geometry:<json schema GeoJson> sistemata la risposta di GET /feature , modificando il livello di \"geometry\" implementata api PUT /features/{uid} . Accetta il paramentro properties con uno schema analogo al parmetro feature di POST /features con queste differenze: nello schema della PUT, uid e prototype NON vengono accettati perch\u00e8 sono campi chiave della feature e non possono essere modificati . lo uid della feature deve essere specificato come url e non come parametro. introduzione dello Schema GeoJson per la validazione modificata POST /features/ per accettare un GeoJson nell'attibuto geometry del Json principale feature 13 Novembre 2020 rinominazione DELETE /elements -> DELETE /features . eliminazione degli alias GET /features/{context} e /features/{context}/{uid} a causa del conflitto l'entry point DELETE /features . Il passaggio del context sar\u00e0 esclusivmante attraverso il parametro cntxt ( nota : questo nome \u00e8 dovuto alla collisione del nome con il campo 'context' dell'oggetto request). In caso lo possiamo cambiare. introduzione dell'alias /features/{uid} per il recupero delle info della specifica Feature. 12 Novembre 2020 ovunque nel mondo il parmetro 'uuid' (universal unique id) diventa 'uid'. rinominazione POST /elements -> POST /features . rinominazione GET /elements -> GET /parameters e modifica uscita in questo schema: { < feature1_UID > :[ { \"series\" : < feature1_param1_series_UID > , \"param\" : < feature1_param1_name > , \"um\" : < feature1_param1_measurement_unit > } , ... { \"series\" : < feature1_paramN_series_UID , \"param\" : < feature1_paramN_name > , \"um\" : < feature1_paramN_meaurement_unit > } ], ... < featureX_UID > :[ { \"series\" : < featureX_param1_series_UID > , \"param\" : < featureX_param1_name > , \"um\" : < featureX_param1_measurement_unit > } , ... { \"series\" : < featureX_paramM_series_UID , \"param\" : < featureX_paramM_name > , \"um\" : < featureX_paramM_meaurement_unit > } ] } introduzione api /features con lo schema usato da Daniele e SimoneD: GET /features GET /features/{context}/ GET /features/{context}/{feature} uscita : nota 1: NON viene introdotto \"context\" , come invece preventivato nota 2: \"cod\" diventa \"label\" . nota 3: \"date\" diventa \"timestamp\" nota 3: dalle properties vengono elminate \"z\" e \"mslm\" . nota 4: \"state\" viene mantenuto ma per ora \u00e8 inutilizzato { \"features\" : [ { \"type\" : \"Feature\" , \"properties\" : { \"uid\" : ..., \"label\" : ..., \"context\" :..., \"date\" : ..., \"type\" : ..., \"style\" : ..., \"state\" : ... } , \"geometry\" : < GeoJson Validable > } , ... { \"type\" : \"Feature\" , \"properties\" : { \"uid\" : ..., \"label\" : ..., \"context\" : ..., \"date\" : ..., \"type\" : ..., \"style\" : ..., \"state\" : ... } , \"geometry\" : < GeoJson Validable > } ] } v2.0.3 11 Novembre 2020 Modificata api POST /elements : la variabile element \u00e8 descritta dalla Classe hielen2.api.data.ElementSchema e validata. In paricolare \u00e8 stato introdotto l'attibuto context Modifcata api GET /data : la variabile datamap \u00e8 descritta dalla Classe hielen2.api.data.DataMapSchema e validata. 9 Novembre 2020 Introdotta la classe hielen2.utils.JsonValidable, per la validazione e documentazione automatica dei parametri delle api (JSON Schema descrition) corretti bug minori in hielen2.datalink 6 Novembre 2020 L'interfaccia DB \u00e8 ora thread safe!!! (almeno per il dummy json db) v2.0.2 4 Novembre 2020 Implementata la documentazione automatica delle api Implementate le api POST ../elements e DELETE ../elements L'uscita per tutte le api element (e per tutte le api con risposta json in generale), seguir\u00e0 questo schema: { \"meta\": { \"data_type\": \"DELETE /elements/ciao\", \"response\": \"ok\" \"message\": \"\", }, \"data\":{ ... } } L'api /series diventa /data e cambia il suo comportamento: la variabile di tipo json datamap si aspetta il campo series invece di parameters . In questo campo devono essere inseriti i codici delle serie e non pi\u00f9 il costrutto \"codice_elemento:parametro_elemento\". I codici delle serie si possono recuperarare dall'api /elements (vedi Nota successiva) L'api /elements cambia la sua risposta e per ogni parametro nella lista parameters degli elementi viene agiunto il codice della serie di riferimento che pu\u00f2 essere fornito senza modifiche a /data : { \"series\":<seriescode>, \"name\":<seriesname>, \"um\":<seriesunit> } GET /series GET /series/{el} GET /series/{el}/{param} GET /prototypes GET /prototypes/{type} GET /prototypes/{type}/forms GET /prototypes/{type}/forms/{form} POST /elements GET /elements GET /elements/{el} DELETE /elements/{el}","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"","title":"CHANGELOG"},{"location":"CHANGELOG/#v205","text":"","title":"v2.0.5"},{"location":"CHANGELOG/#19-gennaio-2021","text":"Revisione concettuale sulle api e modifiche: GET /parametes lo schema di ritorno \u00e8 il seguente: { ..., \"data\": { \"ARCCE01\": [ { \"series\": \"ARCCE01_Rotazione_X\", \"param\" : \"Rotazione X\", \"unit\": \"mm/m\"}, ..... } ] } semplicemente \"param\" al posto di \"name\" actionSchemata \u00e8 l'api che fornir\u00e0 gli schemi per le azioni e va a sostituire quella che era \"prototypes\". Questa esiste ancora (forse per poco) ma pi\u00f9 che altro le informazioni che stanno nella relativa tabella mi servono per il back-end si chiama cos\u00ec (in pratica come prototypes): GET ../actionschemata[/{prototypes}[/{actions}]] action come prima, \u00e8 l'api che gestisce le azioni La versione POST nella sostanza non \u00e8 cambiata a parte il fatto che per default un'azione dichiarer\u00e0 sempre un timestamp per default. Ma questa cosa al front-end non interessa dal momento che le info le recupera da actionSchemanta. E' invece importante nella scrittura dei plugin perch\u00e9 in questo modo le azioni possono essere gestite temporalmente. La versione GET , invece cambia sostanzialmente: non fornir\u00e0 pi\u00f9 i default per la post MA potr\u00e0 fornire una serie temporale di azioni associate a dei valori di elaborazione che danno informazioni all'utente. in questo formato: GET ../actions[/{feature}[/{action}]] ritorna: [ { \"timestamp\":....,\"value\":.... }, { \"timestamp\":...., \"value\":.... }, .... ] esempio: GET .. / actions / ciaociaociao4 / config { \"meta\" : { \"response\" : \"ok\" , \"message\" : \"\" , \"data_type\" : \"GET /actions/ciaociaociao4/config\" } , \"data\" : [ [ { \"timestamp\" : \"2020-12-30 01:00:05\" , \"value\" : { \"master_image\" : \"TIFF image data, little-endian, direntries=14, height=1842, bps=16, compression=none, PhotometricIntepretation=BlackIsZero, width=3545\" , \"step_size\" : \"35\" , \"window_size_change\" : \"10\" , \"transform\" : [ 15 . 0 , 0 . 0 , 464947 . 5 , 0 . 0 , - 15 . 0 , 7977067 . 5 ], \"cache\" : \"20201230010005\" , \"crs\" : null } } , { \"timestamp\" : \"2020-12-30 01:00:07\" , \"value\" : { \"master_image\" : \"TIFF image data, little-endian, direntries=16, height=1842, bps=16, compression=none, PhotometricIntepretation=BlackIsZero, width=3545\" , \"timestamp\" : \"2020-12-30 01:00:07\" , \"step_size\" : \"35\" , \"window_size_change\" : \"10\" , \"transform\" : [ 15 . 0 , 0 . 0 , 464947 . 5 , 0 . 0 , - 15 . 0 , 7977067 . 5 ], \"cache\" : \"20201230010007\" , \"crs\" : \"EPSG:32622\" } } ] ] }","title":"19 Gennaio 2021"},{"location":"CHANGELOG/#15-gennaio-2021","text":"rimodellato il db: dalla tabella \"features\" sono state eliminate le colonne \"a priori\" delle azioni. Queste ultime sono state inserite in una nuova tabella \"actions\" con chiave multipla (\"feature\",\"action\",\"timestamp\"). Rivista l'interfaccia db per permettere l'interrogazione su chiave multipla","title":"15 Gennaio 2021"},{"location":"CHANGELOG/#10-gennaio-2021","text":"Progettazione della gestione temporale delle azioni e separazione del concetto di form da quello di risultato della azione: ogni azione ha uno schema di input e dei risultati in output con uno schema non necessariamente coincidente. Quello che viene fornito alle form sono i dati necessari ad intraprendere un'azione. I risultati dell'azione devono essere registrati con una marcatura temporale. In questo modo ogni azione \u00e8 univocamente determinata e gestibile con un modello del tipo (\"feature\",\"action\",\"timestamp\"), con una cardinalit\u00e0 1-a-molti tra features e azioni Portata a termine la migrazione della gestione delle azioni che vengono ora completamente affidate ai singoli moduli. L'iterfaccia di alto livello \u00e8 ora in grado di gestire agonsticamente le chiamate ad azioni arbitrarie purch\u00e8 ben definite all'interno dei moduli. In questo modo cade il vincolo di definizione do azione \"a priori\"","title":"10 Gennaio 2021"},{"location":"CHANGELOG/#30-dicembre-2020","text":"sviluppo (non completo) di config hielen2.ext.PhotoMonitoring: Implementato il metodo di recupero e settaggio delle informazioni geometriche/geografiche dell'immagine in ingresso Aggancio del codice originale per la gesgione del netcdf (in debug)","title":"30 Dicembre 2020"},{"location":"CHANGELOG/#22-dicembre-20202","text":"Delineata la gestione di mappa delle immagini prodotte: Ogni immagine prodotta sar\u00e0 sempre associata al suo crs e la matrice di trasformazione affine, anche nele caso in cui queste informazioni non dovessero essere passate in configurazione. In questo caso si assume un piano cartesiano con udm in m e una matrice identit\u00e0 per le trasformazioni affini. Sar\u00e0 dunque sempre possibile gestire le immagini come mappe (slippy maps) e sfruttare la tassellazione, il cacheing dei tasselli.","title":"22 Dicembre 20202"},{"location":"CHANGELOG/#20-dicembre-2020","text":"Modificata l'api POST /actions/{feature}/{form} in modo da interrogare la Source (per ora solo PhotoMonitoring) sulla definizione delle azioni: Implementate le classi di Schema per config e feed per il modulo hielen2.ext.PhotoMonitoring . ATTENZIONE per config : introdotto il campo \"timestamp\", eliminati i campi espliciti relativi al word_file ( word_file mantenuto), modificato il campo epsg in csr .","title":"20 Dicembre 2020"},{"location":"CHANGELOG/#15-dicembre-2020","text":"Delineato il modello di scrittura dei Source plugin secondo un template univoco. Ogni plugin potr\u00e0 essere un modulo python definito come segue: deve definire tante classi marshmallow.Schema quante sono le azioni che vengono prese in carico dal Template. Marsmallow \u00e8 un serializzatore di oggetti python. Lo schema definito servir\u00e0 per definire i campi in ingresso per ogni azione e fare i check dei valori in ingresso. Il nome delle classi Schema deve seguire questa sintassi: class {Action}Schema(marshmallow.Schema) dove {Action} \u00e8 il nome dell'azione (es.: config, feed, ..) con l'iniziale maiuscola . Nella classe vengono definiti i tipi dei campi ( marshmallow.fields cfr. https://marshmallow.readthedocs.io/en/stable/ ). ATTENZIONE: in caso fosse necessario l'ingresso di file o comunque oggetti blob dovr\u00e0 essere utilizzato come field la classe hielen2.utils.LocalFile . In questo modo il sistema risolver\u00e0 la chiamata API salvando in locale lo stream dei dati associato a quel determinato field, il quale sar\u00e0 accessibile al template attraverso un path che verr\u00e0 fornito insieme agli altri campi al momento della chiamata del metodo di gestione dell'azione (vedi sotto). deve implementare una classe Source(hielen2.datalink.HielenSource) che esponga tanti metodi quante sono le dichiarazioni di Schema seguendo questa sintassi: il metodo di gestione dell'azione deve chiamarsi come l'azione stessa ( tutto in minuscolo ). Le classi estese sfrutteranno il metodo __init__ della superclasse in modo da avere a disposizione tutto quello di cui necessitano. Questo modello permette di svincolare i template dalla necessit\u00e0 di conoscere a priori le azioni ammmissibili per il sistema. Infatti, facendo introspezione su un template che segua le regole di sintassi sar\u00e0 sempre possibile conoscere le azioni definite ed esternalizzarle al front-end che in base alle definizioni delle classi di Schema delle azioni, sar\u00e0 sempre in grado di instanziare una form adeguata.","title":"15 Dicembre 2020"},{"location":"CHANGELOG/#v205_1","text":"","title":"v2.0.5"},{"location":"CHANGELOG/#9-dicembre-2020","text":"Implementata working POST /actions/{feature}/{form} tramite content-type/multipart dinamico definito dal prototipo: L'api \u00e8 collegata ai moduli reali delle tipologie definiti come templates, con la funzionalit\u00e0 minima di salvare i parametri in ingresso. I moduli sono in fase di sviluppo e man mano che vengono implementati le funzionalit\u00e0 aumenteranno. Implementato Loading dinamico dei moduli di elaborazione definiti come estensioni di hielen2.datalink.HielenSource Implementata working GET /actions/{feature}[/{form}] : Per ogni form richiesta, risponde con tutti i parametri definiti nel relativo prototipo, riempiti con i valori definiti tramite la POST della stessa api. I valori non precedentemente forniti vengono impostati a null Riveduta e corretta GET prototypes/{prototype}/forms[/form] : ATTENZIONE adesso risponde con TUTTI i campi dentro il dizionario \"args\" e comunica i campi obbligatori attraverso l'array \"mandatory\". Questa struttura \u00e8 pi\u00f9 versatile in quanto, una volta definito il set completo degli argomenti, \u00e8 possibile definire un numero arbitrario di sottoinsiemi predicativi non necessariamente distiniti: Oltre al sottoinsieme \"mandatory\" si potrebbe, ad esempio, definire un sottoinsieme di immutabili. Qui sotto una struttura di esempio: { \"data\": { \"args\": { \"epsg\": \"string\", \"master_image\": \"file\", \"negative_pixel_y_size\": \"string\", \"pixel_x_size\": \"string\", \"rotation_about_the_x_axis\": \"string\", \"rotation_about_the_y_axis\": \"string\", \"step_size\": \"string\", \"window_size_change\": \"string\", \"world_file\": \"file\", \"x_coordinate_of_upper_left_pixel_center\": \"string\", \"y_coordinate_of_upper_left_pixel_center\": \"string\" }, \"mandatory\": [ \"master_image\", \"step_size\", \"window_size_change\" ] }, \"meta\": { \"data_type\": \"GET /prototypes/PhotoMonitoring/forms/config\", \"message\": \"\", \"response\": \"ok\" } }","title":"9 Dicembre 2020"},{"location":"CHANGELOG/#7-dicembre-2020","text":"Rimodellato il feature db per contenere gli argomenti delle actions Riveduto il feature_proto db: Inserito il modulo di riferimento tra le info del prototipo (il modulo contenete la classe estesa di hielen2.datalink.HielenSource ) Definita la superclasse hielen2.datalink.HielenSource con definizione univoca di __init__ con questo footprint: (self,featureobject,environment) . La classe definisce inotre i metodi astratti che vengono utilizzati dal sistema che ogni estensione di questa dovr\u00e0 implementare.","title":"7 Dicembre 2020"},{"location":"CHANGELOG/#2-dicembre-2020","text":"Struttura definitiva delle features: { \"properties\":\"...\" \"parameters\":\"...\" \"geometry\":\"...\" } dove: properties mantiene tutte le info della feature. Quelle di base: uid , type , classification , location , description e quelle definite per le specifiche azioni definite per la tipologia. In particolare quella di configurzione. parameters mantiene la struttura di accesso alle info e ai dati dei parametri definiti per la feature. geometry fornisce le informazioni geometriche della feature. Rivedute le api /actions , /parameters , /features ( /data da rivedere)","title":"2 Dicembre 2020"},{"location":"CHANGELOG/#24-novembre-2020","text":"Implementate dummy /actions/{feature}/ e /actions/{feature}/{form}","title":"24 Novembre 2020"},{"location":"CHANGELOG/#23-novembre-2020","text":"Riorganizzato il db delle features per permettere una gestione pi\u00f9 razionale","title":"23 Novembre 2020"},{"location":"CHANGELOG/#19-novembre-2020","text":"riorganizzata la struttura per la gestione delle classi estese che necessitano di dynamic loading: nel modulo himada2.ext (cartella) vengono raccoliti per comodit\u00e0 gli oggetti che saranno implementati man mano come estensione di superclassi astratte appositamente definite: per ora hielen2.datalink.Source e hielen2.datalink.DB e hielen2.datalink.DataCache. Oltre alle classi in hielen2.ext, il sitema potr\u00e0 utilizzare moduli esterni che estendano le superclassi elencate. inserito 'timestamp' nello schema json accettato da POST /feature e PUT /feature . risolto bug minore di incoerenza su GET /data/{feature} e /data/{feature}/{parameter} . Quest'ultima continua ad accettare uno tra i nomi dei parametri della feature. Entrambe rispondo intestando le colonne in uscita con lo uid della serie, come GET /data/ .","title":"19 Novembre 2020"},{"location":"CHANGELOG/#17-novembre-2020","text":"Implementata dummy POST /actions/{feature}/{form} :","title":"17 Novembre 2020"},{"location":"CHANGELOG/#v204","text":"","title":"v2.0.4"},{"location":"CHANGELOG/#16-novembre-2020","text":"per coerenza rivisti i parametri di POST /feature : uid:<string> prototype:<string> properties:<json schema Properties> geometry:<json schema GeoJson> analogo discorso per PUT /feature/{uid} : properties:<json schema Properties> geometry:<json schema GeoJson> sistemata la risposta di GET /feature , modificando il livello di \"geometry\" implementata api PUT /features/{uid} . Accetta il paramentro properties con uno schema analogo al parmetro feature di POST /features con queste differenze: nello schema della PUT, uid e prototype NON vengono accettati perch\u00e8 sono campi chiave della feature e non possono essere modificati . lo uid della feature deve essere specificato come url e non come parametro. introduzione dello Schema GeoJson per la validazione modificata POST /features/ per accettare un GeoJson nell'attibuto geometry del Json principale feature","title":"16 Novembre 2020"},{"location":"CHANGELOG/#13-novembre-2020","text":"rinominazione DELETE /elements -> DELETE /features . eliminazione degli alias GET /features/{context} e /features/{context}/{uid} a causa del conflitto l'entry point DELETE /features . Il passaggio del context sar\u00e0 esclusivmante attraverso il parametro cntxt ( nota : questo nome \u00e8 dovuto alla collisione del nome con il campo 'context' dell'oggetto request). In caso lo possiamo cambiare. introduzione dell'alias /features/{uid} per il recupero delle info della specifica Feature.","title":"13 Novembre 2020"},{"location":"CHANGELOG/#12-novembre-2020","text":"ovunque nel mondo il parmetro 'uuid' (universal unique id) diventa 'uid'. rinominazione POST /elements -> POST /features . rinominazione GET /elements -> GET /parameters e modifica uscita in questo schema: { < feature1_UID > :[ { \"series\" : < feature1_param1_series_UID > , \"param\" : < feature1_param1_name > , \"um\" : < feature1_param1_measurement_unit > } , ... { \"series\" : < feature1_paramN_series_UID , \"param\" : < feature1_paramN_name > , \"um\" : < feature1_paramN_meaurement_unit > } ], ... < featureX_UID > :[ { \"series\" : < featureX_param1_series_UID > , \"param\" : < featureX_param1_name > , \"um\" : < featureX_param1_measurement_unit > } , ... { \"series\" : < featureX_paramM_series_UID , \"param\" : < featureX_paramM_name > , \"um\" : < featureX_paramM_meaurement_unit > } ] } introduzione api /features con lo schema usato da Daniele e SimoneD: GET /features GET /features/{context}/ GET /features/{context}/{feature} uscita : nota 1: NON viene introdotto \"context\" , come invece preventivato nota 2: \"cod\" diventa \"label\" . nota 3: \"date\" diventa \"timestamp\" nota 3: dalle properties vengono elminate \"z\" e \"mslm\" . nota 4: \"state\" viene mantenuto ma per ora \u00e8 inutilizzato { \"features\" : [ { \"type\" : \"Feature\" , \"properties\" : { \"uid\" : ..., \"label\" : ..., \"context\" :..., \"date\" : ..., \"type\" : ..., \"style\" : ..., \"state\" : ... } , \"geometry\" : < GeoJson Validable > } , ... { \"type\" : \"Feature\" , \"properties\" : { \"uid\" : ..., \"label\" : ..., \"context\" : ..., \"date\" : ..., \"type\" : ..., \"style\" : ..., \"state\" : ... } , \"geometry\" : < GeoJson Validable > } ] }","title":"12 Novembre 2020"},{"location":"CHANGELOG/#v203","text":"","title":"v2.0.3"},{"location":"CHANGELOG/#11-novembre-2020","text":"Modificata api POST /elements : la variabile element \u00e8 descritta dalla Classe hielen2.api.data.ElementSchema e validata. In paricolare \u00e8 stato introdotto l'attibuto context Modifcata api GET /data : la variabile datamap \u00e8 descritta dalla Classe hielen2.api.data.DataMapSchema e validata.","title":"11 Novembre 2020"},{"location":"CHANGELOG/#9-novembre-2020","text":"Introdotta la classe hielen2.utils.JsonValidable, per la validazione e documentazione automatica dei parametri delle api (JSON Schema descrition) corretti bug minori in hielen2.datalink","title":"9 Novembre 2020"},{"location":"CHANGELOG/#6-novembre-2020","text":"L'interfaccia DB \u00e8 ora thread safe!!! (almeno per il dummy json db)","title":"6 Novembre 2020"},{"location":"CHANGELOG/#v202","text":"","title":"v2.0.2"},{"location":"CHANGELOG/#4-novembre-2020","text":"Implementata la documentazione automatica delle api Implementate le api POST ../elements e DELETE ../elements L'uscita per tutte le api element (e per tutte le api con risposta json in generale), seguir\u00e0 questo schema: { \"meta\": { \"data_type\": \"DELETE /elements/ciao\", \"response\": \"ok\" \"message\": \"\", }, \"data\":{ ... } } L'api /series diventa /data e cambia il suo comportamento: la variabile di tipo json datamap si aspetta il campo series invece di parameters . In questo campo devono essere inseriti i codici delle serie e non pi\u00f9 il costrutto \"codice_elemento:parametro_elemento\". I codici delle serie si possono recuperarare dall'api /elements (vedi Nota successiva) L'api /elements cambia la sua risposta e per ogni parametro nella lista parameters degli elementi viene agiunto il codice della serie di riferimento che pu\u00f2 essere fornito senza modifiche a /data : { \"series\":<seriescode>, \"name\":<seriesname>, \"um\":<seriesunit> } GET /series GET /series/{el} GET /series/{el}/{param} GET /prototypes GET /prototypes/{type} GET /prototypes/{type}/forms GET /prototypes/{type}/forms/{form} POST /elements GET /elements GET /elements/{el} DELETE /elements/{el}","title":"4 Novembre 2020"},{"location":"TODO/","text":"Con Priorit\u00e0 classe JsonDB: RIVEDERE L'INSERIMENTO!!! E' cambiato il modello * Introduzione delle classi Schema per tutte le azioni di tutte le tipologie Rivisitazione del'api GET /prototypes e GET /actions per l'introspezione dei plugin Configurazione hielen2.ext.PhotoMonitoring (netCDF) definizione array dimensionali X,Y: 1- creo gli array di dimensione adeguata, 2- applico la matrice di trasformazione affine, 3- applico la proiezione da crs in input a EPSG:3857 salvare file in filecache/{uid}/multidim.nc (dati) definire percorso di salvataggio tiles: filecache/{uid}/{map}/ (tiles mappe) salvare il primo tile a risoluzione adeguata: filecache/{uid}/{map}/base.png salvataggio (stoccaggio) dell'immagine di base in filecache/{uid} (eventualmente compressa) Feed hielen2.ext.PhotoMonitoring analisi dei file csv in ingresso (NS, EW, Correlation se esiste) aggirnamento di filecache/{uid}/multidim.nc Configurazione hielen2.ext.TinSAR analisi della formato della master cloud salvataggio (stoccaggio) della nuvola di base recupero info geografiche in caso non esistano info di proiezione geografica si considera spazio cartesiano con coordinate con adeguate alla nuvola base (da verificare) configurare file netCDF e salvarlo in filecache/{uid}/multidim.nc (dati) definire percorso di salvataggio tiles: filecache/{uid}/{map}/ (tiles mappe) configurare cartella di cache per potree filecache/{uid}/{cloud} (potree) Feed hielen2.ext.TinSAR Analisi file in ingresso aggiornamento filecache/{uid}/multidim.nc aggiornamento filecache/{uid}/{cloud} v2.0.6 Interfacce delle Informazioni con risposta mockup. Intento: agganciare lavoro Daniele GET /bases GET /bases/{feature} GET /timelines GET /timelines/{feature} GET /data/ estensione del modello di datamap per accettare GeoGeson v2.0.7 Rivistazione del modulo PhotMonitoring come \"source\". Intento: agganciare le serie dati prodotte dall'elaborazione Photmonitoring alle interfacce v2.0.8 Implementazione del modulo TinSar come \"source\". Intento: agganciare le serie dati prodotte dall'elaborazione TinSar alle interfacce v2.0.9 Implementazione delle chiamate di mappa GET /maps/[/z/x/y] GET /maps/{feature}/[z/x/y] v2.0.10 Implementazione chiamate cloud GET /cloud/{feature} Senza priorit\u00e0 Moduli HielenSource : attualmente, per comodit\u00e0, vengono sviluppati come sotto moduli di hielen2 ma il modo corretto \u00e8 quello di separare lo sviluppo. Sar\u00e0 sempre possibile farlo dal momento che le strutture vengono sviluppate con l'obiettivo della separazione. ~~ Moduli HielenSource : Definire in backend le form come Marshmallow.Schema in modo da condividere la struttura tra moduli e api~~ Obiettivo: assegnare una timestamp ad ogni informazione: le properties degli ogetti dovranno essere delle serie dati. Concetto di informazione minima. Implementare procedura di testing delle api verificare il default dei campi marshmallow (sembra non prenderlo in considerazione, prob non arriva null ma \"\") POST /prototypes Migliorare l'output dei doc del JsonValidable Gestire i filed Nested nei doc del JsonValidable","title":"TODO"},{"location":"TODO/#con-priorita","text":"","title":"Con Priorit\u00e0"},{"location":"TODO/#classe-jsondb-rivedere-linserimento-e-cambiato-il-modello","text":"","title":"classe JsonDB: RIVEDERE L'INSERIMENTO!!! E' cambiato il modello*"},{"location":"TODO/#introduzione-delle-classi-schema-per-tutte-le-azioni-di-tutte-le-tipologie","text":"","title":"Introduzione delle classi Schema per tutte le azioni di tutte le tipologie"},{"location":"TODO/#rivisitazione-delapi-get-prototypes-e-get-actions-per-lintrospezione-dei-plugin","text":"","title":"Rivisitazione del'api GET /prototypes e  GET /actions per l'introspezione dei plugin"},{"location":"TODO/#configurazione-hielen2extphotomonitoring-netcdf","text":"definizione array dimensionali X,Y: 1- creo gli array di dimensione adeguata, 2- applico la matrice di trasformazione affine, 3- applico la proiezione da crs in input a EPSG:3857 salvare file in filecache/{uid}/multidim.nc (dati) definire percorso di salvataggio tiles: filecache/{uid}/{map}/ (tiles mappe) salvare il primo tile a risoluzione adeguata: filecache/{uid}/{map}/base.png salvataggio (stoccaggio) dell'immagine di base in filecache/{uid} (eventualmente compressa)","title":"Configurazione hielen2.ext.PhotoMonitoring (netCDF)"},{"location":"TODO/#feed-hielen2extphotomonitoring","text":"analisi dei file csv in ingresso (NS, EW, Correlation se esiste) aggirnamento di filecache/{uid}/multidim.nc","title":"Feed hielen2.ext.PhotoMonitoring"},{"location":"TODO/#configurazione-hielen2exttinsar","text":"analisi della formato della master cloud salvataggio (stoccaggio) della nuvola di base recupero info geografiche in caso non esistano info di proiezione geografica si considera spazio cartesiano con coordinate con adeguate alla nuvola base (da verificare) configurare file netCDF e salvarlo in filecache/{uid}/multidim.nc (dati) definire percorso di salvataggio tiles: filecache/{uid}/{map}/ (tiles mappe) configurare cartella di cache per potree filecache/{uid}/{cloud} (potree)","title":"Configurazione hielen2.ext.TinSAR"},{"location":"TODO/#feed-hielen2exttinsar","text":"Analisi file in ingresso aggiornamento filecache/{uid}/multidim.nc aggiornamento filecache/{uid}/{cloud}","title":"Feed hielen2.ext.TinSAR"},{"location":"TODO/#v206-interfacce-delle-informazioni-con-risposta-mockup-intento-agganciare-lavoro-daniele","text":"GET /bases GET /bases/{feature} GET /timelines GET /timelines/{feature} GET /data/ estensione del modello di datamap per accettare GeoGeson","title":"v2.0.6 Interfacce delle Informazioni con risposta mockup. Intento: agganciare lavoro Daniele"},{"location":"TODO/#v207-rivistazione-del-modulo-photmonitoring-come-source-intento-agganciare-le-serie-dati-prodotte-dallelaborazione-photmonitoring-alle-interfacce","text":"","title":"v2.0.7 Rivistazione del modulo PhotMonitoring come \"source\". Intento: agganciare le serie dati prodotte dall'elaborazione Photmonitoring alle interfacce"},{"location":"TODO/#v208-implementazione-del-modulo-tinsar-come-source-intento-agganciare-le-serie-dati-prodotte-dallelaborazione-tinsar-alle-interfacce","text":"","title":"v2.0.8 Implementazione del modulo TinSar come \"source\". Intento: agganciare le serie dati prodotte dall'elaborazione TinSar alle interfacce"},{"location":"TODO/#v209-implementazione-delle-chiamate-di-mappa","text":"GET /maps/[/z/x/y] GET /maps/{feature}/[z/x/y]","title":"v2.0.9 Implementazione delle chiamate di mappa"},{"location":"TODO/#v2010-implementazione-chiamate-cloud","text":"GET /cloud/{feature}","title":"v2.0.10 Implementazione chiamate cloud"},{"location":"TODO/#senza-priorita","text":"Moduli HielenSource : attualmente, per comodit\u00e0, vengono sviluppati come sotto moduli di hielen2 ma il modo corretto \u00e8 quello di separare lo sviluppo. Sar\u00e0 sempre possibile farlo dal momento che le strutture vengono sviluppate con l'obiettivo della separazione. ~~ Moduli HielenSource : Definire in backend le form come Marshmallow.Schema in modo da condividere la struttura tra moduli e api~~ Obiettivo: assegnare una timestamp ad ogni informazione: le properties degli ogetti dovranno essere delle serie dati. Concetto di informazione minima. Implementare procedura di testing delle api verificare il default dei campi marshmallow (sembra non prenderlo in considerazione, prob non arriva null ma \"\") POST /prototypes Migliorare l'output dei doc del JsonValidable Gestire i filed Nested nei doc del JsonValidable","title":"Senza priorit\u00e0"},{"location":"docs/API%20Reference/actions/","text":"Actions /actions/{feature} GET params : feature : Basic text / string value actions : Basic text / string value timestamp : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Recupero dello stato corrente delle azioni effettuate su una feature L'intento di questa api \u00e8 quello di fornire i valori richiesti secondo lo schema dell'azione nota 1 : actions accetta valori multipli separati da virgola nota 2 : A seconda dell'action richiesta, alcuni parametri potrebbero essere utilizzati in fase di input ma non registrati. Il che vuol dire che per quei parametri il valore di ritorno sar\u00e0 null viene restituito una struttura di questo tipo: [ { \"feature\"*:..., \"action_name*\":..., \"timestamp\": ..., \"value\":{...} }, { \"feature\"*:..., \"action_name*\":..., \"timestamp\": ..., \"value\":{...} }, ... ] nota 3 :(*) I campi \"feature\" e \"action\" potrebbero non essere restituiti nella struttura nel caso in cui essi risultino non ambigui. \"timestamp\" e \"value\" vengono sempre restituiti Possibili risposte: 404 Not Found : Nel non venga trovata la feature richiesta o essa abbia un problema di configurazione /actions/{feature}/{action} GET params : feature : Basic text / string value action : Basic text / string value timestamp : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : **Recupero dello stato corrente per una specifica azione di una specifica feature** POST params : feature : Basic text / string value action : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Esecuzione delle azioni Richiede l'esecuzione di una specifica azione su una feature, fornendo tutte le informazioni necessarie attraverso una form dinamica dedicata. Oltre ai due parametri feature e form , timestamp , indicati nella url, accetta un multipart/form-data basato sulla specifica form, selezionata tramite i due parametri espliciti. Tutto il content \u00e8 scaricato attarverso i chunk dello stream ('100 continue') per evitare il timeout dei workers in caso di contenuti di grandi dimensioni. Possibili risposte: 200 OK : Nel caso in cui l'azione vada a buon fine. L'azione richiesta viene presa in carico ma potrebbe avere un tempo di esecuzione arbitrario. L'azione quindi viene splittata su un altro processo. 404 Not Found : Nel caso la feature non esista o non sia definita per essa l'azione richiesta. 500 Internal Server Error : Nel caso pessimo che il modulo dichiarato non esista. 501 Not Implemented' : Nel caso la tipologia non fornisse ancora l'iplementazione di uno o tutti i moduli di gestione E' stato implementato il meccanismo minimo di gestione che prevede il salvataggio delle info fornite che possono essere fornite tali e quali in uscita (vedi metodo GET dell'api). Questo meccanismo permette di svluppare i moduli a partire da un template con risposta di default.","title":"Actions"},{"location":"docs/API%20Reference/actions/#actions","text":"","title":"Actions"},{"location":"docs/API%20Reference/actions/#actionsfeature","text":"","title":"/actions/{feature}"},{"location":"docs/API%20Reference/actions/#get","text":"params : feature : Basic text / string value actions : Basic text / string value timestamp : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Recupero dello stato corrente delle azioni effettuate su una feature L'intento di questa api \u00e8 quello di fornire i valori richiesti secondo lo schema dell'azione nota 1 : actions accetta valori multipli separati da virgola nota 2 : A seconda dell'action richiesta, alcuni parametri potrebbero essere utilizzati in fase di input ma non registrati. Il che vuol dire che per quei parametri il valore di ritorno sar\u00e0 null viene restituito una struttura di questo tipo: [ { \"feature\"*:..., \"action_name*\":..., \"timestamp\": ..., \"value\":{...} }, { \"feature\"*:..., \"action_name*\":..., \"timestamp\": ..., \"value\":{...} }, ... ] nota 3 :(*) I campi \"feature\" e \"action\" potrebbero non essere restituiti nella struttura nel caso in cui essi risultino non ambigui. \"timestamp\" e \"value\" vengono sempre restituiti Possibili risposte: 404 Not Found : Nel non venga trovata la feature richiesta o essa abbia un problema di configurazione","title":"GET"},{"location":"docs/API%20Reference/actions/#actionsfeatureaction","text":"","title":"/actions/{feature}/{action}"},{"location":"docs/API%20Reference/actions/#get_1","text":"params : feature : Basic text / string value action : Basic text / string value timestamp : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : **Recupero dello stato corrente per una specifica azione di una specifica feature**","title":"GET"},{"location":"docs/API%20Reference/actions/#post","text":"params : feature : Basic text / string value action : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Esecuzione delle azioni Richiede l'esecuzione di una specifica azione su una feature, fornendo tutte le informazioni necessarie attraverso una form dinamica dedicata. Oltre ai due parametri feature e form , timestamp , indicati nella url, accetta un multipart/form-data basato sulla specifica form, selezionata tramite i due parametri espliciti. Tutto il content \u00e8 scaricato attarverso i chunk dello stream ('100 continue') per evitare il timeout dei workers in caso di contenuti di grandi dimensioni. Possibili risposte: 200 OK : Nel caso in cui l'azione vada a buon fine. L'azione richiesta viene presa in carico ma potrebbe avere un tempo di esecuzione arbitrario. L'azione quindi viene splittata su un altro processo. 404 Not Found : Nel caso la feature non esista o non sia definita per essa l'azione richiesta. 500 Internal Server Error : Nel caso pessimo che il modulo dichiarato non esista. 501 Not Implemented' : Nel caso la tipologia non fornisse ancora l'iplementazione di uno o tutti i moduli di gestione E' stato implementato il meccanismo minimo di gestione che prevede il salvataggio delle info fornite che possono essere fornite tali e quali in uscita (vedi metodo GET dell'api). Questo meccanismo permette di svluppare i moduli a partire da un template con risposta di default.","title":"POST"},{"location":"docs/API%20Reference/actionschemata/","text":"Actionschemata /actionschemata/ GET params : prototypes : Basic text / string value actions : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Recupero dello schema dei parametri per inizializare le forms delle azioni ritorna una struttura json di questo tipo: { \"NomePrototipo1\": { \"action1\": { \"args\": { \"arg1.1\": \"type_arg1.1\", \"arg1.2\": \"type_arg1.2\", ... }, \"mandatory\": [ args keys sublist ] }, \"action2\": { \"args\": { \"arg2.1\": \"type_arg2.1\", \"arg2.2\": \"type_arg2.2\", ... }, }, ... }, \"NomePrototipo3\": { ... }, ... }, /actionschemata/{prototype} GET params : prototype : Basic text / string value actions : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Alias per il recupero di tutte le informazioni di uno specifico prototipo /actionschemata/{prototype}/{action} GET params : prototype : Basic text / string value action : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Alias per il recupero di tutte le informazioni delle form di uno specifico prototipo","title":"Actionschemata"},{"location":"docs/API%20Reference/actionschemata/#actionschemata","text":"","title":"Actionschemata"},{"location":"docs/API%20Reference/actionschemata/#actionschemata_1","text":"","title":"/actionschemata/"},{"location":"docs/API%20Reference/actionschemata/#get","text":"params : prototypes : Basic text / string value actions : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Recupero dello schema dei parametri per inizializare le forms delle azioni ritorna una struttura json di questo tipo: { \"NomePrototipo1\": { \"action1\": { \"args\": { \"arg1.1\": \"type_arg1.1\", \"arg1.2\": \"type_arg1.2\", ... }, \"mandatory\": [ args keys sublist ] }, \"action2\": { \"args\": { \"arg2.1\": \"type_arg2.1\", \"arg2.2\": \"type_arg2.2\", ... }, }, ... }, \"NomePrototipo3\": { ... }, ... },","title":"GET"},{"location":"docs/API%20Reference/actionschemata/#actionschemataprototype","text":"","title":"/actionschemata/{prototype}"},{"location":"docs/API%20Reference/actionschemata/#get_1","text":"params : prototype : Basic text / string value actions : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Alias per il recupero di tutte le informazioni di uno specifico prototipo","title":"GET"},{"location":"docs/API%20Reference/actionschemata/#actionschemataprototypeaction","text":"","title":"/actionschemata/{prototype}/{action}"},{"location":"docs/API%20Reference/actionschemata/#get_2","text":"params : prototype : Basic text / string value action : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Alias per il recupero di tutte le informazioni delle form di uno specifico prototipo","title":"GET"},{"location":"docs/API%20Reference/data/","text":"Data /data/ GET params : datamap : JSON Schema [{ series : [str|bytes], timeto : str|bytes, timefrom : str|bytes}] content_type : Basic text / string value result : format : Supports any of the following formats: Free form UTF-8 text, JSON (Javascript Serialized Object Notation) content_type : text/plain; charset=utf-8, application/json; charset=utf-8 /data/{feature}/ GET params : feature : Basic text / string value par : Basic text / string value timefrom : Basic text / string value timeto : Basic text / string value content_type : Basic text / string value result : format : Supports any of the following formats: Free form UTF-8 text, JSON (Javascript Serialized Object Notation) content_type : text/plain; charset=utf-8, application/json; charset=utf-8 /data/{feature}/{par} GET params : feature : Basic text / string value par : Basic text / string value timefrom : Basic text / string value timeto : Basic text / string value content_type : Basic text / string value result : format : Supports any of the following formats: Free form UTF-8 text, JSON (Javascript Serialized Object Notation) content_type : text/plain; charset=utf-8, application/json; charset=utf-8","title":"Data"},{"location":"docs/API%20Reference/data/#data","text":"","title":"Data"},{"location":"docs/API%20Reference/data/#data_1","text":"","title":"/data/"},{"location":"docs/API%20Reference/data/#get","text":"params : datamap : JSON Schema [{ series : [str|bytes], timeto : str|bytes, timefrom : str|bytes}] content_type : Basic text / string value result : format : Supports any of the following formats: Free form UTF-8 text, JSON (Javascript Serialized Object Notation) content_type : text/plain; charset=utf-8, application/json; charset=utf-8","title":"GET"},{"location":"docs/API%20Reference/data/#datafeature","text":"","title":"/data/{feature}/"},{"location":"docs/API%20Reference/data/#get_1","text":"params : feature : Basic text / string value par : Basic text / string value timefrom : Basic text / string value timeto : Basic text / string value content_type : Basic text / string value result : format : Supports any of the following formats: Free form UTF-8 text, JSON (Javascript Serialized Object Notation) content_type : text/plain; charset=utf-8, application/json; charset=utf-8","title":"GET"},{"location":"docs/API%20Reference/data/#datafeaturepar","text":"","title":"/data/{feature}/{par}"},{"location":"docs/API%20Reference/data/#get_2","text":"params : feature : Basic text / string value par : Basic text / string value timefrom : Basic text / string value timeto : Basic text / string value content_type : Basic text / string value result : format : Supports any of the following formats: Free form UTF-8 text, JSON (Javascript Serialized Object Notation) content_type : text/plain; charset=utf-8, application/json; charset=utf-8","title":"GET"},{"location":"docs/API%20Reference/elements/","text":"Elements /elements/ POST params : element : JSON Schema { prototype : str|bytes, style : str|bytes, description : str|bytes, label : str|bytes, uuid : str|bytes, status : str|bytes, geom : str|bytes, context : str|bytes} result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Api di creazione degli elementi. Ogni elemento deve avere il suo codice univoco uuid e il suo prototipo prototype . Il prototipo dell'elemento forisce informazioni per l'inizializazione della struttura. Possibili risposte: 409 Conflict : Nel caso in cui il codice fornito esista gi\u00e0. 404 Not Found : Nel caso in cui il prototipo richiesto non esista. 201 Created : Nel caso in cui l'elemento venga creato correttamente. GET params : elist : Basic text / string value context : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 /elements/{uuid} GET params : uuid : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 DELETE params : uuid : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8","title":"Elements"},{"location":"docs/API%20Reference/elements/#elements","text":"","title":"Elements"},{"location":"docs/API%20Reference/elements/#elements_1","text":"","title":"/elements/"},{"location":"docs/API%20Reference/elements/#post","text":"params : element : JSON Schema { prototype : str|bytes, style : str|bytes, description : str|bytes, label : str|bytes, uuid : str|bytes, status : str|bytes, geom : str|bytes, context : str|bytes} result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Api di creazione degli elementi. Ogni elemento deve avere il suo codice univoco uuid e il suo prototipo prototype . Il prototipo dell'elemento forisce informazioni per l'inizializazione della struttura. Possibili risposte: 409 Conflict : Nel caso in cui il codice fornito esista gi\u00e0. 404 Not Found : Nel caso in cui il prototipo richiesto non esista. 201 Created : Nel caso in cui l'elemento venga creato correttamente.","title":"POST"},{"location":"docs/API%20Reference/elements/#get","text":"params : elist : Basic text / string value context : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8","title":"GET"},{"location":"docs/API%20Reference/elements/#elementsuuid","text":"","title":"/elements/{uuid}"},{"location":"docs/API%20Reference/elements/#get_1","text":"params : uuid : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8","title":"GET"},{"location":"docs/API%20Reference/elements/#delete","text":"params : uuid : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8","title":"DELETE"},{"location":"docs/API%20Reference/features/","text":"Features /features/ POST params : uid : Basic text / string value prototype : Basic text / string value properties : JSON Schema { location : str|bytes, description : str|bytes, style : str|bytes, status : str|bytes, timestamp : str|bytes, context : str|bytes, label : str|bytes} geometry : JSON Schema {} result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Creazione delle Features. Ogni feature deve avere il suo codice univoco uid e il suo prototipo prototype . Questi due campi sono immutabli (vedi PUT /feature/{uid} ). Il prototipo della feature forisce informazioni per l'inizializazione della struttura. Il parametro geometry deve essere un GeoJson Se la feature viene creata correttamente ne restituisce la struttura Possibili risposte: 409 Conflict : Nel caso in cui il uid fornito esista gi\u00e0. 404 Not Found : Nel caso in cui il prototipo richiesto non esista. 201 Created : Nel caso in cui la feature venga creata correttamente. GET params : uids : Basic text / string value cntxt : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Recupero delle informazioni delle features. nota : uids accetta valori multipli separati da virgola viene restituito una struttura di questo tipo: { \"features\": [ { \"type\": \"Feature\", \"properties\": { ... }, \"geometry\": <GeoJson Validable> }, ... ] } nota : Al contrario di quanto detto nel TODO non viene inserito il context a livello \"features\" perch\u00e8 in effetti \u00e8 una informazione sempre conosciuta a priori (se si lavora per commesse). Al contrario se si lavora per uids allora ha senso inserie questa info all' interno delle properties delle singole features. Possibili risposte: 404 Not Found : Nel caso in cui nessuna feature risponda ai criteri /features/{uid} GET params : uid : Basic text / string value cntxt : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : **Alias di recupero informazioni della specifica feature** PUT params : uid : Basic text / string value properties : JSON Schema { location : str|bytes, description : str|bytes, style : str|bytes, status : str|bytes, timestamp : str|bytes, context : str|bytes, label : str|bytes} geometry : JSON Schema {} result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Modifica delle properties di una feature Possibili risposte: 404 Not Found : Nel caso in cui il prototipo richiesto non esista. 202 Accepted : Nel caso in cui la feature venga modificata correttamente. DELETE params : uid : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Cancellazione delle Features Se la feature viene cancellata correttamente ne restituisce la struttura Possibili risposte: 404 Not Found : Nel caso in cui il prototipo richiesto non esista. 202 Accepted : Nel caso in cui la feature venga eliminata correttamente.","title":"Features"},{"location":"docs/API%20Reference/features/#features","text":"","title":"Features"},{"location":"docs/API%20Reference/features/#features_1","text":"","title":"/features/"},{"location":"docs/API%20Reference/features/#post","text":"params : uid : Basic text / string value prototype : Basic text / string value properties : JSON Schema { location : str|bytes, description : str|bytes, style : str|bytes, status : str|bytes, timestamp : str|bytes, context : str|bytes, label : str|bytes} geometry : JSON Schema {} result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Creazione delle Features. Ogni feature deve avere il suo codice univoco uid e il suo prototipo prototype . Questi due campi sono immutabli (vedi PUT /feature/{uid} ). Il prototipo della feature forisce informazioni per l'inizializazione della struttura. Il parametro geometry deve essere un GeoJson Se la feature viene creata correttamente ne restituisce la struttura Possibili risposte: 409 Conflict : Nel caso in cui il uid fornito esista gi\u00e0. 404 Not Found : Nel caso in cui il prototipo richiesto non esista. 201 Created : Nel caso in cui la feature venga creata correttamente.","title":"POST"},{"location":"docs/API%20Reference/features/#get","text":"params : uids : Basic text / string value cntxt : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Recupero delle informazioni delle features. nota : uids accetta valori multipli separati da virgola viene restituito una struttura di questo tipo: { \"features\": [ { \"type\": \"Feature\", \"properties\": { ... }, \"geometry\": <GeoJson Validable> }, ... ] } nota : Al contrario di quanto detto nel TODO non viene inserito il context a livello \"features\" perch\u00e8 in effetti \u00e8 una informazione sempre conosciuta a priori (se si lavora per commesse). Al contrario se si lavora per uids allora ha senso inserie questa info all' interno delle properties delle singole features. Possibili risposte: 404 Not Found : Nel caso in cui nessuna feature risponda ai criteri","title":"GET"},{"location":"docs/API%20Reference/features/#featuresuid","text":"","title":"/features/{uid}"},{"location":"docs/API%20Reference/features/#get_1","text":"params : uid : Basic text / string value cntxt : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : **Alias di recupero informazioni della specifica feature**","title":"GET"},{"location":"docs/API%20Reference/features/#put","text":"params : uid : Basic text / string value properties : JSON Schema { location : str|bytes, description : str|bytes, style : str|bytes, status : str|bytes, timestamp : str|bytes, context : str|bytes, label : str|bytes} geometry : JSON Schema {} result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Modifica delle properties di una feature Possibili risposte: 404 Not Found : Nel caso in cui il prototipo richiesto non esista. 202 Accepted : Nel caso in cui la feature venga modificata correttamente.","title":"PUT"},{"location":"docs/API%20Reference/features/#delete","text":"params : uid : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Cancellazione delle Features Se la feature viene cancellata correttamente ne restituisce la struttura Possibili risposte: 404 Not Found : Nel caso in cui il prototipo richiesto non esista. 202 Accepted : Nel caso in cui la feature venga eliminata correttamente.","title":"DELETE"},{"location":"docs/API%20Reference/parameters/","text":"Parameters /parameters/ GET params : cntxt : Basic text / string value uids : Basic text / string value params : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : ** Ricerca dei parametri associati alle features ** . __nota__ : uid accetta valori multipli separati da virgola viene restituita una struttura di questo tipo : { \"<fetUID>\" :[ { \"series\" : \"<series_UID>\" , \"param\" : \"<param_name>\" , \"um\" : \"<mearurement_unit>\" } ... ] ... } Possibili risposte : - _404 Not Found_ : Nel caso in cui nessun parametro risponda ai criteri /parameters/{cntxt} GET params : cntxt : Basic text / string value uids : Basic text / string value params : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : **Alias di ricerca dei Parametri nello lo specifico contesto** /parameters/{cntxt}/{uid} GET params : cntxt : Basic text / string value uid : Basic text / string value params : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : **Alias di ricerca dei Parametri della specifica Feature lo specifico contesto** /parameters/{cntxt}/{uid}/{param} GET params : cntxt : Basic text / string value uid : Basic text / string value param : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : **Alias di ricerca dello specifico Parametro della specifica Feature lo specifico contesto**","title":"Parameters"},{"location":"docs/API%20Reference/parameters/#parameters","text":"","title":"Parameters"},{"location":"docs/API%20Reference/parameters/#parameters_1","text":"","title":"/parameters/"},{"location":"docs/API%20Reference/parameters/#get","text":"params : cntxt : Basic text / string value uids : Basic text / string value params : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : ** Ricerca dei parametri associati alle features ** . __nota__ : uid accetta valori multipli separati da virgola viene restituita una struttura di questo tipo : { \"<fetUID>\" :[ { \"series\" : \"<series_UID>\" , \"param\" : \"<param_name>\" , \"um\" : \"<mearurement_unit>\" } ... ] ... } Possibili risposte : - _404 Not Found_ : Nel caso in cui nessun parametro risponda ai criteri","title":"GET"},{"location":"docs/API%20Reference/parameters/#parameterscntxt","text":"","title":"/parameters/{cntxt}"},{"location":"docs/API%20Reference/parameters/#get_1","text":"params : cntxt : Basic text / string value uids : Basic text / string value params : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : **Alias di ricerca dei Parametri nello lo specifico contesto**","title":"GET"},{"location":"docs/API%20Reference/parameters/#parameterscntxtuid","text":"","title":"/parameters/{cntxt}/{uid}"},{"location":"docs/API%20Reference/parameters/#get_2","text":"params : cntxt : Basic text / string value uid : Basic text / string value params : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : **Alias di ricerca dei Parametri della specifica Feature lo specifico contesto**","title":"GET"},{"location":"docs/API%20Reference/parameters/#parameterscntxtuidparam","text":"","title":"/parameters/{cntxt}/{uid}/{param}"},{"location":"docs/API%20Reference/parameters/#get_3","text":"params : cntxt : Basic text / string value uid : Basic text / string value param : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : **Alias di ricerca dello specifico Parametro della specifica Feature lo specifico contesto**","title":"GET"},{"location":"docs/API%20Reference/prototypes/","text":"Prototypes /prototypes/ POST params : prototype : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Definizione di nuovi prototipi PLACEHOLDER: Non ancora implementato GET result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Recupero di tutte le informazioni dei prototipi ritorna una struttura json di questo tipo: { \"NomePrototipo1\": { \"forms\": { \"form1\": { \"args\": { \"arg1.1\": \"type_arg1.1\", \"arg1.2\": \"type_arg1.2\", ... }, \"mandatory\": [ args keys sublist ] }, \"form2\": { \"args\": { \"arg2.1\": \"type_arg2.1\", \"arg2.2\": \"type_arg2.2\", ... }, }, ... }, \"module\": subclass of hielen2.datalink.HilenSource, \"struct\": { \"parameters\": { \"param1\": { \"operands\": { \"output\": \"parameter1 name\" }, \"type\": \"series type\" }, \"param2\": { \"operands\": { \"output\": \"parameter2 name\" }, \"type\": \"series type\" }, ... }, \"properties\": { \"classification\": feature classification, \"type\": feature type } } }, \"NomePrototipo3\": { ... }, ... }, /prototypes/{prototype} GET params : prototype : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Alias per il recupero di tutte le informazioni di uno specifico prototipo /prototypes/{prototype}/forms GET params : prototype : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Alias per il recupero di tutte le informazioni delle form di uno specifico prototipo /prototypes/{prototype}/forms/{form} GET params : prototype : Basic text / string value form : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Alias per il recupero di tutte le informazioni di una specifica form di uno specifico prototipo /prototypes/{prototype}/struct GET params : prototype : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Alias per il recupero delle info di inizializzazione delle features legate ad uno specifico prototipo","title":"Prototypes"},{"location":"docs/API%20Reference/prototypes/#prototypes","text":"","title":"Prototypes"},{"location":"docs/API%20Reference/prototypes/#prototypes_1","text":"","title":"/prototypes/"},{"location":"docs/API%20Reference/prototypes/#post","text":"params : prototype : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Definizione di nuovi prototipi PLACEHOLDER: Non ancora implementato","title":"POST"},{"location":"docs/API%20Reference/prototypes/#get","text":"result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Recupero di tutte le informazioni dei prototipi ritorna una struttura json di questo tipo: { \"NomePrototipo1\": { \"forms\": { \"form1\": { \"args\": { \"arg1.1\": \"type_arg1.1\", \"arg1.2\": \"type_arg1.2\", ... }, \"mandatory\": [ args keys sublist ] }, \"form2\": { \"args\": { \"arg2.1\": \"type_arg2.1\", \"arg2.2\": \"type_arg2.2\", ... }, }, ... }, \"module\": subclass of hielen2.datalink.HilenSource, \"struct\": { \"parameters\": { \"param1\": { \"operands\": { \"output\": \"parameter1 name\" }, \"type\": \"series type\" }, \"param2\": { \"operands\": { \"output\": \"parameter2 name\" }, \"type\": \"series type\" }, ... }, \"properties\": { \"classification\": feature classification, \"type\": feature type } } }, \"NomePrototipo3\": { ... }, ... },","title":"GET"},{"location":"docs/API%20Reference/prototypes/#prototypesprototype","text":"","title":"/prototypes/{prototype}"},{"location":"docs/API%20Reference/prototypes/#get_1","text":"params : prototype : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Alias per il recupero di tutte le informazioni di uno specifico prototipo","title":"GET"},{"location":"docs/API%20Reference/prototypes/#prototypesprototypeforms","text":"","title":"/prototypes/{prototype}/forms"},{"location":"docs/API%20Reference/prototypes/#get_2","text":"params : prototype : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Alias per il recupero di tutte le informazioni delle form di uno specifico prototipo","title":"GET"},{"location":"docs/API%20Reference/prototypes/#prototypesprototypeformsform","text":"","title":"/prototypes/{prototype}/forms/{form}"},{"location":"docs/API%20Reference/prototypes/#get_3","text":"params : prototype : Basic text / string value form : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Alias per il recupero di tutte le informazioni di una specifica form di uno specifico prototipo","title":"GET"},{"location":"docs/API%20Reference/prototypes/#prototypesprototypestruct","text":"","title":"/prototypes/{prototype}/struct"},{"location":"docs/API%20Reference/prototypes/#get_4","text":"params : prototype : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Alias per il recupero delle info di inizializzazione delle features legate ad uno specifico prototipo","title":"GET"},{"location":"reference/hielen2/","text":"Module hielen2 View Source # coding=utf-8 __name__ = \"hielen2\" __version__ = \"2.0.5\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"Multidimention Hierarichical Elaboration Engine\" __license__ = \"MIT\" __uri__ = \"\" import warnings import json from .datalink import dbinit # , cacheinit def _initconf ( confile , envfile ): env = None with open ( envfile ) as ef : env = json . load ( ef ) with open ( confile ) as cf : confstr = cf . read () for k , w in env . items (): placeholder = \"{{\" + k + \"}}\" confstr = confstr . replace ( placeholder , w ) return json . loads ( confstr ) conf = _initconf ( \"./conf/hielen.json\" , \"./conf/env.json\" ) db = dbinit ( conf ) def int_or_str ( value ): try : return int ( value ) except ValueError : return value VERSION = tuple ( map ( int_or_str , __version__ . split ( \".\" ))) __all__ = [ \"conf\" , \"db\" ] Sub-modules hielen2.api hielen2.data hielen2.datalink hielen2.datalink_json hielen2.ext hielen2.source hielen2.utils Variables conf db","title":"Index"},{"location":"reference/hielen2/#module-hielen2","text":"View Source # coding=utf-8 __name__ = \"hielen2\" __version__ = \"2.0.5\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"Multidimention Hierarichical Elaboration Engine\" __license__ = \"MIT\" __uri__ = \"\" import warnings import json from .datalink import dbinit # , cacheinit def _initconf ( confile , envfile ): env = None with open ( envfile ) as ef : env = json . load ( ef ) with open ( confile ) as cf : confstr = cf . read () for k , w in env . items (): placeholder = \"{{\" + k + \"}}\" confstr = confstr . replace ( placeholder , w ) return json . loads ( confstr ) conf = _initconf ( \"./conf/hielen.json\" , \"./conf/env.json\" ) db = dbinit ( conf ) def int_or_str ( value ): try : return int ( value ) except ValueError : return value VERSION = tuple ( map ( int_or_str , __version__ . split ( \".\" ))) __all__ = [ \"conf\" , \"db\" ]","title":"Module hielen2"},{"location":"reference/hielen2/#sub-modules","text":"hielen2.api hielen2.data hielen2.datalink hielen2.datalink_json hielen2.ext hielen2.source hielen2.utils","title":"Sub-modules"},{"location":"reference/hielen2/#variables","text":"conf db","title":"Variables"},{"location":"reference/hielen2/datalink/","text":"Module hielen2.datalink View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 #!/usr/bin/env python # coding=utf-8 from pandas import DataFrame , Series , read_json , NaT from abc import ABC , abstractmethod from hielen2.utils import loadjsonfile , savejsonfile , newinstanceof , hashfile from filelock import Timeout , FileLock from numpy import nan def dbinit ( conf ): return { k : newinstanceof ( w . pop ( \"klass\" ), ** w ) for k , w in conf [ \"db\" ] . items () } class DB ( ABC ): @abstractmethod def __init__ ( self , connection ): pass @abstractmethod def __getitem__ ( self , key ): pass @abstractmethod def __setitem__ ( self , key , value ): pass @abstractmethod def pop ( self , key ): pass class JsonDB ( DB ): def __init__ ( self , connection , schema , lock_timeout_seconds = 10 ): self . jsonfile = connection self . lock = FileLock ( f \" { connection } .lock\" , timeout = lock_timeout_seconds ) self . md5file = f \" { connection } .md5\" self . md5 = None self . schema = schema self . __chk_and_reload_jsondb ( force = True ) def __brute_load_jsondb ( self ): try : self . db = read_json ( self . jsonfile , orient = 'table' , convert_dates = False ) except Exception as e : self . db = DataFrame () if self . db . empty : self . db = DataFrame ({}, columns = self . schema [ 'columns' ]) self . db = self . db . set_index ( self . schema [ 'primary_key' ]) def __chk_and_reload_jsondb ( self , force = False ): \"\"\" Needs to check for json-database file changes in a thread safe way!! \"\"\" md5 = None error = None try : self . lock . acquire () try : if force : raise FileNotFoundError () with open ( self . md5file ) as o : md5 = o . read () if not md5 == self . md5 : self . md5 = md5 self . __brute_load_jsondb () except FileNotFoundError as e : ## refershing hash self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) self . __brute_load_jsondb () finally : self . lock . release () except Timeout : pass def save ( self ): try : self . lock . acquire () try : self . db . to_json ( self . jsonfile , orient = 'table' ) self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) finally : self . lock . release () except Timeout as e : # Just to remind Timout error here raise e def __write_jsondb ( self , key , value ): \"\"\" Needs to lock for writing json-database \"\"\" item = None error = None try : self . lock . acquire () try : self . __chk_and_reload_jsondb () if value is None : # Request to remove key, raises KeyError item = self . __getitem__ ( key ) try : self . db = self . db . drop ( key , axis = 0 ) except KeyError : raise KeyError ( f \"key { key } to remove does not exist\" ) else : # Request to insert key, raises ValueError primarykey = self . schema [ 'primary_key' ] if not isinstance ( key ,( list , set , tuple )): key = [ key ] if key . __len__ () < primarykey . __len__ (): raise ValueError ( f \"key { key !r} is not fully determinated\" ) keydict = dict ( zip ( self . schema [ 'primary_key' ], key )) value . update ( keydict ) df = DataFrame ([ value . values ()]) df . columns = value . keys () df = df . set_index ( self . schema [ 'primary_key' ]) try : self . db = self . db . append ( df , verify_integrity = True ) . sort_index () except ValueError : raise ValueError ( f \"key { key } to insert exists\" ) self . db . replace ({ nan : None , NaT : None }, inplace = True ) item = self . __brute_getitem ( key ) self . save () except Exception as e : error = e finally : self . lock . release () except Timeout as e : error = e if error is not None : raise error return item def __brute_getitem ( self , key = None ): out = None if key is None : out = self . db else : out = self . db . loc [ key ] if isinstance ( out , Series ): out = out . to_frame () . T out . index . names = self . schema [ 'primary_key' ] out = out . reset_index () . to_dict ( orient = 'records' ) if out . __len__ () == 1 : out = out [ 0 ] return out def __getitem__ ( self , key = None ): self . __chk_and_reload_jsondb () if isinstance ( key , list ): try : key = list ( filter ( None , key )) except TypeError : pass return self . __brute_getitem ( key ) def pop ( self , key ): return self . __write_jsondb ( key , None ) def __setitem__ ( self , key = None , value = None ): self . __write_jsondb ( key , value ) class JsonCache ( DB ): def __init__ ( self , connection ): self . cache = ( read_json ( connection , convert_dates = False ) . set_index ([ \"uid\" , \"timestamp\" ])[ \"value\" ] . sort_index () ) self . filename = connection def __getitem__ ( self , key ): return self . cache [ key ] def __setitem__ ( self , key , value ): pass def pop ( self , key ): pass def save ( self ): self . cache . reset_index () . to_json ( self . filename , orient = \"records\" ) Variables nan Functions dbinit def dbinit ( conf ) View Source def dbinit ( conf ): return { k : newinstanceof ( w . pop ( \"klass\" ), ** w ) for k , w in conf [ \"db\" ]. items () } Classes DB class DB ( connection ) Helper class that provides a standard way to create an ABC using inheritance. View Source class DB ( ABC ) : @abstractmethod def __init__ ( self , connection ) : pass @abstractmethod def __getitem__ ( self , key ) : pass @abstractmethod def __setitem__ ( self , key , value ) : pass @abstractmethod def pop ( self , key ) : pass Ancestors (in MRO) abc.ABC Descendants hielen2.datalink.JsonDB hielen2.datalink.JsonCache Methods pop def pop ( self , key ) View Source @abstractmethod def pop ( self , key ) : pass JsonCache class JsonCache ( connection ) Helper class that provides a standard way to create an ABC using inheritance. View Source class JsonCache ( DB ) : def __init__ ( self , connection ) : self . cache = ( read_json ( connection , convert_dates = False ) . set_index ( [ \"uid\", \"timestamp\" ] ) [ \"value\" ] . sort_index () ) self . filename = connection def __getitem__ ( self , key ) : return self . cache [ key ] def __setitem__ ( self , key , value ) : pass def pop ( self , key ) : pass def save ( self ) : self . cache . reset_index (). to_json ( self . filename , orient = \"records\" ) Ancestors (in MRO) hielen2.datalink.DB abc.ABC Methods pop def pop ( self , key ) View Source def pop ( self , key ): pass save def save ( self ) View Source def save ( self ): self . cache . reset_index (). to_json ( self . filename , orient = \"records\" ) JsonDB class JsonDB ( connection , schema , lock_timeout_seconds = 10 ) Helper class that provides a standard way to create an ABC using inheritance. View Source class JsonDB ( DB ) : def __init__ ( self , connection , schema , lock_timeout_seconds = 10 ) : self . jsonfile = connection self . lock = FileLock ( f \"{connection}.lock\" , timeout = lock_timeout_seconds ) self . md5file = f \"{connection}.md5\" self . md5 = None self . schema = schema self . __chk_and_reload_jsondb ( force = True ) def __brute_load_jsondb ( self ) : try : self . db = read_json ( self . jsonfile , orient = 'table' , convert_dates = False ) except Exception as e : self . db = DataFrame () if self . db . empty : self . db = DataFrame ( {} , columns = self . schema [ 'columns' ] ) self . db = self . db . set_index ( self . schema [ 'primary_key' ] ) def __chk_and_reload_jsondb ( self , force = False ) : \"\"\" Needs to check for json-database file changes in a thread safe way!! \"\"\" md5 = None error = None try : self . lock . acquire () try : if force : raise FileNotFoundError () with open ( self . md5file ) as o : md5 = o . read () if not md5 == self . md5 : self . md5 = md5 self . __brute_load_jsondb () except FileNotFoundError as e : ## refershing hash self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) self . __brute_load_jsondb () finally : self . lock . release () except Timeout : pass def save ( self ) : try : self . lock . acquire () try : self . db . to_json ( self . jsonfile , orient = 'table' ) self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) finally : self . lock . release () except Timeout as e : # Just to remind Timout error here raise e def __write_jsondb ( self , key , value ) : \"\"\" Needs to lock for writing json-database \"\"\" item = None error = None try : self . lock . acquire () try : self . __chk_and_reload_jsondb () if value is None : # Request to remove key , raises KeyError item = self . __getitem__ ( key ) try : self . db = self . db . drop ( key , axis = 0 ) except KeyError : raise KeyError ( f \"key {key} to remove does not exist\" ) else : # Request to insert key , raises ValueError primarykey = self . schema [ 'primary_key' ] if not isinstance ( key ,( list , set , tuple )) : key =[ key ] if key . __len__ () < primarykey . __len__ () : raise ValueError ( f \"key {key!r} is not fully determinated\" ) keydict = dict ( zip ( self . schema [ 'primary_key' ] , key )) value . update ( keydict ) df = DataFrame ( [ value.values() ] ) df . columns = value . keys () df = df . set_index ( self . schema [ 'primary_key' ] ) try : self . db = self . db . append ( df , verify_integrity = True ). sort_index () except ValueError : raise ValueError ( f \"key {key} to insert exists\" ) self . db . replace ( { nan : None , NaT : None } , inplace = True ) item = self . __brute_getitem ( key ) self . save () except Exception as e : error = e finally : self . lock . release () except Timeout as e : error = e if error is not None : raise error return item def __brute_getitem ( self , key = None ) : out = None if key is None : out = self . db else : out = self . db . loc [ key ] if isinstance ( out , Series ) : out = out . to_frame (). T out . index . names = self . schema [ 'primary_key' ] out = out . reset_index (). to_dict ( orient = 'records' ) if out . __len__ () == 1 : out = out [ 0 ] return out def __getitem__ ( self , key = None ) : self . __chk_and_reload_jsondb () if isinstance ( key , list ) : try : key = list ( filter ( None , key )) except TypeError : pass return self . __brute_getitem ( key ) def pop ( self , key ) : return self . __write_jsondb ( key , None ) def __setitem__ ( self , key = None , value = None ) : self . __write_jsondb ( key , value ) Ancestors (in MRO) hielen2.datalink.DB abc.ABC Methods pop def pop ( self , key ) View Source def pop ( self , key ): return self . __write_jsondb ( key , None ) save def save ( self ) View Source def save ( self ): try : self . lock . acquire () try : self . db . to_json ( self . jsonfile , orient = 'table' ) self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) finally : self . lock . release () except Timeout as e : # Just to remind Timout error here raise e","title":"Datalink"},{"location":"reference/hielen2/datalink/#module-hielen2datalink","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 #!/usr/bin/env python # coding=utf-8 from pandas import DataFrame , Series , read_json , NaT from abc import ABC , abstractmethod from hielen2.utils import loadjsonfile , savejsonfile , newinstanceof , hashfile from filelock import Timeout , FileLock from numpy import nan def dbinit ( conf ): return { k : newinstanceof ( w . pop ( \"klass\" ), ** w ) for k , w in conf [ \"db\" ] . items () } class DB ( ABC ): @abstractmethod def __init__ ( self , connection ): pass @abstractmethod def __getitem__ ( self , key ): pass @abstractmethod def __setitem__ ( self , key , value ): pass @abstractmethod def pop ( self , key ): pass class JsonDB ( DB ): def __init__ ( self , connection , schema , lock_timeout_seconds = 10 ): self . jsonfile = connection self . lock = FileLock ( f \" { connection } .lock\" , timeout = lock_timeout_seconds ) self . md5file = f \" { connection } .md5\" self . md5 = None self . schema = schema self . __chk_and_reload_jsondb ( force = True ) def __brute_load_jsondb ( self ): try : self . db = read_json ( self . jsonfile , orient = 'table' , convert_dates = False ) except Exception as e : self . db = DataFrame () if self . db . empty : self . db = DataFrame ({}, columns = self . schema [ 'columns' ]) self . db = self . db . set_index ( self . schema [ 'primary_key' ]) def __chk_and_reload_jsondb ( self , force = False ): \"\"\" Needs to check for json-database file changes in a thread safe way!! \"\"\" md5 = None error = None try : self . lock . acquire () try : if force : raise FileNotFoundError () with open ( self . md5file ) as o : md5 = o . read () if not md5 == self . md5 : self . md5 = md5 self . __brute_load_jsondb () except FileNotFoundError as e : ## refershing hash self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) self . __brute_load_jsondb () finally : self . lock . release () except Timeout : pass def save ( self ): try : self . lock . acquire () try : self . db . to_json ( self . jsonfile , orient = 'table' ) self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) finally : self . lock . release () except Timeout as e : # Just to remind Timout error here raise e def __write_jsondb ( self , key , value ): \"\"\" Needs to lock for writing json-database \"\"\" item = None error = None try : self . lock . acquire () try : self . __chk_and_reload_jsondb () if value is None : # Request to remove key, raises KeyError item = self . __getitem__ ( key ) try : self . db = self . db . drop ( key , axis = 0 ) except KeyError : raise KeyError ( f \"key { key } to remove does not exist\" ) else : # Request to insert key, raises ValueError primarykey = self . schema [ 'primary_key' ] if not isinstance ( key ,( list , set , tuple )): key = [ key ] if key . __len__ () < primarykey . __len__ (): raise ValueError ( f \"key { key !r} is not fully determinated\" ) keydict = dict ( zip ( self . schema [ 'primary_key' ], key )) value . update ( keydict ) df = DataFrame ([ value . values ()]) df . columns = value . keys () df = df . set_index ( self . schema [ 'primary_key' ]) try : self . db = self . db . append ( df , verify_integrity = True ) . sort_index () except ValueError : raise ValueError ( f \"key { key } to insert exists\" ) self . db . replace ({ nan : None , NaT : None }, inplace = True ) item = self . __brute_getitem ( key ) self . save () except Exception as e : error = e finally : self . lock . release () except Timeout as e : error = e if error is not None : raise error return item def __brute_getitem ( self , key = None ): out = None if key is None : out = self . db else : out = self . db . loc [ key ] if isinstance ( out , Series ): out = out . to_frame () . T out . index . names = self . schema [ 'primary_key' ] out = out . reset_index () . to_dict ( orient = 'records' ) if out . __len__ () == 1 : out = out [ 0 ] return out def __getitem__ ( self , key = None ): self . __chk_and_reload_jsondb () if isinstance ( key , list ): try : key = list ( filter ( None , key )) except TypeError : pass return self . __brute_getitem ( key ) def pop ( self , key ): return self . __write_jsondb ( key , None ) def __setitem__ ( self , key = None , value = None ): self . __write_jsondb ( key , value ) class JsonCache ( DB ): def __init__ ( self , connection ): self . cache = ( read_json ( connection , convert_dates = False ) . set_index ([ \"uid\" , \"timestamp\" ])[ \"value\" ] . sort_index () ) self . filename = connection def __getitem__ ( self , key ): return self . cache [ key ] def __setitem__ ( self , key , value ): pass def pop ( self , key ): pass def save ( self ): self . cache . reset_index () . to_json ( self . filename , orient = \"records\" )","title":"Module hielen2.datalink"},{"location":"reference/hielen2/datalink/#variables","text":"nan","title":"Variables"},{"location":"reference/hielen2/datalink/#functions","text":"","title":"Functions"},{"location":"reference/hielen2/datalink/#dbinit","text":"def dbinit ( conf ) View Source def dbinit ( conf ): return { k : newinstanceof ( w . pop ( \"klass\" ), ** w ) for k , w in conf [ \"db\" ]. items () }","title":"dbinit"},{"location":"reference/hielen2/datalink/#classes","text":"","title":"Classes"},{"location":"reference/hielen2/datalink/#db","text":"class DB ( connection ) Helper class that provides a standard way to create an ABC using inheritance. View Source class DB ( ABC ) : @abstractmethod def __init__ ( self , connection ) : pass @abstractmethod def __getitem__ ( self , key ) : pass @abstractmethod def __setitem__ ( self , key , value ) : pass @abstractmethod def pop ( self , key ) : pass","title":"DB"},{"location":"reference/hielen2/datalink/#ancestors-in-mro","text":"abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen2/datalink/#descendants","text":"hielen2.datalink.JsonDB hielen2.datalink.JsonCache","title":"Descendants"},{"location":"reference/hielen2/datalink/#methods","text":"","title":"Methods"},{"location":"reference/hielen2/datalink/#pop","text":"def pop ( self , key ) View Source @abstractmethod def pop ( self , key ) : pass","title":"pop"},{"location":"reference/hielen2/datalink/#jsoncache","text":"class JsonCache ( connection ) Helper class that provides a standard way to create an ABC using inheritance. View Source class JsonCache ( DB ) : def __init__ ( self , connection ) : self . cache = ( read_json ( connection , convert_dates = False ) . set_index ( [ \"uid\", \"timestamp\" ] ) [ \"value\" ] . sort_index () ) self . filename = connection def __getitem__ ( self , key ) : return self . cache [ key ] def __setitem__ ( self , key , value ) : pass def pop ( self , key ) : pass def save ( self ) : self . cache . reset_index (). to_json ( self . filename , orient = \"records\" )","title":"JsonCache"},{"location":"reference/hielen2/datalink/#ancestors-in-mro_1","text":"hielen2.datalink.DB abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen2/datalink/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen2/datalink/#pop_1","text":"def pop ( self , key ) View Source def pop ( self , key ): pass","title":"pop"},{"location":"reference/hielen2/datalink/#save","text":"def save ( self ) View Source def save ( self ): self . cache . reset_index (). to_json ( self . filename , orient = \"records\" )","title":"save"},{"location":"reference/hielen2/datalink/#jsondb","text":"class JsonDB ( connection , schema , lock_timeout_seconds = 10 ) Helper class that provides a standard way to create an ABC using inheritance. View Source class JsonDB ( DB ) : def __init__ ( self , connection , schema , lock_timeout_seconds = 10 ) : self . jsonfile = connection self . lock = FileLock ( f \"{connection}.lock\" , timeout = lock_timeout_seconds ) self . md5file = f \"{connection}.md5\" self . md5 = None self . schema = schema self . __chk_and_reload_jsondb ( force = True ) def __brute_load_jsondb ( self ) : try : self . db = read_json ( self . jsonfile , orient = 'table' , convert_dates = False ) except Exception as e : self . db = DataFrame () if self . db . empty : self . db = DataFrame ( {} , columns = self . schema [ 'columns' ] ) self . db = self . db . set_index ( self . schema [ 'primary_key' ] ) def __chk_and_reload_jsondb ( self , force = False ) : \"\"\" Needs to check for json-database file changes in a thread safe way!! \"\"\" md5 = None error = None try : self . lock . acquire () try : if force : raise FileNotFoundError () with open ( self . md5file ) as o : md5 = o . read () if not md5 == self . md5 : self . md5 = md5 self . __brute_load_jsondb () except FileNotFoundError as e : ## refershing hash self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) self . __brute_load_jsondb () finally : self . lock . release () except Timeout : pass def save ( self ) : try : self . lock . acquire () try : self . db . to_json ( self . jsonfile , orient = 'table' ) self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) finally : self . lock . release () except Timeout as e : # Just to remind Timout error here raise e def __write_jsondb ( self , key , value ) : \"\"\" Needs to lock for writing json-database \"\"\" item = None error = None try : self . lock . acquire () try : self . __chk_and_reload_jsondb () if value is None : # Request to remove key , raises KeyError item = self . __getitem__ ( key ) try : self . db = self . db . drop ( key , axis = 0 ) except KeyError : raise KeyError ( f \"key {key} to remove does not exist\" ) else : # Request to insert key , raises ValueError primarykey = self . schema [ 'primary_key' ] if not isinstance ( key ,( list , set , tuple )) : key =[ key ] if key . __len__ () < primarykey . __len__ () : raise ValueError ( f \"key {key!r} is not fully determinated\" ) keydict = dict ( zip ( self . schema [ 'primary_key' ] , key )) value . update ( keydict ) df = DataFrame ( [ value.values() ] ) df . columns = value . keys () df = df . set_index ( self . schema [ 'primary_key' ] ) try : self . db = self . db . append ( df , verify_integrity = True ). sort_index () except ValueError : raise ValueError ( f \"key {key} to insert exists\" ) self . db . replace ( { nan : None , NaT : None } , inplace = True ) item = self . __brute_getitem ( key ) self . save () except Exception as e : error = e finally : self . lock . release () except Timeout as e : error = e if error is not None : raise error return item def __brute_getitem ( self , key = None ) : out = None if key is None : out = self . db else : out = self . db . loc [ key ] if isinstance ( out , Series ) : out = out . to_frame (). T out . index . names = self . schema [ 'primary_key' ] out = out . reset_index (). to_dict ( orient = 'records' ) if out . __len__ () == 1 : out = out [ 0 ] return out def __getitem__ ( self , key = None ) : self . __chk_and_reload_jsondb () if isinstance ( key , list ) : try : key = list ( filter ( None , key )) except TypeError : pass return self . __brute_getitem ( key ) def pop ( self , key ) : return self . __write_jsondb ( key , None ) def __setitem__ ( self , key = None , value = None ) : self . __write_jsondb ( key , value )","title":"JsonDB"},{"location":"reference/hielen2/datalink/#ancestors-in-mro_2","text":"hielen2.datalink.DB abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen2/datalink/#methods_2","text":"","title":"Methods"},{"location":"reference/hielen2/datalink/#pop_2","text":"def pop ( self , key ) View Source def pop ( self , key ): return self . __write_jsondb ( key , None )","title":"pop"},{"location":"reference/hielen2/datalink/#save_1","text":"def save ( self ) View Source def save ( self ): try : self . lock . acquire () try : self . db . to_json ( self . jsonfile , orient = 'table' ) self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) finally : self . lock . release () except Timeout as e : # Just to remind Timout error here raise e","title":"save"},{"location":"reference/hielen2/datalink_json/","text":"Module hielen2.datalink_json View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 #!/usr/bin/env python # coding=utf-8 from pandas import DataFrame , Series , read_json , NaT from abc import ABC , abstractmethod from hielen2.utils import loadjsonfile , savejsonfile , newinstanceof , hashfile from filelock import Timeout , FileLock from numpy import nan import json def dbinit ( conf ): return { k : newinstanceof ( w . pop ( \"klass\" ), ** w ) for k , w in conf [ \"db\" ] . items () } class DB ( ABC ): @abstractmethod def __init__ ( self , connection ): pass @abstractmethod def __getitem__ ( self , key ): pass @abstractmethod def __setitem__ ( self , key , value ): pass @abstractmethod def pop ( self , key ): pass class JsonDB ( DB ): def __init__ ( self , connection , schema , lock_timeout_seconds = 10 ): self . jsonfile = connection self . lock = FileLock ( f \" { connection } .lock\" , timeout = lock_timeout_seconds ) self . md5file = f \" { connection } .md5\" self . md5 = None self . schema = schema self . __chk_and_reload_jsondb ( force = True ) def __brute_load_jsondb ( self ): try : self . db = read_json ( self . jsonfile , orient = 'table' , convert_dates = False ) except Exception as e : self . db = DataFrame () if self . db . empty : self . db = DataFrame ({}, columns = self . schema [ 'columns' ]) self . db = self . db . set_index ( self . schema [ 'primary_key' ]) def __chk_and_reload_jsondb ( self , force = False ): \"\"\" Needs to check for json-database file changes in a thread safe way!! \"\"\" md5 = None error = None try : self . lock . acquire () try : if force : raise FileNotFoundError () with open ( self . md5file ) as o : md5 = o . read () if not md5 == self . md5 : self . md5 = md5 self . __brute_load_jsondb () except FileNotFoundError as e : ## refershing hash self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) self . __brute_load_jsondb () finally : self . lock . release () except Timeout : pass def save ( self ): try : self . lock . acquire () try : self . db . to_json ( self . jsonfile , orient = 'table' ) self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) finally : self . lock . release () except Timeout as e : # Just to remind Timout error here raise e def __write_jsondb ( self , key , value ): \"\"\" Needs to lock for writing json-database \"\"\" item = None error = None try : self . lock . acquire () try : self . __chk_and_reload_jsondb () if value is None : # Request to remove key, raises KeyError item = self . __getitem__ ( key ) try : self . db = self . db . drop ( key , axis = 0 ) except KeyError : raise KeyError ( f \"key { key } to remove does not exist\" ) else : # Request to insert key, raises ValueError primarykey = self . schema [ 'primary_key' ] if not isinstance ( key ,( list , set , tuple )): key = [ key ] if key . __len__ () < primarykey . __len__ (): raise ValueError ( f \"key { key !r} is not fully determinated\" ) keydict = dict ( zip ( self . schema [ 'primary_key' ], key )) keydict [ 'value' ] = value df = read_json ( json . dumps ([ keydict ]), convert_dates = False ) df = df . set_index ( self . schema [ 'primary_key' ]) try : self . db = self . db . append ( df , verify_integrity = True ) . sort_index () except ValueError as e : raise ValueError ( f \"key { key } to insert exists\" ) self . db . replace ({ nan : None , NaT : None }, inplace = True ) item = self . __brute_getitem ( key ) self . save () except Exception as e : error = e finally : self . lock . release () except Timeout as e : error = e if error is not None : raise error return item def __brute_getitem ( self , key = None ): out = None if key is None : out = self . db else : out = self . db . loc [ key ] if isinstance ( out , Series ): out = out . to_frame () . T out . index . names = self . schema [ 'primary_key' ] out = out . reset_index () . to_dict ( orient = 'records' ) if out . __len__ () == 1 : out = out [ 0 ] return out def __getitem__ ( self , key = None ): self . __chk_and_reload_jsondb () if isinstance ( key , list ): try : key = list ( filter ( None , key )) except TypeError : pass return self . __brute_getitem ( key ) def pop ( self , key ): return self . __write_jsondb ( key , None ) def __setitem__ ( self , key = None , value = None ): self . __write_jsondb ( key , value ) class JsonCache ( DB ): def __init__ ( self , connection ): self . cache = ( read_json ( connection , convert_dates = False ) . set_index ([ \"uid\" , \"timestamp\" ])[ \"value\" ] . sort_index () ) self . filename = connection def __getitem__ ( self , key ): return self . cache [ key ] def __setitem__ ( self , key , value ): pass def pop ( self , key ): pass def save ( self ): self . cache . reset_index () . to_json ( self . filename , orient = \"records\" ) Variables nan Functions dbinit def dbinit ( conf ) View Source def dbinit ( conf ): return { k : newinstanceof ( w . pop ( \"klass\" ), ** w ) for k , w in conf [ \"db\" ]. items () } Classes DB class DB ( connection ) Helper class that provides a standard way to create an ABC using inheritance. View Source class DB ( ABC ) : @abstractmethod def __init__ ( self , connection ) : pass @abstractmethod def __getitem__ ( self , key ) : pass @abstractmethod def __setitem__ ( self , key , value ) : pass @abstractmethod def pop ( self , key ) : pass Ancestors (in MRO) abc.ABC Descendants hielen2.datalink_json.JsonDB hielen2.datalink_json.JsonCache Methods pop def pop ( self , key ) View Source @abstractmethod def pop ( self , key ) : pass JsonCache class JsonCache ( connection ) Helper class that provides a standard way to create an ABC using inheritance. View Source class JsonCache ( DB ) : def __init__ ( self , connection ) : self . cache = ( read_json ( connection , convert_dates = False ) . set_index ( [ \"uid\", \"timestamp\" ] ) [ \"value\" ] . sort_index () ) self . filename = connection def __getitem__ ( self , key ) : return self . cache [ key ] def __setitem__ ( self , key , value ) : pass def pop ( self , key ) : pass def save ( self ) : self . cache . reset_index (). to_json ( self . filename , orient = \"records\" ) Ancestors (in MRO) hielen2.datalink_json.DB abc.ABC Methods pop def pop ( self , key ) View Source def pop ( self , key ): pass save def save ( self ) View Source def save ( self ): self . cache . reset_index (). to_json ( self . filename , orient = \"records\" ) JsonDB class JsonDB ( connection , schema , lock_timeout_seconds = 10 ) Helper class that provides a standard way to create an ABC using inheritance. View Source class JsonDB ( DB ) : def __init__ ( self , connection , schema , lock_timeout_seconds = 10 ) : self . jsonfile = connection self . lock = FileLock ( f \"{connection}.lock\" , timeout = lock_timeout_seconds ) self . md5file = f \"{connection}.md5\" self . md5 = None self . schema = schema self . __chk_and_reload_jsondb ( force = True ) def __brute_load_jsondb ( self ) : try : self . db = read_json ( self . jsonfile , orient = 'table' , convert_dates = False ) except Exception as e : self . db = DataFrame () if self . db . empty : self . db = DataFrame ( {} , columns = self . schema [ 'columns' ] ) self . db = self . db . set_index ( self . schema [ 'primary_key' ] ) def __chk_and_reload_jsondb ( self , force = False ) : \"\"\" Needs to check for json-database file changes in a thread safe way!! \"\"\" md5 = None error = None try : self . lock . acquire () try : if force : raise FileNotFoundError () with open ( self . md5file ) as o : md5 = o . read () if not md5 == self . md5 : self . md5 = md5 self . __brute_load_jsondb () except FileNotFoundError as e : ## refershing hash self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) self . __brute_load_jsondb () finally : self . lock . release () except Timeout : pass def save ( self ) : try : self . lock . acquire () try : self . db . to_json ( self . jsonfile , orient = 'table' ) self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) finally : self . lock . release () except Timeout as e : # Just to remind Timout error here raise e def __write_jsondb ( self , key , value ) : \"\"\" Needs to lock for writing json-database \"\"\" item = None error = None try : self . lock . acquire () try : self . __chk_and_reload_jsondb () if value is None : # Request to remove key , raises KeyError item = self . __getitem__ ( key ) try : self . db = self . db . drop ( key , axis = 0 ) except KeyError : raise KeyError ( f \"key {key} to remove does not exist\" ) else : # Request to insert key , raises ValueError primarykey = self . schema [ 'primary_key' ] if not isinstance ( key ,( list , set , tuple )) : key =[ key ] if key . __len__ () < primarykey . __len__ () : raise ValueError ( f \"key {key!r} is not fully determinated\" ) keydict = dict ( zip ( self . schema [ 'primary_key' ] , key )) keydict [ 'value' ]= value df = read_json ( json . dumps ( [ keydict ] ), convert_dates = False ) df = df . set_index ( self . schema [ 'primary_key' ] ) try : self . db = self . db . append ( df , verify_integrity = True ). sort_index () except ValueError as e : raise ValueError ( f \"key {key} to insert exists\" ) self . db . replace ( { nan : None , NaT : None } , inplace = True ) item = self . __brute_getitem ( key ) self . save () except Exception as e : error = e finally : self . lock . release () except Timeout as e : error = e if error is not None : raise error return item def __brute_getitem ( self , key = None ) : out = None if key is None : out = self . db else : out = self . db . loc [ key ] if isinstance ( out , Series ) : out = out . to_frame (). T out . index . names = self . schema [ 'primary_key' ] out = out . reset_index (). to_dict ( orient = 'records' ) if out . __len__ () == 1 : out = out [ 0 ] return out def __getitem__ ( self , key = None ) : self . __chk_and_reload_jsondb () if isinstance ( key , list ) : try : key = list ( filter ( None , key )) except TypeError : pass return self . __brute_getitem ( key ) def pop ( self , key ) : return self . __write_jsondb ( key , None ) def __setitem__ ( self , key = None , value = None ) : self . __write_jsondb ( key , value ) Ancestors (in MRO) hielen2.datalink_json.DB abc.ABC Methods pop def pop ( self , key ) View Source def pop ( self , key ): return self . __write_jsondb ( key , None ) save def save ( self ) View Source def save ( self ): try : self . lock . acquire () try : self . db . to_json ( self . jsonfile , orient = 'table' ) self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) finally : self . lock . release () except Timeout as e : # Just to remind Timout error here raise e","title":"Datalink Json"},{"location":"reference/hielen2/datalink_json/#module-hielen2datalink_json","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 #!/usr/bin/env python # coding=utf-8 from pandas import DataFrame , Series , read_json , NaT from abc import ABC , abstractmethod from hielen2.utils import loadjsonfile , savejsonfile , newinstanceof , hashfile from filelock import Timeout , FileLock from numpy import nan import json def dbinit ( conf ): return { k : newinstanceof ( w . pop ( \"klass\" ), ** w ) for k , w in conf [ \"db\" ] . items () } class DB ( ABC ): @abstractmethod def __init__ ( self , connection ): pass @abstractmethod def __getitem__ ( self , key ): pass @abstractmethod def __setitem__ ( self , key , value ): pass @abstractmethod def pop ( self , key ): pass class JsonDB ( DB ): def __init__ ( self , connection , schema , lock_timeout_seconds = 10 ): self . jsonfile = connection self . lock = FileLock ( f \" { connection } .lock\" , timeout = lock_timeout_seconds ) self . md5file = f \" { connection } .md5\" self . md5 = None self . schema = schema self . __chk_and_reload_jsondb ( force = True ) def __brute_load_jsondb ( self ): try : self . db = read_json ( self . jsonfile , orient = 'table' , convert_dates = False ) except Exception as e : self . db = DataFrame () if self . db . empty : self . db = DataFrame ({}, columns = self . schema [ 'columns' ]) self . db = self . db . set_index ( self . schema [ 'primary_key' ]) def __chk_and_reload_jsondb ( self , force = False ): \"\"\" Needs to check for json-database file changes in a thread safe way!! \"\"\" md5 = None error = None try : self . lock . acquire () try : if force : raise FileNotFoundError () with open ( self . md5file ) as o : md5 = o . read () if not md5 == self . md5 : self . md5 = md5 self . __brute_load_jsondb () except FileNotFoundError as e : ## refershing hash self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) self . __brute_load_jsondb () finally : self . lock . release () except Timeout : pass def save ( self ): try : self . lock . acquire () try : self . db . to_json ( self . jsonfile , orient = 'table' ) self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) finally : self . lock . release () except Timeout as e : # Just to remind Timout error here raise e def __write_jsondb ( self , key , value ): \"\"\" Needs to lock for writing json-database \"\"\" item = None error = None try : self . lock . acquire () try : self . __chk_and_reload_jsondb () if value is None : # Request to remove key, raises KeyError item = self . __getitem__ ( key ) try : self . db = self . db . drop ( key , axis = 0 ) except KeyError : raise KeyError ( f \"key { key } to remove does not exist\" ) else : # Request to insert key, raises ValueError primarykey = self . schema [ 'primary_key' ] if not isinstance ( key ,( list , set , tuple )): key = [ key ] if key . __len__ () < primarykey . __len__ (): raise ValueError ( f \"key { key !r} is not fully determinated\" ) keydict = dict ( zip ( self . schema [ 'primary_key' ], key )) keydict [ 'value' ] = value df = read_json ( json . dumps ([ keydict ]), convert_dates = False ) df = df . set_index ( self . schema [ 'primary_key' ]) try : self . db = self . db . append ( df , verify_integrity = True ) . sort_index () except ValueError as e : raise ValueError ( f \"key { key } to insert exists\" ) self . db . replace ({ nan : None , NaT : None }, inplace = True ) item = self . __brute_getitem ( key ) self . save () except Exception as e : error = e finally : self . lock . release () except Timeout as e : error = e if error is not None : raise error return item def __brute_getitem ( self , key = None ): out = None if key is None : out = self . db else : out = self . db . loc [ key ] if isinstance ( out , Series ): out = out . to_frame () . T out . index . names = self . schema [ 'primary_key' ] out = out . reset_index () . to_dict ( orient = 'records' ) if out . __len__ () == 1 : out = out [ 0 ] return out def __getitem__ ( self , key = None ): self . __chk_and_reload_jsondb () if isinstance ( key , list ): try : key = list ( filter ( None , key )) except TypeError : pass return self . __brute_getitem ( key ) def pop ( self , key ): return self . __write_jsondb ( key , None ) def __setitem__ ( self , key = None , value = None ): self . __write_jsondb ( key , value ) class JsonCache ( DB ): def __init__ ( self , connection ): self . cache = ( read_json ( connection , convert_dates = False ) . set_index ([ \"uid\" , \"timestamp\" ])[ \"value\" ] . sort_index () ) self . filename = connection def __getitem__ ( self , key ): return self . cache [ key ] def __setitem__ ( self , key , value ): pass def pop ( self , key ): pass def save ( self ): self . cache . reset_index () . to_json ( self . filename , orient = \"records\" )","title":"Module hielen2.datalink_json"},{"location":"reference/hielen2/datalink_json/#variables","text":"nan","title":"Variables"},{"location":"reference/hielen2/datalink_json/#functions","text":"","title":"Functions"},{"location":"reference/hielen2/datalink_json/#dbinit","text":"def dbinit ( conf ) View Source def dbinit ( conf ): return { k : newinstanceof ( w . pop ( \"klass\" ), ** w ) for k , w in conf [ \"db\" ]. items () }","title":"dbinit"},{"location":"reference/hielen2/datalink_json/#classes","text":"","title":"Classes"},{"location":"reference/hielen2/datalink_json/#db","text":"class DB ( connection ) Helper class that provides a standard way to create an ABC using inheritance. View Source class DB ( ABC ) : @abstractmethod def __init__ ( self , connection ) : pass @abstractmethod def __getitem__ ( self , key ) : pass @abstractmethod def __setitem__ ( self , key , value ) : pass @abstractmethod def pop ( self , key ) : pass","title":"DB"},{"location":"reference/hielen2/datalink_json/#ancestors-in-mro","text":"abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen2/datalink_json/#descendants","text":"hielen2.datalink_json.JsonDB hielen2.datalink_json.JsonCache","title":"Descendants"},{"location":"reference/hielen2/datalink_json/#methods","text":"","title":"Methods"},{"location":"reference/hielen2/datalink_json/#pop","text":"def pop ( self , key ) View Source @abstractmethod def pop ( self , key ) : pass","title":"pop"},{"location":"reference/hielen2/datalink_json/#jsoncache","text":"class JsonCache ( connection ) Helper class that provides a standard way to create an ABC using inheritance. View Source class JsonCache ( DB ) : def __init__ ( self , connection ) : self . cache = ( read_json ( connection , convert_dates = False ) . set_index ( [ \"uid\", \"timestamp\" ] ) [ \"value\" ] . sort_index () ) self . filename = connection def __getitem__ ( self , key ) : return self . cache [ key ] def __setitem__ ( self , key , value ) : pass def pop ( self , key ) : pass def save ( self ) : self . cache . reset_index (). to_json ( self . filename , orient = \"records\" )","title":"JsonCache"},{"location":"reference/hielen2/datalink_json/#ancestors-in-mro_1","text":"hielen2.datalink_json.DB abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen2/datalink_json/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen2/datalink_json/#pop_1","text":"def pop ( self , key ) View Source def pop ( self , key ): pass","title":"pop"},{"location":"reference/hielen2/datalink_json/#save","text":"def save ( self ) View Source def save ( self ): self . cache . reset_index (). to_json ( self . filename , orient = \"records\" )","title":"save"},{"location":"reference/hielen2/datalink_json/#jsondb","text":"class JsonDB ( connection , schema , lock_timeout_seconds = 10 ) Helper class that provides a standard way to create an ABC using inheritance. View Source class JsonDB ( DB ) : def __init__ ( self , connection , schema , lock_timeout_seconds = 10 ) : self . jsonfile = connection self . lock = FileLock ( f \"{connection}.lock\" , timeout = lock_timeout_seconds ) self . md5file = f \"{connection}.md5\" self . md5 = None self . schema = schema self . __chk_and_reload_jsondb ( force = True ) def __brute_load_jsondb ( self ) : try : self . db = read_json ( self . jsonfile , orient = 'table' , convert_dates = False ) except Exception as e : self . db = DataFrame () if self . db . empty : self . db = DataFrame ( {} , columns = self . schema [ 'columns' ] ) self . db = self . db . set_index ( self . schema [ 'primary_key' ] ) def __chk_and_reload_jsondb ( self , force = False ) : \"\"\" Needs to check for json-database file changes in a thread safe way!! \"\"\" md5 = None error = None try : self . lock . acquire () try : if force : raise FileNotFoundError () with open ( self . md5file ) as o : md5 = o . read () if not md5 == self . md5 : self . md5 = md5 self . __brute_load_jsondb () except FileNotFoundError as e : ## refershing hash self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) self . __brute_load_jsondb () finally : self . lock . release () except Timeout : pass def save ( self ) : try : self . lock . acquire () try : self . db . to_json ( self . jsonfile , orient = 'table' ) self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) finally : self . lock . release () except Timeout as e : # Just to remind Timout error here raise e def __write_jsondb ( self , key , value ) : \"\"\" Needs to lock for writing json-database \"\"\" item = None error = None try : self . lock . acquire () try : self . __chk_and_reload_jsondb () if value is None : # Request to remove key , raises KeyError item = self . __getitem__ ( key ) try : self . db = self . db . drop ( key , axis = 0 ) except KeyError : raise KeyError ( f \"key {key} to remove does not exist\" ) else : # Request to insert key , raises ValueError primarykey = self . schema [ 'primary_key' ] if not isinstance ( key ,( list , set , tuple )) : key =[ key ] if key . __len__ () < primarykey . __len__ () : raise ValueError ( f \"key {key!r} is not fully determinated\" ) keydict = dict ( zip ( self . schema [ 'primary_key' ] , key )) keydict [ 'value' ]= value df = read_json ( json . dumps ( [ keydict ] ), convert_dates = False ) df = df . set_index ( self . schema [ 'primary_key' ] ) try : self . db = self . db . append ( df , verify_integrity = True ). sort_index () except ValueError as e : raise ValueError ( f \"key {key} to insert exists\" ) self . db . replace ( { nan : None , NaT : None } , inplace = True ) item = self . __brute_getitem ( key ) self . save () except Exception as e : error = e finally : self . lock . release () except Timeout as e : error = e if error is not None : raise error return item def __brute_getitem ( self , key = None ) : out = None if key is None : out = self . db else : out = self . db . loc [ key ] if isinstance ( out , Series ) : out = out . to_frame (). T out . index . names = self . schema [ 'primary_key' ] out = out . reset_index (). to_dict ( orient = 'records' ) if out . __len__ () == 1 : out = out [ 0 ] return out def __getitem__ ( self , key = None ) : self . __chk_and_reload_jsondb () if isinstance ( key , list ) : try : key = list ( filter ( None , key )) except TypeError : pass return self . __brute_getitem ( key ) def pop ( self , key ) : return self . __write_jsondb ( key , None ) def __setitem__ ( self , key = None , value = None ) : self . __write_jsondb ( key , value )","title":"JsonDB"},{"location":"reference/hielen2/datalink_json/#ancestors-in-mro_2","text":"hielen2.datalink_json.DB abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen2/datalink_json/#methods_2","text":"","title":"Methods"},{"location":"reference/hielen2/datalink_json/#pop_2","text":"def pop ( self , key ) View Source def pop ( self , key ): return self . __write_jsondb ( key , None )","title":"pop"},{"location":"reference/hielen2/datalink_json/#save_1","text":"def save ( self ) View Source def save ( self ): try : self . lock . acquire () try : self . db . to_json ( self . jsonfile , orient = 'table' ) self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) finally : self . lock . release () except Timeout as e : # Just to remind Timout error here raise e","title":"save"},{"location":"reference/hielen2/source/","text":"Module hielen2.source View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 #!/usr/bin/env python # coding=utf-8 import os from inspect import ismodule from abc import ABC , abstractmethod from importlib import import_module from hielen2 import db , conf from hielen2.utils import getSchemaDict from marshmallow import Schema , fields def loadModule ( proto ): if ismodule ( proto ): return proto mod = db [ \"features_proto\" ][ proto ][ \"module\" ] return import_module ( mod ) def moduleActions ( proto ): mod = loadModule ( proto ) return [ k . replace ( 'Schema' , '' ) . lower () for k in mod . __dict__ . keys () if 'Schema' in k ] def getActionSchema ( proto , action ): mod = loadModule ( proto ) return getSchemaDict ( mod . __getattribute__ ( f \" { action . capitalize () } Schema\" )()) def sourceFactory ( featdict , filecache ): mod = loadModule ( featdict [ 'type' ]) return mod . Source ( feature = featdict , filecache = filecache ) class ActionSchema ( Schema ): ''' Minimal ActionSchema object. Used to define at least a timestamp ''' timestamp = fields . Str ( required = True , allow_none = False ) class HielenSource ( ABC ): def __init__ ( self , feature , filecache ): self . __dict__ . update ( feature ) self . module = import_module ( self . __module__ ) #TODO possibili problemi di sicurezza self . filecache = os . path . join ( filecache , self . uid ) def makeCachePath ( self , path ): outpath = os . path . join ( self . filecache , path ) os . makedirs ( outpath , exist_ok = True ) return outpath def getRelativePath ( self , path ): return path . replace ( f \" { self . filecache } /\" , \"\" ) def execAction ( self , action , ** kwargs ): return self . __getattribute__ ( action )( ** kwargs ) def getActionSchema ( self , action ): return getActionSchema ( self . module , action ) def getActionValues ( self , action = None , timestamp = None ): if action is None : action = slice ( None , None ) if timestamp is None : timestamp = slice ( None , None ) return db [ 'actions' ][ self . uid , action , timestamp ] @abstractmethod def data ( timefrom = None , timeto = None , geom = None , ** kwargs ): pass Variables conf db Functions getActionSchema def getActionSchema ( proto , action ) View Source def getActionSchema ( proto , action ): mod = loadModule ( proto ) return getSchemaDict ( mod . __getattribute__ ( f \"{action.capitalize()}Schema\" )()) loadModule def loadModule ( proto ) View Source def loadModule ( proto ) : if ismodule ( proto ) : return proto mod = db [ \"features_proto\" ][ proto ][ \"module\" ] return import_module ( mod ) moduleActions def moduleActions ( proto ) View Source def moduleActions ( proto ): mod = loadModule ( proto ) return [ k . replace ( 'Schema' , '' ). lower () for k in mod . __dict__ . keys () if 'Schema' in k ] sourceFactory def sourceFactory ( featdict , filecache ) View Source def sourceFactory ( featdict , filecache ): mod = loadModule ( featdict [ 'type' ]) return mod . Source ( feature = featdict , filecache = filecache ) Classes ActionSchema class ActionSchema ( * , only : Union [ Sequence [ str ], Set [ str ], NoneType ] = None , exclude : Union [ Sequence [ str ], Set [ str ]] = (), many : bool = False , context : Union [ Dict , NoneType ] = None , load_only : Union [ Sequence [ str ], Set [ str ]] = (), dump_only : Union [ Sequence [ str ], Set [ str ]] = (), partial : Union [ bool , Sequence [ str ], Set [ str ]] = False , unknown : Union [ str , NoneType ] = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ActionSchema ( Schema ): ''' Minimal ActionSchema object. Used to define at least a timestamp ''' timestamp = fields . Str ( required = True , allow_none = False ) Ancestors (in MRO) marshmallow.schema.Schema marshmallow.base.SchemaABC Descendants hielen2.ext.source_photomonitoring.phm.ConfigSchema hielen2.ext.source_photomonitoring.phm.FeedSchema Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages opts timestamp Static methods from_dict def from_dict ( fields : Dict [ str , Union [ marshmallow . fields . Field , type ]], * , name : str = 'GeneratedSchema' ) -> type Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 View Source @classmethod def from_dict ( cls , fields : typing . Dict [ str , typing . Union [ ma_fields . Field , type ]], * , name : str = \"GeneratedSchema\" ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : Any , * , many : Union [ bool , NoneType ] = None ) Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : typing . Optional [ bool ] = None ): \"\"\"Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\"\" many = self . many if many is None else bool ( many ) if many and is_iterable_but_not_string ( obj ): obj = list ( obj ) if self . _has_processors ( PRE_DUMP ): processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ): result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : Any , * args , many : Union [ bool , NoneType ] = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A json string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : typing . Optional [ bool ] = None , ** kwargs ): \"\"\"Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\"\" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : Any , attr : str , default : Any ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ): \"\"\"Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\"\" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : marshmallow . exceptions . ValidationError , data : Any , * , many : bool , ** kwargs ) Custom error handler function for the schema. :param error: The ValidationError raised during (de)serialization. :param data: The original input data. :param many: Value of many on dump or load. :param partial: Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ): \"\"\"Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\"\" pass load def load ( self , data : Union [ Mapping [ str , Any ], Iterable [ Mapping [ str , Any ]]], * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None ) Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : typing . Union [ typing . Mapping [ str , typing . Any ], typing . Iterable [ typing . Mapping [ str , typing . Any ]], ], * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None ): \"\"\"Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : str , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize obj as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None , ** kwargs ): \"\"\"Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : str , field_obj : marshmallow . fields . Field ) -> None Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \"\"\"Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\"\" return None validate def validate ( self , data : Mapping , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None ) -> Dict [ str , List [ str ]] Validate data against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : typing . Mapping , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None ) -> typing . Dict [ str , typing . List [ str ]]: \"\"\"Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\"\" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]], exc . messages ) return {} HielenSource class HielenSource ( feature , filecache ) Helper class that provides a standard way to create an ABC using inheritance. View Source class HielenSource ( ABC ) : def __init__ ( self , feature , filecache ) : self . __dict__ . update ( feature ) self . module = import_module ( self . __module__ ) #TODO possibili problemi di sicurezza self . filecache = os . path . join ( filecache , self . uid ) def makeCachePath ( self , path ) : outpath = os . path . join ( self . filecache , path ) os . makedirs ( outpath , exist_ok = True ) return outpath def getRelativePath ( self , path ) : return path . replace ( f \"{self.filecache}/\" , \"\" ) def execAction ( self , action , ** kwargs ) : return self . __getattribute__ ( action )( ** kwargs ) def getActionSchema ( self , action ) : return getActionSchema ( self . module , action ) def getActionValues ( self , action = None , timestamp = None ) : if action is None : action = slice ( None , None ) if timestamp is None : timestamp = slice ( None , None ) return db [ 'actions' ][ self.uid,action,timestamp ] @abstractmethod def data ( timefrom = None , timeto = None , geom = None , ** kwargs ) : pass Ancestors (in MRO) abc.ABC Descendants hielen2.ext.source_photomonitoring.phm.Source hielen2.ext.source_tinsar.Source Methods data def data ( timefrom = None , timeto = None , geom = None , ** kwargs ) View Source @abstractmethod def data ( timefrom = None , timeto = None , geom = None , ** kwargs ) : pass execAction def execAction ( self , action , ** kwargs ) View Source def execAction ( self , action , ** kwargs ): return self . __getattribute__ ( action )( ** kwargs ) getActionSchema def getActionSchema ( self , action ) View Source def getActionSchema ( self , action ): return getActionSchema ( self . module , action ) getActionValues def getActionValues ( self , action = None , timestamp = None ) View Source def getActionValues ( self , action = None , timestamp = None ): if action is None : action = slice ( None , None ) if timestamp is None : timestamp = slice ( None , None ) return db [ 'actions' ][ self . uid , action , timestamp ] getRelativePath def getRelativePath ( self , path ) View Source def getRelativePath ( self , path ): return path . replace ( f \"{self.filecache}/\" , \"\" ) makeCachePath def makeCachePath ( self , path ) View Source def makeCachePath ( self , path ): outpath = os . path . join ( self . filecache , path ) os . makedirs ( outpath , exist_ok = True ) return outpath","title":"Source"},{"location":"reference/hielen2/source/#module-hielen2source","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 #!/usr/bin/env python # coding=utf-8 import os from inspect import ismodule from abc import ABC , abstractmethod from importlib import import_module from hielen2 import db , conf from hielen2.utils import getSchemaDict from marshmallow import Schema , fields def loadModule ( proto ): if ismodule ( proto ): return proto mod = db [ \"features_proto\" ][ proto ][ \"module\" ] return import_module ( mod ) def moduleActions ( proto ): mod = loadModule ( proto ) return [ k . replace ( 'Schema' , '' ) . lower () for k in mod . __dict__ . keys () if 'Schema' in k ] def getActionSchema ( proto , action ): mod = loadModule ( proto ) return getSchemaDict ( mod . __getattribute__ ( f \" { action . capitalize () } Schema\" )()) def sourceFactory ( featdict , filecache ): mod = loadModule ( featdict [ 'type' ]) return mod . Source ( feature = featdict , filecache = filecache ) class ActionSchema ( Schema ): ''' Minimal ActionSchema object. Used to define at least a timestamp ''' timestamp = fields . Str ( required = True , allow_none = False ) class HielenSource ( ABC ): def __init__ ( self , feature , filecache ): self . __dict__ . update ( feature ) self . module = import_module ( self . __module__ ) #TODO possibili problemi di sicurezza self . filecache = os . path . join ( filecache , self . uid ) def makeCachePath ( self , path ): outpath = os . path . join ( self . filecache , path ) os . makedirs ( outpath , exist_ok = True ) return outpath def getRelativePath ( self , path ): return path . replace ( f \" { self . filecache } /\" , \"\" ) def execAction ( self , action , ** kwargs ): return self . __getattribute__ ( action )( ** kwargs ) def getActionSchema ( self , action ): return getActionSchema ( self . module , action ) def getActionValues ( self , action = None , timestamp = None ): if action is None : action = slice ( None , None ) if timestamp is None : timestamp = slice ( None , None ) return db [ 'actions' ][ self . uid , action , timestamp ] @abstractmethod def data ( timefrom = None , timeto = None , geom = None , ** kwargs ): pass","title":"Module hielen2.source"},{"location":"reference/hielen2/source/#variables","text":"conf db","title":"Variables"},{"location":"reference/hielen2/source/#functions","text":"","title":"Functions"},{"location":"reference/hielen2/source/#getactionschema","text":"def getActionSchema ( proto , action ) View Source def getActionSchema ( proto , action ): mod = loadModule ( proto ) return getSchemaDict ( mod . __getattribute__ ( f \"{action.capitalize()}Schema\" )())","title":"getActionSchema"},{"location":"reference/hielen2/source/#loadmodule","text":"def loadModule ( proto ) View Source def loadModule ( proto ) : if ismodule ( proto ) : return proto mod = db [ \"features_proto\" ][ proto ][ \"module\" ] return import_module ( mod )","title":"loadModule"},{"location":"reference/hielen2/source/#moduleactions","text":"def moduleActions ( proto ) View Source def moduleActions ( proto ): mod = loadModule ( proto ) return [ k . replace ( 'Schema' , '' ). lower () for k in mod . __dict__ . keys () if 'Schema' in k ]","title":"moduleActions"},{"location":"reference/hielen2/source/#sourcefactory","text":"def sourceFactory ( featdict , filecache ) View Source def sourceFactory ( featdict , filecache ): mod = loadModule ( featdict [ 'type' ]) return mod . Source ( feature = featdict , filecache = filecache )","title":"sourceFactory"},{"location":"reference/hielen2/source/#classes","text":"","title":"Classes"},{"location":"reference/hielen2/source/#actionschema","text":"class ActionSchema ( * , only : Union [ Sequence [ str ], Set [ str ], NoneType ] = None , exclude : Union [ Sequence [ str ], Set [ str ]] = (), many : bool = False , context : Union [ Dict , NoneType ] = None , load_only : Union [ Sequence [ str ], Set [ str ]] = (), dump_only : Union [ Sequence [ str ], Set [ str ]] = (), partial : Union [ bool , Sequence [ str ], Set [ str ]] = False , unknown : Union [ str , NoneType ] = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ActionSchema ( Schema ): ''' Minimal ActionSchema object. Used to define at least a timestamp ''' timestamp = fields . Str ( required = True , allow_none = False )","title":"ActionSchema"},{"location":"reference/hielen2/source/#ancestors-in-mro","text":"marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen2/source/#descendants","text":"hielen2.ext.source_photomonitoring.phm.ConfigSchema hielen2.ext.source_photomonitoring.phm.FeedSchema","title":"Descendants"},{"location":"reference/hielen2/source/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages opts timestamp","title":"Class variables"},{"location":"reference/hielen2/source/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen2/source/#from_dict","text":"def from_dict ( fields : Dict [ str , Union [ marshmallow . fields . Field , type ]], * , name : str = 'GeneratedSchema' ) -> type Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 View Source @classmethod def from_dict ( cls , fields : typing . Dict [ str , typing . Union [ ma_fields . Field , type ]], * , name : str = \"GeneratedSchema\" ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen2/source/#instance-variables","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen2/source/#methods","text":"","title":"Methods"},{"location":"reference/hielen2/source/#dump","text":"def dump ( self , obj : Any , * , many : Union [ bool , NoneType ] = None ) Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : typing . Optional [ bool ] = None ): \"\"\"Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\"\" many = self . many if many is None else bool ( many ) if many and is_iterable_but_not_string ( obj ): obj = list ( obj ) if self . _has_processors ( PRE_DUMP ): processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ): result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen2/source/#dumps","text":"def dumps ( self , obj : Any , * args , many : Union [ bool , NoneType ] = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A json string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : typing . Optional [ bool ] = None , ** kwargs ): \"\"\"Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\"\" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen2/source/#get_attribute","text":"def get_attribute ( self , obj : Any , attr : str , default : Any ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ): \"\"\"Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\"\" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen2/source/#handle_error","text":"def handle_error ( self , error : marshmallow . exceptions . ValidationError , data : Any , * , many : bool , ** kwargs ) Custom error handler function for the schema. :param error: The ValidationError raised during (de)serialization. :param data: The original input data. :param many: Value of many on dump or load. :param partial: Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ): \"\"\"Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\"\" pass","title":"handle_error"},{"location":"reference/hielen2/source/#load","text":"def load ( self , data : Union [ Mapping [ str , Any ], Iterable [ Mapping [ str , Any ]]], * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None ) Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : typing . Union [ typing . Mapping [ str , typing . Any ], typing . Iterable [ typing . Mapping [ str , typing . Any ]], ], * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None ): \"\"\"Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen2/source/#loads","text":"def loads ( self , json_data : str , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize obj as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None , ** kwargs ): \"\"\"Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen2/source/#on_bind_field","text":"def on_bind_field ( self , field_name : str , field_obj : marshmallow . fields . Field ) -> None Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \"\"\"Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\"\" return None","title":"on_bind_field"},{"location":"reference/hielen2/source/#validate","text":"def validate ( self , data : Mapping , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None ) -> Dict [ str , List [ str ]] Validate data against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : typing . Mapping , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None ) -> typing . Dict [ str , typing . List [ str ]]: \"\"\"Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\"\" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]], exc . messages ) return {}","title":"validate"},{"location":"reference/hielen2/source/#hielensource","text":"class HielenSource ( feature , filecache ) Helper class that provides a standard way to create an ABC using inheritance. View Source class HielenSource ( ABC ) : def __init__ ( self , feature , filecache ) : self . __dict__ . update ( feature ) self . module = import_module ( self . __module__ ) #TODO possibili problemi di sicurezza self . filecache = os . path . join ( filecache , self . uid ) def makeCachePath ( self , path ) : outpath = os . path . join ( self . filecache , path ) os . makedirs ( outpath , exist_ok = True ) return outpath def getRelativePath ( self , path ) : return path . replace ( f \"{self.filecache}/\" , \"\" ) def execAction ( self , action , ** kwargs ) : return self . __getattribute__ ( action )( ** kwargs ) def getActionSchema ( self , action ) : return getActionSchema ( self . module , action ) def getActionValues ( self , action = None , timestamp = None ) : if action is None : action = slice ( None , None ) if timestamp is None : timestamp = slice ( None , None ) return db [ 'actions' ][ self.uid,action,timestamp ] @abstractmethod def data ( timefrom = None , timeto = None , geom = None , ** kwargs ) : pass","title":"HielenSource"},{"location":"reference/hielen2/source/#ancestors-in-mro_1","text":"abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen2/source/#descendants_1","text":"hielen2.ext.source_photomonitoring.phm.Source hielen2.ext.source_tinsar.Source","title":"Descendants"},{"location":"reference/hielen2/source/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen2/source/#data","text":"def data ( timefrom = None , timeto = None , geom = None , ** kwargs ) View Source @abstractmethod def data ( timefrom = None , timeto = None , geom = None , ** kwargs ) : pass","title":"data"},{"location":"reference/hielen2/source/#execaction","text":"def execAction ( self , action , ** kwargs ) View Source def execAction ( self , action , ** kwargs ): return self . __getattribute__ ( action )( ** kwargs )","title":"execAction"},{"location":"reference/hielen2/source/#getactionschema_1","text":"def getActionSchema ( self , action ) View Source def getActionSchema ( self , action ): return getActionSchema ( self . module , action )","title":"getActionSchema"},{"location":"reference/hielen2/source/#getactionvalues","text":"def getActionValues ( self , action = None , timestamp = None ) View Source def getActionValues ( self , action = None , timestamp = None ): if action is None : action = slice ( None , None ) if timestamp is None : timestamp = slice ( None , None ) return db [ 'actions' ][ self . uid , action , timestamp ]","title":"getActionValues"},{"location":"reference/hielen2/source/#getrelativepath","text":"def getRelativePath ( self , path ) View Source def getRelativePath ( self , path ): return path . replace ( f \"{self.filecache}/\" , \"\" )","title":"getRelativePath"},{"location":"reference/hielen2/source/#makecachepath","text":"def makeCachePath ( self , path ) View Source def makeCachePath ( self , path ): outpath = os . path . join ( self . filecache , path ) os . makedirs ( outpath , exist_ok = True ) return outpath","title":"makeCachePath"},{"location":"reference/hielen2/utils/","text":"Module hielen2.utils View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 #!/usr/bin/env python # coding=utf-8 from datetime import datetime from re import split , sub , findall from time import mktime import json from importlib import import_module from falcon import HTTPNotAcceptable from hashlib import md5 from marshmallow import Schema , fields def hug_output_format_conten_type ( handlers = [], error = \"The requested format does not match any of those allowed\" , ctpar = \"content_type\" , ): \"\"\"Returns a different handler depending on the input param ctpar If none match and no default is given falcon.HTTPNotAcceptable(error) is raised \"\"\" try : default = handlers [ 0 ] except Exception : default = None handlers = { h . content_type : h for h in handlers } def requested_output_type ( request = None ): try : par = request . _params [ ctpar ] handler = None for k , h in handlers . items (): if par . split ( \";\" )[ 0 ] == k . split ( \";\" )[ 0 ]: handler = h break except Exception : if default is not None : handler = default if handler is None : raise HTTPNotAcceptable ( error ) return handler def output_type ( data , request , response ): handler = requested_output_type ( request ) response . content_type = handler . content_type return handler ( data , request = request , response = response ) output_type . __doc__ = \"Supports any of the following formats: {0} \" . format ( \", \" . join ( function . __doc__ for function in handlers . values ()) ) output_type . content_type = \", \" . join ( handlers . keys ()) output_type . requested = requested_output_type return output_type def newinstanceof ( klass , * args , ** kwargs ): klass_ar = klass . split ( \".\" ) module = \".\" . join ( klass_ar [: - 1 ]) klass = klass_ar [ - 1 ] return getattr ( import_module ( module ), klass )( * args , ** kwargs ) def ut2isot ( u = None ): u = u or 1 return str ( datetime . fromtimestamp ( u )) def isot2ut ( t = None ): t = t or \"1970-01-01T01:00:01.00000Z\" dt = datetime ( * map ( int , split ( \"[^\\d]\" , sub ( \"[^\\d]$\" , \"\" , t )))) return int ( mktime ( dt . timetuple ())) def loadjsonfile ( filename ): with open ( filename ) as jf : return json . load ( jf ) def savejsonfile ( filename , struct ): with open ( filename , \"w\" ) as jf : json . dump ( struct , jf ) def eprint ( * args , fname = \"error\" , ** kwargs ): with open ( fname , \"a\" ) as f : print ( * args , file = f , ** kwargs ) def hashfile ( filename ): BLOCKSIZE = 65536 hasher = md5 () with open ( filename , \"rb\" ) as afile : buf = afile . read ( BLOCKSIZE ) while len ( buf ) > 0 : hasher . update ( buf ) buf = afile . read ( BLOCKSIZE ) return hasher . hexdigest () ### MARSHMALLOW def getSchemaDict ( schema ): out = { \"fields\" :{}, \"required\" :[] } for k , w in schema . dump_fields . items (): out [ 'fields' ][ k ] = w . __class__ . __name__ w . __dict__ [ 'required' ] and out [ \"required\" ] . append ( k ) return out class LocalFile ( fields . String ): \"\"\" Local Filepath manager used to identify a file into the system. Mainliy usefull for action Schema declaration in hielen2.HielenSource extention \"\"\" pass class JsonValidable : \"\"\" JSON Validator class. It is initailzed with a marshmallow.Schema instance. When __call__ function is invoked, \\ uses marshmallow facilities to validate the json and raise errors. Once initalized, changes __doc__ in order to descibe the json accepted. \"\"\" def __field_doc__ ( self , field ): required = field . required and \"!\" or \"\" allow_none = not field . allow_none and \"!\" or \"\" try : types = \"|\" . join ( self . TYPE_MAPPING [ field . __class__ ]) except KeyError : if field . __class__ is fields . List : f , required , allow_none = self . __field_doc__ ( field . inner ) types = f \"[ { f } ]\" elif field . __class__ is fields . Dict : kf , required , allow_none = self . __field_doc__ ( field . key_field ) vf , required , allow_none = self . __field_doc__ ( field . value_field ) types = f \" {{ { kf } , { vf } }} \" else : types = \"\" return ( types , required , allow_none ) def __schema_doc__ ( self ): flds = [] for n , f in self . schema . fields . items (): types , required , allow_none = self . __field_doc__ ( f ) # TODO formattare required e allow_none # flds.append( f\"**{n}**{required}{allow_none}: {types}\") flds . append ( f \"** { n } **: { types } \" ) fields = \", \" . join ( flds ) fields = f \" {{ { fields } }} \" if self . schema . many : fields = f \"[ { fields } ]\" return f \"JSON Schema { fields } \" def __init__ ( self , schema ): self . schema = schema self . TYPE_MAPPING = {} for k , w in self . schema . TYPE_MAPPING . items (): try : self . TYPE_MAPPING [ w ] . append ( findall ( r \"'(.*)'\" , str ( k ))[ 0 ]) except KeyError : self . TYPE_MAPPING [ w ] = [ findall ( r \"'(.*)'\" , str ( k ))[ 0 ]] self . __doc__ = str ( self . __schema_doc__ ()) def __call__ ( self , value ): if type ( value ) is list : # If Falcon is set to comma-separate entries, this segment joins them again. fixed_value = \",\" . join ( value ) else : fixed_value = value return self . schema . loads ( fixed_value ) Functions eprint def eprint ( * args , fname = 'error' , ** kwargs ) View Source def eprint ( * args , fname = \"error\" , ** kwargs ): with open ( fname , \"a\" ) as f : print ( * args , file = f , ** kwargs ) getSchemaDict def getSchemaDict ( schema ) View Source def getSchemaDict ( schema ) : out = { \"fields\" :{} , \"required\" :[] } for k , w in schema . dump_fields . items () : out [ 'fields' ][ k ]= w . __class__ . __name__ w . __dict__ [ 'required' ] and out [ \"required\" ] . append ( k ) return out hashfile def hashfile ( filename ) View Source def hashfile ( filename ): BLOCKSIZE = 65536 hasher = md5 () with open ( filename , \"rb\" ) as afile : buf = afile . read ( BLOCKSIZE ) while len ( buf ) > 0 : hasher . update ( buf ) buf = afile . read ( BLOCKSIZE ) return hasher . hexdigest () hug_output_format_conten_type def hug_output_format_conten_type ( handlers = [], error = 'The requested format does not match any of those allowed' , ctpar = 'content_type' ) Returns a different handler depending on the input param ctpar If none match and no default is given falcon.HTTPNotAcceptable(error) is raised View Source def hug_output_format_conten_type ( handlers = [] , error = \"The requested format does not match any of those allowed\" , ctpar = \"content_type\" , ) : \"\"\"Returns a different handler depending on the input param ctpar If none match and no default is given falcon.HTTPNotAcceptable(error) is raised \"\"\" try : default = handlers [ 0 ] except Exception : default = None handlers = { h . content_type : h for h in handlers } def requested_output_type ( request = None ) : try : par = request . _params [ ctpar ] handler = None for k , h in handlers . items () : if par . split ( \";\" ) [ 0 ] == k . split ( \";\" ) [ 0 ] : handler = h break except Exception : if default is not None : handler = default if handler is None : raise HTTPNotAcceptable ( error ) return handler def output_type ( data , request , response ) : handler = requested_output_type ( request ) response . content_type = handler . content_type return handler ( data , request = request , response = response ) output_type . __doc__ = \"Supports any of the following formats: {0}\" . format ( \", \" . join ( function . __doc__ for function in handlers . values ()) ) output_type . content_type = \", \" . join ( handlers . keys ()) output_type . requested = requested_output_type return output_type isot2ut def isot2ut ( t = None ) View Source def isot2ut ( t = None ): t = t or \"1970-01-01T01:00:01.00000Z\" dt = datetime ( * map ( int , split ( \"[^\\d]\" , sub ( \"[^\\d]$\" , \"\" , t )))) return int ( mktime ( dt . timetuple ())) loadjsonfile def loadjsonfile ( filename ) View Source def loadjsonfile ( filename ): with open ( filename ) as jf : return json . load ( jf ) newinstanceof def newinstanceof ( klass , * args , ** kwargs ) View Source def newinstanceof ( klass , * args , **kwargs ) : klass_ar = klass . split ( \".\" ) module = \".\" . join ( klass_ar [:- 1 ]) klass = klass_ar [ - 1 ] return getattr ( import_module ( module ), klass )( * args , **kwargs ) savejsonfile def savejsonfile ( filename , struct ) View Source def savejsonfile ( filename , struct ): with open ( filename , \"w\" ) as jf : json . dump ( struct , jf ) ut2isot def ut2isot ( u = None ) View Source def ut2isot ( u = None ): u = u or 1 return str ( datetime . fromtimestamp ( u )) Classes JsonValidable class JsonValidable ( schema ) JSON Validator class. It is initailzed with a marshmallow.Schema instance. When call function is invoked, uses marshmallow facilities to validate the json and raise errors. Once initalized, changes doc in order to descibe the json accepted. View Source class JsonValidable : \"\"\" JSON Validator class. It is initailzed with a marshmallow.Schema instance. When __call__ function is invoked, \\ uses marshmallow facilities to validate the json and raise errors. Once initalized, changes __doc__ in order to descibe the json accepted. \"\"\" def __field_doc__ ( self , field ) : required = field . required and \"!\" or \"\" allow_none = not field . allow_none and \"!\" or \"\" try : types = \"|\" . join ( self . TYPE_MAPPING [ field.__class__ ] ) except KeyError : if field . __class__ is fields . List : f , required , allow_none = self . __field_doc__ ( field . inner ) types = f \"[{f}]\" elif field . __class__ is fields . Dict : kf , required , allow_none = self . __field_doc__ ( field . key_field ) vf , required , allow_none = self . __field_doc__ ( field . value_field ) types = f \"{{{kf},{vf}}}\" else : types = \"\" return ( types , required , allow_none ) def __schema_doc__ ( self ) : flds = [] for n , f in self . schema . fields . items () : types , required , allow_none = self . __field_doc__ ( f ) # TODO formattare required e allow_none # flds . append ( f \"**{n}**{required}{allow_none}: {types}\" ) flds . append ( f \"**{n}**: {types}\" ) fields = \", \" . join ( flds ) fields = f \"{{{fields}}}\" if self . schema . many : fields = f \"[{fields}]\" return f \"JSON Schema {fields}\" def __init__ ( self , schema ) : self . schema = schema self . TYPE_MAPPING = {} for k , w in self . schema . TYPE_MAPPING . items () : try : self . TYPE_MAPPING [ w ] . append ( findall ( r \"'(.*)'\" , str ( k )) [ 0 ] ) except KeyError : self . TYPE_MAPPING [ w ] = [ findall(r\"'(.*)'\", str(k))[0 ] ] self . __doc__ = str ( self . __schema_doc__ ()) def __call__ ( self , value ) : if type ( value ) is list : # If Falcon is set to comma - separate entries , this segment joins them again . fixed_value = \",\" . join ( value ) else : fixed_value = value return self . schema . loads ( fixed_value ) LocalFile class LocalFile ( * , default : Any = < marshmallow . missing > , missing : Any = < marshmallow . missing > , data_key : Union [ str , NoneType ] = None , attribute : Union [ str , NoneType ] = None , validate : Union [ Callable [[ Any ], Any ], Iterable [ Callable [[ Any ], Any ]], NoneType ] = None , required : bool = False , allow_none : Union [ bool , NoneType ] = None , load_only : bool = False , dump_only : bool = False , error_messages : Union [ Dict [ str , str ], NoneType ] = None , ** metadata ) Local Filepath manager used to identify a file into the system. Mainliy usefull for action Schema declaration in hielen2.HielenSource extention View Source class LocalFile ( fields . String ): \"\"\" Local Filepath manager used to identify a file into the system. Mainliy usefull for action Schema declaration in hielen2.HielenSource extention \"\"\" pass Ancestors (in MRO) marshmallow.fields.String marshmallow.fields.Field marshmallow.base.FieldABC Class variables default_error_messages name parent Instance variables context The context dictionary for the parent :class: Schema . root Reference to the Schema that this field belongs to even if it is buried in a container field (e.g. List ). Return None for unbound fields. Methods deserialize def deserialize ( self , value : Any , attr : Union [ str , NoneType ] = None , data : Union [ Mapping [ str , Any ], NoneType ] = None , ** kwargs ) Deserialize value . :param value: The value to deserialize. :param attr: The attribute/key in data to deserialize. :param data: The raw input data passed to Schema.load . :param kwargs: Field-specific keyword arguments. :raise ValidationError: If an invalid value is passed or if a required value is missing. View Source def deserialize ( self , value : typing . Any , attr : typing . Optional [ str ] = None , data : typing . Optional [ typing . Mapping [ str , typing . Any ]] = None , ** kwargs ): \"\"\"Deserialize ``value``. :param value: The value to deserialize. :param attr: The attribute/key in `data` to deserialize. :param data: The raw input data passed to `Schema.load`. :param kwargs: Field-specific keyword arguments. :raise ValidationError: If an invalid value is passed or if a required value is missing. \"\"\" # Validate required fields, deserialize, then validate # deserialized value self . _validate_missing ( value ) if value is missing_ : _miss = self . missing return _miss () if callable ( _miss ) else _miss if getattr ( self , \"allow_none\" , False ) is True and value is None : return None output = self . _deserialize ( value , attr , data , ** kwargs ) self . _validate ( output ) return output fail def fail ( self , key : str , ** kwargs ) Helper method that raises a ValidationError with an error message from self.error_messages . .. deprecated:: 3.0.0 Use make_error <marshmallow.fields.Field.make_error> instead. View Source def fail ( self , key : str , ** kwargs ): \"\"\"Helper method that raises a `ValidationError` with an error message from ``self.error_messages``. .. deprecated:: 3.0.0 Use `make_error <marshmallow.fields.Field.make_error>` instead. \"\"\" warnings . warn ( '`Field.fail` is deprecated. Use `raise self.make_error(\"{}\", ...)` instead.' . format ( key ), RemovedInMarshmallow4Warning , ) raise self . make_error ( key = key , ** kwargs ) get_value def get_value ( self , obj , attr , accessor = None , default =< marshmallow . missing > ) Return the value for a given key from an object. :param object obj: The object to get the value from. :param str attr: The attribute/key in obj to get the value from. :param callable accessor: A callable used to retrieve the value of attr from the object obj . Defaults to marshmallow.utils.get_value . View Source def get_value ( self , obj , attr , accessor = None , default = missing_ ): \"\"\"Return the value for a given key from an object. :param object obj: The object to get the value from. :param str attr: The attribute/key in `obj` to get the value from. :param callable accessor: A callable used to retrieve the value of `attr` from the object `obj`. Defaults to `marshmallow.utils.get_value`. \"\"\" # NOTE: Use getattr instead of direct attribute access here so that # subclasses aren't required to define `attribute` member attribute = getattr ( self , \"attribute\" , None ) accessor_func = accessor or utils . get_value check_key = attr if attribute is None else attribute return accessor_func ( obj , check_key , default ) make_error def make_error ( self , key : str , ** kwargs ) -> marshmallow . exceptions . ValidationError Helper method to make a ValidationError with an error message from self.error_messages . View Source def make_error ( self , key : str , ** kwargs ) -> ValidationError : \"\"\"Helper method to make a `ValidationError` with an error message from ``self.error_messages``. \"\"\" try : msg = self . error_messages [ key ] except KeyError as error : class_name = self . __class__ . __name__ message = ( \"ValidationError raised by `{class_name}`, but error key `{key}` does \" \"not exist in the `error_messages` dictionary.\" ). format ( class_name = class_name , key = key ) raise AssertionError ( message ) from error if isinstance ( msg , ( str , bytes )): msg = msg . format ( ** kwargs ) return ValidationError ( msg ) serialize def serialize ( self , attr : str , obj : Any , accessor : Union [ Callable [[ Any , str , Any ], Any ], NoneType ] = None , ** kwargs ) Pulls the value for the given key from the object, applies the field's formatting and returns the result. :param attr: The attribute/key to get from the object. :param obj: The object to access the attribute/key from. :param accessor: Function used to access values from obj . :param kwargs: Field-specific keyword arguments. View Source def serialize ( self , attr : str , obj : typing . Any , accessor : typing . Optional [ typing . Callable [[ typing . Any , str , typing . Any ], typing . Any ] ] = None , ** kwargs ): \"\"\"Pulls the value for the given key from the object, applies the field's formatting and returns the result. :param attr: The attribute/key to get from the object. :param obj: The object to access the attribute/key from. :param accessor: Function used to access values from ``obj``. :param kwargs: Field-specific keyword arguments. \"\"\" if self . _CHECK_ATTRIBUTE : value = self . get_value ( obj , attr , accessor = accessor ) if value is missing_ and hasattr ( self , \"default\" ): default = self . default value = default () if callable ( default ) else default if value is missing_ : return value else : value = None return self . _serialize ( value , attr , obj , ** kwargs )","title":"Utils"},{"location":"reference/hielen2/utils/#module-hielen2utils","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 #!/usr/bin/env python # coding=utf-8 from datetime import datetime from re import split , sub , findall from time import mktime import json from importlib import import_module from falcon import HTTPNotAcceptable from hashlib import md5 from marshmallow import Schema , fields def hug_output_format_conten_type ( handlers = [], error = \"The requested format does not match any of those allowed\" , ctpar = \"content_type\" , ): \"\"\"Returns a different handler depending on the input param ctpar If none match and no default is given falcon.HTTPNotAcceptable(error) is raised \"\"\" try : default = handlers [ 0 ] except Exception : default = None handlers = { h . content_type : h for h in handlers } def requested_output_type ( request = None ): try : par = request . _params [ ctpar ] handler = None for k , h in handlers . items (): if par . split ( \";\" )[ 0 ] == k . split ( \";\" )[ 0 ]: handler = h break except Exception : if default is not None : handler = default if handler is None : raise HTTPNotAcceptable ( error ) return handler def output_type ( data , request , response ): handler = requested_output_type ( request ) response . content_type = handler . content_type return handler ( data , request = request , response = response ) output_type . __doc__ = \"Supports any of the following formats: {0} \" . format ( \", \" . join ( function . __doc__ for function in handlers . values ()) ) output_type . content_type = \", \" . join ( handlers . keys ()) output_type . requested = requested_output_type return output_type def newinstanceof ( klass , * args , ** kwargs ): klass_ar = klass . split ( \".\" ) module = \".\" . join ( klass_ar [: - 1 ]) klass = klass_ar [ - 1 ] return getattr ( import_module ( module ), klass )( * args , ** kwargs ) def ut2isot ( u = None ): u = u or 1 return str ( datetime . fromtimestamp ( u )) def isot2ut ( t = None ): t = t or \"1970-01-01T01:00:01.00000Z\" dt = datetime ( * map ( int , split ( \"[^\\d]\" , sub ( \"[^\\d]$\" , \"\" , t )))) return int ( mktime ( dt . timetuple ())) def loadjsonfile ( filename ): with open ( filename ) as jf : return json . load ( jf ) def savejsonfile ( filename , struct ): with open ( filename , \"w\" ) as jf : json . dump ( struct , jf ) def eprint ( * args , fname = \"error\" , ** kwargs ): with open ( fname , \"a\" ) as f : print ( * args , file = f , ** kwargs ) def hashfile ( filename ): BLOCKSIZE = 65536 hasher = md5 () with open ( filename , \"rb\" ) as afile : buf = afile . read ( BLOCKSIZE ) while len ( buf ) > 0 : hasher . update ( buf ) buf = afile . read ( BLOCKSIZE ) return hasher . hexdigest () ### MARSHMALLOW def getSchemaDict ( schema ): out = { \"fields\" :{}, \"required\" :[] } for k , w in schema . dump_fields . items (): out [ 'fields' ][ k ] = w . __class__ . __name__ w . __dict__ [ 'required' ] and out [ \"required\" ] . append ( k ) return out class LocalFile ( fields . String ): \"\"\" Local Filepath manager used to identify a file into the system. Mainliy usefull for action Schema declaration in hielen2.HielenSource extention \"\"\" pass class JsonValidable : \"\"\" JSON Validator class. It is initailzed with a marshmallow.Schema instance. When __call__ function is invoked, \\ uses marshmallow facilities to validate the json and raise errors. Once initalized, changes __doc__ in order to descibe the json accepted. \"\"\" def __field_doc__ ( self , field ): required = field . required and \"!\" or \"\" allow_none = not field . allow_none and \"!\" or \"\" try : types = \"|\" . join ( self . TYPE_MAPPING [ field . __class__ ]) except KeyError : if field . __class__ is fields . List : f , required , allow_none = self . __field_doc__ ( field . inner ) types = f \"[ { f } ]\" elif field . __class__ is fields . Dict : kf , required , allow_none = self . __field_doc__ ( field . key_field ) vf , required , allow_none = self . __field_doc__ ( field . value_field ) types = f \" {{ { kf } , { vf } }} \" else : types = \"\" return ( types , required , allow_none ) def __schema_doc__ ( self ): flds = [] for n , f in self . schema . fields . items (): types , required , allow_none = self . __field_doc__ ( f ) # TODO formattare required e allow_none # flds.append( f\"**{n}**{required}{allow_none}: {types}\") flds . append ( f \"** { n } **: { types } \" ) fields = \", \" . join ( flds ) fields = f \" {{ { fields } }} \" if self . schema . many : fields = f \"[ { fields } ]\" return f \"JSON Schema { fields } \" def __init__ ( self , schema ): self . schema = schema self . TYPE_MAPPING = {} for k , w in self . schema . TYPE_MAPPING . items (): try : self . TYPE_MAPPING [ w ] . append ( findall ( r \"'(.*)'\" , str ( k ))[ 0 ]) except KeyError : self . TYPE_MAPPING [ w ] = [ findall ( r \"'(.*)'\" , str ( k ))[ 0 ]] self . __doc__ = str ( self . __schema_doc__ ()) def __call__ ( self , value ): if type ( value ) is list : # If Falcon is set to comma-separate entries, this segment joins them again. fixed_value = \",\" . join ( value ) else : fixed_value = value return self . schema . loads ( fixed_value )","title":"Module hielen2.utils"},{"location":"reference/hielen2/utils/#functions","text":"","title":"Functions"},{"location":"reference/hielen2/utils/#eprint","text":"def eprint ( * args , fname = 'error' , ** kwargs ) View Source def eprint ( * args , fname = \"error\" , ** kwargs ): with open ( fname , \"a\" ) as f : print ( * args , file = f , ** kwargs )","title":"eprint"},{"location":"reference/hielen2/utils/#getschemadict","text":"def getSchemaDict ( schema ) View Source def getSchemaDict ( schema ) : out = { \"fields\" :{} , \"required\" :[] } for k , w in schema . dump_fields . items () : out [ 'fields' ][ k ]= w . __class__ . __name__ w . __dict__ [ 'required' ] and out [ \"required\" ] . append ( k ) return out","title":"getSchemaDict"},{"location":"reference/hielen2/utils/#hashfile","text":"def hashfile ( filename ) View Source def hashfile ( filename ): BLOCKSIZE = 65536 hasher = md5 () with open ( filename , \"rb\" ) as afile : buf = afile . read ( BLOCKSIZE ) while len ( buf ) > 0 : hasher . update ( buf ) buf = afile . read ( BLOCKSIZE ) return hasher . hexdigest ()","title":"hashfile"},{"location":"reference/hielen2/utils/#hug_output_format_conten_type","text":"def hug_output_format_conten_type ( handlers = [], error = 'The requested format does not match any of those allowed' , ctpar = 'content_type' ) Returns a different handler depending on the input param ctpar If none match and no default is given falcon.HTTPNotAcceptable(error) is raised View Source def hug_output_format_conten_type ( handlers = [] , error = \"The requested format does not match any of those allowed\" , ctpar = \"content_type\" , ) : \"\"\"Returns a different handler depending on the input param ctpar If none match and no default is given falcon.HTTPNotAcceptable(error) is raised \"\"\" try : default = handlers [ 0 ] except Exception : default = None handlers = { h . content_type : h for h in handlers } def requested_output_type ( request = None ) : try : par = request . _params [ ctpar ] handler = None for k , h in handlers . items () : if par . split ( \";\" ) [ 0 ] == k . split ( \";\" ) [ 0 ] : handler = h break except Exception : if default is not None : handler = default if handler is None : raise HTTPNotAcceptable ( error ) return handler def output_type ( data , request , response ) : handler = requested_output_type ( request ) response . content_type = handler . content_type return handler ( data , request = request , response = response ) output_type . __doc__ = \"Supports any of the following formats: {0}\" . format ( \", \" . join ( function . __doc__ for function in handlers . values ()) ) output_type . content_type = \", \" . join ( handlers . keys ()) output_type . requested = requested_output_type return output_type","title":"hug_output_format_conten_type"},{"location":"reference/hielen2/utils/#isot2ut","text":"def isot2ut ( t = None ) View Source def isot2ut ( t = None ): t = t or \"1970-01-01T01:00:01.00000Z\" dt = datetime ( * map ( int , split ( \"[^\\d]\" , sub ( \"[^\\d]$\" , \"\" , t )))) return int ( mktime ( dt . timetuple ()))","title":"isot2ut"},{"location":"reference/hielen2/utils/#loadjsonfile","text":"def loadjsonfile ( filename ) View Source def loadjsonfile ( filename ): with open ( filename ) as jf : return json . load ( jf )","title":"loadjsonfile"},{"location":"reference/hielen2/utils/#newinstanceof","text":"def newinstanceof ( klass , * args , ** kwargs ) View Source def newinstanceof ( klass , * args , **kwargs ) : klass_ar = klass . split ( \".\" ) module = \".\" . join ( klass_ar [:- 1 ]) klass = klass_ar [ - 1 ] return getattr ( import_module ( module ), klass )( * args , **kwargs )","title":"newinstanceof"},{"location":"reference/hielen2/utils/#savejsonfile","text":"def savejsonfile ( filename , struct ) View Source def savejsonfile ( filename , struct ): with open ( filename , \"w\" ) as jf : json . dump ( struct , jf )","title":"savejsonfile"},{"location":"reference/hielen2/utils/#ut2isot","text":"def ut2isot ( u = None ) View Source def ut2isot ( u = None ): u = u or 1 return str ( datetime . fromtimestamp ( u ))","title":"ut2isot"},{"location":"reference/hielen2/utils/#classes","text":"","title":"Classes"},{"location":"reference/hielen2/utils/#jsonvalidable","text":"class JsonValidable ( schema ) JSON Validator class. It is initailzed with a marshmallow.Schema instance. When call function is invoked, uses marshmallow facilities to validate the json and raise errors. Once initalized, changes doc in order to descibe the json accepted. View Source class JsonValidable : \"\"\" JSON Validator class. It is initailzed with a marshmallow.Schema instance. When __call__ function is invoked, \\ uses marshmallow facilities to validate the json and raise errors. Once initalized, changes __doc__ in order to descibe the json accepted. \"\"\" def __field_doc__ ( self , field ) : required = field . required and \"!\" or \"\" allow_none = not field . allow_none and \"!\" or \"\" try : types = \"|\" . join ( self . TYPE_MAPPING [ field.__class__ ] ) except KeyError : if field . __class__ is fields . List : f , required , allow_none = self . __field_doc__ ( field . inner ) types = f \"[{f}]\" elif field . __class__ is fields . Dict : kf , required , allow_none = self . __field_doc__ ( field . key_field ) vf , required , allow_none = self . __field_doc__ ( field . value_field ) types = f \"{{{kf},{vf}}}\" else : types = \"\" return ( types , required , allow_none ) def __schema_doc__ ( self ) : flds = [] for n , f in self . schema . fields . items () : types , required , allow_none = self . __field_doc__ ( f ) # TODO formattare required e allow_none # flds . append ( f \"**{n}**{required}{allow_none}: {types}\" ) flds . append ( f \"**{n}**: {types}\" ) fields = \", \" . join ( flds ) fields = f \"{{{fields}}}\" if self . schema . many : fields = f \"[{fields}]\" return f \"JSON Schema {fields}\" def __init__ ( self , schema ) : self . schema = schema self . TYPE_MAPPING = {} for k , w in self . schema . TYPE_MAPPING . items () : try : self . TYPE_MAPPING [ w ] . append ( findall ( r \"'(.*)'\" , str ( k )) [ 0 ] ) except KeyError : self . TYPE_MAPPING [ w ] = [ findall(r\"'(.*)'\", str(k))[0 ] ] self . __doc__ = str ( self . __schema_doc__ ()) def __call__ ( self , value ) : if type ( value ) is list : # If Falcon is set to comma - separate entries , this segment joins them again . fixed_value = \",\" . join ( value ) else : fixed_value = value return self . schema . loads ( fixed_value )","title":"JsonValidable"},{"location":"reference/hielen2/utils/#localfile","text":"class LocalFile ( * , default : Any = < marshmallow . missing > , missing : Any = < marshmallow . missing > , data_key : Union [ str , NoneType ] = None , attribute : Union [ str , NoneType ] = None , validate : Union [ Callable [[ Any ], Any ], Iterable [ Callable [[ Any ], Any ]], NoneType ] = None , required : bool = False , allow_none : Union [ bool , NoneType ] = None , load_only : bool = False , dump_only : bool = False , error_messages : Union [ Dict [ str , str ], NoneType ] = None , ** metadata ) Local Filepath manager used to identify a file into the system. Mainliy usefull for action Schema declaration in hielen2.HielenSource extention View Source class LocalFile ( fields . String ): \"\"\" Local Filepath manager used to identify a file into the system. Mainliy usefull for action Schema declaration in hielen2.HielenSource extention \"\"\" pass","title":"LocalFile"},{"location":"reference/hielen2/utils/#ancestors-in-mro","text":"marshmallow.fields.String marshmallow.fields.Field marshmallow.base.FieldABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen2/utils/#class-variables","text":"default_error_messages name parent","title":"Class variables"},{"location":"reference/hielen2/utils/#instance-variables","text":"context The context dictionary for the parent :class: Schema . root Reference to the Schema that this field belongs to even if it is buried in a container field (e.g. List ). Return None for unbound fields.","title":"Instance variables"},{"location":"reference/hielen2/utils/#methods","text":"","title":"Methods"},{"location":"reference/hielen2/utils/#deserialize","text":"def deserialize ( self , value : Any , attr : Union [ str , NoneType ] = None , data : Union [ Mapping [ str , Any ], NoneType ] = None , ** kwargs ) Deserialize value . :param value: The value to deserialize. :param attr: The attribute/key in data to deserialize. :param data: The raw input data passed to Schema.load . :param kwargs: Field-specific keyword arguments. :raise ValidationError: If an invalid value is passed or if a required value is missing. View Source def deserialize ( self , value : typing . Any , attr : typing . Optional [ str ] = None , data : typing . Optional [ typing . Mapping [ str , typing . Any ]] = None , ** kwargs ): \"\"\"Deserialize ``value``. :param value: The value to deserialize. :param attr: The attribute/key in `data` to deserialize. :param data: The raw input data passed to `Schema.load`. :param kwargs: Field-specific keyword arguments. :raise ValidationError: If an invalid value is passed or if a required value is missing. \"\"\" # Validate required fields, deserialize, then validate # deserialized value self . _validate_missing ( value ) if value is missing_ : _miss = self . missing return _miss () if callable ( _miss ) else _miss if getattr ( self , \"allow_none\" , False ) is True and value is None : return None output = self . _deserialize ( value , attr , data , ** kwargs ) self . _validate ( output ) return output","title":"deserialize"},{"location":"reference/hielen2/utils/#fail","text":"def fail ( self , key : str , ** kwargs ) Helper method that raises a ValidationError with an error message from self.error_messages . .. deprecated:: 3.0.0 Use make_error <marshmallow.fields.Field.make_error> instead. View Source def fail ( self , key : str , ** kwargs ): \"\"\"Helper method that raises a `ValidationError` with an error message from ``self.error_messages``. .. deprecated:: 3.0.0 Use `make_error <marshmallow.fields.Field.make_error>` instead. \"\"\" warnings . warn ( '`Field.fail` is deprecated. Use `raise self.make_error(\"{}\", ...)` instead.' . format ( key ), RemovedInMarshmallow4Warning , ) raise self . make_error ( key = key , ** kwargs )","title":"fail"},{"location":"reference/hielen2/utils/#get_value","text":"def get_value ( self , obj , attr , accessor = None , default =< marshmallow . missing > ) Return the value for a given key from an object. :param object obj: The object to get the value from. :param str attr: The attribute/key in obj to get the value from. :param callable accessor: A callable used to retrieve the value of attr from the object obj . Defaults to marshmallow.utils.get_value . View Source def get_value ( self , obj , attr , accessor = None , default = missing_ ): \"\"\"Return the value for a given key from an object. :param object obj: The object to get the value from. :param str attr: The attribute/key in `obj` to get the value from. :param callable accessor: A callable used to retrieve the value of `attr` from the object `obj`. Defaults to `marshmallow.utils.get_value`. \"\"\" # NOTE: Use getattr instead of direct attribute access here so that # subclasses aren't required to define `attribute` member attribute = getattr ( self , \"attribute\" , None ) accessor_func = accessor or utils . get_value check_key = attr if attribute is None else attribute return accessor_func ( obj , check_key , default )","title":"get_value"},{"location":"reference/hielen2/utils/#make_error","text":"def make_error ( self , key : str , ** kwargs ) -> marshmallow . exceptions . ValidationError Helper method to make a ValidationError with an error message from self.error_messages . View Source def make_error ( self , key : str , ** kwargs ) -> ValidationError : \"\"\"Helper method to make a `ValidationError` with an error message from ``self.error_messages``. \"\"\" try : msg = self . error_messages [ key ] except KeyError as error : class_name = self . __class__ . __name__ message = ( \"ValidationError raised by `{class_name}`, but error key `{key}` does \" \"not exist in the `error_messages` dictionary.\" ). format ( class_name = class_name , key = key ) raise AssertionError ( message ) from error if isinstance ( msg , ( str , bytes )): msg = msg . format ( ** kwargs ) return ValidationError ( msg )","title":"make_error"},{"location":"reference/hielen2/utils/#serialize","text":"def serialize ( self , attr : str , obj : Any , accessor : Union [ Callable [[ Any , str , Any ], Any ], NoneType ] = None , ** kwargs ) Pulls the value for the given key from the object, applies the field's formatting and returns the result. :param attr: The attribute/key to get from the object. :param obj: The object to access the attribute/key from. :param accessor: Function used to access values from obj . :param kwargs: Field-specific keyword arguments. View Source def serialize ( self , attr : str , obj : typing . Any , accessor : typing . Optional [ typing . Callable [[ typing . Any , str , typing . Any ], typing . Any ] ] = None , ** kwargs ): \"\"\"Pulls the value for the given key from the object, applies the field's formatting and returns the result. :param attr: The attribute/key to get from the object. :param obj: The object to access the attribute/key from. :param accessor: Function used to access values from ``obj``. :param kwargs: Field-specific keyword arguments. \"\"\" if self . _CHECK_ATTRIBUTE : value = self . get_value ( obj , attr , accessor = accessor ) if value is missing_ and hasattr ( self , \"default\" ): default = self . default value = default () if callable ( default ) else default if value is missing_ : return value else : value = None return self . _serialize ( value , attr , obj , ** kwargs )","title":"serialize"},{"location":"reference/hielen2/api/","text":"Module hielen2.api Sub-modules hielen2.api.actions hielen2.api.actionschemata hielen2.api.data hielen2.api.features hielen2.api.glob hielen2.api.parameters hielen2.api.prototypes","title":"Index"},{"location":"reference/hielen2/api/#module-hielen2api","text":"","title":"Module hielen2.api"},{"location":"reference/hielen2/api/#sub-modules","text":"hielen2.api.actions hielen2.api.actionschemata hielen2.api.data hielen2.api.features hielen2.api.glob hielen2.api.parameters hielen2.api.prototypes","title":"Sub-modules"},{"location":"reference/hielen2/api/actions/","text":"Module hielen2.api.actions View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 #!/usr/bin/env python # coding=utf-8 import hug import tempfile import falcon import os import time import json from hielen2 import db , conf import hielen2.source as sourceman from streaming_form_data import StreamingFormDataParser from streaming_form_data.targets import FileTarget , ValueTarget from himada.api import ResponseFormatter from urllib.parse import unquote from importlib import import_module @hug . get ( \"/ {feature} \" ) def features_actions_values ( feature , actions = None , timestamp = None , request = None , response = None ): \"\"\" **Recupero dello stato corrente delle azioni effettuate su una feature** L'intento di questa api \u00e8 quello di fornire i valori richiesti secondo lo schema dell'azione ___nota 1___: `actions` accetta valori multipli separati da virgola ___nota 2___: A seconda dell'action richiesta, alcuni parametri potrebbero essere utilizzati in fase \\ di input ma non registrati. Il che vuol dire che per quei parametri il valore di ritorno sar\u00e0 null viene restituito una struttura di questo tipo: [ { \"feature\"*:..., \"action_name*\":..., \"timestamp\": ..., \"value\":{...} }, { \"feature\"*:..., \"action_name*\":..., \"timestamp\": ..., \"value\":{...} }, ... ] ___nota 3___ :(*) I campi \"feature\" e \"action\" potrebbero non essere restituiti nella struttura \\ nel caso in cui essi risultino non ambigui. \"timestamp\" e \"value\" vengono sempre restituiti Possibili risposte: - _404 Not Found_: Nel non venga trovata la feature richiesta o essa abbia un problema di \\ configurazione \"\"\" out = ResponseFormatter () # Trying to manage income feature request and its prototype configuration try : feat = db [ \"features\" ][ feature ] featobj = sourceman . sourceFactory ( feat , conf [ 'filecache' ]) out . data = featobj . getActionValues ( actions , timestamp ) if out . data is not list : out . data = [ out . data ] except Exception as e : out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature ' { feature } ' does not exists or it is misconfigured: { e } \" out . format ( request = request , response = response ) return out . format ( request = request , response = response ) return @hug . get ( \"/ {feature} / {action} \" ) def feature_action_values ( feature , action , timestamp = None , request = None , response = None ): \"\"\" **Recupero dello stato corrente per una specifica azione di una specifica feature**\"\"\" return features_actions_values ( feature , action , timestamp , request = request , response = response ) @hug . post ( \"/ {feature} / {action} \" , parse_body = False ) @hug . default_input_format ( content_type = \"multipart/form-data\" ) def make_action ( feature , action , request = None , response = None ): \"\"\" **Esecuzione delle azioni** Richiede l'esecuzione di una specifica azione su una feature, fornendo tutte le informazioni \\ necessarie attraverso una form dinamica dedicata. - Oltre ai due parametri `feature` e `form`, `timestamp`, indicati nella url, accetta un \\ _multipart/form-data_ basato sulla specifica form, selezionata tramite i due parametri espliciti. - Tutto il content \u00e8 scaricato attarverso i chunk dello stream ('100 continue') per evitare il \\ timeout dei workers in caso di contenuti di grandi dimensioni. Possibili risposte: - _200 OK_: Nel caso in cui l'azione vada a buon fine. L'azione richiesta viene presa in carico ma \\ potrebbe avere un tempo di esecuzione arbitrario. L'azione quindi viene splittata su un altro processo. - _404 Not Found_: Nel caso la feature non esista o non sia definita per essa l'azione richiesta. - _500 Internal Server Error_: Nel caso pessimo che il modulo dichiarato non esista. - _501 Not Implemented'_: Nel caso la tipologia non fornisse ancora l'iplementazione di uno o tutti \\ i moduli di gestione E' stato implementato il meccanismo minimo di gestione che prevede il salvataggio delle info \\ fornite che possono essere fornite tali e quali in uscita (vedi metodo GET dell'api). Questo \\ meccanismo permette di svluppare i moduli a partire da un template con risposta di default. \"\"\" out = ResponseFormatter () # Trying to manage income feature request and its prototype configuration try : feat = db [ \"features\" ][ feature ] featobj = sourceman . sourceFactory ( feat , conf [ 'filecache' ]) except KeyError as e : #raise e out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature ' { feature } ' does not exists or it is misconfigured: { e } \" out . format ( request = request , response = response ) return try : schema = featobj . getActionSchema ( action ) except KeyError as e : raise e out . status = falcon . HTTP_NOT_IMPLEMENTED out . message = f \"Prototype ' { featobj . type } ' actions not implemented.\" out . format ( request = request , response = response ) return except ModuleNotFoundError as e : #raise e out . status = falcon . HTTP_INTERNAL_SERVER_ERROR out . message = f \"Prototype ' { featobj . type } ' module not found.\" out . format ( request = request , response = response ) return parser = StreamingFormDataParser ( headers = request . headers ) values = {} # TODO Differenziazione delle tipologie di input for k , w in schema [ \"fields\" ] . items (): if w == \"LocalFile\" : timenow = time . perf_counter () filepath = os . path . join ( tempfile . gettempdir (), f \" { feature } . { k } . { timenow } .part\" ) target = FileTarget ( filepath ) parser . register ( k , target ) values [ k ] = filepath else : target = ValueTarget () parser . register ( k , target ) values [ k ] = target while True : chunk = request . stream . read ( 8192 ) if not chunk : break parser . data_received ( chunk ) kwargs = {} for k , w in values . items (): if isinstance ( w , str ): v = os . path . exists ( w ) and w or None else : v = unquote ( w . value . decode ( \"utf8\" )) or None kwargs [ k ] = v m = [ m for m in schema [ \"required\" ] if kwargs [ m ] is None ] if m . __len__ (): out . status = falcon . HTTP_BAD_REQUEST out . message = f \"Required parameters { m } not supplied\" out . format ( request = request , response = response ) return # CHECKS request checks ALL RIGHT. Continuing with code loading # Trying to initialize feature action manager module try : result = featobj . execAction ( action , ** kwargs ) except AttributeError as e : raise e out . status = falcon . HTTP_NOT_IMPLEMENTED out . message = f \"Action ' { action } ' not implemented.\" out . format ( request = request , response = response ) return except Exception as e : raise e pass try : db [ \"actions\" ][ feature , action , result [ 'timestamp' ]] = { \"value\" : result } db [ \"features\" ] . save () except KeyError as e : #raise e out . status = falcon . HTTP_INTERNAL_SERVER_ERROR out . message = str ( e ) out . format ( request = request , response = response ) except ValueError as e : #raise e out . status = falcon . HTTP_BAD_REQUEST out . message = str ( e ) out . format ( request = request , response = response ) return out . format ( request = request , response = response ) return Variables conf db Functions feature_action_values def feature_action_values ( feature , action , timestamp = None , request = None , response = None ) Recupero dello stato corrente per una specifica azione di una specifica feature View Source @hug . get ( \"/{feature}/{action}\" ) def feature_action_values ( feature , action , timestamp = None , request = None , response = None ) : \"\"\" **Recupero dello stato corrente per una specifica azione di una specifica feature**\"\"\" return features_actions_values ( feature , action , timestamp , request = request , response = response ) features_actions_values def features_actions_values ( feature , actions = None , timestamp = None , request = None , response = None ) Recupero dello stato corrente delle azioni effettuate su una feature L'intento di questa api \u00e8 quello di fornire i valori richiesti secondo lo schema dell'azione nota 1 : actions accetta valori multipli separati da virgola nota 2 : A seconda dell'action richiesta, alcuni parametri potrebbero essere utilizzati in fase di input ma non registrati. Il che vuol dire che per quei parametri il valore di ritorno sar\u00e0 null viene restituito una struttura di questo tipo: [ { \"feature\"*:..., \"action_name*\":..., \"timestamp\": ..., \"value\":{...} }, { \"feature\"*:..., \"action_name*\":..., \"timestamp\": ..., \"value\":{...} }, ... ] nota 3 :(*) I campi \"feature\" e \"action\" potrebbero non essere restituiti nella struttura nel caso in cui essi risultino non ambigui. \"timestamp\" e \"value\" vengono sempre restituiti Possibili risposte: 404 Not Found : Nel non venga trovata la feature richiesta o essa abbia un problema di configurazione View Source @hug . get ( \"/{feature}\" ) def features_actions_values ( feature , actions = None , timestamp = None , request = None , response = None ) : \"\"\" **Recupero dello stato corrente delle azioni effettuate su una feature** L'intento di questa api \u00e8 quello di fornire i valori richiesti secondo lo schema dell'azione ___nota 1___: `actions` accetta valori multipli separati da virgola ___nota 2___: A seconda dell'action richiesta, alcuni parametri potrebbero essere utilizzati in fase \\ di input ma non registrati. Il che vuol dire che per quei parametri il valore di ritorno sar\u00e0 null viene restituito una struttura di questo tipo: [ { \" feature \"*:..., \" action_name * \":..., \" timestamp \": ..., \" value \":{...} }, { \" feature \"*:..., \" action_name * \":..., \" timestamp \": ..., \" value \":{...} }, ... ] ___nota 3___ :(*) I campi \" feature \" e \" action \" potrebbero non essere restituiti nella struttura \\ nel caso in cui essi risultino non ambigui. \" timestamp \" e \" value \" vengono sempre restituiti Possibili risposte: - _404 Not Found_: Nel non venga trovata la feature richiesta o essa abbia un problema di \\ configurazione \"\"\" out = ResponseFormatter () # Trying to manage income feature request and its prototype configuration try : feat = db [ \"features\" ][ feature ] featobj = sourceman . sourceFactory ( feat , conf [ 'filecache' ] ) out . data = featobj . getActionValues ( actions , timestamp ) if out . data is not list : out . data =[ out.data ] except Exception as e : out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature '{feature}' does not exists or it is misconfigured: {e}\" out . format ( request = request , response = response ) return out . format ( request = request , response = response ) return make_action def make_action ( feature , action , request = None , response = None ) Esecuzione delle azioni Richiede l'esecuzione di una specifica azione su una feature, fornendo tutte le informazioni necessarie attraverso una form dinamica dedicata. Oltre ai due parametri feature e form , timestamp , indicati nella url, accetta un multipart/form-data basato sulla specifica form, selezionata tramite i due parametri espliciti. Tutto il content \u00e8 scaricato attarverso i chunk dello stream ('100 continue') per evitare il timeout dei workers in caso di contenuti di grandi dimensioni. Possibili risposte: 200 OK : Nel caso in cui l'azione vada a buon fine. L'azione richiesta viene presa in carico ma potrebbe avere un tempo di esecuzione arbitrario. L'azione quindi viene splittata su un altro processo. 404 Not Found : Nel caso la feature non esista o non sia definita per essa l'azione richiesta. 500 Internal Server Error : Nel caso pessimo che il modulo dichiarato non esista. 501 Not Implemented' : Nel caso la tipologia non fornisse ancora l'iplementazione di uno o tutti i moduli di gestione E' stato implementato il meccanismo minimo di gestione che prevede il salvataggio delle info fornite che possono essere fornite tali e quali in uscita (vedi metodo GET dell'api). Questo meccanismo permette di svluppare i moduli a partire da un template con risposta di default. View Source @hug . post ( \"/{feature}/{action}\" , parse_body = False ) @hug . default_input_format ( content_type = \"multipart/form-data\" ) def make_action ( feature , action , request = None , response = None ) : \"\"\" **Esecuzione delle azioni** Richiede l'esecuzione di una specifica azione su una feature, fornendo tutte le informazioni \\ necessarie attraverso una form dinamica dedicata. - Oltre ai due parametri `feature` e `form`, `timestamp`, indicati nella url, accetta un \\ _multipart/form-data_ basato sulla specifica form, selezionata tramite i due parametri espliciti. - Tutto il content \u00e8 scaricato attarverso i chunk dello stream ('100 continue') per evitare il \\ timeout dei workers in caso di contenuti di grandi dimensioni. Possibili risposte: - _200 OK_: Nel caso in cui l'azione vada a buon fine. L'azione richiesta viene presa in carico ma \\ potrebbe avere un tempo di esecuzione arbitrario. L'azione quindi viene splittata su un altro processo. - _404 Not Found_: Nel caso la feature non esista o non sia definita per essa l'azione richiesta. - _500 Internal Server Error_: Nel caso pessimo che il modulo dichiarato non esista. - _501 Not Implemented'_: Nel caso la tipologia non fornisse ancora l'iplementazione di uno o tutti \\ i moduli di gestione E' stato implementato il meccanismo minimo di gestione che prevede il salvataggio delle info \\ fornite che possono essere fornite tali e quali in uscita (vedi metodo GET dell'api). Questo \\ meccanismo permette di svluppare i moduli a partire da un template con risposta di default. \"\"\" out = ResponseFormatter () # Trying to manage income feature request and its prototype configuration try : feat = db [ \"features\" ][ feature ] featobj = sourceman . sourceFactory ( feat , conf [ 'filecache' ] ) except KeyError as e : #raise e out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature '{feature}' does not exists or it is misconfigured: {e}\" out . format ( request = request , response = response ) return try : schema = featobj . getActionSchema ( action ) except KeyError as e : raise e out . status = falcon . HTTP_NOT_IMPLEMENTED out . message = f \"Prototype '{featobj.type}' actions not implemented.\" out . format ( request = request , response = response ) return except ModuleNotFoundError as e : #raise e out . status = falcon . HTTP_INTERNAL_SERVER_ERROR out . message = f \"Prototype '{featobj.type}' module not found.\" out . format ( request = request , response = response ) return parser = StreamingFormDataParser ( headers = request . headers ) values = {} # TODO Differenziazione delle tipologie di input for k , w in schema [ \"fields\" ] . items () : if w == \"LocalFile\" : timenow = time . perf_counter () filepath = os . path . join ( tempfile . gettempdir (), f \"{feature}.{k}.{timenow}.part\" ) target = FileTarget ( filepath ) parser . register ( k , target ) values [ k ] = filepath else : target = ValueTarget () parser . register ( k , target ) values [ k ] = target while True : chunk = request . stream . read ( 8192 ) if not chunk : break parser . data_received ( chunk ) kwargs = {} for k , w in values . items () : if isinstance ( w , str ) : v = os . path . exists ( w ) and w or None else : v = unquote ( w . value . decode ( \"utf8\" )) or None kwargs [ k ] = v m = [ m for m in schema[\"required\" ] if kwargs [ m ] is None ] if m . __len__ () : out . status = falcon . HTTP_BAD_REQUEST out . message = f \"Required parameters {m} not supplied\" out . format ( request = request , response = response ) return # CHECKS request checks ALL RIGHT . Continuing with code loading # Trying to initialize feature action manager module try : result = featobj . execAction ( action , ** kwargs ) except AttributeError as e : raise e out . status = falcon . HTTP_NOT_IMPLEMENTED out . message = f \"Action '{action}' not implemented.\" out . format ( request = request , response = response ) return except Exception as e : raise e pass try : db [ \"actions\" ][ feature,action,result['timestamp' ] ] = { \"value\" : result } db [ \"features\" ] . save () except KeyError as e : #raise e out . status = falcon . HTTP_INTERNAL_SERVER_ERROR out . message = str ( e ) out . format ( request = request , response = response ) except ValueError as e : #raise e out . status = falcon . HTTP_BAD_REQUEST out . message = str ( e ) out . format ( request = request , response = response ) return out . format ( request = request , response = response ) return","title":"Actions"},{"location":"reference/hielen2/api/actions/#module-hielen2apiactions","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 #!/usr/bin/env python # coding=utf-8 import hug import tempfile import falcon import os import time import json from hielen2 import db , conf import hielen2.source as sourceman from streaming_form_data import StreamingFormDataParser from streaming_form_data.targets import FileTarget , ValueTarget from himada.api import ResponseFormatter from urllib.parse import unquote from importlib import import_module @hug . get ( \"/ {feature} \" ) def features_actions_values ( feature , actions = None , timestamp = None , request = None , response = None ): \"\"\" **Recupero dello stato corrente delle azioni effettuate su una feature** L'intento di questa api \u00e8 quello di fornire i valori richiesti secondo lo schema dell'azione ___nota 1___: `actions` accetta valori multipli separati da virgola ___nota 2___: A seconda dell'action richiesta, alcuni parametri potrebbero essere utilizzati in fase \\ di input ma non registrati. Il che vuol dire che per quei parametri il valore di ritorno sar\u00e0 null viene restituito una struttura di questo tipo: [ { \"feature\"*:..., \"action_name*\":..., \"timestamp\": ..., \"value\":{...} }, { \"feature\"*:..., \"action_name*\":..., \"timestamp\": ..., \"value\":{...} }, ... ] ___nota 3___ :(*) I campi \"feature\" e \"action\" potrebbero non essere restituiti nella struttura \\ nel caso in cui essi risultino non ambigui. \"timestamp\" e \"value\" vengono sempre restituiti Possibili risposte: - _404 Not Found_: Nel non venga trovata la feature richiesta o essa abbia un problema di \\ configurazione \"\"\" out = ResponseFormatter () # Trying to manage income feature request and its prototype configuration try : feat = db [ \"features\" ][ feature ] featobj = sourceman . sourceFactory ( feat , conf [ 'filecache' ]) out . data = featobj . getActionValues ( actions , timestamp ) if out . data is not list : out . data = [ out . data ] except Exception as e : out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature ' { feature } ' does not exists or it is misconfigured: { e } \" out . format ( request = request , response = response ) return out . format ( request = request , response = response ) return @hug . get ( \"/ {feature} / {action} \" ) def feature_action_values ( feature , action , timestamp = None , request = None , response = None ): \"\"\" **Recupero dello stato corrente per una specifica azione di una specifica feature**\"\"\" return features_actions_values ( feature , action , timestamp , request = request , response = response ) @hug . post ( \"/ {feature} / {action} \" , parse_body = False ) @hug . default_input_format ( content_type = \"multipart/form-data\" ) def make_action ( feature , action , request = None , response = None ): \"\"\" **Esecuzione delle azioni** Richiede l'esecuzione di una specifica azione su una feature, fornendo tutte le informazioni \\ necessarie attraverso una form dinamica dedicata. - Oltre ai due parametri `feature` e `form`, `timestamp`, indicati nella url, accetta un \\ _multipart/form-data_ basato sulla specifica form, selezionata tramite i due parametri espliciti. - Tutto il content \u00e8 scaricato attarverso i chunk dello stream ('100 continue') per evitare il \\ timeout dei workers in caso di contenuti di grandi dimensioni. Possibili risposte: - _200 OK_: Nel caso in cui l'azione vada a buon fine. L'azione richiesta viene presa in carico ma \\ potrebbe avere un tempo di esecuzione arbitrario. L'azione quindi viene splittata su un altro processo. - _404 Not Found_: Nel caso la feature non esista o non sia definita per essa l'azione richiesta. - _500 Internal Server Error_: Nel caso pessimo che il modulo dichiarato non esista. - _501 Not Implemented'_: Nel caso la tipologia non fornisse ancora l'iplementazione di uno o tutti \\ i moduli di gestione E' stato implementato il meccanismo minimo di gestione che prevede il salvataggio delle info \\ fornite che possono essere fornite tali e quali in uscita (vedi metodo GET dell'api). Questo \\ meccanismo permette di svluppare i moduli a partire da un template con risposta di default. \"\"\" out = ResponseFormatter () # Trying to manage income feature request and its prototype configuration try : feat = db [ \"features\" ][ feature ] featobj = sourceman . sourceFactory ( feat , conf [ 'filecache' ]) except KeyError as e : #raise e out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature ' { feature } ' does not exists or it is misconfigured: { e } \" out . format ( request = request , response = response ) return try : schema = featobj . getActionSchema ( action ) except KeyError as e : raise e out . status = falcon . HTTP_NOT_IMPLEMENTED out . message = f \"Prototype ' { featobj . type } ' actions not implemented.\" out . format ( request = request , response = response ) return except ModuleNotFoundError as e : #raise e out . status = falcon . HTTP_INTERNAL_SERVER_ERROR out . message = f \"Prototype ' { featobj . type } ' module not found.\" out . format ( request = request , response = response ) return parser = StreamingFormDataParser ( headers = request . headers ) values = {} # TODO Differenziazione delle tipologie di input for k , w in schema [ \"fields\" ] . items (): if w == \"LocalFile\" : timenow = time . perf_counter () filepath = os . path . join ( tempfile . gettempdir (), f \" { feature } . { k } . { timenow } .part\" ) target = FileTarget ( filepath ) parser . register ( k , target ) values [ k ] = filepath else : target = ValueTarget () parser . register ( k , target ) values [ k ] = target while True : chunk = request . stream . read ( 8192 ) if not chunk : break parser . data_received ( chunk ) kwargs = {} for k , w in values . items (): if isinstance ( w , str ): v = os . path . exists ( w ) and w or None else : v = unquote ( w . value . decode ( \"utf8\" )) or None kwargs [ k ] = v m = [ m for m in schema [ \"required\" ] if kwargs [ m ] is None ] if m . __len__ (): out . status = falcon . HTTP_BAD_REQUEST out . message = f \"Required parameters { m } not supplied\" out . format ( request = request , response = response ) return # CHECKS request checks ALL RIGHT. Continuing with code loading # Trying to initialize feature action manager module try : result = featobj . execAction ( action , ** kwargs ) except AttributeError as e : raise e out . status = falcon . HTTP_NOT_IMPLEMENTED out . message = f \"Action ' { action } ' not implemented.\" out . format ( request = request , response = response ) return except Exception as e : raise e pass try : db [ \"actions\" ][ feature , action , result [ 'timestamp' ]] = { \"value\" : result } db [ \"features\" ] . save () except KeyError as e : #raise e out . status = falcon . HTTP_INTERNAL_SERVER_ERROR out . message = str ( e ) out . format ( request = request , response = response ) except ValueError as e : #raise e out . status = falcon . HTTP_BAD_REQUEST out . message = str ( e ) out . format ( request = request , response = response ) return out . format ( request = request , response = response ) return","title":"Module hielen2.api.actions"},{"location":"reference/hielen2/api/actions/#variables","text":"conf db","title":"Variables"},{"location":"reference/hielen2/api/actions/#functions","text":"","title":"Functions"},{"location":"reference/hielen2/api/actions/#feature_action_values","text":"def feature_action_values ( feature , action , timestamp = None , request = None , response = None ) Recupero dello stato corrente per una specifica azione di una specifica feature View Source @hug . get ( \"/{feature}/{action}\" ) def feature_action_values ( feature , action , timestamp = None , request = None , response = None ) : \"\"\" **Recupero dello stato corrente per una specifica azione di una specifica feature**\"\"\" return features_actions_values ( feature , action , timestamp , request = request , response = response )","title":"feature_action_values"},{"location":"reference/hielen2/api/actions/#features_actions_values","text":"def features_actions_values ( feature , actions = None , timestamp = None , request = None , response = None ) Recupero dello stato corrente delle azioni effettuate su una feature L'intento di questa api \u00e8 quello di fornire i valori richiesti secondo lo schema dell'azione nota 1 : actions accetta valori multipli separati da virgola nota 2 : A seconda dell'action richiesta, alcuni parametri potrebbero essere utilizzati in fase di input ma non registrati. Il che vuol dire che per quei parametri il valore di ritorno sar\u00e0 null viene restituito una struttura di questo tipo: [ { \"feature\"*:..., \"action_name*\":..., \"timestamp\": ..., \"value\":{...} }, { \"feature\"*:..., \"action_name*\":..., \"timestamp\": ..., \"value\":{...} }, ... ] nota 3 :(*) I campi \"feature\" e \"action\" potrebbero non essere restituiti nella struttura nel caso in cui essi risultino non ambigui. \"timestamp\" e \"value\" vengono sempre restituiti Possibili risposte: 404 Not Found : Nel non venga trovata la feature richiesta o essa abbia un problema di configurazione View Source @hug . get ( \"/{feature}\" ) def features_actions_values ( feature , actions = None , timestamp = None , request = None , response = None ) : \"\"\" **Recupero dello stato corrente delle azioni effettuate su una feature** L'intento di questa api \u00e8 quello di fornire i valori richiesti secondo lo schema dell'azione ___nota 1___: `actions` accetta valori multipli separati da virgola ___nota 2___: A seconda dell'action richiesta, alcuni parametri potrebbero essere utilizzati in fase \\ di input ma non registrati. Il che vuol dire che per quei parametri il valore di ritorno sar\u00e0 null viene restituito una struttura di questo tipo: [ { \" feature \"*:..., \" action_name * \":..., \" timestamp \": ..., \" value \":{...} }, { \" feature \"*:..., \" action_name * \":..., \" timestamp \": ..., \" value \":{...} }, ... ] ___nota 3___ :(*) I campi \" feature \" e \" action \" potrebbero non essere restituiti nella struttura \\ nel caso in cui essi risultino non ambigui. \" timestamp \" e \" value \" vengono sempre restituiti Possibili risposte: - _404 Not Found_: Nel non venga trovata la feature richiesta o essa abbia un problema di \\ configurazione \"\"\" out = ResponseFormatter () # Trying to manage income feature request and its prototype configuration try : feat = db [ \"features\" ][ feature ] featobj = sourceman . sourceFactory ( feat , conf [ 'filecache' ] ) out . data = featobj . getActionValues ( actions , timestamp ) if out . data is not list : out . data =[ out.data ] except Exception as e : out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature '{feature}' does not exists or it is misconfigured: {e}\" out . format ( request = request , response = response ) return out . format ( request = request , response = response ) return","title":"features_actions_values"},{"location":"reference/hielen2/api/actions/#make_action","text":"def make_action ( feature , action , request = None , response = None ) Esecuzione delle azioni Richiede l'esecuzione di una specifica azione su una feature, fornendo tutte le informazioni necessarie attraverso una form dinamica dedicata. Oltre ai due parametri feature e form , timestamp , indicati nella url, accetta un multipart/form-data basato sulla specifica form, selezionata tramite i due parametri espliciti. Tutto il content \u00e8 scaricato attarverso i chunk dello stream ('100 continue') per evitare il timeout dei workers in caso di contenuti di grandi dimensioni. Possibili risposte: 200 OK : Nel caso in cui l'azione vada a buon fine. L'azione richiesta viene presa in carico ma potrebbe avere un tempo di esecuzione arbitrario. L'azione quindi viene splittata su un altro processo. 404 Not Found : Nel caso la feature non esista o non sia definita per essa l'azione richiesta. 500 Internal Server Error : Nel caso pessimo che il modulo dichiarato non esista. 501 Not Implemented' : Nel caso la tipologia non fornisse ancora l'iplementazione di uno o tutti i moduli di gestione E' stato implementato il meccanismo minimo di gestione che prevede il salvataggio delle info fornite che possono essere fornite tali e quali in uscita (vedi metodo GET dell'api). Questo meccanismo permette di svluppare i moduli a partire da un template con risposta di default. View Source @hug . post ( \"/{feature}/{action}\" , parse_body = False ) @hug . default_input_format ( content_type = \"multipart/form-data\" ) def make_action ( feature , action , request = None , response = None ) : \"\"\" **Esecuzione delle azioni** Richiede l'esecuzione di una specifica azione su una feature, fornendo tutte le informazioni \\ necessarie attraverso una form dinamica dedicata. - Oltre ai due parametri `feature` e `form`, `timestamp`, indicati nella url, accetta un \\ _multipart/form-data_ basato sulla specifica form, selezionata tramite i due parametri espliciti. - Tutto il content \u00e8 scaricato attarverso i chunk dello stream ('100 continue') per evitare il \\ timeout dei workers in caso di contenuti di grandi dimensioni. Possibili risposte: - _200 OK_: Nel caso in cui l'azione vada a buon fine. L'azione richiesta viene presa in carico ma \\ potrebbe avere un tempo di esecuzione arbitrario. L'azione quindi viene splittata su un altro processo. - _404 Not Found_: Nel caso la feature non esista o non sia definita per essa l'azione richiesta. - _500 Internal Server Error_: Nel caso pessimo che il modulo dichiarato non esista. - _501 Not Implemented'_: Nel caso la tipologia non fornisse ancora l'iplementazione di uno o tutti \\ i moduli di gestione E' stato implementato il meccanismo minimo di gestione che prevede il salvataggio delle info \\ fornite che possono essere fornite tali e quali in uscita (vedi metodo GET dell'api). Questo \\ meccanismo permette di svluppare i moduli a partire da un template con risposta di default. \"\"\" out = ResponseFormatter () # Trying to manage income feature request and its prototype configuration try : feat = db [ \"features\" ][ feature ] featobj = sourceman . sourceFactory ( feat , conf [ 'filecache' ] ) except KeyError as e : #raise e out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature '{feature}' does not exists or it is misconfigured: {e}\" out . format ( request = request , response = response ) return try : schema = featobj . getActionSchema ( action ) except KeyError as e : raise e out . status = falcon . HTTP_NOT_IMPLEMENTED out . message = f \"Prototype '{featobj.type}' actions not implemented.\" out . format ( request = request , response = response ) return except ModuleNotFoundError as e : #raise e out . status = falcon . HTTP_INTERNAL_SERVER_ERROR out . message = f \"Prototype '{featobj.type}' module not found.\" out . format ( request = request , response = response ) return parser = StreamingFormDataParser ( headers = request . headers ) values = {} # TODO Differenziazione delle tipologie di input for k , w in schema [ \"fields\" ] . items () : if w == \"LocalFile\" : timenow = time . perf_counter () filepath = os . path . join ( tempfile . gettempdir (), f \"{feature}.{k}.{timenow}.part\" ) target = FileTarget ( filepath ) parser . register ( k , target ) values [ k ] = filepath else : target = ValueTarget () parser . register ( k , target ) values [ k ] = target while True : chunk = request . stream . read ( 8192 ) if not chunk : break parser . data_received ( chunk ) kwargs = {} for k , w in values . items () : if isinstance ( w , str ) : v = os . path . exists ( w ) and w or None else : v = unquote ( w . value . decode ( \"utf8\" )) or None kwargs [ k ] = v m = [ m for m in schema[\"required\" ] if kwargs [ m ] is None ] if m . __len__ () : out . status = falcon . HTTP_BAD_REQUEST out . message = f \"Required parameters {m} not supplied\" out . format ( request = request , response = response ) return # CHECKS request checks ALL RIGHT . Continuing with code loading # Trying to initialize feature action manager module try : result = featobj . execAction ( action , ** kwargs ) except AttributeError as e : raise e out . status = falcon . HTTP_NOT_IMPLEMENTED out . message = f \"Action '{action}' not implemented.\" out . format ( request = request , response = response ) return except Exception as e : raise e pass try : db [ \"actions\" ][ feature,action,result['timestamp' ] ] = { \"value\" : result } db [ \"features\" ] . save () except KeyError as e : #raise e out . status = falcon . HTTP_INTERNAL_SERVER_ERROR out . message = str ( e ) out . format ( request = request , response = response ) except ValueError as e : #raise e out . status = falcon . HTTP_BAD_REQUEST out . message = str ( e ) out . format ( request = request , response = response ) return out . format ( request = request , response = response ) return","title":"make_action"},{"location":"reference/hielen2/api/actionschemata/","text":"Module hielen2.api.actionschemata View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 #!/usr/bin/env python # coding=utf-8 import hug import falcon from hielen2 import db , source from himada.api import ResponseFormatter @hug . get ( \"/\" ) def get_protos_schemata ( prototypes = None , actions = None , request = None , response = None ): \"\"\" **Recupero dello schema dei parametri per inizializare le forms delle azioni** ritorna una struttura json di questo tipo: { \"NomePrototipo1\": { \"action1\": { \"args\": { \"arg1.1\": \"type_arg1.1\", \"arg1.2\": \"type_arg1.2\", ... }, \"mandatory\": [ args keys sublist ] }, \"action2\": { \"args\": { \"arg2.1\": \"type_arg2.1\", \"arg2.2\": \"type_arg2.2\", ... }, }, ... }, \"NomePrototipo3\": { ... }, ... }, \"\"\" out = ResponseFormatter () out . data = {} try : if actions is not None and actions is not list : actions = [ actions ] protos = db [ \"features_proto\" ][ prototypes ] if not isinstance ( protos , list ): protos = [ protos ] for p in protos : uid = p [ 'uid' ] out . data [ uid ] = {} for a in [ act for act in source . moduleActions ( uid ) if actions is None or act in actions ]: out . data [ uid ][ a ] = source . getActionSchema ( uid , a ) except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) raise e response = out . format ( response = response , request = request ) @hug . get ( \"/ {prototype} \" ) def get_proto_schemata ( prototype , actions = None , request = None , response = None ): \"\"\" **Alias per il recupero di tutte le informazioni di uno specifico prototipo** \"\"\" return get_protos_schemata ( prototype , actions , request , response ) @hug . get ( \"/ {prototype} / {action} \" ) def get_proto_schema ( prototype , action , request = None , response = None ): \"\"\" **Alias per il recupero di tutte le informazioni delle form di uno specifico prototipo** \"\"\" return get_protos_schemata ( prototype , action , request , response ) Variables db Functions get_proto_schema def get_proto_schema ( prototype , action , request = None , response = None ) Alias per il recupero di tutte le informazioni delle form di uno specifico prototipo View Source @hug . get ( \"/{prototype}/{action}\" ) def get_proto_schema ( prototype , action , request = None , response = None ) : \"\"\" **Alias per il recupero di tutte le informazioni delle form di uno specifico prototipo** \"\"\" return get_protos_schemata ( prototype , action , request , response ) get_proto_schemata def get_proto_schemata ( prototype , actions = None , request = None , response = None ) Alias per il recupero di tutte le informazioni di uno specifico prototipo View Source @hug . get ( \"/{prototype}\" ) def get_proto_schemata ( prototype , actions = None , request = None , response = None ) : \"\"\" **Alias per il recupero di tutte le informazioni di uno specifico prototipo** \"\"\" return get_protos_schemata ( prototype , actions , request , response ) get_protos_schemata def get_protos_schemata ( prototypes = None , actions = None , request = None , response = None ) Recupero dello schema dei parametri per inizializare le forms delle azioni ritorna una struttura json di questo tipo: { \"NomePrototipo1\": { \"action1\": { \"args\": { \"arg1.1\": \"type_arg1.1\", \"arg1.2\": \"type_arg1.2\", ... }, \"mandatory\": [ args keys sublist ] }, \"action2\": { \"args\": { \"arg2.1\": \"type_arg2.1\", \"arg2.2\": \"type_arg2.2\", ... }, }, ... }, \"NomePrototipo3\": { ... }, ... }, View Source @hug . get ( \"/\" ) def get_protos_schemata ( prototypes = None , actions = None , request = None , response = None ) : \"\"\" **Recupero dello schema dei parametri per inizializare le forms delle azioni** ritorna una struttura json di questo tipo: { \" NomePrototipo1 \": { \" action1 \": { \" args \": { \" arg1 .1 \": \" type_arg1 .1 \", \" arg1 .2 \": \" type_arg1 .2 \", ... }, \" mandatory \": [ args keys sublist ] }, \" action2 \": { \" args \": { \" arg2 .1 \": \" type_arg2 .1 \", \" arg2 .2 \": \" type_arg2 .2 \", ... }, }, ... }, \" NomePrototipo3 \": { ... }, ... }, \"\"\" out = ResponseFormatter () out . data = {} try : if actions is not None and actions is not list : actions =[ actions ] protos = db [ \"features_proto\" ][ prototypes ] if not isinstance ( protos , list ) : protos =[ protos ] for p in protos : uid = p [ 'uid' ] out . data [ uid ]= {} for a in [ act for act in source.moduleActions(uid) if actions is None or act in actions ] : out . data [ uid ][ a ]= source . getActionSchema ( uid , a ) except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) raise e response = out . format ( response = response , request = request )","title":"Actionschemata"},{"location":"reference/hielen2/api/actionschemata/#module-hielen2apiactionschemata","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 #!/usr/bin/env python # coding=utf-8 import hug import falcon from hielen2 import db , source from himada.api import ResponseFormatter @hug . get ( \"/\" ) def get_protos_schemata ( prototypes = None , actions = None , request = None , response = None ): \"\"\" **Recupero dello schema dei parametri per inizializare le forms delle azioni** ritorna una struttura json di questo tipo: { \"NomePrototipo1\": { \"action1\": { \"args\": { \"arg1.1\": \"type_arg1.1\", \"arg1.2\": \"type_arg1.2\", ... }, \"mandatory\": [ args keys sublist ] }, \"action2\": { \"args\": { \"arg2.1\": \"type_arg2.1\", \"arg2.2\": \"type_arg2.2\", ... }, }, ... }, \"NomePrototipo3\": { ... }, ... }, \"\"\" out = ResponseFormatter () out . data = {} try : if actions is not None and actions is not list : actions = [ actions ] protos = db [ \"features_proto\" ][ prototypes ] if not isinstance ( protos , list ): protos = [ protos ] for p in protos : uid = p [ 'uid' ] out . data [ uid ] = {} for a in [ act for act in source . moduleActions ( uid ) if actions is None or act in actions ]: out . data [ uid ][ a ] = source . getActionSchema ( uid , a ) except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) raise e response = out . format ( response = response , request = request ) @hug . get ( \"/ {prototype} \" ) def get_proto_schemata ( prototype , actions = None , request = None , response = None ): \"\"\" **Alias per il recupero di tutte le informazioni di uno specifico prototipo** \"\"\" return get_protos_schemata ( prototype , actions , request , response ) @hug . get ( \"/ {prototype} / {action} \" ) def get_proto_schema ( prototype , action , request = None , response = None ): \"\"\" **Alias per il recupero di tutte le informazioni delle form di uno specifico prototipo** \"\"\" return get_protos_schemata ( prototype , action , request , response )","title":"Module hielen2.api.actionschemata"},{"location":"reference/hielen2/api/actionschemata/#variables","text":"db","title":"Variables"},{"location":"reference/hielen2/api/actionschemata/#functions","text":"","title":"Functions"},{"location":"reference/hielen2/api/actionschemata/#get_proto_schema","text":"def get_proto_schema ( prototype , action , request = None , response = None ) Alias per il recupero di tutte le informazioni delle form di uno specifico prototipo View Source @hug . get ( \"/{prototype}/{action}\" ) def get_proto_schema ( prototype , action , request = None , response = None ) : \"\"\" **Alias per il recupero di tutte le informazioni delle form di uno specifico prototipo** \"\"\" return get_protos_schemata ( prototype , action , request , response )","title":"get_proto_schema"},{"location":"reference/hielen2/api/actionschemata/#get_proto_schemata","text":"def get_proto_schemata ( prototype , actions = None , request = None , response = None ) Alias per il recupero di tutte le informazioni di uno specifico prototipo View Source @hug . get ( \"/{prototype}\" ) def get_proto_schemata ( prototype , actions = None , request = None , response = None ) : \"\"\" **Alias per il recupero di tutte le informazioni di uno specifico prototipo** \"\"\" return get_protos_schemata ( prototype , actions , request , response )","title":"get_proto_schemata"},{"location":"reference/hielen2/api/actionschemata/#get_protos_schemata","text":"def get_protos_schemata ( prototypes = None , actions = None , request = None , response = None ) Recupero dello schema dei parametri per inizializare le forms delle azioni ritorna una struttura json di questo tipo: { \"NomePrototipo1\": { \"action1\": { \"args\": { \"arg1.1\": \"type_arg1.1\", \"arg1.2\": \"type_arg1.2\", ... }, \"mandatory\": [ args keys sublist ] }, \"action2\": { \"args\": { \"arg2.1\": \"type_arg2.1\", \"arg2.2\": \"type_arg2.2\", ... }, }, ... }, \"NomePrototipo3\": { ... }, ... }, View Source @hug . get ( \"/\" ) def get_protos_schemata ( prototypes = None , actions = None , request = None , response = None ) : \"\"\" **Recupero dello schema dei parametri per inizializare le forms delle azioni** ritorna una struttura json di questo tipo: { \" NomePrototipo1 \": { \" action1 \": { \" args \": { \" arg1 .1 \": \" type_arg1 .1 \", \" arg1 .2 \": \" type_arg1 .2 \", ... }, \" mandatory \": [ args keys sublist ] }, \" action2 \": { \" args \": { \" arg2 .1 \": \" type_arg2 .1 \", \" arg2 .2 \": \" type_arg2 .2 \", ... }, }, ... }, \" NomePrototipo3 \": { ... }, ... }, \"\"\" out = ResponseFormatter () out . data = {} try : if actions is not None and actions is not list : actions =[ actions ] protos = db [ \"features_proto\" ][ prototypes ] if not isinstance ( protos , list ) : protos =[ protos ] for p in protos : uid = p [ 'uid' ] out . data [ uid ]= {} for a in [ act for act in source.moduleActions(uid) if actions is None or act in actions ] : out . data [ uid ][ a ]= source . getActionSchema ( uid , a ) except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) raise e response = out . format ( response = response , request = request )","title":"get_protos_schemata"},{"location":"reference/hielen2/api/data/","text":"Module hielen2.api.data View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 #!/usr/bin/env python # coding=utf-8 import hug import falcon import json from marshmallow import Schema , fields from numpy import nan , unique from pandas import DataFrame , to_datetime from hielen2 import db from hielen2.data.data_access_layer import Series from hielen2.utils import hug_output_format_conten_type , JsonValidable from himada.api import ResponseFormatter import asyncio data_out_handler = hug_output_format_conten_type ( [ hug . output_format . text , hug . output_format . json ] ) CSV = \"text/plain; charset=utf-8\" JSON = \"application/json; charset=utf-8\" class DataMapSchema ( Schema ): \"\"\"\"\"\" timefrom = fields . Str ( default = None , required = False ) timeto = fields . Str ( default = None , reuired = False ) series = fields . List ( fields . Str , default = []) ####### API DATATABLE ####### @hug . get ( \"/\" , examples = \"\" , output = data_out_handler ) def tabular_data ( datamap : JsonValidable ( DataMapSchema ( many = True )), content_type = None , request = None , response = None , ): series = {} for s in datamap : try : timefrom = s [ \"timefrom\" ] except KeyError : timefrom = None try : timeto = s [ \"timeto\" ] except KeyError : timeto = None for p in s [ \"series\" ]: if p not in series . keys (): series [ p ] = [] try : series [ p ] . append ( Series ( p ) . thdata ( timefrom = timefrom , timeto = timeto )) except KeyError as e : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = str ( e ) + \" not found\" response = out . format ( response = response , request = request ) return out = DataFrame () for param , sers in series . items (): ser = None for r in sers : s = r . result () if ser is None : ser = s else : ser = ser . append ( s ) . sort_index () idx = unique ( ser . index . values , return_index = True )[ 1 ] ser = ser . iloc [ idx ] ser . columns = [ param ] out = out . join ( ser , how = \"outer\" ) out . index . name = \"timestamp\" requested = data_out_handler . requested ( request ) . content_type if requested == CSV : return hug . types . text ( out . to_csv ()) if requested == JSON : return hug . types . json ( out . to_json ( orient = \"table\" )) @hug . get ( \"/ {feature} /\" , output = data_out_handler ) def tabular_data_el ( feature , par = None , timefrom = None , timeto = None , content_type = None , request = None , response = None , ): try : ft = db [ \"features\" ][ feature ] except KeyError : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = str ( feature ) + \" not found\" response = out . format ( response = response , request = request ) return try : if par is None : series = list ( ft [ \"parameters\" ] . values ()) else : series = [ ft [ \"parameters\" ][ par ]] except KeyError as e : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = str ( e ) + \" not found\" response = out . format ( response = response , request = request ) return datamap = dict ( series = series ) if timefrom is not None : datamap [ \"timefrom\" ] = timefrom if timeto is not None : datamap [ \"timeto\" ] = timeto return tabular_data ( datamap = [ datamap ], request = request , response = response ) @hug . get ( \"/ {feature} / {par} \" , output = data_out_handler ) def tabular_data_par ( feature = None , par = None , timefrom = None , timeto = None , content_type = None , request = None , response = None , ): return tabular_data_el ( feature = feature , par = par , timefrom = timefrom , timeto = timeto , request = request , response = response , ) Variables CSV JSON db nan Functions data_out_handler def data_out_handler ( data , request , response ) Supports any of the following formats: Free form UTF-8 text, JSON (Javascript Serialized Object Notation) View Source def output_type ( data , request , response ): handler = requested_output_type ( request ) response . content_type = handler . content_type return handler ( data , request = request , response = response ) tabular_data def tabular_data ( datamap : < hielen2 . utils . JsonValidable object at 0x7f8574c25eb0 > , content_type = None , request = None , response = None ) View Source @hug . get ( \"/\" , examples = \"\" , output = data_out_handler ) def tabular_data ( datamap : JsonValidable ( DataMapSchema ( many = True )), content_type = None , request = None , response = None , ) : series = {} for s in datamap : try : timefrom = s [ \"timefrom\" ] except KeyError : timefrom = None try : timeto = s [ \"timeto\" ] except KeyError : timeto = None for p in s [ \"series\" ] : if p not in series . keys () : series [ p ] = [] try : series [ p ] . append ( Series ( p ). thdata ( timefrom = timefrom , timeto = timeto )) except KeyError as e : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = str ( e ) + \" not found\" response = out . format ( response = response , request = request ) return out = DataFrame () for param , sers in series . items () : ser = None for r in sers : s = r . result () if ser is None : ser = s else : ser = ser . append ( s ). sort_index () idx = unique ( ser . index . values , return_index = True ) [ 1 ] ser = ser . iloc [ idx ] ser . columns = [ param ] out = out . join ( ser , how = \"outer\" ) out . index . name = \"timestamp\" requested = data_out_handler . requested ( request ). content_type if requested == CSV : return hug . types . text ( out . to_csv ()) if requested == JSON : return hug . types . json ( out . to_json ( orient = \"table\" )) tabular_data_el def tabular_data_el ( feature , par = None , timefrom = None , timeto = None , content_type = None , request = None , response = None ) View Source @hug . get ( \"/{feature}/\" , output = data_out_handler ) def tabular_data_el ( feature , par = None , timefrom = None , timeto = None , content_type = None , request = None , response = None , ) : try : ft = db [ \"features\" ][ feature ] except KeyError : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = str ( feature ) + \" not found\" response = out . format ( response = response , request = request ) return try : if par is None : series = list ( ft [ \"parameters\" ] . values ()) else : series = [ ft[\"parameters\" ][ par ] ] except KeyError as e : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = str ( e ) + \" not found\" response = out . format ( response = response , request = request ) return datamap = dict ( series = series ) if timefrom is not None : datamap [ \"timefrom\" ] = timefrom if timeto is not None : datamap [ \"timeto\" ] = timeto return tabular_data ( datamap =[ datamap ] , request = request , response = response ) tabular_data_par def tabular_data_par ( feature = None , par = None , timefrom = None , timeto = None , content_type = None , request = None , response = None ) View Source @hug . get ( \"/{feature}/{par}\" , output = data_out_handler ) def tabular_data_par ( feature = None , par = None , timefrom = None , timeto = None , content_type = None , request = None , response = None , ) : return tabular_data_el ( feature = feature , par = par , timefrom = timefrom , timeto = timeto , request = request , response = response , ) Classes DataMapSchema class DataMapSchema ( * , only : Union [ Sequence [ str ], Set [ str ], NoneType ] = None , exclude : Union [ Sequence [ str ], Set [ str ]] = (), many : bool = False , context : Union [ Dict , NoneType ] = None , load_only : Union [ Sequence [ str ], Set [ str ]] = (), dump_only : Union [ Sequence [ str ], Set [ str ]] = (), partial : Union [ bool , Sequence [ str ], Set [ str ]] = False , unknown : Union [ str , NoneType ] = None ) View Source class DataMapSchema ( Schema ): \"\"\"\"\"\" timefrom = fields . Str ( default = None , required = False ) timeto = fields . Str ( default = None , reuired = False ) series = fields . List ( fields . Str , default =[]) Ancestors (in MRO) marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages opts series timefrom timeto Static methods from_dict def from_dict ( fields : Dict [ str , Union [ marshmallow . fields . Field , type ]], * , name : str = 'GeneratedSchema' ) -> type Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 View Source @classmethod def from_dict ( cls , fields : typing . Dict [ str , typing . Union [ ma_fields . Field , type ]], * , name : str = \"GeneratedSchema\" ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : Any , * , many : Union [ bool , NoneType ] = None ) Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : typing . Optional [ bool ] = None ): \"\"\"Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\"\" many = self . many if many is None else bool ( many ) if many and is_iterable_but_not_string ( obj ): obj = list ( obj ) if self . _has_processors ( PRE_DUMP ): processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ): result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : Any , * args , many : Union [ bool , NoneType ] = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A json string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : typing . Optional [ bool ] = None , ** kwargs ): \"\"\"Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\"\" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : Any , attr : str , default : Any ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ): \"\"\"Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\"\" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : marshmallow . exceptions . ValidationError , data : Any , * , many : bool , ** kwargs ) Custom error handler function for the schema. :param error: The ValidationError raised during (de)serialization. :param data: The original input data. :param many: Value of many on dump or load. :param partial: Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ): \"\"\"Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\"\" pass load def load ( self , data : Union [ Mapping [ str , Any ], Iterable [ Mapping [ str , Any ]]], * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None ) Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : typing . Union [ typing . Mapping [ str , typing . Any ], typing . Iterable [ typing . Mapping [ str , typing . Any ]], ], * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None ): \"\"\"Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : str , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize obj as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None , ** kwargs ): \"\"\"Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : str , field_obj : marshmallow . fields . Field ) -> None Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \"\"\"Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\"\" return None validate def validate ( self , data : Mapping , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None ) -> Dict [ str , List [ str ]] Validate data against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : typing . Mapping , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None ) -> typing . Dict [ str , typing . List [ str ]]: \"\"\"Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\"\" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]], exc . messages ) return {}","title":"Data"},{"location":"reference/hielen2/api/data/#module-hielen2apidata","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 #!/usr/bin/env python # coding=utf-8 import hug import falcon import json from marshmallow import Schema , fields from numpy import nan , unique from pandas import DataFrame , to_datetime from hielen2 import db from hielen2.data.data_access_layer import Series from hielen2.utils import hug_output_format_conten_type , JsonValidable from himada.api import ResponseFormatter import asyncio data_out_handler = hug_output_format_conten_type ( [ hug . output_format . text , hug . output_format . json ] ) CSV = \"text/plain; charset=utf-8\" JSON = \"application/json; charset=utf-8\" class DataMapSchema ( Schema ): \"\"\"\"\"\" timefrom = fields . Str ( default = None , required = False ) timeto = fields . Str ( default = None , reuired = False ) series = fields . List ( fields . Str , default = []) ####### API DATATABLE ####### @hug . get ( \"/\" , examples = \"\" , output = data_out_handler ) def tabular_data ( datamap : JsonValidable ( DataMapSchema ( many = True )), content_type = None , request = None , response = None , ): series = {} for s in datamap : try : timefrom = s [ \"timefrom\" ] except KeyError : timefrom = None try : timeto = s [ \"timeto\" ] except KeyError : timeto = None for p in s [ \"series\" ]: if p not in series . keys (): series [ p ] = [] try : series [ p ] . append ( Series ( p ) . thdata ( timefrom = timefrom , timeto = timeto )) except KeyError as e : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = str ( e ) + \" not found\" response = out . format ( response = response , request = request ) return out = DataFrame () for param , sers in series . items (): ser = None for r in sers : s = r . result () if ser is None : ser = s else : ser = ser . append ( s ) . sort_index () idx = unique ( ser . index . values , return_index = True )[ 1 ] ser = ser . iloc [ idx ] ser . columns = [ param ] out = out . join ( ser , how = \"outer\" ) out . index . name = \"timestamp\" requested = data_out_handler . requested ( request ) . content_type if requested == CSV : return hug . types . text ( out . to_csv ()) if requested == JSON : return hug . types . json ( out . to_json ( orient = \"table\" )) @hug . get ( \"/ {feature} /\" , output = data_out_handler ) def tabular_data_el ( feature , par = None , timefrom = None , timeto = None , content_type = None , request = None , response = None , ): try : ft = db [ \"features\" ][ feature ] except KeyError : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = str ( feature ) + \" not found\" response = out . format ( response = response , request = request ) return try : if par is None : series = list ( ft [ \"parameters\" ] . values ()) else : series = [ ft [ \"parameters\" ][ par ]] except KeyError as e : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = str ( e ) + \" not found\" response = out . format ( response = response , request = request ) return datamap = dict ( series = series ) if timefrom is not None : datamap [ \"timefrom\" ] = timefrom if timeto is not None : datamap [ \"timeto\" ] = timeto return tabular_data ( datamap = [ datamap ], request = request , response = response ) @hug . get ( \"/ {feature} / {par} \" , output = data_out_handler ) def tabular_data_par ( feature = None , par = None , timefrom = None , timeto = None , content_type = None , request = None , response = None , ): return tabular_data_el ( feature = feature , par = par , timefrom = timefrom , timeto = timeto , request = request , response = response , )","title":"Module hielen2.api.data"},{"location":"reference/hielen2/api/data/#variables","text":"CSV JSON db nan","title":"Variables"},{"location":"reference/hielen2/api/data/#functions","text":"","title":"Functions"},{"location":"reference/hielen2/api/data/#data_out_handler","text":"def data_out_handler ( data , request , response ) Supports any of the following formats: Free form UTF-8 text, JSON (Javascript Serialized Object Notation) View Source def output_type ( data , request , response ): handler = requested_output_type ( request ) response . content_type = handler . content_type return handler ( data , request = request , response = response )","title":"data_out_handler"},{"location":"reference/hielen2/api/data/#tabular_data","text":"def tabular_data ( datamap : < hielen2 . utils . JsonValidable object at 0x7f8574c25eb0 > , content_type = None , request = None , response = None ) View Source @hug . get ( \"/\" , examples = \"\" , output = data_out_handler ) def tabular_data ( datamap : JsonValidable ( DataMapSchema ( many = True )), content_type = None , request = None , response = None , ) : series = {} for s in datamap : try : timefrom = s [ \"timefrom\" ] except KeyError : timefrom = None try : timeto = s [ \"timeto\" ] except KeyError : timeto = None for p in s [ \"series\" ] : if p not in series . keys () : series [ p ] = [] try : series [ p ] . append ( Series ( p ). thdata ( timefrom = timefrom , timeto = timeto )) except KeyError as e : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = str ( e ) + \" not found\" response = out . format ( response = response , request = request ) return out = DataFrame () for param , sers in series . items () : ser = None for r in sers : s = r . result () if ser is None : ser = s else : ser = ser . append ( s ). sort_index () idx = unique ( ser . index . values , return_index = True ) [ 1 ] ser = ser . iloc [ idx ] ser . columns = [ param ] out = out . join ( ser , how = \"outer\" ) out . index . name = \"timestamp\" requested = data_out_handler . requested ( request ). content_type if requested == CSV : return hug . types . text ( out . to_csv ()) if requested == JSON : return hug . types . json ( out . to_json ( orient = \"table\" ))","title":"tabular_data"},{"location":"reference/hielen2/api/data/#tabular_data_el","text":"def tabular_data_el ( feature , par = None , timefrom = None , timeto = None , content_type = None , request = None , response = None ) View Source @hug . get ( \"/{feature}/\" , output = data_out_handler ) def tabular_data_el ( feature , par = None , timefrom = None , timeto = None , content_type = None , request = None , response = None , ) : try : ft = db [ \"features\" ][ feature ] except KeyError : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = str ( feature ) + \" not found\" response = out . format ( response = response , request = request ) return try : if par is None : series = list ( ft [ \"parameters\" ] . values ()) else : series = [ ft[\"parameters\" ][ par ] ] except KeyError as e : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = str ( e ) + \" not found\" response = out . format ( response = response , request = request ) return datamap = dict ( series = series ) if timefrom is not None : datamap [ \"timefrom\" ] = timefrom if timeto is not None : datamap [ \"timeto\" ] = timeto return tabular_data ( datamap =[ datamap ] , request = request , response = response )","title":"tabular_data_el"},{"location":"reference/hielen2/api/data/#tabular_data_par","text":"def tabular_data_par ( feature = None , par = None , timefrom = None , timeto = None , content_type = None , request = None , response = None ) View Source @hug . get ( \"/{feature}/{par}\" , output = data_out_handler ) def tabular_data_par ( feature = None , par = None , timefrom = None , timeto = None , content_type = None , request = None , response = None , ) : return tabular_data_el ( feature = feature , par = par , timefrom = timefrom , timeto = timeto , request = request , response = response , )","title":"tabular_data_par"},{"location":"reference/hielen2/api/data/#classes","text":"","title":"Classes"},{"location":"reference/hielen2/api/data/#datamapschema","text":"class DataMapSchema ( * , only : Union [ Sequence [ str ], Set [ str ], NoneType ] = None , exclude : Union [ Sequence [ str ], Set [ str ]] = (), many : bool = False , context : Union [ Dict , NoneType ] = None , load_only : Union [ Sequence [ str ], Set [ str ]] = (), dump_only : Union [ Sequence [ str ], Set [ str ]] = (), partial : Union [ bool , Sequence [ str ], Set [ str ]] = False , unknown : Union [ str , NoneType ] = None ) View Source class DataMapSchema ( Schema ): \"\"\"\"\"\" timefrom = fields . Str ( default = None , required = False ) timeto = fields . Str ( default = None , reuired = False ) series = fields . List ( fields . Str , default =[])","title":"DataMapSchema"},{"location":"reference/hielen2/api/data/#ancestors-in-mro","text":"marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen2/api/data/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages opts series timefrom timeto","title":"Class variables"},{"location":"reference/hielen2/api/data/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen2/api/data/#from_dict","text":"def from_dict ( fields : Dict [ str , Union [ marshmallow . fields . Field , type ]], * , name : str = 'GeneratedSchema' ) -> type Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 View Source @classmethod def from_dict ( cls , fields : typing . Dict [ str , typing . Union [ ma_fields . Field , type ]], * , name : str = \"GeneratedSchema\" ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen2/api/data/#instance-variables","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen2/api/data/#methods","text":"","title":"Methods"},{"location":"reference/hielen2/api/data/#dump","text":"def dump ( self , obj : Any , * , many : Union [ bool , NoneType ] = None ) Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : typing . Optional [ bool ] = None ): \"\"\"Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\"\" many = self . many if many is None else bool ( many ) if many and is_iterable_but_not_string ( obj ): obj = list ( obj ) if self . _has_processors ( PRE_DUMP ): processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ): result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen2/api/data/#dumps","text":"def dumps ( self , obj : Any , * args , many : Union [ bool , NoneType ] = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A json string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : typing . Optional [ bool ] = None , ** kwargs ): \"\"\"Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\"\" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen2/api/data/#get_attribute","text":"def get_attribute ( self , obj : Any , attr : str , default : Any ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ): \"\"\"Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\"\" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen2/api/data/#handle_error","text":"def handle_error ( self , error : marshmallow . exceptions . ValidationError , data : Any , * , many : bool , ** kwargs ) Custom error handler function for the schema. :param error: The ValidationError raised during (de)serialization. :param data: The original input data. :param many: Value of many on dump or load. :param partial: Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ): \"\"\"Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\"\" pass","title":"handle_error"},{"location":"reference/hielen2/api/data/#load","text":"def load ( self , data : Union [ Mapping [ str , Any ], Iterable [ Mapping [ str , Any ]]], * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None ) Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : typing . Union [ typing . Mapping [ str , typing . Any ], typing . Iterable [ typing . Mapping [ str , typing . Any ]], ], * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None ): \"\"\"Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen2/api/data/#loads","text":"def loads ( self , json_data : str , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize obj as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None , ** kwargs ): \"\"\"Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen2/api/data/#on_bind_field","text":"def on_bind_field ( self , field_name : str , field_obj : marshmallow . fields . Field ) -> None Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \"\"\"Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\"\" return None","title":"on_bind_field"},{"location":"reference/hielen2/api/data/#validate","text":"def validate ( self , data : Mapping , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None ) -> Dict [ str , List [ str ]] Validate data against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : typing . Mapping , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None ) -> typing . Dict [ str , typing . List [ str ]]: \"\"\"Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\"\" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]], exc . messages ) return {}","title":"validate"},{"location":"reference/hielen2/api/features/","text":"Module hielen2.api.features View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 #!/usr/bin/env python # coding=utf-8 import hug import falcon from hielen2 import db from hielen2.utils import JsonValidable from marshmallow import Schema , fields from himada.api import ResponseFormatter from marshmallow_geojson import GeoJSONSchema class FeaturePropertiesSchema ( Schema ): context = fields . Str ( default = \"no-context\" , allow_none = False ) label = fields . Str ( default = None ) description = fields . Str ( default = None ) location = fields . Str ( default = None ) style = fields . Str ( default = None ) status = fields . Str ( default = None ) timestamp = fields . Str ( default = None ) @hug . post ( \"/\" ) def create_feature ( uid , prototype , properties : JsonValidable ( FeaturePropertiesSchema ()) = {}, geometry : JsonValidable ( GeoJSONSchema ()) = {}, request = None , response = None , ): \"\"\" **Creazione delle Features.** Ogni feature deve avere il suo codice univoco `uid` e il suo prototipo `prototype`. Questi due \\ campi sono immutabli (vedi PUT `/feature/{uid}`). Il prototipo della feature forisce informazioni per l'inizializazione della struttura. Il parametro `geometry` deve essere un GeoJson Se la feature viene creata correttamente ne restituisce la struttura Possibili risposte: - _409 Conflict_: Nel caso in cui il uid fornito esista gi\u00e0. - _404 Not Found_: Nel caso in cui il prototipo richiesto non esista. - _201 Created_: Nel caso in cui la feature venga creata correttamente. \"\"\" out = ResponseFormatter ( status = falcon . HTTP_CREATED ) try : feature = db [ \"features_proto\" ][ prototype ][ 'struct' ] #TODO CREARE SERIES feature [ 'parameters' ] = { k : None for k in feature [ 'parameters' ] . keys () } ## feature [ \"geometry\" ] = geometry feature [ \"uid\" ] = uid try : assert properties [ \"context\" ] is not None except Exception : properties [ \"context\" ] = \"no-context\" feature . update ( properties ) db [ \"features\" ][ uid ] = feature out . data = db [ \"features\" ][ uid ] except KeyError as e : out . message = f \"prototype ' { prototype } ' not found.\" out . status = falcon . HTTP_NOT_FOUND except ValueError as e : out . message = f \"feature ' { feature [ 'uid' ] } ' exists\" out . status = falcon . HTTP_CONFLICT response = out . format ( response = response , request = request ) return @hug . get ( \"/\" ) def features_info ( uids = None , cntxt = None , request = None , response = None ): \"\"\" **Recupero delle informazioni delle features.** __nota__: uids accetta valori multipli separati da virgola viene restituito una struttura di questo tipo: { \"features\": [ { \"type\": \"Feature\", \"properties\": { ... }, \"geometry\": <GeoJson Validable> }, ... ] } ___nota___: Al contrario di quanto detto nel TODO non viene inserito il context a livello \\ \"features\" perch\u00e8 in effetti \u00e8 una informazione sempre conosciuta a priori (se si lavora \\ per commesse). Al contrario se si lavora per uids allora ha senso inserie questa info all' \\ interno delle properties delle singole features. Possibili risposte: - _404 Not Found_: Nel caso in cui nessuna feature risponda ai criteri \"\"\" out = ResponseFormatter () try : out . data = [] extract = db [ \"features\" ][ uids ] if not isinstance ( extract , list ): extract = [ extract ] for v in extract : if cntxt is None or v [ \"context\" ] == cntxt : out . data . append ({ \"type\" : \"Feature\" , \"geometry\" : v . pop ( \"geometry\" ), \"parameters\" : v . pop ( \"parameters\" ), \"properties\" : v }) except KeyError as e : out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) return @hug . get ( \"/ {uid} \" ) def feature_info ( uid , cntxt = None , request = None , response = None ): \"\"\" **Alias di recupero informazioni della specifica feature**\"\"\" return features_info ( uid , cntxt , request , response ) @hug . put ( \"/ {uid} \" ) def update_feature ( uid , properties : JsonValidable ( FeaturePropertiesSchema ()) = {}, geometry : JsonValidable ( GeoJSONSchema ()) = {}, request = None , response = None , ): \"\"\" **Modifica delle properties di una feature** Possibili risposte: - _404 Not Found_: Nel caso in cui il prototipo richiesto non esista. - _202 Accepted_: Nel caso in cui la feature venga modificata correttamente. \"\"\" out = ResponseFormatter ( status = falcon . HTTP_ACCEPTED ) if uid is None : out . status = falcon . HTTP_BAD_REQUEST out . message = \"None value not allowed\" try : feat = db [ \"features\" ][ uid ] feat . update ( properties ) feat [ \"geometry\" ] . update ( geometry ) db [ \"features\" ][ uid ] = None db [ \"features\" ][ uid ] = feat out . data = db [ \"features\" ][ uid ] except KeyError as e : out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature ' { uid } ' not foud.\" response = out . format ( response = response , request = request ) return @hug . delete ( \"/ {uid} \" ) def del_feature ( uid , request = None , response = None ): \"\"\" **Cancellazione delle Features** Se la feature viene cancellata correttamente ne restituisce la struttura Possibili risposte: - _404 Not Found_: Nel caso in cui il prototipo richiesto non esista. - _202 Accepted_: Nel caso in cui la feature venga eliminata correttamente. \"\"\" out = ResponseFormatter ( falcon . HTTP_ACCEPTED ) if uid is None : out . status = falcon . HTTP_BAD_REQUEST out . message = \"None value not allowed\" try : out . data = db [ \"features\" ][ uid ] db [ \"features\" ][ uid ] = None except KeyError as e : out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature ' { uid } ' not foud.\" response = out . format ( response = response , request = request ) return Variables db Functions create_feature def create_feature ( uid , prototype , properties : < hielen2 . utils . JsonValidable object at 0x7f8574be43d0 > = {}, geometry : < hielen2 . utils . JsonValidable object at 0x7f8574be45b0 > = {}, request = None , response = None ) Creazione delle Features. Ogni feature deve avere il suo codice univoco uid e il suo prototipo prototype . Questi due campi sono immutabli (vedi PUT /feature/{uid} ). Il prototipo della feature forisce informazioni per l'inizializazione della struttura. Il parametro geometry deve essere un GeoJson Se la feature viene creata correttamente ne restituisce la struttura Possibili risposte: 409 Conflict : Nel caso in cui il uid fornito esista gi\u00e0. 404 Not Found : Nel caso in cui il prototipo richiesto non esista. 201 Created : Nel caso in cui la feature venga creata correttamente. View Source @hug . post ( \"/\" ) def create_feature ( uid , prototype , properties : JsonValidable ( FeaturePropertiesSchema ()) = {} , geometry : JsonValidable ( GeoJSONSchema ()) = {} , request = None , response = None , ) : \"\"\" **Creazione delle Features.** Ogni feature deve avere il suo codice univoco `uid` e il suo prototipo `prototype`. Questi due \\ campi sono immutabli (vedi PUT `/feature/{uid}`). Il prototipo della feature forisce informazioni per l'inizializazione della struttura. Il parametro `geometry` deve essere un GeoJson Se la feature viene creata correttamente ne restituisce la struttura Possibili risposte: - _409 Conflict_: Nel caso in cui il uid fornito esista gi\u00e0. - _404 Not Found_: Nel caso in cui il prototipo richiesto non esista. - _201 Created_: Nel caso in cui la feature venga creata correttamente. \"\"\" out = ResponseFormatter ( status = falcon . HTTP_CREATED ) try : feature = db [ \"features_proto\" ][ prototype ][ 'struct' ] #TODO CREARE SERIES feature [ 'parameters' ]= { k : None for k in feature [ 'parameters' ] . keys () } ## feature [ \"geometry\" ]= geometry feature [ \"uid\" ] = uid try : assert properties [ \"context\" ] is not None except Exception : properties [ \"context\" ] = \"no-context\" feature . update ( properties ) db [ \"features\" ][ uid ] = feature out . data = db [ \"features\" ][ uid ] except KeyError as e : out . message = f \"prototype '{prototype}' not found.\" out . status = falcon . HTTP_NOT_FOUND except ValueError as e : out . message = f \"feature '{feature['uid']}' exists\" out . status = falcon . HTTP_CONFLICT response = out . format ( response = response , request = request ) return del_feature def del_feature ( uid , request = None , response = None ) Cancellazione delle Features Se la feature viene cancellata correttamente ne restituisce la struttura Possibili risposte: 404 Not Found : Nel caso in cui il prototipo richiesto non esista. 202 Accepted : Nel caso in cui la feature venga eliminata correttamente. View Source @hug . delete ( \"/{uid}\" ) def del_feature ( uid , request = None , response = None ) : \"\"\" **Cancellazione delle Features** Se la feature viene cancellata correttamente ne restituisce la struttura Possibili risposte: - _404 Not Found_: Nel caso in cui il prototipo richiesto non esista. - _202 Accepted_: Nel caso in cui la feature venga eliminata correttamente. \"\"\" out = ResponseFormatter ( falcon . HTTP_ACCEPTED ) if uid is None : out . status = falcon . HTTP_BAD_REQUEST out . message = \"None value not allowed\" try : out . data = db [ \"features\" ][ uid ] db [ \"features\" ][ uid ] = None except KeyError as e : out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature '{uid}' not foud.\" response = out . format ( response = response , request = request ) return feature_info def feature_info ( uid , cntxt = None , request = None , response = None ) Alias di recupero informazioni della specifica feature View Source @hug . get ( \"/{uid}\" ) def feature_info ( uid , cntxt = None , request = None , response = None ) : \"\"\" **Alias di recupero informazioni della specifica feature**\"\"\" return features_info ( uid , cntxt , request , response ) features_info def features_info ( uids = None , cntxt = None , request = None , response = None ) Recupero delle informazioni delle features. nota : uids accetta valori multipli separati da virgola viene restituito una struttura di questo tipo: { \"features\": [ { \"type\": \"Feature\", \"properties\": { ... }, \"geometry\": <GeoJson Validable> }, ... ] } nota : Al contrario di quanto detto nel TODO non viene inserito il context a livello \"features\" perch\u00e8 in effetti \u00e8 una informazione sempre conosciuta a priori (se si lavora per commesse). Al contrario se si lavora per uids allora ha senso inserie questa info all' interno delle properties delle singole features. Possibili risposte: 404 Not Found : Nel caso in cui nessuna feature risponda ai criteri View Source @hug . get ( \"/\" ) def features_info ( uids = None , cntxt = None , request = None , response = None ) : \"\"\" **Recupero delle informazioni delle features.** __nota__: uids accetta valori multipli separati da virgola viene restituito una struttura di questo tipo: { \" features \": [ { \" type \": \" Feature \", \" properties \": { ... }, \" geometry \": <GeoJson Validable> }, ... ] } ___nota___: Al contrario di quanto detto nel TODO non viene inserito il context a livello \\ \" features \" perch\u00e8 in effetti \u00e8 una informazione sempre conosciuta a priori (se si lavora \\ per commesse). Al contrario se si lavora per uids allora ha senso inserie questa info all' \\ interno delle properties delle singole features. Possibili risposte: - _404 Not Found_: Nel caso in cui nessuna feature risponda ai criteri \"\"\" out = ResponseFormatter () try : out . data = [] extract = db [ \"features\" ][ uids ] if not isinstance ( extract , list ) : extract =[ extract ] for v in extract : if cntxt is None or v [ \"context\" ] == cntxt : out . data . append ( { \"type\" : \"Feature\" , \"geometry\" : v . pop ( \"geometry\" ), \"parameters\" : v . pop ( \"parameters\" ), \"properties\" : v } ) except KeyError as e : out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) return update_feature def update_feature ( uid , properties : < hielen2 . utils . JsonValidable object at 0x7f8574be4760 > = {}, geometry : < hielen2 . utils . JsonValidable object at 0x7f8574be4b50 > = {}, request = None , response = None ) Modifica delle properties di una feature Possibili risposte: 404 Not Found : Nel caso in cui il prototipo richiesto non esista. 202 Accepted : Nel caso in cui la feature venga modificata correttamente. View Source @hug . put ( \"/{uid}\" ) def update_feature ( uid , properties : JsonValidable ( FeaturePropertiesSchema ()) = {} , geometry : JsonValidable ( GeoJSONSchema ()) = {} , request = None , response = None , ) : \"\"\" **Modifica delle properties di una feature** Possibili risposte: - _404 Not Found_: Nel caso in cui il prototipo richiesto non esista. - _202 Accepted_: Nel caso in cui la feature venga modificata correttamente. \"\"\" out = ResponseFormatter ( status = falcon . HTTP_ACCEPTED ) if uid is None : out . status = falcon . HTTP_BAD_REQUEST out . message = \"None value not allowed\" try : feat = db [ \"features\" ][ uid ] feat . update ( properties ) feat [ \"geometry\" ] . update ( geometry ) db [ \"features\" ][ uid ] = None db [ \"features\" ][ uid ] = feat out . data = db [ \"features\" ][ uid ] except KeyError as e : out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature '{uid}' not foud.\" response = out . format ( response = response , request = request ) return Classes FeaturePropertiesSchema class FeaturePropertiesSchema ( * , only : Union [ Sequence [ str ], Set [ str ], NoneType ] = None , exclude : Union [ Sequence [ str ], Set [ str ]] = (), many : bool = False , context : Union [ Dict , NoneType ] = None , load_only : Union [ Sequence [ str ], Set [ str ]] = (), dump_only : Union [ Sequence [ str ], Set [ str ]] = (), partial : Union [ bool , Sequence [ str ], Set [ str ]] = False , unknown : Union [ str , NoneType ] = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'} :param only: Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. :param exclude: Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. :param many: Should be set to True if obj is a collection so that the object will be serialized to a list. :param context: Optional context passed to :class: fields.Method and :class: fields.Function fields. :param load_only: Fields to skip during serialization (write-only fields) :param dump_only: Fields to skip during deserialization (read-only fields) :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. View Source class FeaturePropertiesSchema ( Schema ): context = fields . Str ( default = \"no-context\" , allow_none = False ) label = fields . Str ( default = None ) description = fields . Str ( default = None ) location = fields . Str ( default = None ) style = fields . Str ( default = None ) status = fields . Str ( default = None ) timestamp = fields . Str ( default = None ) Ancestors (in MRO) marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING context description error_messages label location opts status style timestamp Static methods from_dict def from_dict ( fields : Dict [ str , Union [ marshmallow . fields . Field , type ]], * , name : str = 'GeneratedSchema' ) -> type Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 View Source @classmethod def from_dict ( cls , fields : typing . Dict [ str , typing . Union [ ma_fields . Field , type ]], * , name : str = \"GeneratedSchema\" ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : Any , * , many : Union [ bool , NoneType ] = None ) Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : typing . Optional [ bool ] = None ): \"\"\"Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\"\" many = self . many if many is None else bool ( many ) if many and is_iterable_but_not_string ( obj ): obj = list ( obj ) if self . _has_processors ( PRE_DUMP ): processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ): result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : Any , * args , many : Union [ bool , NoneType ] = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A json string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : typing . Optional [ bool ] = None , ** kwargs ): \"\"\"Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\"\" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : Any , attr : str , default : Any ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ): \"\"\"Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\"\" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : marshmallow . exceptions . ValidationError , data : Any , * , many : bool , ** kwargs ) Custom error handler function for the schema. :param error: The ValidationError raised during (de)serialization. :param data: The original input data. :param many: Value of many on dump or load. :param partial: Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ): \"\"\"Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\"\" pass load def load ( self , data : Union [ Mapping [ str , Any ], Iterable [ Mapping [ str , Any ]]], * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None ) Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : typing . Union [ typing . Mapping [ str , typing . Any ], typing . Iterable [ typing . Mapping [ str , typing . Any ]], ], * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None ): \"\"\"Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : str , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize obj as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None , ** kwargs ): \"\"\"Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : str , field_obj : marshmallow . fields . Field ) -> None Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \"\"\"Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\"\" return None validate def validate ( self , data : Mapping , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None ) -> Dict [ str , List [ str ]] Validate data against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : typing . Mapping , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None ) -> typing . Dict [ str , typing . List [ str ]]: \"\"\"Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\"\" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]], exc . messages ) return {}","title":"Features"},{"location":"reference/hielen2/api/features/#module-hielen2apifeatures","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 #!/usr/bin/env python # coding=utf-8 import hug import falcon from hielen2 import db from hielen2.utils import JsonValidable from marshmallow import Schema , fields from himada.api import ResponseFormatter from marshmallow_geojson import GeoJSONSchema class FeaturePropertiesSchema ( Schema ): context = fields . Str ( default = \"no-context\" , allow_none = False ) label = fields . Str ( default = None ) description = fields . Str ( default = None ) location = fields . Str ( default = None ) style = fields . Str ( default = None ) status = fields . Str ( default = None ) timestamp = fields . Str ( default = None ) @hug . post ( \"/\" ) def create_feature ( uid , prototype , properties : JsonValidable ( FeaturePropertiesSchema ()) = {}, geometry : JsonValidable ( GeoJSONSchema ()) = {}, request = None , response = None , ): \"\"\" **Creazione delle Features.** Ogni feature deve avere il suo codice univoco `uid` e il suo prototipo `prototype`. Questi due \\ campi sono immutabli (vedi PUT `/feature/{uid}`). Il prototipo della feature forisce informazioni per l'inizializazione della struttura. Il parametro `geometry` deve essere un GeoJson Se la feature viene creata correttamente ne restituisce la struttura Possibili risposte: - _409 Conflict_: Nel caso in cui il uid fornito esista gi\u00e0. - _404 Not Found_: Nel caso in cui il prototipo richiesto non esista. - _201 Created_: Nel caso in cui la feature venga creata correttamente. \"\"\" out = ResponseFormatter ( status = falcon . HTTP_CREATED ) try : feature = db [ \"features_proto\" ][ prototype ][ 'struct' ] #TODO CREARE SERIES feature [ 'parameters' ] = { k : None for k in feature [ 'parameters' ] . keys () } ## feature [ \"geometry\" ] = geometry feature [ \"uid\" ] = uid try : assert properties [ \"context\" ] is not None except Exception : properties [ \"context\" ] = \"no-context\" feature . update ( properties ) db [ \"features\" ][ uid ] = feature out . data = db [ \"features\" ][ uid ] except KeyError as e : out . message = f \"prototype ' { prototype } ' not found.\" out . status = falcon . HTTP_NOT_FOUND except ValueError as e : out . message = f \"feature ' { feature [ 'uid' ] } ' exists\" out . status = falcon . HTTP_CONFLICT response = out . format ( response = response , request = request ) return @hug . get ( \"/\" ) def features_info ( uids = None , cntxt = None , request = None , response = None ): \"\"\" **Recupero delle informazioni delle features.** __nota__: uids accetta valori multipli separati da virgola viene restituito una struttura di questo tipo: { \"features\": [ { \"type\": \"Feature\", \"properties\": { ... }, \"geometry\": <GeoJson Validable> }, ... ] } ___nota___: Al contrario di quanto detto nel TODO non viene inserito il context a livello \\ \"features\" perch\u00e8 in effetti \u00e8 una informazione sempre conosciuta a priori (se si lavora \\ per commesse). Al contrario se si lavora per uids allora ha senso inserie questa info all' \\ interno delle properties delle singole features. Possibili risposte: - _404 Not Found_: Nel caso in cui nessuna feature risponda ai criteri \"\"\" out = ResponseFormatter () try : out . data = [] extract = db [ \"features\" ][ uids ] if not isinstance ( extract , list ): extract = [ extract ] for v in extract : if cntxt is None or v [ \"context\" ] == cntxt : out . data . append ({ \"type\" : \"Feature\" , \"geometry\" : v . pop ( \"geometry\" ), \"parameters\" : v . pop ( \"parameters\" ), \"properties\" : v }) except KeyError as e : out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) return @hug . get ( \"/ {uid} \" ) def feature_info ( uid , cntxt = None , request = None , response = None ): \"\"\" **Alias di recupero informazioni della specifica feature**\"\"\" return features_info ( uid , cntxt , request , response ) @hug . put ( \"/ {uid} \" ) def update_feature ( uid , properties : JsonValidable ( FeaturePropertiesSchema ()) = {}, geometry : JsonValidable ( GeoJSONSchema ()) = {}, request = None , response = None , ): \"\"\" **Modifica delle properties di una feature** Possibili risposte: - _404 Not Found_: Nel caso in cui il prototipo richiesto non esista. - _202 Accepted_: Nel caso in cui la feature venga modificata correttamente. \"\"\" out = ResponseFormatter ( status = falcon . HTTP_ACCEPTED ) if uid is None : out . status = falcon . HTTP_BAD_REQUEST out . message = \"None value not allowed\" try : feat = db [ \"features\" ][ uid ] feat . update ( properties ) feat [ \"geometry\" ] . update ( geometry ) db [ \"features\" ][ uid ] = None db [ \"features\" ][ uid ] = feat out . data = db [ \"features\" ][ uid ] except KeyError as e : out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature ' { uid } ' not foud.\" response = out . format ( response = response , request = request ) return @hug . delete ( \"/ {uid} \" ) def del_feature ( uid , request = None , response = None ): \"\"\" **Cancellazione delle Features** Se la feature viene cancellata correttamente ne restituisce la struttura Possibili risposte: - _404 Not Found_: Nel caso in cui il prototipo richiesto non esista. - _202 Accepted_: Nel caso in cui la feature venga eliminata correttamente. \"\"\" out = ResponseFormatter ( falcon . HTTP_ACCEPTED ) if uid is None : out . status = falcon . HTTP_BAD_REQUEST out . message = \"None value not allowed\" try : out . data = db [ \"features\" ][ uid ] db [ \"features\" ][ uid ] = None except KeyError as e : out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature ' { uid } ' not foud.\" response = out . format ( response = response , request = request ) return","title":"Module hielen2.api.features"},{"location":"reference/hielen2/api/features/#variables","text":"db","title":"Variables"},{"location":"reference/hielen2/api/features/#functions","text":"","title":"Functions"},{"location":"reference/hielen2/api/features/#create_feature","text":"def create_feature ( uid , prototype , properties : < hielen2 . utils . JsonValidable object at 0x7f8574be43d0 > = {}, geometry : < hielen2 . utils . JsonValidable object at 0x7f8574be45b0 > = {}, request = None , response = None ) Creazione delle Features. Ogni feature deve avere il suo codice univoco uid e il suo prototipo prototype . Questi due campi sono immutabli (vedi PUT /feature/{uid} ). Il prototipo della feature forisce informazioni per l'inizializazione della struttura. Il parametro geometry deve essere un GeoJson Se la feature viene creata correttamente ne restituisce la struttura Possibili risposte: 409 Conflict : Nel caso in cui il uid fornito esista gi\u00e0. 404 Not Found : Nel caso in cui il prototipo richiesto non esista. 201 Created : Nel caso in cui la feature venga creata correttamente. View Source @hug . post ( \"/\" ) def create_feature ( uid , prototype , properties : JsonValidable ( FeaturePropertiesSchema ()) = {} , geometry : JsonValidable ( GeoJSONSchema ()) = {} , request = None , response = None , ) : \"\"\" **Creazione delle Features.** Ogni feature deve avere il suo codice univoco `uid` e il suo prototipo `prototype`. Questi due \\ campi sono immutabli (vedi PUT `/feature/{uid}`). Il prototipo della feature forisce informazioni per l'inizializazione della struttura. Il parametro `geometry` deve essere un GeoJson Se la feature viene creata correttamente ne restituisce la struttura Possibili risposte: - _409 Conflict_: Nel caso in cui il uid fornito esista gi\u00e0. - _404 Not Found_: Nel caso in cui il prototipo richiesto non esista. - _201 Created_: Nel caso in cui la feature venga creata correttamente. \"\"\" out = ResponseFormatter ( status = falcon . HTTP_CREATED ) try : feature = db [ \"features_proto\" ][ prototype ][ 'struct' ] #TODO CREARE SERIES feature [ 'parameters' ]= { k : None for k in feature [ 'parameters' ] . keys () } ## feature [ \"geometry\" ]= geometry feature [ \"uid\" ] = uid try : assert properties [ \"context\" ] is not None except Exception : properties [ \"context\" ] = \"no-context\" feature . update ( properties ) db [ \"features\" ][ uid ] = feature out . data = db [ \"features\" ][ uid ] except KeyError as e : out . message = f \"prototype '{prototype}' not found.\" out . status = falcon . HTTP_NOT_FOUND except ValueError as e : out . message = f \"feature '{feature['uid']}' exists\" out . status = falcon . HTTP_CONFLICT response = out . format ( response = response , request = request ) return","title":"create_feature"},{"location":"reference/hielen2/api/features/#del_feature","text":"def del_feature ( uid , request = None , response = None ) Cancellazione delle Features Se la feature viene cancellata correttamente ne restituisce la struttura Possibili risposte: 404 Not Found : Nel caso in cui il prototipo richiesto non esista. 202 Accepted : Nel caso in cui la feature venga eliminata correttamente. View Source @hug . delete ( \"/{uid}\" ) def del_feature ( uid , request = None , response = None ) : \"\"\" **Cancellazione delle Features** Se la feature viene cancellata correttamente ne restituisce la struttura Possibili risposte: - _404 Not Found_: Nel caso in cui il prototipo richiesto non esista. - _202 Accepted_: Nel caso in cui la feature venga eliminata correttamente. \"\"\" out = ResponseFormatter ( falcon . HTTP_ACCEPTED ) if uid is None : out . status = falcon . HTTP_BAD_REQUEST out . message = \"None value not allowed\" try : out . data = db [ \"features\" ][ uid ] db [ \"features\" ][ uid ] = None except KeyError as e : out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature '{uid}' not foud.\" response = out . format ( response = response , request = request ) return","title":"del_feature"},{"location":"reference/hielen2/api/features/#feature_info","text":"def feature_info ( uid , cntxt = None , request = None , response = None ) Alias di recupero informazioni della specifica feature View Source @hug . get ( \"/{uid}\" ) def feature_info ( uid , cntxt = None , request = None , response = None ) : \"\"\" **Alias di recupero informazioni della specifica feature**\"\"\" return features_info ( uid , cntxt , request , response )","title":"feature_info"},{"location":"reference/hielen2/api/features/#features_info","text":"def features_info ( uids = None , cntxt = None , request = None , response = None ) Recupero delle informazioni delle features. nota : uids accetta valori multipli separati da virgola viene restituito una struttura di questo tipo: { \"features\": [ { \"type\": \"Feature\", \"properties\": { ... }, \"geometry\": <GeoJson Validable> }, ... ] } nota : Al contrario di quanto detto nel TODO non viene inserito il context a livello \"features\" perch\u00e8 in effetti \u00e8 una informazione sempre conosciuta a priori (se si lavora per commesse). Al contrario se si lavora per uids allora ha senso inserie questa info all' interno delle properties delle singole features. Possibili risposte: 404 Not Found : Nel caso in cui nessuna feature risponda ai criteri View Source @hug . get ( \"/\" ) def features_info ( uids = None , cntxt = None , request = None , response = None ) : \"\"\" **Recupero delle informazioni delle features.** __nota__: uids accetta valori multipli separati da virgola viene restituito una struttura di questo tipo: { \" features \": [ { \" type \": \" Feature \", \" properties \": { ... }, \" geometry \": <GeoJson Validable> }, ... ] } ___nota___: Al contrario di quanto detto nel TODO non viene inserito il context a livello \\ \" features \" perch\u00e8 in effetti \u00e8 una informazione sempre conosciuta a priori (se si lavora \\ per commesse). Al contrario se si lavora per uids allora ha senso inserie questa info all' \\ interno delle properties delle singole features. Possibili risposte: - _404 Not Found_: Nel caso in cui nessuna feature risponda ai criteri \"\"\" out = ResponseFormatter () try : out . data = [] extract = db [ \"features\" ][ uids ] if not isinstance ( extract , list ) : extract =[ extract ] for v in extract : if cntxt is None or v [ \"context\" ] == cntxt : out . data . append ( { \"type\" : \"Feature\" , \"geometry\" : v . pop ( \"geometry\" ), \"parameters\" : v . pop ( \"parameters\" ), \"properties\" : v } ) except KeyError as e : out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) return","title":"features_info"},{"location":"reference/hielen2/api/features/#update_feature","text":"def update_feature ( uid , properties : < hielen2 . utils . JsonValidable object at 0x7f8574be4760 > = {}, geometry : < hielen2 . utils . JsonValidable object at 0x7f8574be4b50 > = {}, request = None , response = None ) Modifica delle properties di una feature Possibili risposte: 404 Not Found : Nel caso in cui il prototipo richiesto non esista. 202 Accepted : Nel caso in cui la feature venga modificata correttamente. View Source @hug . put ( \"/{uid}\" ) def update_feature ( uid , properties : JsonValidable ( FeaturePropertiesSchema ()) = {} , geometry : JsonValidable ( GeoJSONSchema ()) = {} , request = None , response = None , ) : \"\"\" **Modifica delle properties di una feature** Possibili risposte: - _404 Not Found_: Nel caso in cui il prototipo richiesto non esista. - _202 Accepted_: Nel caso in cui la feature venga modificata correttamente. \"\"\" out = ResponseFormatter ( status = falcon . HTTP_ACCEPTED ) if uid is None : out . status = falcon . HTTP_BAD_REQUEST out . message = \"None value not allowed\" try : feat = db [ \"features\" ][ uid ] feat . update ( properties ) feat [ \"geometry\" ] . update ( geometry ) db [ \"features\" ][ uid ] = None db [ \"features\" ][ uid ] = feat out . data = db [ \"features\" ][ uid ] except KeyError as e : out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature '{uid}' not foud.\" response = out . format ( response = response , request = request ) return","title":"update_feature"},{"location":"reference/hielen2/api/features/#classes","text":"","title":"Classes"},{"location":"reference/hielen2/api/features/#featurepropertiesschema","text":"class FeaturePropertiesSchema ( * , only : Union [ Sequence [ str ], Set [ str ], NoneType ] = None , exclude : Union [ Sequence [ str ], Set [ str ]] = (), many : bool = False , context : Union [ Dict , NoneType ] = None , load_only : Union [ Sequence [ str ], Set [ str ]] = (), dump_only : Union [ Sequence [ str ], Set [ str ]] = (), partial : Union [ bool , Sequence [ str ], Set [ str ]] = False , unknown : Union [ str , NoneType ] = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'} :param only: Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. :param exclude: Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. :param many: Should be set to True if obj is a collection so that the object will be serialized to a list. :param context: Optional context passed to :class: fields.Method and :class: fields.Function fields. :param load_only: Fields to skip during serialization (write-only fields) :param dump_only: Fields to skip during deserialization (read-only fields) :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. View Source class FeaturePropertiesSchema ( Schema ): context = fields . Str ( default = \"no-context\" , allow_none = False ) label = fields . Str ( default = None ) description = fields . Str ( default = None ) location = fields . Str ( default = None ) style = fields . Str ( default = None ) status = fields . Str ( default = None ) timestamp = fields . Str ( default = None )","title":"FeaturePropertiesSchema"},{"location":"reference/hielen2/api/features/#ancestors-in-mro","text":"marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen2/api/features/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING context description error_messages label location opts status style timestamp","title":"Class variables"},{"location":"reference/hielen2/api/features/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen2/api/features/#from_dict","text":"def from_dict ( fields : Dict [ str , Union [ marshmallow . fields . Field , type ]], * , name : str = 'GeneratedSchema' ) -> type Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 View Source @classmethod def from_dict ( cls , fields : typing . Dict [ str , typing . Union [ ma_fields . Field , type ]], * , name : str = \"GeneratedSchema\" ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen2/api/features/#instance-variables","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen2/api/features/#methods","text":"","title":"Methods"},{"location":"reference/hielen2/api/features/#dump","text":"def dump ( self , obj : Any , * , many : Union [ bool , NoneType ] = None ) Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : typing . Optional [ bool ] = None ): \"\"\"Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\"\" many = self . many if many is None else bool ( many ) if many and is_iterable_but_not_string ( obj ): obj = list ( obj ) if self . _has_processors ( PRE_DUMP ): processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ): result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen2/api/features/#dumps","text":"def dumps ( self , obj : Any , * args , many : Union [ bool , NoneType ] = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A json string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : typing . Optional [ bool ] = None , ** kwargs ): \"\"\"Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\"\" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen2/api/features/#get_attribute","text":"def get_attribute ( self , obj : Any , attr : str , default : Any ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ): \"\"\"Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\"\" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen2/api/features/#handle_error","text":"def handle_error ( self , error : marshmallow . exceptions . ValidationError , data : Any , * , many : bool , ** kwargs ) Custom error handler function for the schema. :param error: The ValidationError raised during (de)serialization. :param data: The original input data. :param many: Value of many on dump or load. :param partial: Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ): \"\"\"Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\"\" pass","title":"handle_error"},{"location":"reference/hielen2/api/features/#load","text":"def load ( self , data : Union [ Mapping [ str , Any ], Iterable [ Mapping [ str , Any ]]], * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None ) Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : typing . Union [ typing . Mapping [ str , typing . Any ], typing . Iterable [ typing . Mapping [ str , typing . Any ]], ], * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None ): \"\"\"Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen2/api/features/#loads","text":"def loads ( self , json_data : str , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize obj as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None , ** kwargs ): \"\"\"Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen2/api/features/#on_bind_field","text":"def on_bind_field ( self , field_name : str , field_obj : marshmallow . fields . Field ) -> None Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \"\"\"Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\"\" return None","title":"on_bind_field"},{"location":"reference/hielen2/api/features/#validate","text":"def validate ( self , data : Mapping , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None ) -> Dict [ str , List [ str ]] Validate data against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : typing . Mapping , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None ) -> typing . Dict [ str , typing . List [ str ]]: \"\"\"Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\"\" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]], exc . messages ) return {}","title":"validate"},{"location":"reference/hielen2/api/glob/","text":"Module hielen2.api.glob View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #!/usr/bin/env python # coding=utf-8 import hug from . import parameters , prototypes , data , features , actions , actionschemata import falcon \"\"\" @hug.not_found() def not_found(): return {'error': { 'status': falcon.status.HTTP_NOT_FOUND, 'description': 'URL is invalid.', }} api = hug.get(on_invalid=hug.redirect.not_found) \"\"\" @hug . extend_api ( \"/parameters\" ) def elemman (): \"\"\" parameters manager \"\"\" return [ parameters ] @hug . extend_api ( \"/prototypes\" ) def protoman (): \"\"\" Prototypes manager \"\"\" return [ prototypes ] @hug . extend_api ( \"/data\" ) def dataman (): \"\"\" Series manager \"\"\" return [ data ] @hug . extend_api ( \"/features\" ) def dataman (): \"\"\" Series manager \"\"\" return [ features ] @hug . extend_api ( \"/actions\" ) def dataman (): \"\"\" Series manager \"\"\" return [ actions ] @hug . extend_api ( \"/actionschemata\" ) def dataman (): \"\"\" Series manager \"\"\" return [ actionschemata ] Functions dataman def dataman ( ) Series manager View Source @hug . extend_api ( \"/actionschemata\" ) def dataman () : \"\"\" Series manager \"\"\" return [ actionschemata ] elemman def elemman ( ) parameters manager View Source @hug . extend_api ( \"/parameters\" ) def elemman () : \"\"\" parameters manager \"\"\" return [ parameters ] protoman def protoman ( ) Prototypes manager View Source @hug . extend_api ( \"/prototypes\" ) def protoman () : \"\"\" Prototypes manager \"\"\" return [ prototypes ]","title":"Glob"},{"location":"reference/hielen2/api/glob/#module-hielen2apiglob","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #!/usr/bin/env python # coding=utf-8 import hug from . import parameters , prototypes , data , features , actions , actionschemata import falcon \"\"\" @hug.not_found() def not_found(): return {'error': { 'status': falcon.status.HTTP_NOT_FOUND, 'description': 'URL is invalid.', }} api = hug.get(on_invalid=hug.redirect.not_found) \"\"\" @hug . extend_api ( \"/parameters\" ) def elemman (): \"\"\" parameters manager \"\"\" return [ parameters ] @hug . extend_api ( \"/prototypes\" ) def protoman (): \"\"\" Prototypes manager \"\"\" return [ prototypes ] @hug . extend_api ( \"/data\" ) def dataman (): \"\"\" Series manager \"\"\" return [ data ] @hug . extend_api ( \"/features\" ) def dataman (): \"\"\" Series manager \"\"\" return [ features ] @hug . extend_api ( \"/actions\" ) def dataman (): \"\"\" Series manager \"\"\" return [ actions ] @hug . extend_api ( \"/actionschemata\" ) def dataman (): \"\"\" Series manager \"\"\" return [ actionschemata ]","title":"Module hielen2.api.glob"},{"location":"reference/hielen2/api/glob/#functions","text":"","title":"Functions"},{"location":"reference/hielen2/api/glob/#dataman","text":"def dataman ( ) Series manager View Source @hug . extend_api ( \"/actionschemata\" ) def dataman () : \"\"\" Series manager \"\"\" return [ actionschemata ]","title":"dataman"},{"location":"reference/hielen2/api/glob/#elemman","text":"def elemman ( ) parameters manager View Source @hug . extend_api ( \"/parameters\" ) def elemman () : \"\"\" parameters manager \"\"\" return [ parameters ]","title":"elemman"},{"location":"reference/hielen2/api/glob/#protoman","text":"def protoman ( ) Prototypes manager View Source @hug . extend_api ( \"/prototypes\" ) def protoman () : \"\"\" Prototypes manager \"\"\" return [ prototypes ]","title":"protoman"},{"location":"reference/hielen2/api/parameters/","text":"Module hielen2.api.parameters View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 #!/usr/bin/env python # coding=utf-8 import hug import falcon from hielen2 import db from hielen2.utils import JsonValidable from marshmallow import Schema , fields from himada.api import ResponseFormatter @hug . get ( \"/\" , examples = \"\" ) def features_params ( cntxt = None , uids = None , params = None , request = None , response = None ): \"\"\" **Ricerca dei parametri associati alle features**. __nota__: uid accetta valori multipli separati da virgola viene restituita una struttura di questo tipo: { \"<fetUID>\":[ { \"series\":\"<series_UID>\", \"param\":\"<param_name>\", \"um\":\"<mearurement_unit>\" } ... ] ... } Possibili risposte: - _404 Not Found_: Nel caso in cui nessun parametro risponda ai criteri \"\"\" def _format ( param , series ): if series is None : return None parameters = [] try : parameters . append ({ \"series\" : series , \"name\" : param , \"unit\" : db [ \"series\" ][ series ][ \"mu\" ], }) except AttributeError as e : pass except TypeError as e : pass return parameters out = ResponseFormatter () try : if not isinstance ( params , ( list , set )) and params is not None : params = [ params ] feats = db [ \"features\" ][ uids ] if not isinstance ( feats , list ): feats = [ feats ] out . data = {} for f in feats : if cntxt is None or f [ \"context\" ] == cntxt : parameters = [] try : for p , s in f [ 'parameters' ] . items (): if s is not None and ( params is None or p in params ): parameters . append ({ \"series\" : s , \"param\" : p , \"unit\" : db [ \"series\" ][ s ][ \"mu\" ]}) except AttributeError : pass out . data [ f [ 'uid' ]] = parameters except KeyError as e : out . status = falcon . HTTP_OK out . message = str ( e ) response = out . format ( response = response , request = request ) return @hug . get ( \"/ {cntxt} \" ) def context_features_params ( cntxt = None , uids = None , params = None , request = None , response = None ): \"\"\" **Alias di ricerca dei Parametri nello lo specifico contesto**\"\"\" return features_params ( cntxt , uids , params , request , response ) @hug . get ( \"/ {cntxt} / {uid} \" ) def context_feature_params ( cntxt = None , uid = None , params = None , request = None , response = None ): \"\"\" **Alias di ricerca dei Parametri della specifica Feature lo specifico contesto**\"\"\" return features_params ( cntxt , uid , params , request , response ) @hug . get ( \"/ {cntxt} / {uid} / {param} \" ) def context_feature_params ( cntxt = None , uid = None , param = None , request = None , response = None ): \"\"\" **Alias di ricerca dello specifico Parametro della specifica Feature lo specifico contesto**\"\"\" return features_params ( cntxt , uid , param , request , response ) Variables db Functions context_feature_params def context_feature_params ( cntxt = None , uid = None , param = None , request = None , response = None ) Alias di ricerca dello specifico Parametro della specifica Feature lo specifico contesto View Source @hug . get ( \"/{cntxt}/{uid}/{param}\" ) def context_feature_params ( cntxt = None , uid = None , param = None , request = None , response = None ) : \"\"\" **Alias di ricerca dello specifico Parametro della specifica Feature lo specifico contesto**\"\"\" return features_params ( cntxt , uid , param , request , response ) context_features_params def context_features_params ( cntxt = None , uids = None , params = None , request = None , response = None ) Alias di ricerca dei Parametri nello lo specifico contesto View Source @hug . get ( \"/{cntxt}\" ) def context_features_params ( cntxt = None , uids = None , params = None , request = None , response = None ) : \"\"\" **Alias di ricerca dei Parametri nello lo specifico contesto**\"\"\" return features_params ( cntxt , uids , params , request , response ) features_params def features_params ( cntxt = None , uids = None , params = None , request = None , response = None ) Ricerca dei parametri associati alle features . nota : uid accetta valori multipli separati da virgola viene restituita una struttura di questo tipo: { \"<fetUID>\":[ { \"series\":\"<series_UID>\", \"param\":\"<param_name>\", \"um\":\"<mearurement_unit>\" } ... ] ... } Possibili risposte: 404 Not Found : Nel caso in cui nessun parametro risponda ai criteri View Source @hug . get ( \"/\" , examples = \"\" ) def features_params ( cntxt = None , uids = None , params = None , request = None , response = None ) : \"\"\" **Ricerca dei parametri associati alle features**. __nota__: uid accetta valori multipli separati da virgola viene restituita una struttura di questo tipo: { \" < fetUID > \":[ { \" series \":\" < series_UID > \", \" param \":\" < param_name > \", \" um \":\" < mearurement_unit > \" } ... ] ... } Possibili risposte: - _404 Not Found_: Nel caso in cui nessun parametro risponda ai criteri \"\"\" def _format ( param , series ) : if series is None : return None parameters = [] try : parameters . append ( { \"series\" : series , \"name\" : param , \"unit\" : db [ \"series\" ][ series ][ \"mu\" ] , } ) except AttributeError as e : pass except TypeError as e : pass return parameters out = ResponseFormatter () try : if not isinstance ( params , ( list , set )) and params is not None : params = [ params ] feats = db [ \"features\" ][ uids ] if not isinstance ( feats , list ) : feats =[ feats ] out . data = {} for f in feats : if cntxt is None or f [ \"context\" ] == cntxt : parameters = [] try : for p , s in f [ 'parameters' ] . items () : if s is not None and ( params is None or p in params ) : parameters . append ( { \"series\" : s , \"param\" : p , \"unit\" : db [ \"series\" ][ s ][ \"mu\" ] } ) except AttributeError : pass out . data [ f['uid' ] ] = parameters except KeyError as e : out . status = falcon . HTTP_OK out . message = str ( e ) response = out . format ( response = response , request = request ) return","title":"Parameters"},{"location":"reference/hielen2/api/parameters/#module-hielen2apiparameters","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 #!/usr/bin/env python # coding=utf-8 import hug import falcon from hielen2 import db from hielen2.utils import JsonValidable from marshmallow import Schema , fields from himada.api import ResponseFormatter @hug . get ( \"/\" , examples = \"\" ) def features_params ( cntxt = None , uids = None , params = None , request = None , response = None ): \"\"\" **Ricerca dei parametri associati alle features**. __nota__: uid accetta valori multipli separati da virgola viene restituita una struttura di questo tipo: { \"<fetUID>\":[ { \"series\":\"<series_UID>\", \"param\":\"<param_name>\", \"um\":\"<mearurement_unit>\" } ... ] ... } Possibili risposte: - _404 Not Found_: Nel caso in cui nessun parametro risponda ai criteri \"\"\" def _format ( param , series ): if series is None : return None parameters = [] try : parameters . append ({ \"series\" : series , \"name\" : param , \"unit\" : db [ \"series\" ][ series ][ \"mu\" ], }) except AttributeError as e : pass except TypeError as e : pass return parameters out = ResponseFormatter () try : if not isinstance ( params , ( list , set )) and params is not None : params = [ params ] feats = db [ \"features\" ][ uids ] if not isinstance ( feats , list ): feats = [ feats ] out . data = {} for f in feats : if cntxt is None or f [ \"context\" ] == cntxt : parameters = [] try : for p , s in f [ 'parameters' ] . items (): if s is not None and ( params is None or p in params ): parameters . append ({ \"series\" : s , \"param\" : p , \"unit\" : db [ \"series\" ][ s ][ \"mu\" ]}) except AttributeError : pass out . data [ f [ 'uid' ]] = parameters except KeyError as e : out . status = falcon . HTTP_OK out . message = str ( e ) response = out . format ( response = response , request = request ) return @hug . get ( \"/ {cntxt} \" ) def context_features_params ( cntxt = None , uids = None , params = None , request = None , response = None ): \"\"\" **Alias di ricerca dei Parametri nello lo specifico contesto**\"\"\" return features_params ( cntxt , uids , params , request , response ) @hug . get ( \"/ {cntxt} / {uid} \" ) def context_feature_params ( cntxt = None , uid = None , params = None , request = None , response = None ): \"\"\" **Alias di ricerca dei Parametri della specifica Feature lo specifico contesto**\"\"\" return features_params ( cntxt , uid , params , request , response ) @hug . get ( \"/ {cntxt} / {uid} / {param} \" ) def context_feature_params ( cntxt = None , uid = None , param = None , request = None , response = None ): \"\"\" **Alias di ricerca dello specifico Parametro della specifica Feature lo specifico contesto**\"\"\" return features_params ( cntxt , uid , param , request , response )","title":"Module hielen2.api.parameters"},{"location":"reference/hielen2/api/parameters/#variables","text":"db","title":"Variables"},{"location":"reference/hielen2/api/parameters/#functions","text":"","title":"Functions"},{"location":"reference/hielen2/api/parameters/#context_feature_params","text":"def context_feature_params ( cntxt = None , uid = None , param = None , request = None , response = None ) Alias di ricerca dello specifico Parametro della specifica Feature lo specifico contesto View Source @hug . get ( \"/{cntxt}/{uid}/{param}\" ) def context_feature_params ( cntxt = None , uid = None , param = None , request = None , response = None ) : \"\"\" **Alias di ricerca dello specifico Parametro della specifica Feature lo specifico contesto**\"\"\" return features_params ( cntxt , uid , param , request , response )","title":"context_feature_params"},{"location":"reference/hielen2/api/parameters/#context_features_params","text":"def context_features_params ( cntxt = None , uids = None , params = None , request = None , response = None ) Alias di ricerca dei Parametri nello lo specifico contesto View Source @hug . get ( \"/{cntxt}\" ) def context_features_params ( cntxt = None , uids = None , params = None , request = None , response = None ) : \"\"\" **Alias di ricerca dei Parametri nello lo specifico contesto**\"\"\" return features_params ( cntxt , uids , params , request , response )","title":"context_features_params"},{"location":"reference/hielen2/api/parameters/#features_params","text":"def features_params ( cntxt = None , uids = None , params = None , request = None , response = None ) Ricerca dei parametri associati alle features . nota : uid accetta valori multipli separati da virgola viene restituita una struttura di questo tipo: { \"<fetUID>\":[ { \"series\":\"<series_UID>\", \"param\":\"<param_name>\", \"um\":\"<mearurement_unit>\" } ... ] ... } Possibili risposte: 404 Not Found : Nel caso in cui nessun parametro risponda ai criteri View Source @hug . get ( \"/\" , examples = \"\" ) def features_params ( cntxt = None , uids = None , params = None , request = None , response = None ) : \"\"\" **Ricerca dei parametri associati alle features**. __nota__: uid accetta valori multipli separati da virgola viene restituita una struttura di questo tipo: { \" < fetUID > \":[ { \" series \":\" < series_UID > \", \" param \":\" < param_name > \", \" um \":\" < mearurement_unit > \" } ... ] ... } Possibili risposte: - _404 Not Found_: Nel caso in cui nessun parametro risponda ai criteri \"\"\" def _format ( param , series ) : if series is None : return None parameters = [] try : parameters . append ( { \"series\" : series , \"name\" : param , \"unit\" : db [ \"series\" ][ series ][ \"mu\" ] , } ) except AttributeError as e : pass except TypeError as e : pass return parameters out = ResponseFormatter () try : if not isinstance ( params , ( list , set )) and params is not None : params = [ params ] feats = db [ \"features\" ][ uids ] if not isinstance ( feats , list ) : feats =[ feats ] out . data = {} for f in feats : if cntxt is None or f [ \"context\" ] == cntxt : parameters = [] try : for p , s in f [ 'parameters' ] . items () : if s is not None and ( params is None or p in params ) : parameters . append ( { \"series\" : s , \"param\" : p , \"unit\" : db [ \"series\" ][ s ][ \"mu\" ] } ) except AttributeError : pass out . data [ f['uid' ] ] = parameters except KeyError as e : out . status = falcon . HTTP_OK out . message = str ( e ) response = out . format ( response = response , request = request ) return","title":"features_params"},{"location":"reference/hielen2/api/prototypes/","text":"Module hielen2.api.prototypes View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 #!/usr/bin/env python # coding=utf-8 import hug import falcon from hielen2 import db from himada.api import ResponseFormatter @hug . post ( \"/\" ) def new_protptype ( prototype , request = None , response = None ): \"\"\" ** Definizione di nuovi prototipi ** _PLACEHOLDER: Non ancora implementato_ \"\"\" return \"not yet implemented\" @hug . get ( \"/\" ) def prototypes ( request = None , response = None ): \"\"\" **Recupero di tutte le informazioni dei prototipi** ritorna una struttura json di questo tipo: { \"NomePrototipo1\": { \"forms\": { \"form1\": { \"args\": { \"arg1.1\": \"type_arg1.1\", \"arg1.2\": \"type_arg1.2\", ... }, \"mandatory\": [ args keys sublist ] }, \"form2\": { \"args\": { \"arg2.1\": \"type_arg2.1\", \"arg2.2\": \"type_arg2.2\", ... }, }, ... }, \"module\": subclass of hielen2.datalink.HilenSource, \"struct\": { \"parameters\": { \"param1\": { \"operands\": { \"output\": \"parameter1 name\" }, \"type\": \"series type\" }, \"param2\": { \"operands\": { \"output\": \"parameter2 name\" }, \"type\": \"series type\" }, ... }, \"properties\": { \"classification\": feature classification, \"type\": feature type } } }, \"NomePrototipo3\": { ... }, ... }, \"\"\" out = ResponseFormatter () try : out . data = db [ \"features_proto\" ][ None ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) @hug . get ( \"/ {prototype} \" ) def protptype ( prototype , request = None , response = None ): \"\"\" **Alias per il recupero di tutte le informazioni di uno specifico prototipo** \"\"\" out = ResponseFormatter () try : out . data = db [ \"features_proto\" ][ prototype ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) @hug . get ( \"/ {prototype} /forms\" ) def prototype_forms ( prototype , request = None , response = None ): \"\"\" **Alias per il recupero di tutte le informazioni delle form di uno specifico prototipo** \"\"\" out = ResponseFormatter () try : out . data = db [ \"features_proto\" ][ prototype ][ \"forms\" ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) @hug . get ( \"/ {prototype} /forms/ {form} \" ) def prototype_form ( prototype , form , request = None , response = None ): \"\"\" **Alias per il recupero di tutte le informazioni di una specifica form di uno specifico prototipo** \"\"\" out = ResponseFormatter () try : out . data = db [ \"features_proto\" ][ prototype ][ \"forms\" ][ form ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) @hug . get ( \"/ {prototype} /struct\" ) def prototype_struct ( prototype , request = None , response = None ): \"\"\" **Alias per il recupero delle info di inizializzazione delle features legate ad uno specifico \\ prototipo** \"\"\" out = ResponseFormatter () try : out . data = db [ \"features_proto\" ][ prototype ][ \"struct\" ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) Variables db Functions new_protptype def new_protptype ( prototype , request = None , response = None ) Definizione di nuovi prototipi PLACEHOLDER: Non ancora implementato View Source @hug . post ( \"/\" ) def new_protptype ( prototype , request = None , response = None ) : \"\"\" ** Definizione di nuovi prototipi ** _PLACEHOLDER: Non ancora implementato_ \"\"\" return \"not yet implemented\" prototype_form def prototype_form ( prototype , form , request = None , response = None ) Alias per il recupero di tutte le informazioni di una specifica form di uno specifico prototipo View Source @hug . get ( \"/{prototype}/forms/{form}\" ) def prototype_form ( prototype , form , request = None , response = None ) : \"\"\" **Alias per il recupero di tutte le informazioni di una specifica form di uno specifico prototipo** \"\"\" out = ResponseFormatter () try : out . data = db [ \"features_proto\" ][ prototype ][ \"forms\" ][ form ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) prototype_forms def prototype_forms ( prototype , request = None , response = None ) Alias per il recupero di tutte le informazioni delle form di uno specifico prototipo View Source @hug . get ( \"/{prototype}/forms\" ) def prototype_forms ( prototype , request = None , response = None ) : \"\"\" **Alias per il recupero di tutte le informazioni delle form di uno specifico prototipo** \"\"\" out = ResponseFormatter () try : out . data = db [ \"features_proto\" ][ prototype ][ \"forms\" ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) prototype_struct def prototype_struct ( prototype , request = None , response = None ) Alias per il recupero delle info di inizializzazione delle features legate ad uno specifico prototipo View Source @hug . get ( \"/{prototype}/struct\" ) def prototype_struct ( prototype , request = None , response = None ) : \"\"\" **Alias per il recupero delle info di inizializzazione delle features legate ad uno specifico \\ prototipo** \"\"\" out = ResponseFormatter () try : out . data = db [ \"features_proto\" ][ prototype ][ \"struct\" ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) prototypes def prototypes ( request = None , response = None ) Recupero di tutte le informazioni dei prototipi ritorna una struttura json di questo tipo: { \"NomePrototipo1\": { \"forms\": { \"form1\": { \"args\": { \"arg1.1\": \"type_arg1.1\", \"arg1.2\": \"type_arg1.2\", ... }, \"mandatory\": [ args keys sublist ] }, \"form2\": { \"args\": { \"arg2.1\": \"type_arg2.1\", \"arg2.2\": \"type_arg2.2\", ... }, }, ... }, \"module\": subclass of hielen2.datalink.HilenSource, \"struct\": { \"parameters\": { \"param1\": { \"operands\": { \"output\": \"parameter1 name\" }, \"type\": \"series type\" }, \"param2\": { \"operands\": { \"output\": \"parameter2 name\" }, \"type\": \"series type\" }, ... }, \"properties\": { \"classification\": feature classification, \"type\": feature type } } }, \"NomePrototipo3\": { ... }, ... }, View Source @hug . get ( \"/\" ) def prototypes ( request = None , response = None ) : \"\"\" **Recupero di tutte le informazioni dei prototipi** ritorna una struttura json di questo tipo: { \" NomePrototipo1 \": { \" forms \": { \" form1 \": { \" args \": { \" arg1 .1 \": \" type_arg1 .1 \", \" arg1 .2 \": \" type_arg1 .2 \", ... }, \" mandatory \": [ args keys sublist ] }, \" form2 \": { \" args \": { \" arg2 .1 \": \" type_arg2 .1 \", \" arg2 .2 \": \" type_arg2 .2 \", ... }, }, ... }, \" module \": subclass of hielen2.datalink.HilenSource, \" struct \": { \" parameters \": { \" param1 \": { \" operands \": { \" output \": \" parameter1 name \" }, \" type \": \" series type \" }, \" param2 \": { \" operands \": { \" output \": \" parameter2 name \" }, \" type \": \" series type \" }, ... }, \" properties \": { \" classification \": feature classification, \" type \": feature type } } }, \" NomePrototipo3 \": { ... }, ... }, \"\"\" out = ResponseFormatter () try : out . data = db [ \"features_proto\" ][ None ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) protptype def protptype ( prototype , request = None , response = None ) Alias per il recupero di tutte le informazioni di uno specifico prototipo View Source @hug . get ( \"/{prototype}\" ) def protptype ( prototype , request = None , response = None ) : \"\"\" **Alias per il recupero di tutte le informazioni di uno specifico prototipo** \"\"\" out = ResponseFormatter () try : out . data = db [ \"features_proto\" ][ prototype ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request )","title":"Prototypes"},{"location":"reference/hielen2/api/prototypes/#module-hielen2apiprototypes","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 #!/usr/bin/env python # coding=utf-8 import hug import falcon from hielen2 import db from himada.api import ResponseFormatter @hug . post ( \"/\" ) def new_protptype ( prototype , request = None , response = None ): \"\"\" ** Definizione di nuovi prototipi ** _PLACEHOLDER: Non ancora implementato_ \"\"\" return \"not yet implemented\" @hug . get ( \"/\" ) def prototypes ( request = None , response = None ): \"\"\" **Recupero di tutte le informazioni dei prototipi** ritorna una struttura json di questo tipo: { \"NomePrototipo1\": { \"forms\": { \"form1\": { \"args\": { \"arg1.1\": \"type_arg1.1\", \"arg1.2\": \"type_arg1.2\", ... }, \"mandatory\": [ args keys sublist ] }, \"form2\": { \"args\": { \"arg2.1\": \"type_arg2.1\", \"arg2.2\": \"type_arg2.2\", ... }, }, ... }, \"module\": subclass of hielen2.datalink.HilenSource, \"struct\": { \"parameters\": { \"param1\": { \"operands\": { \"output\": \"parameter1 name\" }, \"type\": \"series type\" }, \"param2\": { \"operands\": { \"output\": \"parameter2 name\" }, \"type\": \"series type\" }, ... }, \"properties\": { \"classification\": feature classification, \"type\": feature type } } }, \"NomePrototipo3\": { ... }, ... }, \"\"\" out = ResponseFormatter () try : out . data = db [ \"features_proto\" ][ None ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) @hug . get ( \"/ {prototype} \" ) def protptype ( prototype , request = None , response = None ): \"\"\" **Alias per il recupero di tutte le informazioni di uno specifico prototipo** \"\"\" out = ResponseFormatter () try : out . data = db [ \"features_proto\" ][ prototype ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) @hug . get ( \"/ {prototype} /forms\" ) def prototype_forms ( prototype , request = None , response = None ): \"\"\" **Alias per il recupero di tutte le informazioni delle form di uno specifico prototipo** \"\"\" out = ResponseFormatter () try : out . data = db [ \"features_proto\" ][ prototype ][ \"forms\" ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) @hug . get ( \"/ {prototype} /forms/ {form} \" ) def prototype_form ( prototype , form , request = None , response = None ): \"\"\" **Alias per il recupero di tutte le informazioni di una specifica form di uno specifico prototipo** \"\"\" out = ResponseFormatter () try : out . data = db [ \"features_proto\" ][ prototype ][ \"forms\" ][ form ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) @hug . get ( \"/ {prototype} /struct\" ) def prototype_struct ( prototype , request = None , response = None ): \"\"\" **Alias per il recupero delle info di inizializzazione delle features legate ad uno specifico \\ prototipo** \"\"\" out = ResponseFormatter () try : out . data = db [ \"features_proto\" ][ prototype ][ \"struct\" ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request )","title":"Module hielen2.api.prototypes"},{"location":"reference/hielen2/api/prototypes/#variables","text":"db","title":"Variables"},{"location":"reference/hielen2/api/prototypes/#functions","text":"","title":"Functions"},{"location":"reference/hielen2/api/prototypes/#new_protptype","text":"def new_protptype ( prototype , request = None , response = None ) Definizione di nuovi prototipi PLACEHOLDER: Non ancora implementato View Source @hug . post ( \"/\" ) def new_protptype ( prototype , request = None , response = None ) : \"\"\" ** Definizione di nuovi prototipi ** _PLACEHOLDER: Non ancora implementato_ \"\"\" return \"not yet implemented\"","title":"new_protptype"},{"location":"reference/hielen2/api/prototypes/#prototype_form","text":"def prototype_form ( prototype , form , request = None , response = None ) Alias per il recupero di tutte le informazioni di una specifica form di uno specifico prototipo View Source @hug . get ( \"/{prototype}/forms/{form}\" ) def prototype_form ( prototype , form , request = None , response = None ) : \"\"\" **Alias per il recupero di tutte le informazioni di una specifica form di uno specifico prototipo** \"\"\" out = ResponseFormatter () try : out . data = db [ \"features_proto\" ][ prototype ][ \"forms\" ][ form ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request )","title":"prototype_form"},{"location":"reference/hielen2/api/prototypes/#prototype_forms","text":"def prototype_forms ( prototype , request = None , response = None ) Alias per il recupero di tutte le informazioni delle form di uno specifico prototipo View Source @hug . get ( \"/{prototype}/forms\" ) def prototype_forms ( prototype , request = None , response = None ) : \"\"\" **Alias per il recupero di tutte le informazioni delle form di uno specifico prototipo** \"\"\" out = ResponseFormatter () try : out . data = db [ \"features_proto\" ][ prototype ][ \"forms\" ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request )","title":"prototype_forms"},{"location":"reference/hielen2/api/prototypes/#prototype_struct","text":"def prototype_struct ( prototype , request = None , response = None ) Alias per il recupero delle info di inizializzazione delle features legate ad uno specifico prototipo View Source @hug . get ( \"/{prototype}/struct\" ) def prototype_struct ( prototype , request = None , response = None ) : \"\"\" **Alias per il recupero delle info di inizializzazione delle features legate ad uno specifico \\ prototipo** \"\"\" out = ResponseFormatter () try : out . data = db [ \"features_proto\" ][ prototype ][ \"struct\" ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request )","title":"prototype_struct"},{"location":"reference/hielen2/api/prototypes/#prototypes","text":"def prototypes ( request = None , response = None ) Recupero di tutte le informazioni dei prototipi ritorna una struttura json di questo tipo: { \"NomePrototipo1\": { \"forms\": { \"form1\": { \"args\": { \"arg1.1\": \"type_arg1.1\", \"arg1.2\": \"type_arg1.2\", ... }, \"mandatory\": [ args keys sublist ] }, \"form2\": { \"args\": { \"arg2.1\": \"type_arg2.1\", \"arg2.2\": \"type_arg2.2\", ... }, }, ... }, \"module\": subclass of hielen2.datalink.HilenSource, \"struct\": { \"parameters\": { \"param1\": { \"operands\": { \"output\": \"parameter1 name\" }, \"type\": \"series type\" }, \"param2\": { \"operands\": { \"output\": \"parameter2 name\" }, \"type\": \"series type\" }, ... }, \"properties\": { \"classification\": feature classification, \"type\": feature type } } }, \"NomePrototipo3\": { ... }, ... }, View Source @hug . get ( \"/\" ) def prototypes ( request = None , response = None ) : \"\"\" **Recupero di tutte le informazioni dei prototipi** ritorna una struttura json di questo tipo: { \" NomePrototipo1 \": { \" forms \": { \" form1 \": { \" args \": { \" arg1 .1 \": \" type_arg1 .1 \", \" arg1 .2 \": \" type_arg1 .2 \", ... }, \" mandatory \": [ args keys sublist ] }, \" form2 \": { \" args \": { \" arg2 .1 \": \" type_arg2 .1 \", \" arg2 .2 \": \" type_arg2 .2 \", ... }, }, ... }, \" module \": subclass of hielen2.datalink.HilenSource, \" struct \": { \" parameters \": { \" param1 \": { \" operands \": { \" output \": \" parameter1 name \" }, \" type \": \" series type \" }, \" param2 \": { \" operands \": { \" output \": \" parameter2 name \" }, \" type \": \" series type \" }, ... }, \" properties \": { \" classification \": feature classification, \" type \": feature type } } }, \" NomePrototipo3 \": { ... }, ... }, \"\"\" out = ResponseFormatter () try : out . data = db [ \"features_proto\" ][ None ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request )","title":"prototypes"},{"location":"reference/hielen2/api/prototypes/#protptype","text":"def protptype ( prototype , request = None , response = None ) Alias per il recupero di tutte le informazioni di uno specifico prototipo View Source @hug . get ( \"/{prototype}\" ) def protptype ( prototype , request = None , response = None ) : \"\"\" **Alias per il recupero di tutte le informazioni di uno specifico prototipo** \"\"\" out = ResponseFormatter () try : out . data = db [ \"features_proto\" ][ prototype ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request )","title":"protptype"},{"location":"reference/hielen2/data/","text":"Module hielen2.data Sub-modules hielen2.data.calculation hielen2.data.data_access_layer","title":"Index"},{"location":"reference/hielen2/data/#module-hielen2data","text":"","title":"Module hielen2.data"},{"location":"reference/hielen2/data/#sub-modules","text":"hielen2.data.calculation hielen2.data.data_access_layer","title":"Sub-modules"},{"location":"reference/hielen2/data/calculation/","text":"Module hielen2.data.calculation View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 #!/usr/bin/env python # coding=utf-8 __name__ = \"hielen2.series.calculation\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"hub for hielen calculations\" __license__ = \"MIT\" __uri__ = \"\" from pandas import DataFrame , Series import math import numpy as np #### CUSTOM LIBRARY #### def poly_trans ( S0 , ** kwargs ): def _parse ( k , w ): k = k . replace ( \"E\" , \"\" ) return f \" { w } *S0** { k } \" operator = \"+\" . join ( _parse ( * x ) for x in kwargs . items () if x [ 0 ][ 0 ] in [ \"E\" , \"e\" ]) return eval ( operator ) def slope ( S0 , unit , radius ): if unit == \"\u00b0\" : S0 = S0 [ 0 ] . apply ( lambda x : math . sin ( math . radians ( x ))) return S0 * radius def aligned ( func ): def wrap_align ( left , right ): left = left . copy () right = right . copy () try : left . columns = list ( range ( len ( left . columns ))) except AttributeError : left . name = 0 try : right . columns = list ( range ( len ( right . columns ))) except AttributeError : right . name = 0 left , right = left . align ( right , axis = 0 , copy = False ) mask = left . notna ()[ 0 ] right = right . fillna ( method = \"pad\" ) return func ( left [ mask ], right [ mask ]) return wrap_align @aligned def add ( left , right ): right = right . fillna ( 0 ) return left + right @aligned def sub ( left , right ): right = right . fillna ( 0 ) return left - right def filter ( b ): d = abs ( b - b . rolling ( window = 50 , center = True , min_periods = 1 ) . apply ( np . mean )) std = abs ( b . rolling ( window = 50 , center = True , min_periods = 1 ) . apply ( np . std )) return b [ d < 3 * std ] def int_or_str ( value ): try : return int ( value ) except ValueError : return value VERSION = tuple ( map ( int_or_str , __version__ . split ( \".\" ))) __all__ = [ \"poly_trans\" , \"add\" , \"sub\" , \"slope\" ] Functions add def add ( left , right ) View Source def wrap_align ( left , right ) : left = left . copy () right = right . copy () try : left . columns = list ( range ( len ( left . columns ))) except AttributeError : left . name = 0 try : right . columns = list ( range ( len ( right . columns ))) except AttributeError : right . name = 0 left , right = left . align ( right , axis = 0 , copy = False ) mask = left . notna () [ 0 ] right = right . fillna ( method = \"pad\" ) return func ( left [ mask ] , right [ mask ] ) poly_trans def poly_trans ( S0 , ** kwargs ) View Source def poly_trans ( S0 , ** kwargs ): def _parse ( k , w ): k = k . replace ( \"E\" , \"\" ) return f \"{w}*S0**{k}\" operator = \"+\" . join ( _parse ( * x ) for x in kwargs . items () if x [ 0 ][ 0 ] in [ \"E\" , \"e\" ]) return eval ( operator ) slope def slope ( S0 , unit , radius ) View Source def slope ( S0 , unit , radius ): if unit == \"\u00b0\" : S0 = S0 [ 0 ]. apply ( lambda x : math . sin ( math . radians ( x ))) return S0 * radius sub def sub ( left , right ) View Source def wrap_align ( left , right ) : left = left . copy () right = right . copy () try : left . columns = list ( range ( len ( left . columns ))) except AttributeError : left . name = 0 try : right . columns = list ( range ( len ( right . columns ))) except AttributeError : right . name = 0 left , right = left . align ( right , axis = 0 , copy = False ) mask = left . notna () [ 0 ] right = right . fillna ( method = \"pad\" ) return func ( left [ mask ] , right [ mask ] )","title":"Calculation"},{"location":"reference/hielen2/data/calculation/#module-hielen2datacalculation","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 #!/usr/bin/env python # coding=utf-8 __name__ = \"hielen2.series.calculation\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"hub for hielen calculations\" __license__ = \"MIT\" __uri__ = \"\" from pandas import DataFrame , Series import math import numpy as np #### CUSTOM LIBRARY #### def poly_trans ( S0 , ** kwargs ): def _parse ( k , w ): k = k . replace ( \"E\" , \"\" ) return f \" { w } *S0** { k } \" operator = \"+\" . join ( _parse ( * x ) for x in kwargs . items () if x [ 0 ][ 0 ] in [ \"E\" , \"e\" ]) return eval ( operator ) def slope ( S0 , unit , radius ): if unit == \"\u00b0\" : S0 = S0 [ 0 ] . apply ( lambda x : math . sin ( math . radians ( x ))) return S0 * radius def aligned ( func ): def wrap_align ( left , right ): left = left . copy () right = right . copy () try : left . columns = list ( range ( len ( left . columns ))) except AttributeError : left . name = 0 try : right . columns = list ( range ( len ( right . columns ))) except AttributeError : right . name = 0 left , right = left . align ( right , axis = 0 , copy = False ) mask = left . notna ()[ 0 ] right = right . fillna ( method = \"pad\" ) return func ( left [ mask ], right [ mask ]) return wrap_align @aligned def add ( left , right ): right = right . fillna ( 0 ) return left + right @aligned def sub ( left , right ): right = right . fillna ( 0 ) return left - right def filter ( b ): d = abs ( b - b . rolling ( window = 50 , center = True , min_periods = 1 ) . apply ( np . mean )) std = abs ( b . rolling ( window = 50 , center = True , min_periods = 1 ) . apply ( np . std )) return b [ d < 3 * std ] def int_or_str ( value ): try : return int ( value ) except ValueError : return value VERSION = tuple ( map ( int_or_str , __version__ . split ( \".\" ))) __all__ = [ \"poly_trans\" , \"add\" , \"sub\" , \"slope\" ]","title":"Module hielen2.data.calculation"},{"location":"reference/hielen2/data/calculation/#functions","text":"","title":"Functions"},{"location":"reference/hielen2/data/calculation/#add","text":"def add ( left , right ) View Source def wrap_align ( left , right ) : left = left . copy () right = right . copy () try : left . columns = list ( range ( len ( left . columns ))) except AttributeError : left . name = 0 try : right . columns = list ( range ( len ( right . columns ))) except AttributeError : right . name = 0 left , right = left . align ( right , axis = 0 , copy = False ) mask = left . notna () [ 0 ] right = right . fillna ( method = \"pad\" ) return func ( left [ mask ] , right [ mask ] )","title":"add"},{"location":"reference/hielen2/data/calculation/#poly_trans","text":"def poly_trans ( S0 , ** kwargs ) View Source def poly_trans ( S0 , ** kwargs ): def _parse ( k , w ): k = k . replace ( \"E\" , \"\" ) return f \"{w}*S0**{k}\" operator = \"+\" . join ( _parse ( * x ) for x in kwargs . items () if x [ 0 ][ 0 ] in [ \"E\" , \"e\" ]) return eval ( operator )","title":"poly_trans"},{"location":"reference/hielen2/data/calculation/#slope","text":"def slope ( S0 , unit , radius ) View Source def slope ( S0 , unit , radius ): if unit == \"\u00b0\" : S0 = S0 [ 0 ]. apply ( lambda x : math . sin ( math . radians ( x ))) return S0 * radius","title":"slope"},{"location":"reference/hielen2/data/calculation/#sub","text":"def sub ( left , right ) View Source def wrap_align ( left , right ) : left = left . copy () right = right . copy () try : left . columns = list ( range ( len ( left . columns ))) except AttributeError : left . name = 0 try : right . columns = list ( range ( len ( right . columns ))) except AttributeError : right . name = 0 left , right = left . align ( right , axis = 0 , copy = False ) mask = left . notna () [ 0 ] right = right . fillna ( method = \"pad\" ) return func ( left [ mask ] , right [ mask ] )","title":"sub"},{"location":"reference/hielen2/data/data_access_layer/","text":"Module hielen2.data.data_access_layer View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 #!/usr/bin/env python # coding=utf-8 from pandas import DataFrame from time import time from concurrent.futures import ThreadPoolExecutor from functools import wraps from numpy import nan , unique from importlib import import_module from hielen2 import db from hielen2.utils import isot2ut , ut2isot def _threadpool ( f ): @wraps ( f ) def wrap ( * args , ** kwargs ): return ThreadPoolExecutor () . submit ( f , * args , ** kwargs ) return wrap class Series : def __init__ ( self , uid ): series_info = db [ \"series\" ][ uid ] self . __dict__ . update ( series_info ) geninfo = dict ( ( k , w ) for k , w in series_info . items () if k in ( \"modules\" , \"operator\" , \"operands\" ) ) self . generator = Generator ( ** geninfo ) @_threadpool def thdata ( self , timefrom = None , timeto = None , * args , ** kwargs ): return self . data ( timefrom , timeto ) def data ( self , timefrom = None , timeto = None ): if timefrom is not None : if self . first is not None : timefrom = max ( self . first , timefrom ) else : timefrom = self . first if timeto is not None : if self . last is not None : timeto = min ( self . last , timeto ) else : timeto = self . last try : out = db [ \"datacache\" ][ self . uid ] . to_frame () if timefrom is not None and out . index . max () < timefrom : out = out . tail ( 1 ) else : out = out [ timefrom : timeto ] except KeyError : out = DataFrame () timefrom2 = out . index . max () if timefrom2 is nan : timefrom2 = timefrom else : # timefrom2 = max(isot2ut(timefrom2),isot2ut(timefrom) or 1) timefrom2 = max ( isot2ut ( timefrom2 ), isot2ut ( timefrom ) or 1 ) timefrom2 = ut2isot ( timefrom2 ) gen = self . generator . _generate ( timefrom = timefrom2 , timeto = timeto ) try : gen = gen . to_frame () except AttributeError : pass gen . columns = list ( range ( gen . columns . __len__ ())) out = out . append ( gen ) . sort_index () idx = unique ( out . index . values , return_index = True )[ 1 ] out = out . iloc [ idx ] out . index . name = \"timestamp\" return out class Generator : def __init__ ( self , modules = None , operator = None , operands = None ): self . operator = operator or \"DataFrame()\" self . modules = {} if not modules is None : for k , m in modules . items (): self . operator = self . operator . replace ( k , f \"self.modules[ { k !r} ]\" ) self . modules [ k ] = import_module ( m ) self . operands = {} if operands is not None : self . operands = dict ( Generator . _parse_operand ( * op ) for op in operands . items () ) def _parse_operand ( key , value ): \"\"\" trying to extract a series \"\"\" try : return ( key , Series ( value )) except KeyError : pass \"\"\" trying to extract element attribute \"\"\" try : v = value . split ( \".\" ) assert v . __len__ () == 2 return ( key , db [ \"features\" ][ v [ 0 ]][ \"properties\" ][ v [ 1 ]]) except Exception : pass \"\"\" giving up. It should be a scalar. return it \"\"\" return ( key , value ) def _generate ( self , timefrom , timeto ): operands = dict ( timefrom = timefrom , timeto = timeto ) operands . update ( { k : w for k , w in self . operands . items () if not isinstance ( w , Series )} ) runners = { k : w . thdata ( timefrom , timeto ) for k , w in self . operands . items () if isinstance ( w , Series ) } operands . update ({ k : w . result () for k , w in runners . items ()}) # operands.update( { k:w.data(timefrom,timeto) for k,w in self.operands.items() if isinstance(w,Series) } ) # print('OPERANDI',operands) # print('OPERATORE', self.operator) return eval ( self . operator ) Variables db nan Classes Generator class Generator ( modules = None , operator = None , operands = None ) View Source class Generator : def __init__ ( self , modules = None , operator = None , operands = None ) : self . operator = operator or \"DataFrame()\" self . modules = {} if not modules is None : for k , m in modules . items () : self . operator = self . operator . replace ( k , f \"self.modules[{k!r}]\" ) self . modules [ k ] = import_module ( m ) self . operands = {} if operands is not None : self . operands = dict ( Generator . _parse_operand ( * op ) for op in operands . items () ) def _parse_operand ( key , value ) : \"\"\" trying to extract a series \"\"\" try : return ( key , Series ( value )) except KeyError : pass \"\"\" trying to extract element attribute \"\"\" try : v = value . split ( \".\" ) assert v . __len__ () == 2 return ( key , db [ \"features\" ][ v[0 ] ] [ \"properties\" ][ v[1 ] ] ) except Exception : pass \"\"\" giving up. It should be a scalar. return it \"\"\" return ( key , value ) def _generate ( self , timefrom , timeto ) : operands = dict ( timefrom = timefrom , timeto = timeto ) operands . update ( { k : w for k , w in self . operands . items () if not isinstance ( w , Series ) } ) runners = { k : w . thdata ( timefrom , timeto ) for k , w in self . operands . items () if isinstance ( w , Series ) } operands . update ( { k : w . result () for k , w in runners . items () } ) # operands . update ( { k : w . data ( timefrom , timeto ) for k , w in self . operands . items () if isinstance ( w , Series ) } ) # print ( 'OPERANDI' , operands ) # print ( 'OPERATORE' , self . operator ) return eval ( self . operator ) Series class Series ( uid ) View Source class Series : def __init__ ( self , uid ) : series_info = db [ \"series\" ][ uid ] self . __dict__ . update ( series_info ) geninfo = dict ( ( k , w ) for k , w in series_info . items () if k in ( \"modules\" , \"operator\" , \"operands\" ) ) self . generator = Generator ( ** geninfo ) @_threadpool def thdata ( self , timefrom = None , timeto = None , * args , ** kwargs ) : return self . data ( timefrom , timeto ) def data ( self , timefrom = None , timeto = None ) : if timefrom is not None : if self . first is not None : timefrom = max ( self . first , timefrom ) else : timefrom = self . first if timeto is not None : if self . last is not None : timeto = min ( self . last , timeto ) else : timeto = self . last try : out = db [ \"datacache\" ][ self.uid ] . to_frame () if timefrom is not None and out . index . max () < timefrom : out = out . tail ( 1 ) else : out = out [ timefrom:timeto ] except KeyError : out = DataFrame () timefrom2 = out . index . max () if timefrom2 is nan : timefrom2 = timefrom else : # timefrom2 = max ( isot2ut ( timefrom2 ), isot2ut ( timefrom ) or 1 ) timefrom2 = max ( isot2ut ( timefrom2 ), isot2ut ( timefrom ) or 1 ) timefrom2 = ut2isot ( timefrom2 ) gen = self . generator . _generate ( timefrom = timefrom2 , timeto = timeto ) try : gen = gen . to_frame () except AttributeError : pass gen . columns = list ( range ( gen . columns . __len__ ())) out = out . append ( gen ). sort_index () idx = unique ( out . index . values , return_index = True ) [ 1 ] out = out . iloc [ idx ] out . index . name = \"timestamp\" return out Methods data def data ( self , timefrom = None , timeto = None ) View Source def data ( self , timefrom = None , timeto = None ) : if timefrom is not None : if self . first is not None : timefrom = max ( self . first , timefrom ) else : timefrom = self . first if timeto is not None : if self . last is not None : timeto = min ( self . last , timeto ) else : timeto = self . last try : out = db [ \"datacache\" ][ self.uid ] . to_frame () if timefrom is not None and out . index . max () < timefrom : out = out . tail ( 1 ) else : out = out [ timefrom:timeto ] except KeyError : out = DataFrame () timefrom2 = out . index . max () if timefrom2 is nan : timefrom2 = timefrom else : # timefrom2 = max ( isot2ut ( timefrom2 ), isot2ut ( timefrom ) or 1 ) timefrom2 = max ( isot2ut ( timefrom2 ), isot2ut ( timefrom ) or 1 ) timefrom2 = ut2isot ( timefrom2 ) gen = self . generator . _generate ( timefrom = timefrom2 , timeto = timeto ) try : gen = gen . to_frame () except AttributeError : pass gen . columns = list ( range ( gen . columns . __len__ ())) out = out . append ( gen ). sort_index () idx = unique ( out . index . values , return_index = True ) [ 1 ] out = out . iloc [ idx ] out . index . name = \"timestamp\" return out thdata def thdata ( self , timefrom = None , timeto = None , * args , ** kwargs ) View Source @_threadpool def thdata ( self , timefrom = None , timeto = None , * args , ** kwargs ) : return self . data ( timefrom , timeto )","title":"Data Access Layer"},{"location":"reference/hielen2/data/data_access_layer/#module-hielen2datadata_access_layer","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 #!/usr/bin/env python # coding=utf-8 from pandas import DataFrame from time import time from concurrent.futures import ThreadPoolExecutor from functools import wraps from numpy import nan , unique from importlib import import_module from hielen2 import db from hielen2.utils import isot2ut , ut2isot def _threadpool ( f ): @wraps ( f ) def wrap ( * args , ** kwargs ): return ThreadPoolExecutor () . submit ( f , * args , ** kwargs ) return wrap class Series : def __init__ ( self , uid ): series_info = db [ \"series\" ][ uid ] self . __dict__ . update ( series_info ) geninfo = dict ( ( k , w ) for k , w in series_info . items () if k in ( \"modules\" , \"operator\" , \"operands\" ) ) self . generator = Generator ( ** geninfo ) @_threadpool def thdata ( self , timefrom = None , timeto = None , * args , ** kwargs ): return self . data ( timefrom , timeto ) def data ( self , timefrom = None , timeto = None ): if timefrom is not None : if self . first is not None : timefrom = max ( self . first , timefrom ) else : timefrom = self . first if timeto is not None : if self . last is not None : timeto = min ( self . last , timeto ) else : timeto = self . last try : out = db [ \"datacache\" ][ self . uid ] . to_frame () if timefrom is not None and out . index . max () < timefrom : out = out . tail ( 1 ) else : out = out [ timefrom : timeto ] except KeyError : out = DataFrame () timefrom2 = out . index . max () if timefrom2 is nan : timefrom2 = timefrom else : # timefrom2 = max(isot2ut(timefrom2),isot2ut(timefrom) or 1) timefrom2 = max ( isot2ut ( timefrom2 ), isot2ut ( timefrom ) or 1 ) timefrom2 = ut2isot ( timefrom2 ) gen = self . generator . _generate ( timefrom = timefrom2 , timeto = timeto ) try : gen = gen . to_frame () except AttributeError : pass gen . columns = list ( range ( gen . columns . __len__ ())) out = out . append ( gen ) . sort_index () idx = unique ( out . index . values , return_index = True )[ 1 ] out = out . iloc [ idx ] out . index . name = \"timestamp\" return out class Generator : def __init__ ( self , modules = None , operator = None , operands = None ): self . operator = operator or \"DataFrame()\" self . modules = {} if not modules is None : for k , m in modules . items (): self . operator = self . operator . replace ( k , f \"self.modules[ { k !r} ]\" ) self . modules [ k ] = import_module ( m ) self . operands = {} if operands is not None : self . operands = dict ( Generator . _parse_operand ( * op ) for op in operands . items () ) def _parse_operand ( key , value ): \"\"\" trying to extract a series \"\"\" try : return ( key , Series ( value )) except KeyError : pass \"\"\" trying to extract element attribute \"\"\" try : v = value . split ( \".\" ) assert v . __len__ () == 2 return ( key , db [ \"features\" ][ v [ 0 ]][ \"properties\" ][ v [ 1 ]]) except Exception : pass \"\"\" giving up. It should be a scalar. return it \"\"\" return ( key , value ) def _generate ( self , timefrom , timeto ): operands = dict ( timefrom = timefrom , timeto = timeto ) operands . update ( { k : w for k , w in self . operands . items () if not isinstance ( w , Series )} ) runners = { k : w . thdata ( timefrom , timeto ) for k , w in self . operands . items () if isinstance ( w , Series ) } operands . update ({ k : w . result () for k , w in runners . items ()}) # operands.update( { k:w.data(timefrom,timeto) for k,w in self.operands.items() if isinstance(w,Series) } ) # print('OPERANDI',operands) # print('OPERATORE', self.operator) return eval ( self . operator )","title":"Module hielen2.data.data_access_layer"},{"location":"reference/hielen2/data/data_access_layer/#variables","text":"db nan","title":"Variables"},{"location":"reference/hielen2/data/data_access_layer/#classes","text":"","title":"Classes"},{"location":"reference/hielen2/data/data_access_layer/#generator","text":"class Generator ( modules = None , operator = None , operands = None ) View Source class Generator : def __init__ ( self , modules = None , operator = None , operands = None ) : self . operator = operator or \"DataFrame()\" self . modules = {} if not modules is None : for k , m in modules . items () : self . operator = self . operator . replace ( k , f \"self.modules[{k!r}]\" ) self . modules [ k ] = import_module ( m ) self . operands = {} if operands is not None : self . operands = dict ( Generator . _parse_operand ( * op ) for op in operands . items () ) def _parse_operand ( key , value ) : \"\"\" trying to extract a series \"\"\" try : return ( key , Series ( value )) except KeyError : pass \"\"\" trying to extract element attribute \"\"\" try : v = value . split ( \".\" ) assert v . __len__ () == 2 return ( key , db [ \"features\" ][ v[0 ] ] [ \"properties\" ][ v[1 ] ] ) except Exception : pass \"\"\" giving up. It should be a scalar. return it \"\"\" return ( key , value ) def _generate ( self , timefrom , timeto ) : operands = dict ( timefrom = timefrom , timeto = timeto ) operands . update ( { k : w for k , w in self . operands . items () if not isinstance ( w , Series ) } ) runners = { k : w . thdata ( timefrom , timeto ) for k , w in self . operands . items () if isinstance ( w , Series ) } operands . update ( { k : w . result () for k , w in runners . items () } ) # operands . update ( { k : w . data ( timefrom , timeto ) for k , w in self . operands . items () if isinstance ( w , Series ) } ) # print ( 'OPERANDI' , operands ) # print ( 'OPERATORE' , self . operator ) return eval ( self . operator )","title":"Generator"},{"location":"reference/hielen2/data/data_access_layer/#series","text":"class Series ( uid ) View Source class Series : def __init__ ( self , uid ) : series_info = db [ \"series\" ][ uid ] self . __dict__ . update ( series_info ) geninfo = dict ( ( k , w ) for k , w in series_info . items () if k in ( \"modules\" , \"operator\" , \"operands\" ) ) self . generator = Generator ( ** geninfo ) @_threadpool def thdata ( self , timefrom = None , timeto = None , * args , ** kwargs ) : return self . data ( timefrom , timeto ) def data ( self , timefrom = None , timeto = None ) : if timefrom is not None : if self . first is not None : timefrom = max ( self . first , timefrom ) else : timefrom = self . first if timeto is not None : if self . last is not None : timeto = min ( self . last , timeto ) else : timeto = self . last try : out = db [ \"datacache\" ][ self.uid ] . to_frame () if timefrom is not None and out . index . max () < timefrom : out = out . tail ( 1 ) else : out = out [ timefrom:timeto ] except KeyError : out = DataFrame () timefrom2 = out . index . max () if timefrom2 is nan : timefrom2 = timefrom else : # timefrom2 = max ( isot2ut ( timefrom2 ), isot2ut ( timefrom ) or 1 ) timefrom2 = max ( isot2ut ( timefrom2 ), isot2ut ( timefrom ) or 1 ) timefrom2 = ut2isot ( timefrom2 ) gen = self . generator . _generate ( timefrom = timefrom2 , timeto = timeto ) try : gen = gen . to_frame () except AttributeError : pass gen . columns = list ( range ( gen . columns . __len__ ())) out = out . append ( gen ). sort_index () idx = unique ( out . index . values , return_index = True ) [ 1 ] out = out . iloc [ idx ] out . index . name = \"timestamp\" return out","title":"Series"},{"location":"reference/hielen2/data/data_access_layer/#methods","text":"","title":"Methods"},{"location":"reference/hielen2/data/data_access_layer/#data","text":"def data ( self , timefrom = None , timeto = None ) View Source def data ( self , timefrom = None , timeto = None ) : if timefrom is not None : if self . first is not None : timefrom = max ( self . first , timefrom ) else : timefrom = self . first if timeto is not None : if self . last is not None : timeto = min ( self . last , timeto ) else : timeto = self . last try : out = db [ \"datacache\" ][ self.uid ] . to_frame () if timefrom is not None and out . index . max () < timefrom : out = out . tail ( 1 ) else : out = out [ timefrom:timeto ] except KeyError : out = DataFrame () timefrom2 = out . index . max () if timefrom2 is nan : timefrom2 = timefrom else : # timefrom2 = max ( isot2ut ( timefrom2 ), isot2ut ( timefrom ) or 1 ) timefrom2 = max ( isot2ut ( timefrom2 ), isot2ut ( timefrom ) or 1 ) timefrom2 = ut2isot ( timefrom2 ) gen = self . generator . _generate ( timefrom = timefrom2 , timeto = timeto ) try : gen = gen . to_frame () except AttributeError : pass gen . columns = list ( range ( gen . columns . __len__ ())) out = out . append ( gen ). sort_index () idx = unique ( out . index . values , return_index = True ) [ 1 ] out = out . iloc [ idx ] out . index . name = \"timestamp\" return out","title":"data"},{"location":"reference/hielen2/data/data_access_layer/#thdata","text":"def thdata ( self , timefrom = None , timeto = None , * args , ** kwargs ) View Source @_threadpool def thdata ( self , timefrom = None , timeto = None , * args , ** kwargs ) : return self . data ( timefrom , timeto )","title":"thdata"},{"location":"reference/hielen2/ext/","text":"Module hielen2.ext Sub-modules hielen2.ext.source_csv hielen2.ext.source_photomonitoring hielen2.ext.source_smori hielen2.ext.source_tinsar hielen2.ext.source_winecap","title":"Index"},{"location":"reference/hielen2/ext/#module-hielen2ext","text":"","title":"Module hielen2.ext"},{"location":"reference/hielen2/ext/#sub-modules","text":"hielen2.ext.source_csv hielen2.ext.source_photomonitoring hielen2.ext.source_smori hielen2.ext.source_tinsar hielen2.ext.source_winecap","title":"Sub-modules"},{"location":"reference/hielen2/ext/source_csv/","text":"Module hielen2.ext.source_csv View Source # coding: utf-8 from pandas import DataFrame , Series , to_datetime , read_csv import json import requests def get_ch ( path = \"./incomes\" , restype = None , resource = None , filename = \"last_load.csv\" , column = None , timefrom = None , timeto = None , ): return GWO ( path , restype , filename ) . getDataSeries ( resource = resource , column = column , timefrom = timefrom , timeto = timeto ) class GWO : def __init__ ( self , path = \"./incomes\" , restype = None , filename = \"last_load.csv\" ): self . path = path self . restype = restype self . filename = filename def getDataSeries ( self , resource = None , column = None , timefrom = None , timeto = None ): out = read_csv ( f \"{self.path}/{self.restype}/{resource}/{self.filename}\" , header = None , index_col = [ 0 ], )[ column ] # out.index=to_datetime(out.index) out = out . loc [ timefrom : timeto ] return out Functions get_ch def get_ch ( path = './incomes' , restype = None , resource = None , filename = 'last_load.csv' , column = None , timefrom = None , timeto = None ) View Source def get_ch ( path = \"./incomes\" , restype = None , resource = None , filename = \"last_load.csv\" , column = None , timefrom = None , timeto = None , ): return GWO ( path , restype , filename ). getDataSeries ( resource = resource , column = column , timefrom = timefrom , timeto = timeto ) Classes GWO class GWO ( path = './incomes' , restype = None , filename = 'last_load.csv' ) View Source class GWO : def __init__ ( self , path = \"./incomes\" , restype = None , filename = \"last_load.csv\" ) : self . path = path self . restype = restype self . filename = filename def getDataSeries ( self , resource = None , column = None , timefrom = None , timeto = None ) : out = read_csv ( f \"{self.path}/{self.restype}/{resource}/{self.filename}\" , header = None , index_col =[ 0 ] , ) [ column ] # out . index = to_datetime ( out . index ) out = out . loc [ timefrom:timeto ] return out Methods getDataSeries def getDataSeries ( self , resource = None , column = None , timefrom = None , timeto = None ) View Source def getDataSeries ( self , resource = None , column = None , timefrom = None , timeto = None ) : out = read_csv ( f \"{self.path}/{self.restype}/{resource}/{self.filename}\" , header = None , index_col =[ 0 ] , ) [ column ] # out . index = to_datetime ( out . index ) out = out . loc [ timefrom:timeto ] return out","title":"Source Csv"},{"location":"reference/hielen2/ext/source_csv/#module-hielen2extsource_csv","text":"View Source # coding: utf-8 from pandas import DataFrame , Series , to_datetime , read_csv import json import requests def get_ch ( path = \"./incomes\" , restype = None , resource = None , filename = \"last_load.csv\" , column = None , timefrom = None , timeto = None , ): return GWO ( path , restype , filename ) . getDataSeries ( resource = resource , column = column , timefrom = timefrom , timeto = timeto ) class GWO : def __init__ ( self , path = \"./incomes\" , restype = None , filename = \"last_load.csv\" ): self . path = path self . restype = restype self . filename = filename def getDataSeries ( self , resource = None , column = None , timefrom = None , timeto = None ): out = read_csv ( f \"{self.path}/{self.restype}/{resource}/{self.filename}\" , header = None , index_col = [ 0 ], )[ column ] # out.index=to_datetime(out.index) out = out . loc [ timefrom : timeto ] return out","title":"Module hielen2.ext.source_csv"},{"location":"reference/hielen2/ext/source_csv/#functions","text":"","title":"Functions"},{"location":"reference/hielen2/ext/source_csv/#get_ch","text":"def get_ch ( path = './incomes' , restype = None , resource = None , filename = 'last_load.csv' , column = None , timefrom = None , timeto = None ) View Source def get_ch ( path = \"./incomes\" , restype = None , resource = None , filename = \"last_load.csv\" , column = None , timefrom = None , timeto = None , ): return GWO ( path , restype , filename ). getDataSeries ( resource = resource , column = column , timefrom = timefrom , timeto = timeto )","title":"get_ch"},{"location":"reference/hielen2/ext/source_csv/#classes","text":"","title":"Classes"},{"location":"reference/hielen2/ext/source_csv/#gwo","text":"class GWO ( path = './incomes' , restype = None , filename = 'last_load.csv' ) View Source class GWO : def __init__ ( self , path = \"./incomes\" , restype = None , filename = \"last_load.csv\" ) : self . path = path self . restype = restype self . filename = filename def getDataSeries ( self , resource = None , column = None , timefrom = None , timeto = None ) : out = read_csv ( f \"{self.path}/{self.restype}/{resource}/{self.filename}\" , header = None , index_col =[ 0 ] , ) [ column ] # out . index = to_datetime ( out . index ) out = out . loc [ timefrom:timeto ] return out","title":"GWO"},{"location":"reference/hielen2/ext/source_csv/#methods","text":"","title":"Methods"},{"location":"reference/hielen2/ext/source_csv/#getdataseries","text":"def getDataSeries ( self , resource = None , column = None , timefrom = None , timeto = None ) View Source def getDataSeries ( self , resource = None , column = None , timefrom = None , timeto = None ) : out = read_csv ( f \"{self.path}/{self.restype}/{resource}/{self.filename}\" , header = None , index_col =[ 0 ] , ) [ column ] # out . index = to_datetime ( out . index ) out = out . loc [ timefrom:timeto ] return out","title":"getDataSeries"},{"location":"reference/hielen2/ext/source_smori/","text":"Module hielen2.ext.source_smori View Source # coding: utf-8 from pandas import DataFrame , Series , to_datetime import json import requests def get_ch ( sito = None , id_stazione = None , id_unita = None , id_sensore = None , aggr = \"avg\" , timefrom = None , timeto = None , ): return GWO () . getDataSeries ( sito = sito , stazione = id_stazione , unita = id_unita , sensore = id_sensore , aggr = \"avg\" , timefrom = timefrom , timeto = timeto , ) class GWO : def __init__ ( self , uri = \"https://www.smori.it/tisma/api/v1/sensor_data.php\" ): self . uri = uri def getDataSeries ( self , sito = None , stazione = None , unita = None , sensore = None , aggr = \"avg\" , timefrom = None , timeto = None , ): params = dict ( sito = sito , stazione = stazione , unita = unita , sensore = sensore , ) if aggr is not None : params [ \"aggr\" ] = aggr if timefrom is not None : params [ \"dal\" ] = timefrom if timefrom is not None : params [ \"al\" ] = timeto r = requests . get ( url = self . uri , params = params ) out = DataFrame ( json . loads ( r . text )[ \"data\" ]) # print (r.url) if out . empty : return out out = out . set_index ([ \"timestamp\" ])[ \"valore\" ] out = out . astype ( float , copy = False , errors = \"ignore\" ) out . name = f \"{stazione}_{unita}_{sensore}\" out . index = to_datetime ( out . index ) return out Functions get_ch def get_ch ( sito = None , id_stazione = None , id_unita = None , id_sensore = None , aggr = 'avg' , timefrom = None , timeto = None ) View Source def get_ch ( sito = None , id_stazione = None , id_unita = None , id_sensore = None , aggr = \"avg\" , timefrom = None , timeto = None , ): return GWO (). getDataSeries ( sito = sito , stazione = id_stazione , unita = id_unita , sensore = id_sensore , aggr = \"avg\" , timefrom = timefrom , timeto = timeto , ) Classes GWO class GWO ( uri = 'https://www.smori.it/tisma/api/v1/sensor_data.php' ) View Source class GWO: def __init__ ( self , uri = \"https://www.smori.it/tisma/api/v1/sensor_data.php\" ): self . uri = uri def getDataSeries ( self , sito = None , stazione = None , unita = None , sensore = None , aggr = \"avg\" , timefrom = None , timeto = None , ): params = dict ( sito = sito , stazione = stazione , unita = unita , sensore = sensore , ) if aggr is not None: params [ \"aggr\" ] = aggr if timefrom is not None: params [ \"dal\" ] = timefrom if timefrom is not None: params [ \"al\" ] = timeto r = requests . get ( url = self . uri , params = params ) out = DataFrame ( json . loads ( r . text )[ \"data\" ]) # print (r.url) if out . empty: return out out = out . set_index ([ \"timestamp\" ])[ \"valore\" ] out = out . astype ( float , copy = False , errors = \"ignore\" ) out . name = f \"{stazione}_{unita}_{sensore}\" out . index = to_datetime ( out . index ) return out Methods getDataSeries def getDataSeries ( self , sito = None , stazione = None , unita = None , sensore = None , aggr = 'avg' , timefrom = None , timeto = None ) View Source def getDataSeries ( self , sito = None , stazione = None , unita = None , sensore = None , aggr = \"avg\" , timefrom = None , timeto = None , ): params = dict ( sito = sito , stazione = stazione , unita = unita , sensore = sensore , ) if aggr is not None : params [ \"aggr\" ] = aggr if timefrom is not None : params [ \"dal\" ] = timefrom if timefrom is not None : params [ \"al\" ] = timeto r = requests . get ( url = self . uri , params = params ) out = DataFrame ( json . loads ( r . text )[ \"data\" ]) # print ( r . url ) if out . empty : return out out = out . set_index ([ \"timestamp\" ])[ \"valore\" ] out = out . astype ( float , copy = False , errors = \"ignore\" ) out . name = f \"{stazione}_{unita}_{sensore}\" out . index = to_datetime ( out . index ) return out","title":"Source Smori"},{"location":"reference/hielen2/ext/source_smori/#module-hielen2extsource_smori","text":"View Source # coding: utf-8 from pandas import DataFrame , Series , to_datetime import json import requests def get_ch ( sito = None , id_stazione = None , id_unita = None , id_sensore = None , aggr = \"avg\" , timefrom = None , timeto = None , ): return GWO () . getDataSeries ( sito = sito , stazione = id_stazione , unita = id_unita , sensore = id_sensore , aggr = \"avg\" , timefrom = timefrom , timeto = timeto , ) class GWO : def __init__ ( self , uri = \"https://www.smori.it/tisma/api/v1/sensor_data.php\" ): self . uri = uri def getDataSeries ( self , sito = None , stazione = None , unita = None , sensore = None , aggr = \"avg\" , timefrom = None , timeto = None , ): params = dict ( sito = sito , stazione = stazione , unita = unita , sensore = sensore , ) if aggr is not None : params [ \"aggr\" ] = aggr if timefrom is not None : params [ \"dal\" ] = timefrom if timefrom is not None : params [ \"al\" ] = timeto r = requests . get ( url = self . uri , params = params ) out = DataFrame ( json . loads ( r . text )[ \"data\" ]) # print (r.url) if out . empty : return out out = out . set_index ([ \"timestamp\" ])[ \"valore\" ] out = out . astype ( float , copy = False , errors = \"ignore\" ) out . name = f \"{stazione}_{unita}_{sensore}\" out . index = to_datetime ( out . index ) return out","title":"Module hielen2.ext.source_smori"},{"location":"reference/hielen2/ext/source_smori/#functions","text":"","title":"Functions"},{"location":"reference/hielen2/ext/source_smori/#get_ch","text":"def get_ch ( sito = None , id_stazione = None , id_unita = None , id_sensore = None , aggr = 'avg' , timefrom = None , timeto = None ) View Source def get_ch ( sito = None , id_stazione = None , id_unita = None , id_sensore = None , aggr = \"avg\" , timefrom = None , timeto = None , ): return GWO (). getDataSeries ( sito = sito , stazione = id_stazione , unita = id_unita , sensore = id_sensore , aggr = \"avg\" , timefrom = timefrom , timeto = timeto , )","title":"get_ch"},{"location":"reference/hielen2/ext/source_smori/#classes","text":"","title":"Classes"},{"location":"reference/hielen2/ext/source_smori/#gwo","text":"class GWO ( uri = 'https://www.smori.it/tisma/api/v1/sensor_data.php' ) View Source class GWO: def __init__ ( self , uri = \"https://www.smori.it/tisma/api/v1/sensor_data.php\" ): self . uri = uri def getDataSeries ( self , sito = None , stazione = None , unita = None , sensore = None , aggr = \"avg\" , timefrom = None , timeto = None , ): params = dict ( sito = sito , stazione = stazione , unita = unita , sensore = sensore , ) if aggr is not None: params [ \"aggr\" ] = aggr if timefrom is not None: params [ \"dal\" ] = timefrom if timefrom is not None: params [ \"al\" ] = timeto r = requests . get ( url = self . uri , params = params ) out = DataFrame ( json . loads ( r . text )[ \"data\" ]) # print (r.url) if out . empty: return out out = out . set_index ([ \"timestamp\" ])[ \"valore\" ] out = out . astype ( float , copy = False , errors = \"ignore\" ) out . name = f \"{stazione}_{unita}_{sensore}\" out . index = to_datetime ( out . index ) return out","title":"GWO"},{"location":"reference/hielen2/ext/source_smori/#methods","text":"","title":"Methods"},{"location":"reference/hielen2/ext/source_smori/#getdataseries","text":"def getDataSeries ( self , sito = None , stazione = None , unita = None , sensore = None , aggr = 'avg' , timefrom = None , timeto = None ) View Source def getDataSeries ( self , sito = None , stazione = None , unita = None , sensore = None , aggr = \"avg\" , timefrom = None , timeto = None , ): params = dict ( sito = sito , stazione = stazione , unita = unita , sensore = sensore , ) if aggr is not None : params [ \"aggr\" ] = aggr if timefrom is not None : params [ \"dal\" ] = timefrom if timefrom is not None : params [ \"al\" ] = timeto r = requests . get ( url = self . uri , params = params ) out = DataFrame ( json . loads ( r . text )[ \"data\" ]) # print ( r . url ) if out . empty : return out out = out . set_index ([ \"timestamp\" ])[ \"valore\" ] out = out . astype ( float , copy = False , errors = \"ignore\" ) out . name = f \"{stazione}_{unita}_{sensore}\" out . index = to_datetime ( out . index ) return out","title":"getDataSeries"},{"location":"reference/hielen2/ext/source_winecap/","text":"Module hielen2.ext.source_winecap View Source # coding: utf-8 from pandas import DataFrame , Series , to_datetime from zeep import Client from zeep.helpers import serialize_object from concurrent.futures import ThreadPoolExecutor from functools import wraps from time import time from hielen.utils import isot2ut \"\"\" sudo apt-get install libxml2-dev libxslt1-dev pip install lxml==4.2.5 zeep \"\"\" # key='80d373db820fea6f8c5f57d125eb509d' key = \"04a71268d386d61801824863ad7e2a5d\" GWOmac = \"00009DEA\" def get_ch ( GW = None , LG = None , CH = None , timefrom = None , timeto = None ): return GWO ( mac = GW ) . getDataSeries ( mac = LG , ch = CH , timefrom = timefrom , timeto = timeto ) def threadpool ( f , executor = None ): @wraps ( f ) def wrap ( * args , ** kwargs ): return ThreadPoolExecutor () . submit ( f , * args , ** kwargs ) return wrap class GWO : def __init__ ( self , key = key , mac = GWOmac , wsdl = \"http://www.winecap.it/winecapws.wsdl\" ): self . key = key self . mac = mac self . client = Client ( wsdl = wsdl ) self . _gch = self . client . service . getChannelHistory self . _gsh = self . client . service . getSystemHistory self . _gsl = self . client . service . getSensorList def getSensorsList ( self ): return DataFrame ( serialize_object ( self . _gsl ( self . key , self . mac ))) def getDataSeries ( self , mac , ch , timefrom = None , timeto = None ): if not isinstance ( timefrom , int ): timefrom = isot2ut ( timefrom ) if timeto is None : timeto = int ( time ()) if not isinstance ( timeto , int ): timeto = isot2ut ( timeto ) ahead = True out = Series () while ahead : u = DataFrame ( serialize_object ( self . _gch ( self . key , self . mac , mac , ch , timefrom , timeto ) ) ) if u . __len__ () < 1024 : ahead = False if u . __len__ () > 0 : u = u . set_index ([ \"timeStamp\" ])[ \"value\" ] u . index . names = [ \"timestamp\" ] timefrom = u . index . max () + 1 out = out . append ( u ) out = out . sort_index () out . name = f \"{mac}_{ch}\" out . sort_index () out . index = to_datetime ( out . index , unit = \"s\" ) return out @threadpool def getThreadedSeries ( self , * args , ** kwargs ): return self . getDataSeries ( * args , ** kwargs ) def getDataFrame ( self , reqser = [], timefrom = None , timeto = None ): thds = [ self . getThreadedSeries ( * x , timefrom , timeto ) for x in reqser ] return [ x . result () for x in thds ] def getDataFrameSE ( self , reqser = [], timefrom = None , timeto = None ): return [ self . getDataSeries ( * x , timefrom , timeto ) for x in reqser ] Variables GWOmac key Functions get_ch def get_ch ( GW = None , LG = None , CH = None , timefrom = None , timeto = None ) View Source def get_ch ( GW = None , LG = None , CH = None , timefrom = None , timeto = None ): return GWO ( mac = GW ). getDataSeries ( mac = LG , ch = CH , timefrom = timefrom , timeto = timeto ) threadpool def threadpool ( f , executor = None ) View Source def threadpool ( f , executor = None ) : @wraps ( f ) def wrap ( * args , ** kwargs ) : return ThreadPoolExecutor (). submit ( f , * args , ** kwargs ) return wrap Classes GWO class GWO ( key = '04a71268d386d61801824863ad7e2a5d' , mac = '00009DEA' , wsdl = 'http://www.winecap.it/winecapws.wsdl' ) View Source class GWO : def __init__ ( self , key = key , mac = GWOmac , wsdl = \"http://www.winecap.it/winecapws.wsdl\" ) : self . key = key self . mac = mac self . client = Client ( wsdl = wsdl ) self . _gch = self . client . service . getChannelHistory self . _gsh = self . client . service . getSystemHistory self . _gsl = self . client . service . getSensorList def getSensorsList ( self ) : return DataFrame ( serialize_object ( self . _gsl ( self . key , self . mac ))) def getDataSeries ( self , mac , ch , timefrom = None , timeto = None ) : if not isinstance ( timefrom , int ) : timefrom = isot2ut ( timefrom ) if timeto is None : timeto = int ( time ()) if not isinstance ( timeto , int ) : timeto = isot2ut ( timeto ) ahead = True out = Series () while ahead : u = DataFrame ( serialize_object ( self . _gch ( self . key , self . mac , mac , ch , timefrom , timeto ) ) ) if u . __len__ () < 1024 : ahead = False if u . __len__ () > 0 : u = u . set_index ( [ \"timeStamp\" ] ) [ \"value\" ] u . index . names = [ \"timestamp\" ] timefrom = u . index . max () + 1 out = out . append ( u ) out = out . sort_index () out . name = f \"{mac}_{ch}\" out . sort_index () out . index = to_datetime ( out . index , unit = \"s\" ) return out @threadpool def getThreadedSeries ( self , * args , ** kwargs ) : return self . getDataSeries ( * args , ** kwargs ) def getDataFrame ( self , reqser = [] , timefrom = None , timeto = None ) : thds = [ self.getThreadedSeries(*x, timefrom, timeto) for x in reqser ] return [ x.result() for x in thds ] def getDataFrameSE ( self , reqser = [] , timefrom = None , timeto = None ) : return [ self.getDataSeries(*x, timefrom, timeto) for x in reqser ] Methods getDataFrame def getDataFrame ( self , reqser = [], timefrom = None , timeto = None ) View Source def getDataFrame ( self , reqser = [], timefrom = None , timeto = None ): thds = [ self . getThreadedSeries ( * x , timefrom , timeto ) for x in reqser ] return [ x . result () for x in thds ] getDataFrameSE def getDataFrameSE ( self , reqser = [], timefrom = None , timeto = None ) View Source def getDataFrameSE ( self , reqser = [], timefrom = None , timeto = None ): return [ self . getDataSeries ( * x , timefrom , timeto ) for x in reqser ] getDataSeries def getDataSeries ( self , mac , ch , timefrom = None , timeto = None ) View Source def getDataSeries ( self , mac , ch , timefrom = None , timeto = None ): if not isinstance ( timefrom , int ): timefrom = isot2ut ( timefrom ) if timeto is None : timeto = int ( time ()) if not isinstance ( timeto , int ): timeto = isot2ut ( timeto ) ahead = True out = Series () while ahead : u = DataFrame ( serialize_object ( self . _gch ( self . key , self . mac , mac , ch , timefrom , timeto ) ) ) if u . __len__ () < 1024 : ahead = False if u . __len__ () > 0 : u = u . set_index ([ \"timeStamp\" ])[ \"value\" ] u . index . names = [ \"timestamp\" ] timefrom = u . index . max () + 1 out = out . append ( u ) out = out . sort_index () out . name = f \"{mac}_{ch}\" out . sort_index () out . index = to_datetime ( out . index , unit = \"s\" ) return out getSensorsList def getSensorsList ( self ) View Source def getSensorsList ( self ): return DataFrame ( serialize_object ( self . _gsl ( self . key , self . mac ))) getThreadedSeries def getThreadedSeries ( self , * args , ** kwargs ) View Source @threadpool def getThreadedSeries ( self , * args , ** kwargs ) : return self . getDataSeries ( * args , ** kwargs )","title":"Source Winecap"},{"location":"reference/hielen2/ext/source_winecap/#module-hielen2extsource_winecap","text":"View Source # coding: utf-8 from pandas import DataFrame , Series , to_datetime from zeep import Client from zeep.helpers import serialize_object from concurrent.futures import ThreadPoolExecutor from functools import wraps from time import time from hielen.utils import isot2ut \"\"\" sudo apt-get install libxml2-dev libxslt1-dev pip install lxml==4.2.5 zeep \"\"\" # key='80d373db820fea6f8c5f57d125eb509d' key = \"04a71268d386d61801824863ad7e2a5d\" GWOmac = \"00009DEA\" def get_ch ( GW = None , LG = None , CH = None , timefrom = None , timeto = None ): return GWO ( mac = GW ) . getDataSeries ( mac = LG , ch = CH , timefrom = timefrom , timeto = timeto ) def threadpool ( f , executor = None ): @wraps ( f ) def wrap ( * args , ** kwargs ): return ThreadPoolExecutor () . submit ( f , * args , ** kwargs ) return wrap class GWO : def __init__ ( self , key = key , mac = GWOmac , wsdl = \"http://www.winecap.it/winecapws.wsdl\" ): self . key = key self . mac = mac self . client = Client ( wsdl = wsdl ) self . _gch = self . client . service . getChannelHistory self . _gsh = self . client . service . getSystemHistory self . _gsl = self . client . service . getSensorList def getSensorsList ( self ): return DataFrame ( serialize_object ( self . _gsl ( self . key , self . mac ))) def getDataSeries ( self , mac , ch , timefrom = None , timeto = None ): if not isinstance ( timefrom , int ): timefrom = isot2ut ( timefrom ) if timeto is None : timeto = int ( time ()) if not isinstance ( timeto , int ): timeto = isot2ut ( timeto ) ahead = True out = Series () while ahead : u = DataFrame ( serialize_object ( self . _gch ( self . key , self . mac , mac , ch , timefrom , timeto ) ) ) if u . __len__ () < 1024 : ahead = False if u . __len__ () > 0 : u = u . set_index ([ \"timeStamp\" ])[ \"value\" ] u . index . names = [ \"timestamp\" ] timefrom = u . index . max () + 1 out = out . append ( u ) out = out . sort_index () out . name = f \"{mac}_{ch}\" out . sort_index () out . index = to_datetime ( out . index , unit = \"s\" ) return out @threadpool def getThreadedSeries ( self , * args , ** kwargs ): return self . getDataSeries ( * args , ** kwargs ) def getDataFrame ( self , reqser = [], timefrom = None , timeto = None ): thds = [ self . getThreadedSeries ( * x , timefrom , timeto ) for x in reqser ] return [ x . result () for x in thds ] def getDataFrameSE ( self , reqser = [], timefrom = None , timeto = None ): return [ self . getDataSeries ( * x , timefrom , timeto ) for x in reqser ]","title":"Module hielen2.ext.source_winecap"},{"location":"reference/hielen2/ext/source_winecap/#variables","text":"GWOmac key","title":"Variables"},{"location":"reference/hielen2/ext/source_winecap/#functions","text":"","title":"Functions"},{"location":"reference/hielen2/ext/source_winecap/#get_ch","text":"def get_ch ( GW = None , LG = None , CH = None , timefrom = None , timeto = None ) View Source def get_ch ( GW = None , LG = None , CH = None , timefrom = None , timeto = None ): return GWO ( mac = GW ). getDataSeries ( mac = LG , ch = CH , timefrom = timefrom , timeto = timeto )","title":"get_ch"},{"location":"reference/hielen2/ext/source_winecap/#threadpool","text":"def threadpool ( f , executor = None ) View Source def threadpool ( f , executor = None ) : @wraps ( f ) def wrap ( * args , ** kwargs ) : return ThreadPoolExecutor (). submit ( f , * args , ** kwargs ) return wrap","title":"threadpool"},{"location":"reference/hielen2/ext/source_winecap/#classes","text":"","title":"Classes"},{"location":"reference/hielen2/ext/source_winecap/#gwo","text":"class GWO ( key = '04a71268d386d61801824863ad7e2a5d' , mac = '00009DEA' , wsdl = 'http://www.winecap.it/winecapws.wsdl' ) View Source class GWO : def __init__ ( self , key = key , mac = GWOmac , wsdl = \"http://www.winecap.it/winecapws.wsdl\" ) : self . key = key self . mac = mac self . client = Client ( wsdl = wsdl ) self . _gch = self . client . service . getChannelHistory self . _gsh = self . client . service . getSystemHistory self . _gsl = self . client . service . getSensorList def getSensorsList ( self ) : return DataFrame ( serialize_object ( self . _gsl ( self . key , self . mac ))) def getDataSeries ( self , mac , ch , timefrom = None , timeto = None ) : if not isinstance ( timefrom , int ) : timefrom = isot2ut ( timefrom ) if timeto is None : timeto = int ( time ()) if not isinstance ( timeto , int ) : timeto = isot2ut ( timeto ) ahead = True out = Series () while ahead : u = DataFrame ( serialize_object ( self . _gch ( self . key , self . mac , mac , ch , timefrom , timeto ) ) ) if u . __len__ () < 1024 : ahead = False if u . __len__ () > 0 : u = u . set_index ( [ \"timeStamp\" ] ) [ \"value\" ] u . index . names = [ \"timestamp\" ] timefrom = u . index . max () + 1 out = out . append ( u ) out = out . sort_index () out . name = f \"{mac}_{ch}\" out . sort_index () out . index = to_datetime ( out . index , unit = \"s\" ) return out @threadpool def getThreadedSeries ( self , * args , ** kwargs ) : return self . getDataSeries ( * args , ** kwargs ) def getDataFrame ( self , reqser = [] , timefrom = None , timeto = None ) : thds = [ self.getThreadedSeries(*x, timefrom, timeto) for x in reqser ] return [ x.result() for x in thds ] def getDataFrameSE ( self , reqser = [] , timefrom = None , timeto = None ) : return [ self.getDataSeries(*x, timefrom, timeto) for x in reqser ]","title":"GWO"},{"location":"reference/hielen2/ext/source_winecap/#methods","text":"","title":"Methods"},{"location":"reference/hielen2/ext/source_winecap/#getdataframe","text":"def getDataFrame ( self , reqser = [], timefrom = None , timeto = None ) View Source def getDataFrame ( self , reqser = [], timefrom = None , timeto = None ): thds = [ self . getThreadedSeries ( * x , timefrom , timeto ) for x in reqser ] return [ x . result () for x in thds ]","title":"getDataFrame"},{"location":"reference/hielen2/ext/source_winecap/#getdataframese","text":"def getDataFrameSE ( self , reqser = [], timefrom = None , timeto = None ) View Source def getDataFrameSE ( self , reqser = [], timefrom = None , timeto = None ): return [ self . getDataSeries ( * x , timefrom , timeto ) for x in reqser ]","title":"getDataFrameSE"},{"location":"reference/hielen2/ext/source_winecap/#getdataseries","text":"def getDataSeries ( self , mac , ch , timefrom = None , timeto = None ) View Source def getDataSeries ( self , mac , ch , timefrom = None , timeto = None ): if not isinstance ( timefrom , int ): timefrom = isot2ut ( timefrom ) if timeto is None : timeto = int ( time ()) if not isinstance ( timeto , int ): timeto = isot2ut ( timeto ) ahead = True out = Series () while ahead : u = DataFrame ( serialize_object ( self . _gch ( self . key , self . mac , mac , ch , timefrom , timeto ) ) ) if u . __len__ () < 1024 : ahead = False if u . __len__ () > 0 : u = u . set_index ([ \"timeStamp\" ])[ \"value\" ] u . index . names = [ \"timestamp\" ] timefrom = u . index . max () + 1 out = out . append ( u ) out = out . sort_index () out . name = f \"{mac}_{ch}\" out . sort_index () out . index = to_datetime ( out . index , unit = \"s\" ) return out","title":"getDataSeries"},{"location":"reference/hielen2/ext/source_winecap/#getsensorslist","text":"def getSensorsList ( self ) View Source def getSensorsList ( self ): return DataFrame ( serialize_object ( self . _gsl ( self . key , self . mac )))","title":"getSensorsList"},{"location":"reference/hielen2/ext/source_winecap/#getthreadedseries","text":"def getThreadedSeries ( self , * args , ** kwargs ) View Source @threadpool def getThreadedSeries ( self , * args , ** kwargs ) : return self . getDataSeries ( * args , ** kwargs )","title":"getThreadedSeries"},{"location":"reference/hielen2/ext/source_photomonitoring/","text":"Module hielen2.ext.source_photomonitoring View Source # coding=utf-8 __name__ = \"Source_Photomonitoring\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from .phm import Source , ConfigSchema , FeedSchema from . import ncmangle __all__ = [ \"Source\" , \"ConfigSchema\" , \"FeedSchema\" ] Sub-modules hielen2.ext.source_photomonitoring.ncmangle hielen2.ext.source_photomonitoring.phm Classes ConfigSchema class ConfigSchema ( * , only : Union [ Sequence [ str ], Set [ str ], NoneType ] = None , exclude : Union [ Sequence [ str ], Set [ str ]] = (), many : bool = False , context : Union [ Dict , NoneType ] = None , load_only : Union [ Sequence [ str ], Set [ str ]] = (), dump_only : Union [ Sequence [ str ], Set [ str ]] = (), partial : Union [ bool , Sequence [ str ], Set [ str ]] = False , unknown : Union [ str , NoneType ] = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): master_image = LocalFile ( required = True , allow_none = False ) step_size = fields . Str ( required = False , default = \"8\" ) window_size_change = fields . Str ( required = False , default = \"0\" ) geo_reference_file = LocalFile ( required = False , default = None ) crs = fields . Str ( required = False , default = None ) Ancestors (in MRO) hielen2.source.ActionSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING crs error_messages geo_reference_file master_image opts step_size window_size_change Static methods from_dict def from_dict ( fields : Dict [ str , Union [ marshmallow . fields . Field , type ]], * , name : str = 'GeneratedSchema' ) -> type Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 View Source @classmethod def from_dict ( cls , fields : typing . Dict [ str , typing . Union [ ma_fields . Field , type ]], * , name : str = \"GeneratedSchema\" ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : Any , * , many : Union [ bool , NoneType ] = None ) Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : typing . Optional [ bool ] = None ): \"\"\"Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\"\" many = self . many if many is None else bool ( many ) if many and is_iterable_but_not_string ( obj ): obj = list ( obj ) if self . _has_processors ( PRE_DUMP ): processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ): result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : Any , * args , many : Union [ bool , NoneType ] = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A json string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : typing . Optional [ bool ] = None , ** kwargs ): \"\"\"Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\"\" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : Any , attr : str , default : Any ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ): \"\"\"Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\"\" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : marshmallow . exceptions . ValidationError , data : Any , * , many : bool , ** kwargs ) Custom error handler function for the schema. :param error: The ValidationError raised during (de)serialization. :param data: The original input data. :param many: Value of many on dump or load. :param partial: Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ): \"\"\"Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\"\" pass load def load ( self , data : Union [ Mapping [ str , Any ], Iterable [ Mapping [ str , Any ]]], * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None ) Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : typing . Union [ typing . Mapping [ str , typing . Any ], typing . Iterable [ typing . Mapping [ str , typing . Any ]], ], * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None ): \"\"\"Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : str , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize obj as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None , ** kwargs ): \"\"\"Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : str , field_obj : marshmallow . fields . Field ) -> None Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \"\"\"Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\"\" return None validate def validate ( self , data : Mapping , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None ) -> Dict [ str , List [ str ]] Validate data against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : typing . Mapping , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None ) -> typing . Dict [ str , typing . List [ str ]]: \"\"\"Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\"\" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]], exc . messages ) return {} FeedSchema class FeedSchema ( * , only : Union [ Sequence [ str ], Set [ str ], NoneType ] = None , exclude : Union [ Sequence [ str ], Set [ str ]] = (), many : bool = False , context : Union [ Dict , NoneType ] = None , load_only : Union [ Sequence [ str ], Set [ str ]] = (), dump_only : Union [ Sequence [ str ], Set [ str ]] = (), partial : Union [ bool , Sequence [ str ], Set [ str ]] = False , unknown : Union [ str , NoneType ] = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class FeedSchema ( ActionSchema ): reference_time = fields . Str ( required = False , allow_none = False ) NS_displacement = LocalFile ( required = False , allow_none = False ) EW_displacement = LocalFile ( required = False , allow_none = False ) Coer = LocalFile ( required = False , allow_none = False ) Ancestors (in MRO) hielen2.source.ActionSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Coer EW_displacement Meta NS_displacement OPTIONS_CLASS TYPE_MAPPING error_messages opts reference_time Static methods from_dict def from_dict ( fields : Dict [ str , Union [ marshmallow . fields . Field , type ]], * , name : str = 'GeneratedSchema' ) -> type Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 View Source @classmethod def from_dict ( cls , fields : typing . Dict [ str , typing . Union [ ma_fields . Field , type ]], * , name : str = \"GeneratedSchema\" ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : Any , * , many : Union [ bool , NoneType ] = None ) Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : typing . Optional [ bool ] = None ): \"\"\"Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\"\" many = self . many if many is None else bool ( many ) if many and is_iterable_but_not_string ( obj ): obj = list ( obj ) if self . _has_processors ( PRE_DUMP ): processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ): result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : Any , * args , many : Union [ bool , NoneType ] = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A json string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : typing . Optional [ bool ] = None , ** kwargs ): \"\"\"Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\"\" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : Any , attr : str , default : Any ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ): \"\"\"Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\"\" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : marshmallow . exceptions . ValidationError , data : Any , * , many : bool , ** kwargs ) Custom error handler function for the schema. :param error: The ValidationError raised during (de)serialization. :param data: The original input data. :param many: Value of many on dump or load. :param partial: Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ): \"\"\"Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\"\" pass load def load ( self , data : Union [ Mapping [ str , Any ], Iterable [ Mapping [ str , Any ]]], * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None ) Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : typing . Union [ typing . Mapping [ str , typing . Any ], typing . Iterable [ typing . Mapping [ str , typing . Any ]], ], * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None ): \"\"\"Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : str , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize obj as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None , ** kwargs ): \"\"\"Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : str , field_obj : marshmallow . fields . Field ) -> None Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \"\"\"Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\"\" return None validate def validate ( self , data : Mapping , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None ) -> Dict [ str , List [ str ]] Validate data against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : typing . Mapping , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None ) -> typing . Dict [ str , typing . List [ str ]]: \"\"\"Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\"\" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]], exc . messages ) return {} Source class Source ( feature , filecache ) def init (self, feature, filecache): self. dict .update(feature.pop('properties')) self.geometry=feature.pop('geometry') self.actions=feature self.filecache = os.path.join(filecache,self.uid) os.makedirs(self.filecache, exist_ok=True) View Source class Source ( HielenSource ) : ''' def __init__(self, feature, filecache): self.__dict__.update(feature.pop('properties')) self.geometry=feature.pop('geometry') self.actions=feature self.filecache = os.path.join(filecache,self.uid) os.makedirs(self.filecache, exist_ok=True) ''' def config ( self , **kwargs ) : out= {} path_tempimage = Path ( kwargs [ \"master_image\" ]) path_tempref = kwargs [ \"geo_reference_file\" ] refpath = self . makeCachePath ( re . sub ( \" [ ^\\d ] \",\"\",kwargs['timestamp']) ) path_masterimage=Path(refpath) / \" master . img \" path_masternetcdf=Path(refpath) / \" master . nc \" path_georef=None try: name=str(path_tempimage).split(\" . \") with open(path_tempref) as trf: try: float(trf.readline()) path_georef=Path(\" . \".join([*name[0:-1],\" wld \"])) except Exception as e: path_georef=Path(\" . \".join([*name,\" aux \",\" xml \" ])) Path ( path_tempref ). replace ( path_georef ) except Exception as e : pass try : crs = rasterio . crs . CRS . from_string ( kwargs [ 'crs' ]) except Exception : crs = None with rasterio . open ( path_tempimage ) as src : meta = src . meta . copy () if crs is not None : meta . update ({ 'crs': crs }) with rasterio . open ( path_masterimage , 'w' , **meta ) as dst : for i in range ( 1 , src . count + 1 ) : dst . write ( src . read ( i ), i ) out [ 'master_image' ] = magic . from_file ( str ( path_masterimage )) out [ 'timestamp' ] = kwargs [ 'timestamp' ] out [ 'step_size' ] = kwargs [ 'step_size' ] out [ 'window_size_change' ] = kwargs [ 'window_size_change' ] out [ 'transform' ] = list ( meta [ 'transform' ])[ 0 : 6 ] out [ 'cache' ] = self . getRelativePath ( refpath ) try : out [ 'crs' ] = meta [ 'crs' ]. to_string () except AttributeError : out [ 'crs' ] = None #nc = NCMangler ( path_masternetcdf , **out ) return out def feed ( self , **kwargs ) : return kwargs def data ( self , timefrom = None , timeto = None , geom = None , **kwargs ) : return kwargs Ancestors (in MRO) hielen2.source.HielenSource abc.ABC Methods config def config ( self , ** kwargs ) View Source def config ( self , **kwargs ) : out= {} path_tempimage = Path ( kwargs [ \"master_image\" ]) path_tempref = kwargs [ \"geo_reference_file\" ] refpath = self . makeCachePath ( re . sub ( \" [ ^\\d ] \",\"\",kwargs['timestamp']) ) path_masterimage=Path(refpath) / \" master . img \" path_masternetcdf=Path(refpath) / \" master . nc \" path_georef=None try: name=str(path_tempimage).split(\" . \") with open(path_tempref) as trf: try: float(trf.readline()) path_georef=Path(\" . \".join([*name[0:-1],\" wld \"])) except Exception as e: path_georef=Path(\" . \".join([*name,\" aux \",\" xml \" ])) Path ( path_tempref ). replace ( path_georef ) except Exception as e : pass try : crs = rasterio . crs . CRS . from_string ( kwargs [ 'crs' ]) except Exception : crs = None with rasterio . open ( path_tempimage ) as src : meta = src . meta . copy () if crs is not None : meta . update ({ 'crs': crs }) with rasterio . open ( path_masterimage , 'w' , **meta ) as dst : for i in range ( 1 , src . count + 1 ) : dst . write ( src . read ( i ), i ) out [ 'master_image' ] = magic . from_file ( str ( path_masterimage )) out [ 'timestamp' ] = kwargs [ 'timestamp' ] out [ 'step_size' ] = kwargs [ 'step_size' ] out [ 'window_size_change' ] = kwargs [ 'window_size_change' ] out [ 'transform' ] = list ( meta [ 'transform' ])[ 0 : 6 ] out [ 'cache' ] = self . getRelativePath ( refpath ) try : out [ 'crs' ] = meta [ 'crs' ]. to_string () except AttributeError : out [ 'crs' ] = None #nc = NCMangler ( path_masternetcdf , **out ) return out data def data ( self , timefrom = None , timeto = None , geom = None , ** kwargs ) View Source def data ( self , timefrom = None , timeto = None , geom = None , ** kwargs ): return kwargs execAction def execAction ( self , action , ** kwargs ) View Source def execAction ( self , action , ** kwargs ): return self . __getattribute__ ( action )( ** kwargs ) feed def feed ( self , ** kwargs ) View Source def feed ( self , ** kwargs ): return kwargs getActionSchema def getActionSchema ( self , action ) View Source def getActionSchema ( self , action ): return getActionSchema ( self . module , action ) getActionValues def getActionValues ( self , action = None , timestamp = None ) View Source def getActionValues ( self , action = None , timestamp = None ): if action is None : action = slice ( None , None ) if timestamp is None : timestamp = slice ( None , None ) return db [ 'actions' ][ self . uid , action , timestamp ] getRelativePath def getRelativePath ( self , path ) View Source def getRelativePath ( self , path ): return path . replace ( f \"{self.filecache}/\" , \"\" ) makeCachePath def makeCachePath ( self , path ) View Source def makeCachePath ( self , path ): outpath = os . path . join ( self . filecache , path ) os . makedirs ( outpath , exist_ok = True ) return outpath","title":"Index"},{"location":"reference/hielen2/ext/source_photomonitoring/#module-hielen2extsource_photomonitoring","text":"View Source # coding=utf-8 __name__ = \"Source_Photomonitoring\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from .phm import Source , ConfigSchema , FeedSchema from . import ncmangle __all__ = [ \"Source\" , \"ConfigSchema\" , \"FeedSchema\" ]","title":"Module hielen2.ext.source_photomonitoring"},{"location":"reference/hielen2/ext/source_photomonitoring/#sub-modules","text":"hielen2.ext.source_photomonitoring.ncmangle hielen2.ext.source_photomonitoring.phm","title":"Sub-modules"},{"location":"reference/hielen2/ext/source_photomonitoring/#classes","text":"","title":"Classes"},{"location":"reference/hielen2/ext/source_photomonitoring/#configschema","text":"class ConfigSchema ( * , only : Union [ Sequence [ str ], Set [ str ], NoneType ] = None , exclude : Union [ Sequence [ str ], Set [ str ]] = (), many : bool = False , context : Union [ Dict , NoneType ] = None , load_only : Union [ Sequence [ str ], Set [ str ]] = (), dump_only : Union [ Sequence [ str ], Set [ str ]] = (), partial : Union [ bool , Sequence [ str ], Set [ str ]] = False , unknown : Union [ str , NoneType ] = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): master_image = LocalFile ( required = True , allow_none = False ) step_size = fields . Str ( required = False , default = \"8\" ) window_size_change = fields . Str ( required = False , default = \"0\" ) geo_reference_file = LocalFile ( required = False , default = None ) crs = fields . Str ( required = False , default = None )","title":"ConfigSchema"},{"location":"reference/hielen2/ext/source_photomonitoring/#ancestors-in-mro","text":"hielen2.source.ActionSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen2/ext/source_photomonitoring/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING crs error_messages geo_reference_file master_image opts step_size window_size_change","title":"Class variables"},{"location":"reference/hielen2/ext/source_photomonitoring/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen2/ext/source_photomonitoring/#from_dict","text":"def from_dict ( fields : Dict [ str , Union [ marshmallow . fields . Field , type ]], * , name : str = 'GeneratedSchema' ) -> type Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 View Source @classmethod def from_dict ( cls , fields : typing . Dict [ str , typing . Union [ ma_fields . Field , type ]], * , name : str = \"GeneratedSchema\" ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen2/ext/source_photomonitoring/#instance-variables","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen2/ext/source_photomonitoring/#methods","text":"","title":"Methods"},{"location":"reference/hielen2/ext/source_photomonitoring/#dump","text":"def dump ( self , obj : Any , * , many : Union [ bool , NoneType ] = None ) Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : typing . Optional [ bool ] = None ): \"\"\"Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\"\" many = self . many if many is None else bool ( many ) if many and is_iterable_but_not_string ( obj ): obj = list ( obj ) if self . _has_processors ( PRE_DUMP ): processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ): result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen2/ext/source_photomonitoring/#dumps","text":"def dumps ( self , obj : Any , * args , many : Union [ bool , NoneType ] = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A json string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : typing . Optional [ bool ] = None , ** kwargs ): \"\"\"Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\"\" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen2/ext/source_photomonitoring/#get_attribute","text":"def get_attribute ( self , obj : Any , attr : str , default : Any ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ): \"\"\"Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\"\" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen2/ext/source_photomonitoring/#handle_error","text":"def handle_error ( self , error : marshmallow . exceptions . ValidationError , data : Any , * , many : bool , ** kwargs ) Custom error handler function for the schema. :param error: The ValidationError raised during (de)serialization. :param data: The original input data. :param many: Value of many on dump or load. :param partial: Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ): \"\"\"Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\"\" pass","title":"handle_error"},{"location":"reference/hielen2/ext/source_photomonitoring/#load","text":"def load ( self , data : Union [ Mapping [ str , Any ], Iterable [ Mapping [ str , Any ]]], * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None ) Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : typing . Union [ typing . Mapping [ str , typing . Any ], typing . Iterable [ typing . Mapping [ str , typing . Any ]], ], * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None ): \"\"\"Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen2/ext/source_photomonitoring/#loads","text":"def loads ( self , json_data : str , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize obj as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None , ** kwargs ): \"\"\"Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen2/ext/source_photomonitoring/#on_bind_field","text":"def on_bind_field ( self , field_name : str , field_obj : marshmallow . fields . Field ) -> None Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \"\"\"Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\"\" return None","title":"on_bind_field"},{"location":"reference/hielen2/ext/source_photomonitoring/#validate","text":"def validate ( self , data : Mapping , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None ) -> Dict [ str , List [ str ]] Validate data against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : typing . Mapping , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None ) -> typing . Dict [ str , typing . List [ str ]]: \"\"\"Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\"\" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]], exc . messages ) return {}","title":"validate"},{"location":"reference/hielen2/ext/source_photomonitoring/#feedschema","text":"class FeedSchema ( * , only : Union [ Sequence [ str ], Set [ str ], NoneType ] = None , exclude : Union [ Sequence [ str ], Set [ str ]] = (), many : bool = False , context : Union [ Dict , NoneType ] = None , load_only : Union [ Sequence [ str ], Set [ str ]] = (), dump_only : Union [ Sequence [ str ], Set [ str ]] = (), partial : Union [ bool , Sequence [ str ], Set [ str ]] = False , unknown : Union [ str , NoneType ] = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class FeedSchema ( ActionSchema ): reference_time = fields . Str ( required = False , allow_none = False ) NS_displacement = LocalFile ( required = False , allow_none = False ) EW_displacement = LocalFile ( required = False , allow_none = False ) Coer = LocalFile ( required = False , allow_none = False )","title":"FeedSchema"},{"location":"reference/hielen2/ext/source_photomonitoring/#ancestors-in-mro_1","text":"hielen2.source.ActionSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen2/ext/source_photomonitoring/#class-variables_1","text":"Coer EW_displacement Meta NS_displacement OPTIONS_CLASS TYPE_MAPPING error_messages opts reference_time","title":"Class variables"},{"location":"reference/hielen2/ext/source_photomonitoring/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/hielen2/ext/source_photomonitoring/#from_dict_1","text":"def from_dict ( fields : Dict [ str , Union [ marshmallow . fields . Field , type ]], * , name : str = 'GeneratedSchema' ) -> type Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 View Source @classmethod def from_dict ( cls , fields : typing . Dict [ str , typing . Union [ ma_fields . Field , type ]], * , name : str = \"GeneratedSchema\" ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen2/ext/source_photomonitoring/#instance-variables_1","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen2/ext/source_photomonitoring/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen2/ext/source_photomonitoring/#dump_1","text":"def dump ( self , obj : Any , * , many : Union [ bool , NoneType ] = None ) Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : typing . Optional [ bool ] = None ): \"\"\"Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\"\" many = self . many if many is None else bool ( many ) if many and is_iterable_but_not_string ( obj ): obj = list ( obj ) if self . _has_processors ( PRE_DUMP ): processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ): result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen2/ext/source_photomonitoring/#dumps_1","text":"def dumps ( self , obj : Any , * args , many : Union [ bool , NoneType ] = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A json string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : typing . Optional [ bool ] = None , ** kwargs ): \"\"\"Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\"\" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen2/ext/source_photomonitoring/#get_attribute_1","text":"def get_attribute ( self , obj : Any , attr : str , default : Any ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ): \"\"\"Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\"\" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen2/ext/source_photomonitoring/#handle_error_1","text":"def handle_error ( self , error : marshmallow . exceptions . ValidationError , data : Any , * , many : bool , ** kwargs ) Custom error handler function for the schema. :param error: The ValidationError raised during (de)serialization. :param data: The original input data. :param many: Value of many on dump or load. :param partial: Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ): \"\"\"Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\"\" pass","title":"handle_error"},{"location":"reference/hielen2/ext/source_photomonitoring/#load_1","text":"def load ( self , data : Union [ Mapping [ str , Any ], Iterable [ Mapping [ str , Any ]]], * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None ) Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : typing . Union [ typing . Mapping [ str , typing . Any ], typing . Iterable [ typing . Mapping [ str , typing . Any ]], ], * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None ): \"\"\"Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen2/ext/source_photomonitoring/#loads_1","text":"def loads ( self , json_data : str , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize obj as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None , ** kwargs ): \"\"\"Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen2/ext/source_photomonitoring/#on_bind_field_1","text":"def on_bind_field ( self , field_name : str , field_obj : marshmallow . fields . Field ) -> None Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \"\"\"Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\"\" return None","title":"on_bind_field"},{"location":"reference/hielen2/ext/source_photomonitoring/#validate_1","text":"def validate ( self , data : Mapping , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None ) -> Dict [ str , List [ str ]] Validate data against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : typing . Mapping , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None ) -> typing . Dict [ str , typing . List [ str ]]: \"\"\"Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\"\" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]], exc . messages ) return {}","title":"validate"},{"location":"reference/hielen2/ext/source_photomonitoring/#source","text":"class Source ( feature , filecache ) def init (self, feature, filecache): self. dict .update(feature.pop('properties')) self.geometry=feature.pop('geometry') self.actions=feature self.filecache = os.path.join(filecache,self.uid) os.makedirs(self.filecache, exist_ok=True) View Source class Source ( HielenSource ) : ''' def __init__(self, feature, filecache): self.__dict__.update(feature.pop('properties')) self.geometry=feature.pop('geometry') self.actions=feature self.filecache = os.path.join(filecache,self.uid) os.makedirs(self.filecache, exist_ok=True) ''' def config ( self , **kwargs ) : out= {} path_tempimage = Path ( kwargs [ \"master_image\" ]) path_tempref = kwargs [ \"geo_reference_file\" ] refpath = self . makeCachePath ( re . sub ( \" [ ^\\d ] \",\"\",kwargs['timestamp']) ) path_masterimage=Path(refpath) / \" master . img \" path_masternetcdf=Path(refpath) / \" master . nc \" path_georef=None try: name=str(path_tempimage).split(\" . \") with open(path_tempref) as trf: try: float(trf.readline()) path_georef=Path(\" . \".join([*name[0:-1],\" wld \"])) except Exception as e: path_georef=Path(\" . \".join([*name,\" aux \",\" xml \" ])) Path ( path_tempref ). replace ( path_georef ) except Exception as e : pass try : crs = rasterio . crs . CRS . from_string ( kwargs [ 'crs' ]) except Exception : crs = None with rasterio . open ( path_tempimage ) as src : meta = src . meta . copy () if crs is not None : meta . update ({ 'crs': crs }) with rasterio . open ( path_masterimage , 'w' , **meta ) as dst : for i in range ( 1 , src . count + 1 ) : dst . write ( src . read ( i ), i ) out [ 'master_image' ] = magic . from_file ( str ( path_masterimage )) out [ 'timestamp' ] = kwargs [ 'timestamp' ] out [ 'step_size' ] = kwargs [ 'step_size' ] out [ 'window_size_change' ] = kwargs [ 'window_size_change' ] out [ 'transform' ] = list ( meta [ 'transform' ])[ 0 : 6 ] out [ 'cache' ] = self . getRelativePath ( refpath ) try : out [ 'crs' ] = meta [ 'crs' ]. to_string () except AttributeError : out [ 'crs' ] = None #nc = NCMangler ( path_masternetcdf , **out ) return out def feed ( self , **kwargs ) : return kwargs def data ( self , timefrom = None , timeto = None , geom = None , **kwargs ) : return kwargs","title":"Source"},{"location":"reference/hielen2/ext/source_photomonitoring/#ancestors-in-mro_2","text":"hielen2.source.HielenSource abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen2/ext/source_photomonitoring/#methods_2","text":"","title":"Methods"},{"location":"reference/hielen2/ext/source_photomonitoring/#config","text":"def config ( self , ** kwargs ) View Source def config ( self , **kwargs ) : out= {} path_tempimage = Path ( kwargs [ \"master_image\" ]) path_tempref = kwargs [ \"geo_reference_file\" ] refpath = self . makeCachePath ( re . sub ( \" [ ^\\d ] \",\"\",kwargs['timestamp']) ) path_masterimage=Path(refpath) / \" master . img \" path_masternetcdf=Path(refpath) / \" master . nc \" path_georef=None try: name=str(path_tempimage).split(\" . \") with open(path_tempref) as trf: try: float(trf.readline()) path_georef=Path(\" . \".join([*name[0:-1],\" wld \"])) except Exception as e: path_georef=Path(\" . \".join([*name,\" aux \",\" xml \" ])) Path ( path_tempref ). replace ( path_georef ) except Exception as e : pass try : crs = rasterio . crs . CRS . from_string ( kwargs [ 'crs' ]) except Exception : crs = None with rasterio . open ( path_tempimage ) as src : meta = src . meta . copy () if crs is not None : meta . update ({ 'crs': crs }) with rasterio . open ( path_masterimage , 'w' , **meta ) as dst : for i in range ( 1 , src . count + 1 ) : dst . write ( src . read ( i ), i ) out [ 'master_image' ] = magic . from_file ( str ( path_masterimage )) out [ 'timestamp' ] = kwargs [ 'timestamp' ] out [ 'step_size' ] = kwargs [ 'step_size' ] out [ 'window_size_change' ] = kwargs [ 'window_size_change' ] out [ 'transform' ] = list ( meta [ 'transform' ])[ 0 : 6 ] out [ 'cache' ] = self . getRelativePath ( refpath ) try : out [ 'crs' ] = meta [ 'crs' ]. to_string () except AttributeError : out [ 'crs' ] = None #nc = NCMangler ( path_masternetcdf , **out ) return out","title":"config"},{"location":"reference/hielen2/ext/source_photomonitoring/#data","text":"def data ( self , timefrom = None , timeto = None , geom = None , ** kwargs ) View Source def data ( self , timefrom = None , timeto = None , geom = None , ** kwargs ): return kwargs","title":"data"},{"location":"reference/hielen2/ext/source_photomonitoring/#execaction","text":"def execAction ( self , action , ** kwargs ) View Source def execAction ( self , action , ** kwargs ): return self . __getattribute__ ( action )( ** kwargs )","title":"execAction"},{"location":"reference/hielen2/ext/source_photomonitoring/#feed","text":"def feed ( self , ** kwargs ) View Source def feed ( self , ** kwargs ): return kwargs","title":"feed"},{"location":"reference/hielen2/ext/source_photomonitoring/#getactionschema","text":"def getActionSchema ( self , action ) View Source def getActionSchema ( self , action ): return getActionSchema ( self . module , action )","title":"getActionSchema"},{"location":"reference/hielen2/ext/source_photomonitoring/#getactionvalues","text":"def getActionValues ( self , action = None , timestamp = None ) View Source def getActionValues ( self , action = None , timestamp = None ): if action is None : action = slice ( None , None ) if timestamp is None : timestamp = slice ( None , None ) return db [ 'actions' ][ self . uid , action , timestamp ]","title":"getActionValues"},{"location":"reference/hielen2/ext/source_photomonitoring/#getrelativepath","text":"def getRelativePath ( self , path ) View Source def getRelativePath ( self , path ): return path . replace ( f \"{self.filecache}/\" , \"\" )","title":"getRelativePath"},{"location":"reference/hielen2/ext/source_photomonitoring/#makecachepath","text":"def makeCachePath ( self , path ) View Source def makeCachePath ( self , path ): outpath = os . path . join ( self . filecache , path ) os . makedirs ( outpath , exist_ok = True ) return outpath","title":"makeCachePath"},{"location":"reference/hielen2/ext/source_photomonitoring/ncmangle/","text":"Module hielen2.ext.source_photomonitoring.ncmangle View Source # coding: utf-8 import numpy as np import pandas as pd import re from netCDF4 import Dataset , date2num import os ''' timestamp = fields.Str(required=True, allow_none=False) master_image = fileds.Str(required=True, allow_none=False) step_size = fields.Str(required=False, default=\"8\") window_size_change = fields.Str(required=False,default=\"0\") world_file = fields.Str(required=False,default=None) crs: \"EPSG:3857\" {'driver': 'GTiff', 'dtype': 'uint16', 'nodata': 0.0, 'width': 3545, 'height': 1842, 'count': 1, 'crs': CRS.from_epsg(32622), 'transform': Affine(15.0, 0.0, 464947.5, 0.0, -15.0, 7977067.5)} ''' class NCMangler (): def __init__ ( self , targetfile , timestamp , height , width , step_size = 8 , window_size_change = 0 , transform = None , crs = None , ** kwargs ): \"\"\" Crea il file netCDF secondo un formato standard returns: la struttura dati del file NetCDF params name: nome del file y_values: dimensione delle y x_values: dimensione delle x refitime: tempo zero \"\"\" if not os . path . exists ( targetfile ): height = float ( height ) width = float ( width ) window_size_change = float ( window_size_change ) step_size = float ( step_size ) ydim = ( height - window_size_change * 2 ) / step_size xdim = ( width - window_size_change * 2 ) / step_size x_values = np . arange ( window_size_change , xdim ) * step_size * transform [ 0 ] + transform [ 2 ] y_values = np . arange ( window_size_change , ydim ) * step_size * transform [ 3 ] + transform [ 5 ] rootgrp = Dataset ( targetfile , 'w' , format = \"NETCDF4\" ) rootgrp . Conventions = \"CF-1.7\" rootgrp . timestamp = str ( np . datetime64 ( timestamp )) # time informations rootgrp . createDimension ( \"time\" , None ) rootgrp . createVariable ( \"time\" , \"f8\" ,( \"time\" ,)) rootgrp . variables [ \"time\" ] . units = f \"hours since { timestamp } \" rootgrp . variables [ \"time\" ] . calendar = \"standard\" rootgrp . variables [ \"time\" ] . long_name = \"observation_time\" # y informations rootgrp . createDimension ( \"y\" , y_values . __len__ ()) rootgrp . createVariable ( \"y\" , \"f4\" ,( \"y\" ,)) rootgrp . variables [ \"y\" ] . units = \"1\" rootgrp . variables [ \"y\" ] . long_name = \"projection_y_coordinate\" rootgrp . variables [ \"y\" ][:] = y_values # x informations rootgrp . createDimension ( \"x\" , x_values . __len__ ()) rootgrp . createVariable ( \"x\" , \"f4\" ,( \"x\" ,)) rootgrp . variables [ \"x\" ] . units = \"1\" rootgrp . variables [ \"x\" ] . long_name = \"projection_x_coordinate\" rootgrp . variables [ \"x\" ][:] = x_values ''' # module information rootgrp.createVariable(\"module\",\"f4\",(\"time\",\"y\",\"x\",), fill_value=np.nan,zlib=True,least_significant_digit=3) rootgrp.variables[\"module\"].units=\"1\" rootgrp.variables[\"module\"].long_name=\"module_of_relativie_displacement\" # angle informations rootgrp.createVariable(\"angle\",\"f4\",(\"time\",\"y\",\"x\",), fill_value=np.nan,zlib=True,least_significant_digit=2) rootgrp.variables[\"angle\"].units=\"radians\" rootgrp.variables[\"angle\"].long_name=\"versor_of_relative_displacement\" ''' # ns (north-south) informations rootgrp . createVariable ( \"ns\" , \"f4\" ,( \"time\" , \"y\" , \"x\" ,), fill_value = np . nan , zlib = True , least_significant_digit = 3 ) rootgrp . variables [ \"ns\" ] . units = \"px\" rootgrp . variables [ \"ns\" ] . long_name = \"north_south_axis_displacement\" # ew (east-west) informations rootgrp . createVariable ( \"ew\" , \"f4\" ,( \"time\" , \"y\" , \"x\" ,), fill_value = np . nan , zlib = True , least_significant_digit = 3 ) rootgrp . variables [ \"ew\" ] . units = \"px\" rootgrp . variables [ \"ew\" ] . long_name = \"east_west_axis_displacement\" # corr (correlation coefficient) informations rootgrp . createVariable ( \"corr\" , \"f4\" ,( \"time\" , \"y\" , \"x\" ,), fill_value = np . nan , zlib = True , least_significant_digit = 3 ) rootgrp . variables [ \"corr\" ] . units = \"1\" rootgrp . variables [ \"corr\" ] . long_name = \"correlation_coefficient\" rootgrp . close () self . dataset = Dataset ( targetfile , 'a' , format = \"NETCDF4\" ) # CLASS METHOD def _prepare_frames ( fileNS = None , fileEW = None , fileCORR = None ): NS = pd . read_csv ( fileNS , header = None ) EW = pd . read_csv ( fileEW , header = None ) CORR = pd . read_csv ( fileCORR , header = None ) #MO = np.sqrt(NS**2 + EW**2) #AN = np.arctan2(NS,EW) return { \"ns\" : NS , \"ew\" : EW , \"corr\" : CORR } #return {\"module\":MO,\"angle\":AN, \"corr\":CORR} def _append_data ( self , time , ** kwargs ): \"\"\" Appende i grid al file netCDF rootgrp: Struttura NetCDF time: timestamp del dato var: variablile da riempire value: grid da appendere \"\"\" dataset = self . dataset time = date2num ( time , dataset . variables [ 'time' ] . units ) position = np . where ( dataset . variables [ 'time' ] == time ) try : position = int ( position [ 0 ]) except TypeError : position = dataset . variables [ 'time' ] . shape [ 0 ] dataset . variables [ 'time' ][ position ] = time for var , val in kwargs . items (): val . index = dataset [ 'y' ][:] . data val . columns = dataset [ 'x' ][:] . data dataset . variables [ var ][ position ,:,:] = val return dataset def coalesce_files ( self , time = None , fileNS = None , fileEW = None , fileCORR = None ): frames = NCMangler . _prepare_frames ( fileNS = fileNS , fileEW = fileEW , fileCORR = fileCORR ) self . _append_data ( time , ** frames ) return self def close ( self ): self . dataset . close () def agoodtime ( t ): try : t = np . datetime64 ( t ) assert not np . isnat ( t ) t = str ( t ) except Exception : t = None return t Functions agoodtime def agoodtime ( t ) View Source def agoodtime ( t ): try : t = np . datetime64 ( t ) assert not np . isnat ( t ) t = str ( t ) except Exception : t = None return t Classes NCMangler class NCMangler ( targetfile , timestamp , height , width , step_size = 8 , window_size_change = 0 , transform = None , crs = None , ** kwargs ) View Source class NCMangler () : def __init__ ( self , targetfile , timestamp , height , width , step_size = 8 , window_size_change = 0 , transform = None , crs = None , ** kwargs ) : \"\"\" Crea il file netCDF secondo un formato standard returns: la struttura dati del file NetCDF params name: nome del file y_values: dimensione delle y x_values: dimensione delle x refitime: tempo zero \"\"\" if not os . path . exists ( targetfile ) : height = float ( height ) width = float ( width ) window_size_change = float ( window_size_change ) step_size = float ( step_size ) ydim = ( height - window_size_change * 2 ) / step_size xdim = ( width - window_size_change * 2 ) / step_size x_values = np . arange ( window_size_change , xdim ) * step_size * transform [ 0 ]+ transform [ 2 ] y_values = np . arange ( window_size_change , ydim ) * step_size * transform [ 3 ]+ transform [ 5 ] rootgrp = Dataset ( targetfile , 'w' , format = \"NETCDF4\" ) rootgrp . Conventions = \"CF-1.7\" rootgrp . timestamp = str ( np . datetime64 ( timestamp )) # time informations rootgrp . createDimension ( \"time\" , None ) rootgrp . createVariable ( \"time\" , \"f8\" ,( \"time\" ,)) rootgrp . variables [ \"time\" ] . units = f \"hours since {timestamp}\" rootgrp . variables [ \"time\" ] . calendar = \"standard\" rootgrp . variables [ \"time\" ] . long_name = \"observation_time\" # y informations rootgrp . createDimension ( \"y\" , y_values . __len__ ()) rootgrp . createVariable ( \"y\" , \"f4\" ,( \"y\" ,)) rootgrp . variables [ \"y\" ] . units = \"1\" rootgrp . variables [ \"y\" ] . long_name = \"projection_y_coordinate\" rootgrp . variables [ \"y\" ][ : ]= y_values # x informations rootgrp . createDimension ( \"x\" , x_values . __len__ ()) rootgrp . createVariable ( \"x\" , \"f4\" ,( \"x\" ,)) rootgrp . variables [ \"x\" ] . units = \"1\" rootgrp . variables [ \"x\" ] . long_name = \"projection_x_coordinate\" rootgrp . variables [ \"x\" ][ : ]= x_values ''' # module information rootgrp.createVariable(\"module\",\"f4\",(\"time\",\"y\",\"x\",), fill_value=np.nan,zlib=True,least_significant_digit=3) rootgrp.variables[\"module\"].units=\"1\" rootgrp.variables[\"module\"].long_name=\"module_of_relativie_displacement\" # angle informations rootgrp.createVariable(\"angle\",\"f4\",(\"time\",\"y\",\"x\",), fill_value=np.nan,zlib=True,least_significant_digit=2) rootgrp.variables[\"angle\"].units=\"radians\" rootgrp.variables[\"angle\"].long_name=\"versor_of_relative_displacement\" ''' # ns ( north - south ) informations rootgrp . createVariable ( \"ns\" , \"f4\" ,( \"time\" , \"y\" , \"x\" ,), fill_value = np . nan , zlib = True , least_significant_digit = 3 ) rootgrp . variables [ \"ns\" ] . units = \"px\" rootgrp . variables [ \"ns\" ] . long_name = \"north_south_axis_displacement\" # ew ( east - west ) informations rootgrp . createVariable ( \"ew\" , \"f4\" ,( \"time\" , \"y\" , \"x\" ,), fill_value = np . nan , zlib = True , least_significant_digit = 3 ) rootgrp . variables [ \"ew\" ] . units = \"px\" rootgrp . variables [ \"ew\" ] . long_name = \"east_west_axis_displacement\" # corr ( correlation coefficient ) informations rootgrp . createVariable ( \"corr\" , \"f4\" ,( \"time\" , \"y\" , \"x\" ,), fill_value = np . nan , zlib = True , least_significant_digit = 3 ) rootgrp . variables [ \"corr\" ] . units = \"1\" rootgrp . variables [ \"corr\" ] . long_name = \"correlation_coefficient\" rootgrp . close () self . dataset = Dataset ( targetfile , 'a' , format = \"NETCDF4\" ) # CLASS METHOD def _prepare_frames ( fileNS = None , fileEW = None , fileCORR = None ) : NS = pd . read_csv ( fileNS , header = None ) EW = pd . read_csv ( fileEW , header = None ) CORR = pd . read_csv ( fileCORR , header = None ) #MO = np . sqrt ( NS ** 2 + EW ** 2 ) #AN = np . arctan2 ( NS , EW ) return { \"ns\" : NS , \"ew\" : EW , \"corr\" : CORR } #return { \"module\" : MO , \"angle\" : AN , \"corr\" : CORR } def _append_data ( self , time , ** kwargs ) : \"\"\" Appende i grid al file netCDF rootgrp: Struttura NetCDF time: timestamp del dato var: variablile da riempire value: grid da appendere \"\"\" dataset = self . dataset time = date2num ( time , dataset . variables [ 'time' ] . units ) position = np . where ( dataset . variables [ 'time' ] == time ) try : position = int ( position [ 0 ] ) except TypeError : position = dataset . variables [ 'time' ] . shape [ 0 ] dataset . variables [ 'time' ][ position ]= time for var , val in kwargs . items () : val . index = dataset [ 'y' ][ : ] . data val . columns = dataset [ 'x' ][ : ] . data dataset . variables [ var ][ position,:,: ] = val return dataset def coalesce_files ( self , time = None , fileNS = None , fileEW = None , fileCORR = None ) : frames = NCMangler . _prepare_frames ( fileNS = fileNS , fileEW = fileEW , fileCORR = fileCORR ) self . _append_data ( time , ** frames ) return self def close ( self ) : self . dataset . close () Methods close def close ( self ) View Source def close ( self ): self . dataset . close () coalesce_files def coalesce_files ( self , time = None , fileNS = None , fileEW = None , fileCORR = None ) View Source def coalesce_files ( self , time = None , fileNS = None , fileEW = None , fileCORR = None ): frames = NCMangler . _prepare_frames ( fileNS = fileNS , fileEW = fileEW , fileCORR = fileCORR ) self . _append_data ( time , ** frames ) return self","title":"Ncmangle"},{"location":"reference/hielen2/ext/source_photomonitoring/ncmangle/#module-hielen2extsource_photomonitoringncmangle","text":"View Source # coding: utf-8 import numpy as np import pandas as pd import re from netCDF4 import Dataset , date2num import os ''' timestamp = fields.Str(required=True, allow_none=False) master_image = fileds.Str(required=True, allow_none=False) step_size = fields.Str(required=False, default=\"8\") window_size_change = fields.Str(required=False,default=\"0\") world_file = fields.Str(required=False,default=None) crs: \"EPSG:3857\" {'driver': 'GTiff', 'dtype': 'uint16', 'nodata': 0.0, 'width': 3545, 'height': 1842, 'count': 1, 'crs': CRS.from_epsg(32622), 'transform': Affine(15.0, 0.0, 464947.5, 0.0, -15.0, 7977067.5)} ''' class NCMangler (): def __init__ ( self , targetfile , timestamp , height , width , step_size = 8 , window_size_change = 0 , transform = None , crs = None , ** kwargs ): \"\"\" Crea il file netCDF secondo un formato standard returns: la struttura dati del file NetCDF params name: nome del file y_values: dimensione delle y x_values: dimensione delle x refitime: tempo zero \"\"\" if not os . path . exists ( targetfile ): height = float ( height ) width = float ( width ) window_size_change = float ( window_size_change ) step_size = float ( step_size ) ydim = ( height - window_size_change * 2 ) / step_size xdim = ( width - window_size_change * 2 ) / step_size x_values = np . arange ( window_size_change , xdim ) * step_size * transform [ 0 ] + transform [ 2 ] y_values = np . arange ( window_size_change , ydim ) * step_size * transform [ 3 ] + transform [ 5 ] rootgrp = Dataset ( targetfile , 'w' , format = \"NETCDF4\" ) rootgrp . Conventions = \"CF-1.7\" rootgrp . timestamp = str ( np . datetime64 ( timestamp )) # time informations rootgrp . createDimension ( \"time\" , None ) rootgrp . createVariable ( \"time\" , \"f8\" ,( \"time\" ,)) rootgrp . variables [ \"time\" ] . units = f \"hours since { timestamp } \" rootgrp . variables [ \"time\" ] . calendar = \"standard\" rootgrp . variables [ \"time\" ] . long_name = \"observation_time\" # y informations rootgrp . createDimension ( \"y\" , y_values . __len__ ()) rootgrp . createVariable ( \"y\" , \"f4\" ,( \"y\" ,)) rootgrp . variables [ \"y\" ] . units = \"1\" rootgrp . variables [ \"y\" ] . long_name = \"projection_y_coordinate\" rootgrp . variables [ \"y\" ][:] = y_values # x informations rootgrp . createDimension ( \"x\" , x_values . __len__ ()) rootgrp . createVariable ( \"x\" , \"f4\" ,( \"x\" ,)) rootgrp . variables [ \"x\" ] . units = \"1\" rootgrp . variables [ \"x\" ] . long_name = \"projection_x_coordinate\" rootgrp . variables [ \"x\" ][:] = x_values ''' # module information rootgrp.createVariable(\"module\",\"f4\",(\"time\",\"y\",\"x\",), fill_value=np.nan,zlib=True,least_significant_digit=3) rootgrp.variables[\"module\"].units=\"1\" rootgrp.variables[\"module\"].long_name=\"module_of_relativie_displacement\" # angle informations rootgrp.createVariable(\"angle\",\"f4\",(\"time\",\"y\",\"x\",), fill_value=np.nan,zlib=True,least_significant_digit=2) rootgrp.variables[\"angle\"].units=\"radians\" rootgrp.variables[\"angle\"].long_name=\"versor_of_relative_displacement\" ''' # ns (north-south) informations rootgrp . createVariable ( \"ns\" , \"f4\" ,( \"time\" , \"y\" , \"x\" ,), fill_value = np . nan , zlib = True , least_significant_digit = 3 ) rootgrp . variables [ \"ns\" ] . units = \"px\" rootgrp . variables [ \"ns\" ] . long_name = \"north_south_axis_displacement\" # ew (east-west) informations rootgrp . createVariable ( \"ew\" , \"f4\" ,( \"time\" , \"y\" , \"x\" ,), fill_value = np . nan , zlib = True , least_significant_digit = 3 ) rootgrp . variables [ \"ew\" ] . units = \"px\" rootgrp . variables [ \"ew\" ] . long_name = \"east_west_axis_displacement\" # corr (correlation coefficient) informations rootgrp . createVariable ( \"corr\" , \"f4\" ,( \"time\" , \"y\" , \"x\" ,), fill_value = np . nan , zlib = True , least_significant_digit = 3 ) rootgrp . variables [ \"corr\" ] . units = \"1\" rootgrp . variables [ \"corr\" ] . long_name = \"correlation_coefficient\" rootgrp . close () self . dataset = Dataset ( targetfile , 'a' , format = \"NETCDF4\" ) # CLASS METHOD def _prepare_frames ( fileNS = None , fileEW = None , fileCORR = None ): NS = pd . read_csv ( fileNS , header = None ) EW = pd . read_csv ( fileEW , header = None ) CORR = pd . read_csv ( fileCORR , header = None ) #MO = np.sqrt(NS**2 + EW**2) #AN = np.arctan2(NS,EW) return { \"ns\" : NS , \"ew\" : EW , \"corr\" : CORR } #return {\"module\":MO,\"angle\":AN, \"corr\":CORR} def _append_data ( self , time , ** kwargs ): \"\"\" Appende i grid al file netCDF rootgrp: Struttura NetCDF time: timestamp del dato var: variablile da riempire value: grid da appendere \"\"\" dataset = self . dataset time = date2num ( time , dataset . variables [ 'time' ] . units ) position = np . where ( dataset . variables [ 'time' ] == time ) try : position = int ( position [ 0 ]) except TypeError : position = dataset . variables [ 'time' ] . shape [ 0 ] dataset . variables [ 'time' ][ position ] = time for var , val in kwargs . items (): val . index = dataset [ 'y' ][:] . data val . columns = dataset [ 'x' ][:] . data dataset . variables [ var ][ position ,:,:] = val return dataset def coalesce_files ( self , time = None , fileNS = None , fileEW = None , fileCORR = None ): frames = NCMangler . _prepare_frames ( fileNS = fileNS , fileEW = fileEW , fileCORR = fileCORR ) self . _append_data ( time , ** frames ) return self def close ( self ): self . dataset . close () def agoodtime ( t ): try : t = np . datetime64 ( t ) assert not np . isnat ( t ) t = str ( t ) except Exception : t = None return t","title":"Module hielen2.ext.source_photomonitoring.ncmangle"},{"location":"reference/hielen2/ext/source_photomonitoring/ncmangle/#functions","text":"","title":"Functions"},{"location":"reference/hielen2/ext/source_photomonitoring/ncmangle/#agoodtime","text":"def agoodtime ( t ) View Source def agoodtime ( t ): try : t = np . datetime64 ( t ) assert not np . isnat ( t ) t = str ( t ) except Exception : t = None return t","title":"agoodtime"},{"location":"reference/hielen2/ext/source_photomonitoring/ncmangle/#classes","text":"","title":"Classes"},{"location":"reference/hielen2/ext/source_photomonitoring/ncmangle/#ncmangler","text":"class NCMangler ( targetfile , timestamp , height , width , step_size = 8 , window_size_change = 0 , transform = None , crs = None , ** kwargs ) View Source class NCMangler () : def __init__ ( self , targetfile , timestamp , height , width , step_size = 8 , window_size_change = 0 , transform = None , crs = None , ** kwargs ) : \"\"\" Crea il file netCDF secondo un formato standard returns: la struttura dati del file NetCDF params name: nome del file y_values: dimensione delle y x_values: dimensione delle x refitime: tempo zero \"\"\" if not os . path . exists ( targetfile ) : height = float ( height ) width = float ( width ) window_size_change = float ( window_size_change ) step_size = float ( step_size ) ydim = ( height - window_size_change * 2 ) / step_size xdim = ( width - window_size_change * 2 ) / step_size x_values = np . arange ( window_size_change , xdim ) * step_size * transform [ 0 ]+ transform [ 2 ] y_values = np . arange ( window_size_change , ydim ) * step_size * transform [ 3 ]+ transform [ 5 ] rootgrp = Dataset ( targetfile , 'w' , format = \"NETCDF4\" ) rootgrp . Conventions = \"CF-1.7\" rootgrp . timestamp = str ( np . datetime64 ( timestamp )) # time informations rootgrp . createDimension ( \"time\" , None ) rootgrp . createVariable ( \"time\" , \"f8\" ,( \"time\" ,)) rootgrp . variables [ \"time\" ] . units = f \"hours since {timestamp}\" rootgrp . variables [ \"time\" ] . calendar = \"standard\" rootgrp . variables [ \"time\" ] . long_name = \"observation_time\" # y informations rootgrp . createDimension ( \"y\" , y_values . __len__ ()) rootgrp . createVariable ( \"y\" , \"f4\" ,( \"y\" ,)) rootgrp . variables [ \"y\" ] . units = \"1\" rootgrp . variables [ \"y\" ] . long_name = \"projection_y_coordinate\" rootgrp . variables [ \"y\" ][ : ]= y_values # x informations rootgrp . createDimension ( \"x\" , x_values . __len__ ()) rootgrp . createVariable ( \"x\" , \"f4\" ,( \"x\" ,)) rootgrp . variables [ \"x\" ] . units = \"1\" rootgrp . variables [ \"x\" ] . long_name = \"projection_x_coordinate\" rootgrp . variables [ \"x\" ][ : ]= x_values ''' # module information rootgrp.createVariable(\"module\",\"f4\",(\"time\",\"y\",\"x\",), fill_value=np.nan,zlib=True,least_significant_digit=3) rootgrp.variables[\"module\"].units=\"1\" rootgrp.variables[\"module\"].long_name=\"module_of_relativie_displacement\" # angle informations rootgrp.createVariable(\"angle\",\"f4\",(\"time\",\"y\",\"x\",), fill_value=np.nan,zlib=True,least_significant_digit=2) rootgrp.variables[\"angle\"].units=\"radians\" rootgrp.variables[\"angle\"].long_name=\"versor_of_relative_displacement\" ''' # ns ( north - south ) informations rootgrp . createVariable ( \"ns\" , \"f4\" ,( \"time\" , \"y\" , \"x\" ,), fill_value = np . nan , zlib = True , least_significant_digit = 3 ) rootgrp . variables [ \"ns\" ] . units = \"px\" rootgrp . variables [ \"ns\" ] . long_name = \"north_south_axis_displacement\" # ew ( east - west ) informations rootgrp . createVariable ( \"ew\" , \"f4\" ,( \"time\" , \"y\" , \"x\" ,), fill_value = np . nan , zlib = True , least_significant_digit = 3 ) rootgrp . variables [ \"ew\" ] . units = \"px\" rootgrp . variables [ \"ew\" ] . long_name = \"east_west_axis_displacement\" # corr ( correlation coefficient ) informations rootgrp . createVariable ( \"corr\" , \"f4\" ,( \"time\" , \"y\" , \"x\" ,), fill_value = np . nan , zlib = True , least_significant_digit = 3 ) rootgrp . variables [ \"corr\" ] . units = \"1\" rootgrp . variables [ \"corr\" ] . long_name = \"correlation_coefficient\" rootgrp . close () self . dataset = Dataset ( targetfile , 'a' , format = \"NETCDF4\" ) # CLASS METHOD def _prepare_frames ( fileNS = None , fileEW = None , fileCORR = None ) : NS = pd . read_csv ( fileNS , header = None ) EW = pd . read_csv ( fileEW , header = None ) CORR = pd . read_csv ( fileCORR , header = None ) #MO = np . sqrt ( NS ** 2 + EW ** 2 ) #AN = np . arctan2 ( NS , EW ) return { \"ns\" : NS , \"ew\" : EW , \"corr\" : CORR } #return { \"module\" : MO , \"angle\" : AN , \"corr\" : CORR } def _append_data ( self , time , ** kwargs ) : \"\"\" Appende i grid al file netCDF rootgrp: Struttura NetCDF time: timestamp del dato var: variablile da riempire value: grid da appendere \"\"\" dataset = self . dataset time = date2num ( time , dataset . variables [ 'time' ] . units ) position = np . where ( dataset . variables [ 'time' ] == time ) try : position = int ( position [ 0 ] ) except TypeError : position = dataset . variables [ 'time' ] . shape [ 0 ] dataset . variables [ 'time' ][ position ]= time for var , val in kwargs . items () : val . index = dataset [ 'y' ][ : ] . data val . columns = dataset [ 'x' ][ : ] . data dataset . variables [ var ][ position,:,: ] = val return dataset def coalesce_files ( self , time = None , fileNS = None , fileEW = None , fileCORR = None ) : frames = NCMangler . _prepare_frames ( fileNS = fileNS , fileEW = fileEW , fileCORR = fileCORR ) self . _append_data ( time , ** frames ) return self def close ( self ) : self . dataset . close ()","title":"NCMangler"},{"location":"reference/hielen2/ext/source_photomonitoring/ncmangle/#methods","text":"","title":"Methods"},{"location":"reference/hielen2/ext/source_photomonitoring/ncmangle/#close","text":"def close ( self ) View Source def close ( self ): self . dataset . close ()","title":"close"},{"location":"reference/hielen2/ext/source_photomonitoring/ncmangle/#coalesce_files","text":"def coalesce_files ( self , time = None , fileNS = None , fileEW = None , fileCORR = None ) View Source def coalesce_files ( self , time = None , fileNS = None , fileEW = None , fileCORR = None ): frames = NCMangler . _prepare_frames ( fileNS = fileNS , fileEW = fileEW , fileCORR = fileCORR ) self . _append_data ( time , ** frames ) return self","title":"coalesce_files"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/","text":"Module hielen2.ext.source_photomonitoring.phm View Source # coding = utf - 8 from hielen2 . source import HielenSource , ActionSchema from hielen2 . utils import LocalFile import rasterio import magic import os import re from pathlib import Path from . ncmangle import NCMangler from marshmallow import fields class ConfigSchema ( ActionSchema ) : master_image = LocalFile ( required = True , allow_none = False ) step_size = fields . Str ( required = False , default= \"8\" ) window_size_change = fields . Str ( required = False , default= \"0\" ) geo_reference_file = LocalFile ( required = False , default = None ) crs = fields . Str ( required = False , default = None ) class FeedSchema ( ActionSchema ) : reference_time = fields . Str ( required = False , allow_none = False ) NS_displacement = LocalFile ( required = False , allow_none = False ) EW_displacement = LocalFile ( required = False , allow_none = False ) Coer = LocalFile ( required = False , allow_none = False ) class Source ( HielenSource ) : ''' def __init__(self, feature, filecache): self.__dict__.update(feature.pop('properties')) self.geometry=feature.pop('geometry') self.actions=feature self.filecache = os.path.join(filecache,self.uid) os.makedirs(self.filecache, exist_ok=True) ''' def config ( self , **kwargs ) : out= {} path_tempimage = Path ( kwargs [ \"master_image\" ]) path_tempref = kwargs [ \"geo_reference_file\" ] refpath = self . makeCachePath ( re . sub ( \" [ ^\\d ] \",\"\",kwargs['timestamp']) ) path_masterimage=Path(refpath) / \" master . img \" path_masternetcdf=Path(refpath) / \" master . nc \" path_georef=None try: name=str(path_tempimage).split(\" . \") with open(path_tempref) as trf: try: float(trf.readline()) path_georef=Path(\" . \".join([*name[0:-1],\" wld \"])) except Exception as e: path_georef=Path(\" . \".join([*name,\" aux \",\" xml \" ])) Path ( path_tempref ). replace ( path_georef ) except Exception as e : pass try : crs = rasterio . crs . CRS . from_string ( kwargs [ 'crs' ]) except Exception : crs = None with rasterio . open ( path_tempimage ) as src : meta = src . meta . copy () if crs is not None : meta . update ({ 'crs': crs }) with rasterio . open ( path_masterimage , 'w' , **meta ) as dst : for i in range ( 1 , src . count + 1 ) : dst . write ( src . read ( i ), i ) out [ 'master_image' ] = magic . from_file ( str ( path_masterimage )) out [ 'timestamp' ] = kwargs [ 'timestamp' ] out [ 'step_size' ] = kwargs [ 'step_size' ] out [ 'window_size_change' ] = kwargs [ 'window_size_change' ] out [ 'transform' ] = list ( meta [ 'transform' ])[ 0 : 6 ] out [ 'cache' ] = self . getRelativePath ( refpath ) try : out [ 'crs' ] = meta [ 'crs' ]. to_string () except AttributeError : out [ 'crs' ] = None #nc = NCMangler ( path_masternetcdf , **out ) return out def feed ( self , **kwargs ) : return kwargs def data ( self , timefrom = None , timeto = None , geom = None , **kwargs ) : return kwargs Classes ConfigSchema class ConfigSchema ( * , only : Union [ Sequence [ str ], Set [ str ], NoneType ] = None , exclude : Union [ Sequence [ str ], Set [ str ]] = (), many : bool = False , context : Union [ Dict , NoneType ] = None , load_only : Union [ Sequence [ str ], Set [ str ]] = (), dump_only : Union [ Sequence [ str ], Set [ str ]] = (), partial : Union [ bool , Sequence [ str ], Set [ str ]] = False , unknown : Union [ str , NoneType ] = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): master_image = LocalFile ( required = True , allow_none = False ) step_size = fields . Str ( required = False , default = \"8\" ) window_size_change = fields . Str ( required = False , default = \"0\" ) geo_reference_file = LocalFile ( required = False , default = None ) crs = fields . Str ( required = False , default = None ) Ancestors (in MRO) hielen2.source.ActionSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING crs error_messages geo_reference_file master_image opts step_size window_size_change Static methods from_dict def from_dict ( fields : Dict [ str , Union [ marshmallow . fields . Field , type ]], * , name : str = 'GeneratedSchema' ) -> type Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 View Source @classmethod def from_dict ( cls , fields : typing . Dict [ str , typing . Union [ ma_fields . Field , type ]], * , name : str = \"GeneratedSchema\" ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : Any , * , many : Union [ bool , NoneType ] = None ) Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : typing . Optional [ bool ] = None ): \"\"\"Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\"\" many = self . many if many is None else bool ( many ) if many and is_iterable_but_not_string ( obj ): obj = list ( obj ) if self . _has_processors ( PRE_DUMP ): processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ): result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : Any , * args , many : Union [ bool , NoneType ] = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A json string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : typing . Optional [ bool ] = None , ** kwargs ): \"\"\"Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\"\" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : Any , attr : str , default : Any ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ): \"\"\"Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\"\" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : marshmallow . exceptions . ValidationError , data : Any , * , many : bool , ** kwargs ) Custom error handler function for the schema. :param error: The ValidationError raised during (de)serialization. :param data: The original input data. :param many: Value of many on dump or load. :param partial: Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ): \"\"\"Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\"\" pass load def load ( self , data : Union [ Mapping [ str , Any ], Iterable [ Mapping [ str , Any ]]], * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None ) Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : typing . Union [ typing . Mapping [ str , typing . Any ], typing . Iterable [ typing . Mapping [ str , typing . Any ]], ], * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None ): \"\"\"Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : str , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize obj as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None , ** kwargs ): \"\"\"Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : str , field_obj : marshmallow . fields . Field ) -> None Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \"\"\"Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\"\" return None validate def validate ( self , data : Mapping , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None ) -> Dict [ str , List [ str ]] Validate data against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : typing . Mapping , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None ) -> typing . Dict [ str , typing . List [ str ]]: \"\"\"Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\"\" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]], exc . messages ) return {} FeedSchema class FeedSchema ( * , only : Union [ Sequence [ str ], Set [ str ], NoneType ] = None , exclude : Union [ Sequence [ str ], Set [ str ]] = (), many : bool = False , context : Union [ Dict , NoneType ] = None , load_only : Union [ Sequence [ str ], Set [ str ]] = (), dump_only : Union [ Sequence [ str ], Set [ str ]] = (), partial : Union [ bool , Sequence [ str ], Set [ str ]] = False , unknown : Union [ str , NoneType ] = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class FeedSchema ( ActionSchema ): reference_time = fields . Str ( required = False , allow_none = False ) NS_displacement = LocalFile ( required = False , allow_none = False ) EW_displacement = LocalFile ( required = False , allow_none = False ) Coer = LocalFile ( required = False , allow_none = False ) Ancestors (in MRO) hielen2.source.ActionSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Coer EW_displacement Meta NS_displacement OPTIONS_CLASS TYPE_MAPPING error_messages opts reference_time Static methods from_dict def from_dict ( fields : Dict [ str , Union [ marshmallow . fields . Field , type ]], * , name : str = 'GeneratedSchema' ) -> type Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 View Source @classmethod def from_dict ( cls , fields : typing . Dict [ str , typing . Union [ ma_fields . Field , type ]], * , name : str = \"GeneratedSchema\" ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : Any , * , many : Union [ bool , NoneType ] = None ) Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : typing . Optional [ bool ] = None ): \"\"\"Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\"\" many = self . many if many is None else bool ( many ) if many and is_iterable_but_not_string ( obj ): obj = list ( obj ) if self . _has_processors ( PRE_DUMP ): processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ): result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : Any , * args , many : Union [ bool , NoneType ] = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A json string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : typing . Optional [ bool ] = None , ** kwargs ): \"\"\"Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\"\" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : Any , attr : str , default : Any ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ): \"\"\"Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\"\" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : marshmallow . exceptions . ValidationError , data : Any , * , many : bool , ** kwargs ) Custom error handler function for the schema. :param error: The ValidationError raised during (de)serialization. :param data: The original input data. :param many: Value of many on dump or load. :param partial: Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ): \"\"\"Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\"\" pass load def load ( self , data : Union [ Mapping [ str , Any ], Iterable [ Mapping [ str , Any ]]], * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None ) Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : typing . Union [ typing . Mapping [ str , typing . Any ], typing . Iterable [ typing . Mapping [ str , typing . Any ]], ], * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None ): \"\"\"Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : str , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize obj as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None , ** kwargs ): \"\"\"Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : str , field_obj : marshmallow . fields . Field ) -> None Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \"\"\"Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\"\" return None validate def validate ( self , data : Mapping , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None ) -> Dict [ str , List [ str ]] Validate data against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : typing . Mapping , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None ) -> typing . Dict [ str , typing . List [ str ]]: \"\"\"Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\"\" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]], exc . messages ) return {} Source class Source ( feature , filecache ) def init (self, feature, filecache): self. dict .update(feature.pop('properties')) self.geometry=feature.pop('geometry') self.actions=feature self.filecache = os.path.join(filecache,self.uid) os.makedirs(self.filecache, exist_ok=True) View Source class Source ( HielenSource ) : ''' def __init__(self, feature, filecache): self.__dict__.update(feature.pop('properties')) self.geometry=feature.pop('geometry') self.actions=feature self.filecache = os.path.join(filecache,self.uid) os.makedirs(self.filecache, exist_ok=True) ''' def config ( self , **kwargs ) : out= {} path_tempimage = Path ( kwargs [ \"master_image\" ]) path_tempref = kwargs [ \"geo_reference_file\" ] refpath = self . makeCachePath ( re . sub ( \" [ ^\\d ] \",\"\",kwargs['timestamp']) ) path_masterimage=Path(refpath) / \" master . img \" path_masternetcdf=Path(refpath) / \" master . nc \" path_georef=None try: name=str(path_tempimage).split(\" . \") with open(path_tempref) as trf: try: float(trf.readline()) path_georef=Path(\" . \".join([*name[0:-1],\" wld \"])) except Exception as e: path_georef=Path(\" . \".join([*name,\" aux \",\" xml \" ])) Path ( path_tempref ). replace ( path_georef ) except Exception as e : pass try : crs = rasterio . crs . CRS . from_string ( kwargs [ 'crs' ]) except Exception : crs = None with rasterio . open ( path_tempimage ) as src : meta = src . meta . copy () if crs is not None : meta . update ({ 'crs': crs }) with rasterio . open ( path_masterimage , 'w' , **meta ) as dst : for i in range ( 1 , src . count + 1 ) : dst . write ( src . read ( i ), i ) out [ 'master_image' ] = magic . from_file ( str ( path_masterimage )) out [ 'timestamp' ] = kwargs [ 'timestamp' ] out [ 'step_size' ] = kwargs [ 'step_size' ] out [ 'window_size_change' ] = kwargs [ 'window_size_change' ] out [ 'transform' ] = list ( meta [ 'transform' ])[ 0 : 6 ] out [ 'cache' ] = self . getRelativePath ( refpath ) try : out [ 'crs' ] = meta [ 'crs' ]. to_string () except AttributeError : out [ 'crs' ] = None #nc = NCMangler ( path_masternetcdf , **out ) return out def feed ( self , **kwargs ) : return kwargs def data ( self , timefrom = None , timeto = None , geom = None , **kwargs ) : return kwargs Ancestors (in MRO) hielen2.source.HielenSource abc.ABC Methods config def config ( self , ** kwargs ) View Source def config ( self , **kwargs ) : out= {} path_tempimage = Path ( kwargs [ \"master_image\" ]) path_tempref = kwargs [ \"geo_reference_file\" ] refpath = self . makeCachePath ( re . sub ( \" [ ^\\d ] \",\"\",kwargs['timestamp']) ) path_masterimage=Path(refpath) / \" master . img \" path_masternetcdf=Path(refpath) / \" master . nc \" path_georef=None try: name=str(path_tempimage).split(\" . \") with open(path_tempref) as trf: try: float(trf.readline()) path_georef=Path(\" . \".join([*name[0:-1],\" wld \"])) except Exception as e: path_georef=Path(\" . \".join([*name,\" aux \",\" xml \" ])) Path ( path_tempref ). replace ( path_georef ) except Exception as e : pass try : crs = rasterio . crs . CRS . from_string ( kwargs [ 'crs' ]) except Exception : crs = None with rasterio . open ( path_tempimage ) as src : meta = src . meta . copy () if crs is not None : meta . update ({ 'crs': crs }) with rasterio . open ( path_masterimage , 'w' , **meta ) as dst : for i in range ( 1 , src . count + 1 ) : dst . write ( src . read ( i ), i ) out [ 'master_image' ] = magic . from_file ( str ( path_masterimage )) out [ 'timestamp' ] = kwargs [ 'timestamp' ] out [ 'step_size' ] = kwargs [ 'step_size' ] out [ 'window_size_change' ] = kwargs [ 'window_size_change' ] out [ 'transform' ] = list ( meta [ 'transform' ])[ 0 : 6 ] out [ 'cache' ] = self . getRelativePath ( refpath ) try : out [ 'crs' ] = meta [ 'crs' ]. to_string () except AttributeError : out [ 'crs' ] = None #nc = NCMangler ( path_masternetcdf , **out ) return out data def data ( self , timefrom = None , timeto = None , geom = None , ** kwargs ) View Source def data ( self , timefrom = None , timeto = None , geom = None , ** kwargs ): return kwargs execAction def execAction ( self , action , ** kwargs ) View Source def execAction ( self , action , ** kwargs ): return self . __getattribute__ ( action )( ** kwargs ) feed def feed ( self , ** kwargs ) View Source def feed ( self , ** kwargs ): return kwargs getActionSchema def getActionSchema ( self , action ) View Source def getActionSchema ( self , action ): return getActionSchema ( self . module , action ) getActionValues def getActionValues ( self , action = None , timestamp = None ) View Source def getActionValues ( self , action = None , timestamp = None ): if action is None : action = slice ( None , None ) if timestamp is None : timestamp = slice ( None , None ) return db [ 'actions' ][ self . uid , action , timestamp ] getRelativePath def getRelativePath ( self , path ) View Source def getRelativePath ( self , path ): return path . replace ( f \"{self.filecache}/\" , \"\" ) makeCachePath def makeCachePath ( self , path ) View Source def makeCachePath ( self , path ): outpath = os . path . join ( self . filecache , path ) os . makedirs ( outpath , exist_ok = True ) return outpath","title":"Phm"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#module-hielen2extsource_photomonitoringphm","text":"View Source # coding = utf - 8 from hielen2 . source import HielenSource , ActionSchema from hielen2 . utils import LocalFile import rasterio import magic import os import re from pathlib import Path from . ncmangle import NCMangler from marshmallow import fields class ConfigSchema ( ActionSchema ) : master_image = LocalFile ( required = True , allow_none = False ) step_size = fields . Str ( required = False , default= \"8\" ) window_size_change = fields . Str ( required = False , default= \"0\" ) geo_reference_file = LocalFile ( required = False , default = None ) crs = fields . Str ( required = False , default = None ) class FeedSchema ( ActionSchema ) : reference_time = fields . Str ( required = False , allow_none = False ) NS_displacement = LocalFile ( required = False , allow_none = False ) EW_displacement = LocalFile ( required = False , allow_none = False ) Coer = LocalFile ( required = False , allow_none = False ) class Source ( HielenSource ) : ''' def __init__(self, feature, filecache): self.__dict__.update(feature.pop('properties')) self.geometry=feature.pop('geometry') self.actions=feature self.filecache = os.path.join(filecache,self.uid) os.makedirs(self.filecache, exist_ok=True) ''' def config ( self , **kwargs ) : out= {} path_tempimage = Path ( kwargs [ \"master_image\" ]) path_tempref = kwargs [ \"geo_reference_file\" ] refpath = self . makeCachePath ( re . sub ( \" [ ^\\d ] \",\"\",kwargs['timestamp']) ) path_masterimage=Path(refpath) / \" master . img \" path_masternetcdf=Path(refpath) / \" master . nc \" path_georef=None try: name=str(path_tempimage).split(\" . \") with open(path_tempref) as trf: try: float(trf.readline()) path_georef=Path(\" . \".join([*name[0:-1],\" wld \"])) except Exception as e: path_georef=Path(\" . \".join([*name,\" aux \",\" xml \" ])) Path ( path_tempref ). replace ( path_georef ) except Exception as e : pass try : crs = rasterio . crs . CRS . from_string ( kwargs [ 'crs' ]) except Exception : crs = None with rasterio . open ( path_tempimage ) as src : meta = src . meta . copy () if crs is not None : meta . update ({ 'crs': crs }) with rasterio . open ( path_masterimage , 'w' , **meta ) as dst : for i in range ( 1 , src . count + 1 ) : dst . write ( src . read ( i ), i ) out [ 'master_image' ] = magic . from_file ( str ( path_masterimage )) out [ 'timestamp' ] = kwargs [ 'timestamp' ] out [ 'step_size' ] = kwargs [ 'step_size' ] out [ 'window_size_change' ] = kwargs [ 'window_size_change' ] out [ 'transform' ] = list ( meta [ 'transform' ])[ 0 : 6 ] out [ 'cache' ] = self . getRelativePath ( refpath ) try : out [ 'crs' ] = meta [ 'crs' ]. to_string () except AttributeError : out [ 'crs' ] = None #nc = NCMangler ( path_masternetcdf , **out ) return out def feed ( self , **kwargs ) : return kwargs def data ( self , timefrom = None , timeto = None , geom = None , **kwargs ) : return kwargs","title":"Module hielen2.ext.source_photomonitoring.phm"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#classes","text":"","title":"Classes"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#configschema","text":"class ConfigSchema ( * , only : Union [ Sequence [ str ], Set [ str ], NoneType ] = None , exclude : Union [ Sequence [ str ], Set [ str ]] = (), many : bool = False , context : Union [ Dict , NoneType ] = None , load_only : Union [ Sequence [ str ], Set [ str ]] = (), dump_only : Union [ Sequence [ str ], Set [ str ]] = (), partial : Union [ bool , Sequence [ str ], Set [ str ]] = False , unknown : Union [ str , NoneType ] = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): master_image = LocalFile ( required = True , allow_none = False ) step_size = fields . Str ( required = False , default = \"8\" ) window_size_change = fields . Str ( required = False , default = \"0\" ) geo_reference_file = LocalFile ( required = False , default = None ) crs = fields . Str ( required = False , default = None )","title":"ConfigSchema"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#ancestors-in-mro","text":"hielen2.source.ActionSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING crs error_messages geo_reference_file master_image opts step_size window_size_change","title":"Class variables"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#from_dict","text":"def from_dict ( fields : Dict [ str , Union [ marshmallow . fields . Field , type ]], * , name : str = 'GeneratedSchema' ) -> type Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 View Source @classmethod def from_dict ( cls , fields : typing . Dict [ str , typing . Union [ ma_fields . Field , type ]], * , name : str = \"GeneratedSchema\" ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#instance-variables","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#methods","text":"","title":"Methods"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#dump","text":"def dump ( self , obj : Any , * , many : Union [ bool , NoneType ] = None ) Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : typing . Optional [ bool ] = None ): \"\"\"Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\"\" many = self . many if many is None else bool ( many ) if many and is_iterable_but_not_string ( obj ): obj = list ( obj ) if self . _has_processors ( PRE_DUMP ): processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ): result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#dumps","text":"def dumps ( self , obj : Any , * args , many : Union [ bool , NoneType ] = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A json string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : typing . Optional [ bool ] = None , ** kwargs ): \"\"\"Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\"\" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#get_attribute","text":"def get_attribute ( self , obj : Any , attr : str , default : Any ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ): \"\"\"Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\"\" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#handle_error","text":"def handle_error ( self , error : marshmallow . exceptions . ValidationError , data : Any , * , many : bool , ** kwargs ) Custom error handler function for the schema. :param error: The ValidationError raised during (de)serialization. :param data: The original input data. :param many: Value of many on dump or load. :param partial: Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ): \"\"\"Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\"\" pass","title":"handle_error"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#load","text":"def load ( self , data : Union [ Mapping [ str , Any ], Iterable [ Mapping [ str , Any ]]], * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None ) Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : typing . Union [ typing . Mapping [ str , typing . Any ], typing . Iterable [ typing . Mapping [ str , typing . Any ]], ], * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None ): \"\"\"Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#loads","text":"def loads ( self , json_data : str , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize obj as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None , ** kwargs ): \"\"\"Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#on_bind_field","text":"def on_bind_field ( self , field_name : str , field_obj : marshmallow . fields . Field ) -> None Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \"\"\"Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\"\" return None","title":"on_bind_field"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#validate","text":"def validate ( self , data : Mapping , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None ) -> Dict [ str , List [ str ]] Validate data against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : typing . Mapping , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None ) -> typing . Dict [ str , typing . List [ str ]]: \"\"\"Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\"\" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]], exc . messages ) return {}","title":"validate"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#feedschema","text":"class FeedSchema ( * , only : Union [ Sequence [ str ], Set [ str ], NoneType ] = None , exclude : Union [ Sequence [ str ], Set [ str ]] = (), many : bool = False , context : Union [ Dict , NoneType ] = None , load_only : Union [ Sequence [ str ], Set [ str ]] = (), dump_only : Union [ Sequence [ str ], Set [ str ]] = (), partial : Union [ bool , Sequence [ str ], Set [ str ]] = False , unknown : Union [ str , NoneType ] = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class FeedSchema ( ActionSchema ): reference_time = fields . Str ( required = False , allow_none = False ) NS_displacement = LocalFile ( required = False , allow_none = False ) EW_displacement = LocalFile ( required = False , allow_none = False ) Coer = LocalFile ( required = False , allow_none = False )","title":"FeedSchema"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#ancestors-in-mro_1","text":"hielen2.source.ActionSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#class-variables_1","text":"Coer EW_displacement Meta NS_displacement OPTIONS_CLASS TYPE_MAPPING error_messages opts reference_time","title":"Class variables"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#from_dict_1","text":"def from_dict ( fields : Dict [ str , Union [ marshmallow . fields . Field , type ]], * , name : str = 'GeneratedSchema' ) -> type Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 View Source @classmethod def from_dict ( cls , fields : typing . Dict [ str , typing . Union [ ma_fields . Field , type ]], * , name : str = \"GeneratedSchema\" ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#instance-variables_1","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#dump_1","text":"def dump ( self , obj : Any , * , many : Union [ bool , NoneType ] = None ) Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : typing . Optional [ bool ] = None ): \"\"\"Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\"\" many = self . many if many is None else bool ( many ) if many and is_iterable_but_not_string ( obj ): obj = list ( obj ) if self . _has_processors ( PRE_DUMP ): processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ): result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#dumps_1","text":"def dumps ( self , obj : Any , * args , many : Union [ bool , NoneType ] = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A json string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : typing . Optional [ bool ] = None , ** kwargs ): \"\"\"Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\"\" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#get_attribute_1","text":"def get_attribute ( self , obj : Any , attr : str , default : Any ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ): \"\"\"Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\"\" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#handle_error_1","text":"def handle_error ( self , error : marshmallow . exceptions . ValidationError , data : Any , * , many : bool , ** kwargs ) Custom error handler function for the schema. :param error: The ValidationError raised during (de)serialization. :param data: The original input data. :param many: Value of many on dump or load. :param partial: Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ): \"\"\"Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\"\" pass","title":"handle_error"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#load_1","text":"def load ( self , data : Union [ Mapping [ str , Any ], Iterable [ Mapping [ str , Any ]]], * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None ) Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : typing . Union [ typing . Mapping [ str , typing . Any ], typing . Iterable [ typing . Mapping [ str , typing . Any ]], ], * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None ): \"\"\"Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#loads_1","text":"def loads ( self , json_data : str , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize obj as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None , ** kwargs ): \"\"\"Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#on_bind_field_1","text":"def on_bind_field ( self , field_name : str , field_obj : marshmallow . fields . Field ) -> None Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \"\"\"Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\"\" return None","title":"on_bind_field"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#validate_1","text":"def validate ( self , data : Mapping , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None ) -> Dict [ str , List [ str ]] Validate data against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : typing . Mapping , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None ) -> typing . Dict [ str , typing . List [ str ]]: \"\"\"Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\"\" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]], exc . messages ) return {}","title":"validate"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#source","text":"class Source ( feature , filecache ) def init (self, feature, filecache): self. dict .update(feature.pop('properties')) self.geometry=feature.pop('geometry') self.actions=feature self.filecache = os.path.join(filecache,self.uid) os.makedirs(self.filecache, exist_ok=True) View Source class Source ( HielenSource ) : ''' def __init__(self, feature, filecache): self.__dict__.update(feature.pop('properties')) self.geometry=feature.pop('geometry') self.actions=feature self.filecache = os.path.join(filecache,self.uid) os.makedirs(self.filecache, exist_ok=True) ''' def config ( self , **kwargs ) : out= {} path_tempimage = Path ( kwargs [ \"master_image\" ]) path_tempref = kwargs [ \"geo_reference_file\" ] refpath = self . makeCachePath ( re . sub ( \" [ ^\\d ] \",\"\",kwargs['timestamp']) ) path_masterimage=Path(refpath) / \" master . img \" path_masternetcdf=Path(refpath) / \" master . nc \" path_georef=None try: name=str(path_tempimage).split(\" . \") with open(path_tempref) as trf: try: float(trf.readline()) path_georef=Path(\" . \".join([*name[0:-1],\" wld \"])) except Exception as e: path_georef=Path(\" . \".join([*name,\" aux \",\" xml \" ])) Path ( path_tempref ). replace ( path_georef ) except Exception as e : pass try : crs = rasterio . crs . CRS . from_string ( kwargs [ 'crs' ]) except Exception : crs = None with rasterio . open ( path_tempimage ) as src : meta = src . meta . copy () if crs is not None : meta . update ({ 'crs': crs }) with rasterio . open ( path_masterimage , 'w' , **meta ) as dst : for i in range ( 1 , src . count + 1 ) : dst . write ( src . read ( i ), i ) out [ 'master_image' ] = magic . from_file ( str ( path_masterimage )) out [ 'timestamp' ] = kwargs [ 'timestamp' ] out [ 'step_size' ] = kwargs [ 'step_size' ] out [ 'window_size_change' ] = kwargs [ 'window_size_change' ] out [ 'transform' ] = list ( meta [ 'transform' ])[ 0 : 6 ] out [ 'cache' ] = self . getRelativePath ( refpath ) try : out [ 'crs' ] = meta [ 'crs' ]. to_string () except AttributeError : out [ 'crs' ] = None #nc = NCMangler ( path_masternetcdf , **out ) return out def feed ( self , **kwargs ) : return kwargs def data ( self , timefrom = None , timeto = None , geom = None , **kwargs ) : return kwargs","title":"Source"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#ancestors-in-mro_2","text":"hielen2.source.HielenSource abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#methods_2","text":"","title":"Methods"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#config","text":"def config ( self , ** kwargs ) View Source def config ( self , **kwargs ) : out= {} path_tempimage = Path ( kwargs [ \"master_image\" ]) path_tempref = kwargs [ \"geo_reference_file\" ] refpath = self . makeCachePath ( re . sub ( \" [ ^\\d ] \",\"\",kwargs['timestamp']) ) path_masterimage=Path(refpath) / \" master . img \" path_masternetcdf=Path(refpath) / \" master . nc \" path_georef=None try: name=str(path_tempimage).split(\" . \") with open(path_tempref) as trf: try: float(trf.readline()) path_georef=Path(\" . \".join([*name[0:-1],\" wld \"])) except Exception as e: path_georef=Path(\" . \".join([*name,\" aux \",\" xml \" ])) Path ( path_tempref ). replace ( path_georef ) except Exception as e : pass try : crs = rasterio . crs . CRS . from_string ( kwargs [ 'crs' ]) except Exception : crs = None with rasterio . open ( path_tempimage ) as src : meta = src . meta . copy () if crs is not None : meta . update ({ 'crs': crs }) with rasterio . open ( path_masterimage , 'w' , **meta ) as dst : for i in range ( 1 , src . count + 1 ) : dst . write ( src . read ( i ), i ) out [ 'master_image' ] = magic . from_file ( str ( path_masterimage )) out [ 'timestamp' ] = kwargs [ 'timestamp' ] out [ 'step_size' ] = kwargs [ 'step_size' ] out [ 'window_size_change' ] = kwargs [ 'window_size_change' ] out [ 'transform' ] = list ( meta [ 'transform' ])[ 0 : 6 ] out [ 'cache' ] = self . getRelativePath ( refpath ) try : out [ 'crs' ] = meta [ 'crs' ]. to_string () except AttributeError : out [ 'crs' ] = None #nc = NCMangler ( path_masternetcdf , **out ) return out","title":"config"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#data","text":"def data ( self , timefrom = None , timeto = None , geom = None , ** kwargs ) View Source def data ( self , timefrom = None , timeto = None , geom = None , ** kwargs ): return kwargs","title":"data"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#execaction","text":"def execAction ( self , action , ** kwargs ) View Source def execAction ( self , action , ** kwargs ): return self . __getattribute__ ( action )( ** kwargs )","title":"execAction"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#feed","text":"def feed ( self , ** kwargs ) View Source def feed ( self , ** kwargs ): return kwargs","title":"feed"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#getactionschema","text":"def getActionSchema ( self , action ) View Source def getActionSchema ( self , action ): return getActionSchema ( self . module , action )","title":"getActionSchema"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#getactionvalues","text":"def getActionValues ( self , action = None , timestamp = None ) View Source def getActionValues ( self , action = None , timestamp = None ): if action is None : action = slice ( None , None ) if timestamp is None : timestamp = slice ( None , None ) return db [ 'actions' ][ self . uid , action , timestamp ]","title":"getActionValues"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#getrelativepath","text":"def getRelativePath ( self , path ) View Source def getRelativePath ( self , path ): return path . replace ( f \"{self.filecache}/\" , \"\" )","title":"getRelativePath"},{"location":"reference/hielen2/ext/source_photomonitoring/phm/#makecachepath","text":"def makeCachePath ( self , path ) View Source def makeCachePath ( self , path ): outpath = os . path . join ( self . filecache , path ) os . makedirs ( outpath , exist_ok = True ) return outpath","title":"makeCachePath"},{"location":"reference/hielen2/ext/source_tinsar/","text":"Module hielen2.ext.source_tinsar View Source # coding=utf-8 from hielen2.source import HielenSource class Source ( HielenSource ): def config ( self , ** kwargs ): return kwargs def feed ( self , ** kwargs ): return kwargs def data ( self , timefrom = None , timeto = None , geom = None , ** kwargs ): return kwargs Sub-modules hielen2.ext.source_tinsar.cloudpainter Classes Source class Source ( feature , filecache ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Source ( HielenSource ): def config ( self , ** kwargs ): return kwargs def feed ( self , ** kwargs ): return kwargs def data ( self , timefrom = None , timeto = None , geom = None , ** kwargs ): return kwargs Ancestors (in MRO) hielen2.source.HielenSource abc.ABC Methods config def config ( self , ** kwargs ) View Source def config ( self , ** kwargs ): return kwargs data def data ( self , timefrom = None , timeto = None , geom = None , ** kwargs ) View Source def data ( self , timefrom = None , timeto = None , geom = None , ** kwargs ): return kwargs execAction def execAction ( self , action , ** kwargs ) View Source def execAction ( self , action , ** kwargs ): return self . __getattribute__ ( action )( ** kwargs ) feed def feed ( self , ** kwargs ) View Source def feed ( self , ** kwargs ): return kwargs getActionSchema def getActionSchema ( self , action ) View Source def getActionSchema ( self , action ): return getActionSchema ( self . module , action ) getActionValues def getActionValues ( self , action = None , timestamp = None ) View Source def getActionValues ( self , action = None , timestamp = None ): if action is None : action = slice ( None , None ) if timestamp is None : timestamp = slice ( None , None ) return db [ 'actions' ][ self . uid , action , timestamp ] getRelativePath def getRelativePath ( self , path ) View Source def getRelativePath ( self , path ): return path . replace ( f \"{self.filecache}/\" , \"\" ) makeCachePath def makeCachePath ( self , path ) View Source def makeCachePath ( self , path ): outpath = os . path . join ( self . filecache , path ) os . makedirs ( outpath , exist_ok = True ) return outpath","title":"Index"},{"location":"reference/hielen2/ext/source_tinsar/#module-hielen2extsource_tinsar","text":"View Source # coding=utf-8 from hielen2.source import HielenSource class Source ( HielenSource ): def config ( self , ** kwargs ): return kwargs def feed ( self , ** kwargs ): return kwargs def data ( self , timefrom = None , timeto = None , geom = None , ** kwargs ): return kwargs","title":"Module hielen2.ext.source_tinsar"},{"location":"reference/hielen2/ext/source_tinsar/#sub-modules","text":"hielen2.ext.source_tinsar.cloudpainter","title":"Sub-modules"},{"location":"reference/hielen2/ext/source_tinsar/#classes","text":"","title":"Classes"},{"location":"reference/hielen2/ext/source_tinsar/#source","text":"class Source ( feature , filecache ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Source ( HielenSource ): def config ( self , ** kwargs ): return kwargs def feed ( self , ** kwargs ): return kwargs def data ( self , timefrom = None , timeto = None , geom = None , ** kwargs ): return kwargs","title":"Source"},{"location":"reference/hielen2/ext/source_tinsar/#ancestors-in-mro","text":"hielen2.source.HielenSource abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen2/ext/source_tinsar/#methods","text":"","title":"Methods"},{"location":"reference/hielen2/ext/source_tinsar/#config","text":"def config ( self , ** kwargs ) View Source def config ( self , ** kwargs ): return kwargs","title":"config"},{"location":"reference/hielen2/ext/source_tinsar/#data","text":"def data ( self , timefrom = None , timeto = None , geom = None , ** kwargs ) View Source def data ( self , timefrom = None , timeto = None , geom = None , ** kwargs ): return kwargs","title":"data"},{"location":"reference/hielen2/ext/source_tinsar/#execaction","text":"def execAction ( self , action , ** kwargs ) View Source def execAction ( self , action , ** kwargs ): return self . __getattribute__ ( action )( ** kwargs )","title":"execAction"},{"location":"reference/hielen2/ext/source_tinsar/#feed","text":"def feed ( self , ** kwargs ) View Source def feed ( self , ** kwargs ): return kwargs","title":"feed"},{"location":"reference/hielen2/ext/source_tinsar/#getactionschema","text":"def getActionSchema ( self , action ) View Source def getActionSchema ( self , action ): return getActionSchema ( self . module , action )","title":"getActionSchema"},{"location":"reference/hielen2/ext/source_tinsar/#getactionvalues","text":"def getActionValues ( self , action = None , timestamp = None ) View Source def getActionValues ( self , action = None , timestamp = None ): if action is None : action = slice ( None , None ) if timestamp is None : timestamp = slice ( None , None ) return db [ 'actions' ][ self . uid , action , timestamp ]","title":"getActionValues"},{"location":"reference/hielen2/ext/source_tinsar/#getrelativepath","text":"def getRelativePath ( self , path ) View Source def getRelativePath ( self , path ): return path . replace ( f \"{self.filecache}/\" , \"\" )","title":"getRelativePath"},{"location":"reference/hielen2/ext/source_tinsar/#makecachepath","text":"def makeCachePath ( self , path ) View Source def makeCachePath ( self , path ): outpath = os . path . join ( self . filecache , path ) os . makedirs ( outpath , exist_ok = True ) return outpath","title":"makeCachePath"},{"location":"reference/hielen2/ext/source_tinsar/cloudpainter/","text":"Module hielen2.ext.source_tinsar.cloudpainter View Source # coding: utf-8 import pandas as pd import numpy as np from scipy.spatial import KDTree from matplotlib.colors import Normalize , Colormap , LinearSegmentedColormap from matplotlib.cm import ScalarMappable import open3d as o3d def valorize ( basecld , valcld , distance = 10 , group = 1 , degree = 0 ): \"\"\" Assigns values to input base cloud points, overlapping the input values cloud and calculating, for each point in base cloud, the [distance based, weighted] mean of the values of N nearest neighbours, taken from the input values cloud. returns: pandas.Series containing calculated values for all the points in the base cloud which has at least one neighbour within the fixed distance params: basecld - pandas.DataFrame or numpy.ndarray with shape (n,3), representing the coordinates of the points of the base cloud. ['x','y','z'] valcld - pandas.DataFrame or numpy.ndarray with shape (n,4), representing the coordinates of the points of the value cloud and the value of each of them. ['x','y','z','v'] distance - maximum search range for neighbours group - maximum number of neighbours to search for degree - degree of contribution loss over the distance for each neighbour value. Each value of the neighbours is weighted as: 1/d**degree where d is the distance between the neighbour and the base cloud point. Degree 0 implies the arithmetic mean of all the neighbour values found, regardless the relative distance. i.e: N1----------P----N2 Given two neighbours, N1 and N2, for a fixed point P where: d(N1)=10; v(N1)=-15 d(N2)=4; v(N2)=3 v(P) = (-15/10**d+3/4**d)/(1/10**d+1/4**d) being d the degree, we have: d=0 : v(P) = -6 <-- arimetic mean d=1 : v(P) = -2.14 d=2 : v(P) = 0.51 d=3 : v(P) = 1.91 d=4 : v(P) = 2.55 d=5 : v(P) = 2.81 .. d=9 : v(P) = 2.99 .. d(x): v(P) = 3 <-- convergence to the closest's value Note: with group=1 and degree=0, each base cloud point assumes the exact value of the unique closest neighbour, if it exists. \"\"\" basecld = pd . DataFrame ( basecld ) basecld . columns = [ \"x\" , \"y\" , \"z\" ] valcld = pd . DataFrame ( valcld ) valcld . columns = [ \"x\" , \"y\" , \"z\" , \"v\" ] ## Calculating the Series of distance (dist) and value clouds relative ## ids (idsv). the position of each cell in the arrays reflects the cells ## in the base cloud. k = KDTree ( valcld [[ \"x\" , \"y\" , \"z\" ]] . values ) dist , idsv = k . query ( basecld . values , group , distance_upper_bound = distance ) dist = pd . DataFrame ( dist ) . stack () dist . name = \"dist\" idsv = pd . DataFrame ( idsv ) . stack () idsv . name = \"idsv\" ## Here we construct the DataFrame contains relation beetween each point ## in base cloud (base cloud index) and his neighbous (value cloud ids, ## distance and neighbour group progressive). Then we clean the infinite ## distances (points with no neighbours) values = dist . to_frame () . join ( idsv ) values = values [ values [ \"dist\" ] != np . inf ] # Indexind on 'idsv', allows to join with the value cloud and add the 'v' # info values = values . reset_index () . set_index ( \"idsv\" ) . sort_index () values = values . join ( valcld [ \"v\" ], how = \"left\" ) values . columns = [ \"cldid\" , \"instance\" , \"dist\" , \"displ\" ] ## Indexing on 'cldid' and 'instance', allow to make DataFrame comparable ## with base cloud values = values . set_index ([ \"cldid\" , \"instance\" ]) . sort_index () ## Here we calculte the [distance based, weighted] mean values [ \"weight\" ] = 1 / np . power ( values [ \"dist\" ], degree ) values [ \"contrib\" ] = values [ \"displ\" ] * values [ \"weight\" ] values = values . groupby ( \"cldid\" ) . apply ( lambda x : sum ( x [ \"contrib\" ]) / sum ( x [ \"weight\" ]) ) return values def colorize ( vals , cmap = [ \"red\" , \"green\" , \"blue\" ], vmin = None , vmax = None ): \"\"\" Maps each value in the input array with the appropriate RGBA color. See matplotlib.colors.Colormap returns: ndarray with shape (n,4) containing the color tuples ['r','g','b','a'] color channels values are normalized in range (0,1) params: vals - array of values. cmap - See matplotlib.colors.Colormap object or colour list. default ['red','green','blue']. vmax - max limit value for colormap. If None is passed, vals.max(). will be assumed, otherwise vals exceding this parameter will be clipped vmin - min limit value for colormap. If None is passed, vals.min() will be assumed, otherwise vals under this parameter will be clipped \"\"\" vmin = vmin or vals . min () vmax = vmax or vals . max () norm = Normalize ( vmin = vmin , vmax = vmax , clip = True ) if not isinstance ( cmap , Colormap ): cmap = LinearSegmentedColormap . from_list ( \"mycmap\" , cmap ) mapper = ScalarMappable ( norm = norm , cmap = cmap ) cols = mapper . to_rgba ( vals ) return cols def paint ( basecld , valcld , distance = 10 , group = 1 , degree = 0 , cmap = [ \"red\" , \"green\" , \"blue\" ], vmin = None , vmax = None , ): \"\"\" Assigns a color to each point of a base cloud, merging the information of a second valorized cloud overlapping the first one. See cloudpainter.valorize and cloudpainter.colorize for futher informations result: pandas.DataFrame containing ['x','y','z','v','r','g','b'] tuples for each point in the base cloud. Points with no neighbours will be assigned with [0.9,0.9,0.9] for ['r','g','b'] and np.nan for ['v'] params: basecld - pandas.DataFrame or numpy.ndarray with shape (n,3), representing the coordinates of the points of the base cloud. ['x','y','z'] valcld - pandas.DataFrame or numpy.ndarray with shape (n,4), representing the coordinates of the points of the value cloud and the value of each of them. ['x','y','z','v'] distance - maximum search range for neighbours group - maximum number of neighbours to search for degree - degree of contribution loss over the distance for each neighbour value. Each value of the neighbours is weighted as: 1/d**degree where d is the distance between the neighbour and the base cloud point. Degree 0 implies the arithmetic mean of all the neighbour values found, regardless the relative distance. cmap - matplotlib.colors.Colormap object or colour list. default ['red','green','blue']. vmax - max limit value for colormap. If None is passed, vals.max(). will be assumed, otherwise vals exceding this parameter will be clipped vmin - min limit value for colormap. If None is passed, vals.min() will be assumed, otherwise vals under this parameter will be clipped \"\"\" basecld = pd . DataFrame ( basecld ) basecld . columns = [ \"x\" , \"y\" , \"z\" ] valcld = pd . DataFrame ( valcld ) valcld . columns = [ \"x\" , \"y\" , \"z\" , \"v\" ] values = valorize ( basecld , valcld , distance = distance , group = group , degree = degree ) values . name = \"v\" colors = pd . DataFrame ( colorize ( values , cmap = cmap , vmin = vmin , vmax = vmax ), columns = [ \"r\" , \"g\" , \"b\" , \"a\" ], index = values . index , )[[ \"r\" , \"g\" , \"b\" ]] result = basecld . join ( colors , how = \"left\" ) . replace ( np . nan , 0.9 ) result = result . join ( values , how = \"left\" ) return result [[ \"x\" , \"y\" , \"z\" , \"v\" , \"r\" , \"g\" , \"b\" ]] def main (): cld = pd . read_csv ( \"./cloud.orig.csv\" , header = None , sep = \" \" ) rea = pd . read_csv ( \"./nuvola_spost_utm.csv\" , sep = \";\" , decimal = \",\" )[ [ \"X_UTM\" , \"Y_UTM\" , \"Height\" , \"Spostament\" ] ] # ESEMPIO 1 # Smooth --- Il peso dei vicini \u00e8 alto, la distanza di influenza \u00e8 alta e i limiti di colore sono # impostati tra min e max dei valori in ingresso # res = paint ( cld , rea , distance = 10 , group = 10 , degree = 2 , cmap = [ \"red\" , \"green\" , \"blue\" ], vmin = None , vmax = None , ) # ESEMPIO 2 # N-N secco --- Un solo vicino che assegna il colore. I limiti di colore pi\u00f9 stretti del range dei # valori in ingresso # ### res=paint(cld,rea,distance=10,group=1,degree=0,cmap=['red','orange','yellow'],vmin=-2.5,vmax=2.5) # QUI USO open3d perch\u00e8 \u00e8 molto comodo pcl = o3d . geometry . PointCloud () pcl . points = o3d . utility . Vector3dVector ( res [[ \"x\" , \"y\" , \"z\" ]] . values ) pcl . colors = o3d . utility . Vector3dVector ( res [[ \"r\" , \"g\" , \"b\" ]] . values ) o3d . visualization . draw_geometries ([ pcl ]) if __name__ == \"__main__\" : main () Functions colorize def colorize ( vals , cmap = [ 'red' , 'green' , 'blue' ], vmin = None , vmax = None ) Maps each value in the input array with the appropriate RGBA color. See matplotlib.colors.Colormap returns: ndarray with shape (n,4) containing the color tuples ['r','g','b','a'] color channels values are normalized in range (0,1) params: vals - array of values. cmap - See matplotlib.colors.Colormap object or colour list. default ['red','green','blue']. vmax - max limit value for colormap. If None is passed, vals.max(). will be assumed, otherwise vals exceding this parameter will be clipped vmin - min limit value for colormap. If None is passed, vals.min() will be assumed, otherwise vals under this parameter will be clipped View Source def colorize ( vals , cmap = [ \"red\" , \"green\" , \"blue\" ], vmin = None , vmax = None ): \"\"\" Maps each value in the input array with the appropriate RGBA color. See matplotlib.colors.Colormap returns: ndarray with shape (n,4) containing the color tuples ['r','g','b','a'] color channels values are normalized in range (0,1) params: vals - array of values. cmap - See matplotlib.colors.Colormap object or colour list. default ['red','green','blue']. vmax - max limit value for colormap. If None is passed, vals.max(). will be assumed, otherwise vals exceding this parameter will be clipped vmin - min limit value for colormap. If None is passed, vals.min() will be assumed, otherwise vals under this parameter will be clipped \"\"\" vmin = vmin or vals . min () vmax = vmax or vals . max () norm = Normalize ( vmin = vmin , vmax = vmax , clip = True ) if not isinstance ( cmap , Colormap ): cmap = LinearSegmentedColormap . from_list ( \"mycmap\" , cmap ) mapper = ScalarMappable ( norm = norm , cmap = cmap ) cols = mapper . to_rgba ( vals ) return cols main def main ( ) View Source def main () : cld = pd . read_csv ( \"./cloud.orig.csv\" , header = None , sep = \" \" ) rea = pd . read_csv ( \"./nuvola_spost_utm.csv\" , sep = \";\" , decimal = \",\" ) [ [\"X_UTM\", \"Y_UTM\", \"Height\", \"Spostament\" ] ] # ESEMPIO 1 # Smooth --- Il peso dei vicini \u00e8 alto, la distanza di influenza \u00e8 alta e i limiti di colore sono # impostati tra min e max dei valori in ingresso # res = paint ( cld , rea , distance = 10 , group = 10 , degree = 2 , cmap =[ \"red\", \"green\", \"blue\" ] , vmin = None , vmax = None , ) # ESEMPIO 2 # N - N secco --- Un solo vicino che assegna il colore. I limiti di colore pi\u00f9 stretti del range dei # valori in ingresso # ### res = paint ( cld , rea , distance = 10 , group = 1 , degree = 0 , cmap =[ 'red','orange','yellow' ] , vmin =- 2.5 , vmax = 2.5 ) # QUI USO open3d perch\u00e8 \u00e8 molto comodo pcl = o3d . geometry . PointCloud () pcl . points = o3d . utility . Vector3dVector ( res [ [\"x\", \"y\", \"z\" ] ] . values ) pcl . colors = o3d . utility . Vector3dVector ( res [ [\"r\", \"g\", \"b\" ] ] . values ) o3d . visualization . draw_geometries ( [ pcl ] ) paint def paint ( basecld , valcld , distance = 10 , group = 1 , degree = 0 , cmap = [ 'red' , 'green' , 'blue' ], vmin = None , vmax = None ) Assigns a color to each point of a base cloud, merging the information of a second valorized cloud overlapping the first one. See cloudpainter.valorize and cloudpainter.colorize for futher informations result: pandas.DataFrame containing ['x','y','z','v','r','g','b'] tuples for each point in the base cloud. Points with no neighbours will be assigned with [0.9,0.9,0.9] for ['r','g','b'] and np.nan for ['v'] params: basecld - pandas.DataFrame or numpy.ndarray with shape (n,3), representing the coordinates of the points of the base cloud. ['x','y','z'] valcld - pandas.DataFrame or numpy.ndarray with shape (n,4), representing the coordinates of the points of the value cloud and the value of each of them. ['x','y','z','v'] distance - maximum search range for neighbours group - maximum number of neighbours to search for degree - degree of contribution loss over the distance for each neighbour value. Each value of the neighbours is weighted as: 1 / d ** degree where d is the distance between the neighbour and the base cloud point . Degree 0 implies the arithmetic mean of all the neighbour values found , regardless the relative distance . cmap - matplotlib.colors.Colormap object or colour list. default ['red','green','blue']. vmax - max limit value for colormap. If None is passed, vals.max(). will be assumed, otherwise vals exceding this parameter will be clipped vmin - min limit value for colormap. If None is passed, vals.min() will be assumed, otherwise vals under this parameter will be clipped View Source def paint ( basecld , valcld , distance = 10 , group = 1 , degree = 0 , cmap = [ \"red\" , \"green\" , \"blue\" ], vmin = None , vmax = None , ): \"\"\" Assigns a color to each point of a base cloud, merging the information of a second valorized cloud overlapping the first one. See cloudpainter.valorize and cloudpainter.colorize for futher informations result: pandas.DataFrame containing ['x','y','z','v','r','g','b'] tuples for each point in the base cloud. Points with no neighbours will be assigned with [0.9,0.9,0.9] for ['r','g','b'] and np.nan for ['v'] params: basecld - pandas.DataFrame or numpy.ndarray with shape (n,3), representing the coordinates of the points of the base cloud. ['x','y','z'] valcld - pandas.DataFrame or numpy.ndarray with shape (n,4), representing the coordinates of the points of the value cloud and the value of each of them. ['x','y','z','v'] distance - maximum search range for neighbours group - maximum number of neighbours to search for degree - degree of contribution loss over the distance for each neighbour value. Each value of the neighbours is weighted as: 1/d**degree where d is the distance between the neighbour and the base cloud point. Degree 0 implies the arithmetic mean of all the neighbour values found, regardless the relative distance. cmap - matplotlib.colors.Colormap object or colour list. default ['red','green','blue']. vmax - max limit value for colormap. If None is passed, vals.max(). will be assumed, otherwise vals exceding this parameter will be clipped vmin - min limit value for colormap. If None is passed, vals.min() will be assumed, otherwise vals under this parameter will be clipped \"\"\" basecld = pd . DataFrame ( basecld ) basecld . columns = [ \"x\" , \"y\" , \"z\" ] valcld = pd . DataFrame ( valcld ) valcld . columns = [ \"x\" , \"y\" , \"z\" , \"v\" ] values = valorize ( basecld , valcld , distance = distance , group = group , degree = degree ) values . name = \"v\" colors = pd . DataFrame ( colorize ( values , cmap = cmap , vmin = vmin , vmax = vmax ), columns = [ \"r\" , \"g\" , \"b\" , \"a\" ], index = values . index , )[[ \"r\" , \"g\" , \"b\" ]] result = basecld . join ( colors , how = \"left\" ). replace ( np . nan , 0 . 9 ) result = result . join ( values , how = \"left\" ) return result [[ \"x\" , \"y\" , \"z\" , \"v\" , \"r\" , \"g\" , \"b\" ]] valorize def valorize ( basecld , valcld , distance = 10 , group = 1 , degree = 0 ) Assigns values to input base cloud points, overlapping the input values cloud and calculating, for each point in base cloud, the [distance based, weighted] mean of the values of N nearest neighbours, taken from the input values cloud. returns: pandas.Series containing calculated values for all the points in the base cloud which has at least one neighbour within the fixed distance params: basecld - pandas.DataFrame or numpy.ndarray with shape (n,3), representing the coordinates of the points of the base cloud. ['x','y','z'] valcld - pandas.DataFrame or numpy.ndarray with shape (n,4), representing the coordinates of the points of the value cloud and the value of each of them. ['x','y','z','v'] distance - maximum search range for neighbours group - maximum number of neighbours to search for degree - degree of contribution loss over the distance for each neighbour value. Each value of the neighbours is weighted as: 1 / d ** degree where d is the distance between the neighbour and the base cloud point . Degree 0 implies the arithmetic mean of all the neighbour values found , regardless the relative distance . i . e : N1 ----------P----N2 Given two neighbours , N1 and N2 , for a fixed point P where : d ( N1 ) = 10 ; v ( N1 ) =- 15 d ( N2 ) = 4 ; v ( N2 ) = 3 v ( P ) = ( - 15 / 10 ** d + 3 / 4 ** d ) / ( 1 / 10 ** d + 1 / 4 ** d ) being d the degree , we have : d = 0 : v ( P ) = - 6 < -- arimetic mean d = 1 : v ( P ) = - 2 . 14 d = 2 : v ( P ) = 0 . 51 d = 3 : v ( P ) = 1 . 91 d = 4 : v ( P ) = 2 . 55 d = 5 : v ( P ) = 2 . 81 .. d = 9 : v ( P ) = 2 . 99 .. d ( x ): v ( P ) = 3 < -- convergence to the closest's value Note: with group=1 and degree=0, each base cloud point assumes the exact value of the unique closest neighbour, if it exists. View Source def valorize ( basecld , valcld , distance = 10 , group = 1 , degree = 0 ): \"\"\" Assigns values to input base cloud points, overlapping the input values cloud and calculating, for each point in base cloud, the [distance based, weighted] mean of the values of N nearest neighbours, taken from the input values cloud. returns: pandas.Series containing calculated values for all the points in the base cloud which has at least one neighbour within the fixed distance params: basecld - pandas.DataFrame or numpy.ndarray with shape (n,3), representing the coordinates of the points of the base cloud. ['x','y','z'] valcld - pandas.DataFrame or numpy.ndarray with shape (n,4), representing the coordinates of the points of the value cloud and the value of each of them. ['x','y','z','v'] distance - maximum search range for neighbours group - maximum number of neighbours to search for degree - degree of contribution loss over the distance for each neighbour value. Each value of the neighbours is weighted as: 1/d**degree where d is the distance between the neighbour and the base cloud point. Degree 0 implies the arithmetic mean of all the neighbour values found, regardless the relative distance. i.e: N1----------P----N2 Given two neighbours, N1 and N2, for a fixed point P where: d(N1)=10; v(N1)=-15 d(N2)=4; v(N2)=3 v(P) = (-15/10**d+3/4**d)/(1/10**d+1/4**d) being d the degree, we have: d=0 : v(P) = -6 <-- arimetic mean d=1 : v(P) = -2.14 d=2 : v(P) = 0.51 d=3 : v(P) = 1.91 d=4 : v(P) = 2.55 d=5 : v(P) = 2.81 .. d=9 : v(P) = 2.99 .. d(x): v(P) = 3 <-- convergence to the closest's value Note: with group=1 and degree=0, each base cloud point assumes the exact value of the unique closest neighbour, if it exists. \"\"\" basecld = pd . DataFrame ( basecld ) basecld . columns = [ \"x\" , \"y\" , \"z\" ] valcld = pd . DataFrame ( valcld ) valcld . columns = [ \"x\" , \"y\" , \"z\" , \"v\" ] ## Calculating the Series of distance ( dist ) and value clouds relative ## ids ( idsv ). the position of each cell in the arrays reflects the cells ## in the base cloud . k = KDTree ( valcld [[ \"x\" , \"y\" , \"z\" ]]. values ) dist , idsv = k . query ( basecld . values , group , distance_upper_bound = distance ) dist = pd . DataFrame ( dist ). stack () dist . name = \"dist\" idsv = pd . DataFrame ( idsv ). stack () idsv . name = \"idsv\" ## Here we construct the DataFrame contains relation beetween each point ## in base cloud ( base cloud index ) and his neighbous ( value cloud ids , ## distance and neighbour group progressive ). Then we clean the infinite ## distances ( points with no neighbours ) values = dist . to_frame (). join ( idsv ) values = values [ values [ \"dist\" ] != np . inf ] # Indexind on 'idsv' , allows to join with the value cloud and add the 'v' # info values = values . reset_index (). set_index ( \"idsv\" ). sort_index () values = values . join ( valcld [ \"v\" ], how = \"left\" ) values . columns = [ \"cldid\" , \"instance\" , \"dist\" , \"displ\" ] ## Indexing on 'cldid' and 'instance' , allow to make DataFrame comparable ## with base cloud values = values . set_index ([ \"cldid\" , \"instance\" ]). sort_index () ## Here we calculte the [ distance based , weighted ] mean values [ \"weight\" ] = 1 / np . power ( values [ \"dist\" ], degree ) values [ \"contrib\" ] = values [ \"displ\" ] * values [ \"weight\" ] values = values . groupby ( \"cldid\" ). apply ( lambda x : sum ( x [ \"contrib\" ]) / sum ( x [ \"weight\" ]) ) return values","title":"Cloudpainter"},{"location":"reference/hielen2/ext/source_tinsar/cloudpainter/#module-hielen2extsource_tinsarcloudpainter","text":"View Source # coding: utf-8 import pandas as pd import numpy as np from scipy.spatial import KDTree from matplotlib.colors import Normalize , Colormap , LinearSegmentedColormap from matplotlib.cm import ScalarMappable import open3d as o3d def valorize ( basecld , valcld , distance = 10 , group = 1 , degree = 0 ): \"\"\" Assigns values to input base cloud points, overlapping the input values cloud and calculating, for each point in base cloud, the [distance based, weighted] mean of the values of N nearest neighbours, taken from the input values cloud. returns: pandas.Series containing calculated values for all the points in the base cloud which has at least one neighbour within the fixed distance params: basecld - pandas.DataFrame or numpy.ndarray with shape (n,3), representing the coordinates of the points of the base cloud. ['x','y','z'] valcld - pandas.DataFrame or numpy.ndarray with shape (n,4), representing the coordinates of the points of the value cloud and the value of each of them. ['x','y','z','v'] distance - maximum search range for neighbours group - maximum number of neighbours to search for degree - degree of contribution loss over the distance for each neighbour value. Each value of the neighbours is weighted as: 1/d**degree where d is the distance between the neighbour and the base cloud point. Degree 0 implies the arithmetic mean of all the neighbour values found, regardless the relative distance. i.e: N1----------P----N2 Given two neighbours, N1 and N2, for a fixed point P where: d(N1)=10; v(N1)=-15 d(N2)=4; v(N2)=3 v(P) = (-15/10**d+3/4**d)/(1/10**d+1/4**d) being d the degree, we have: d=0 : v(P) = -6 <-- arimetic mean d=1 : v(P) = -2.14 d=2 : v(P) = 0.51 d=3 : v(P) = 1.91 d=4 : v(P) = 2.55 d=5 : v(P) = 2.81 .. d=9 : v(P) = 2.99 .. d(x): v(P) = 3 <-- convergence to the closest's value Note: with group=1 and degree=0, each base cloud point assumes the exact value of the unique closest neighbour, if it exists. \"\"\" basecld = pd . DataFrame ( basecld ) basecld . columns = [ \"x\" , \"y\" , \"z\" ] valcld = pd . DataFrame ( valcld ) valcld . columns = [ \"x\" , \"y\" , \"z\" , \"v\" ] ## Calculating the Series of distance (dist) and value clouds relative ## ids (idsv). the position of each cell in the arrays reflects the cells ## in the base cloud. k = KDTree ( valcld [[ \"x\" , \"y\" , \"z\" ]] . values ) dist , idsv = k . query ( basecld . values , group , distance_upper_bound = distance ) dist = pd . DataFrame ( dist ) . stack () dist . name = \"dist\" idsv = pd . DataFrame ( idsv ) . stack () idsv . name = \"idsv\" ## Here we construct the DataFrame contains relation beetween each point ## in base cloud (base cloud index) and his neighbous (value cloud ids, ## distance and neighbour group progressive). Then we clean the infinite ## distances (points with no neighbours) values = dist . to_frame () . join ( idsv ) values = values [ values [ \"dist\" ] != np . inf ] # Indexind on 'idsv', allows to join with the value cloud and add the 'v' # info values = values . reset_index () . set_index ( \"idsv\" ) . sort_index () values = values . join ( valcld [ \"v\" ], how = \"left\" ) values . columns = [ \"cldid\" , \"instance\" , \"dist\" , \"displ\" ] ## Indexing on 'cldid' and 'instance', allow to make DataFrame comparable ## with base cloud values = values . set_index ([ \"cldid\" , \"instance\" ]) . sort_index () ## Here we calculte the [distance based, weighted] mean values [ \"weight\" ] = 1 / np . power ( values [ \"dist\" ], degree ) values [ \"contrib\" ] = values [ \"displ\" ] * values [ \"weight\" ] values = values . groupby ( \"cldid\" ) . apply ( lambda x : sum ( x [ \"contrib\" ]) / sum ( x [ \"weight\" ]) ) return values def colorize ( vals , cmap = [ \"red\" , \"green\" , \"blue\" ], vmin = None , vmax = None ): \"\"\" Maps each value in the input array with the appropriate RGBA color. See matplotlib.colors.Colormap returns: ndarray with shape (n,4) containing the color tuples ['r','g','b','a'] color channels values are normalized in range (0,1) params: vals - array of values. cmap - See matplotlib.colors.Colormap object or colour list. default ['red','green','blue']. vmax - max limit value for colormap. If None is passed, vals.max(). will be assumed, otherwise vals exceding this parameter will be clipped vmin - min limit value for colormap. If None is passed, vals.min() will be assumed, otherwise vals under this parameter will be clipped \"\"\" vmin = vmin or vals . min () vmax = vmax or vals . max () norm = Normalize ( vmin = vmin , vmax = vmax , clip = True ) if not isinstance ( cmap , Colormap ): cmap = LinearSegmentedColormap . from_list ( \"mycmap\" , cmap ) mapper = ScalarMappable ( norm = norm , cmap = cmap ) cols = mapper . to_rgba ( vals ) return cols def paint ( basecld , valcld , distance = 10 , group = 1 , degree = 0 , cmap = [ \"red\" , \"green\" , \"blue\" ], vmin = None , vmax = None , ): \"\"\" Assigns a color to each point of a base cloud, merging the information of a second valorized cloud overlapping the first one. See cloudpainter.valorize and cloudpainter.colorize for futher informations result: pandas.DataFrame containing ['x','y','z','v','r','g','b'] tuples for each point in the base cloud. Points with no neighbours will be assigned with [0.9,0.9,0.9] for ['r','g','b'] and np.nan for ['v'] params: basecld - pandas.DataFrame or numpy.ndarray with shape (n,3), representing the coordinates of the points of the base cloud. ['x','y','z'] valcld - pandas.DataFrame or numpy.ndarray with shape (n,4), representing the coordinates of the points of the value cloud and the value of each of them. ['x','y','z','v'] distance - maximum search range for neighbours group - maximum number of neighbours to search for degree - degree of contribution loss over the distance for each neighbour value. Each value of the neighbours is weighted as: 1/d**degree where d is the distance between the neighbour and the base cloud point. Degree 0 implies the arithmetic mean of all the neighbour values found, regardless the relative distance. cmap - matplotlib.colors.Colormap object or colour list. default ['red','green','blue']. vmax - max limit value for colormap. If None is passed, vals.max(). will be assumed, otherwise vals exceding this parameter will be clipped vmin - min limit value for colormap. If None is passed, vals.min() will be assumed, otherwise vals under this parameter will be clipped \"\"\" basecld = pd . DataFrame ( basecld ) basecld . columns = [ \"x\" , \"y\" , \"z\" ] valcld = pd . DataFrame ( valcld ) valcld . columns = [ \"x\" , \"y\" , \"z\" , \"v\" ] values = valorize ( basecld , valcld , distance = distance , group = group , degree = degree ) values . name = \"v\" colors = pd . DataFrame ( colorize ( values , cmap = cmap , vmin = vmin , vmax = vmax ), columns = [ \"r\" , \"g\" , \"b\" , \"a\" ], index = values . index , )[[ \"r\" , \"g\" , \"b\" ]] result = basecld . join ( colors , how = \"left\" ) . replace ( np . nan , 0.9 ) result = result . join ( values , how = \"left\" ) return result [[ \"x\" , \"y\" , \"z\" , \"v\" , \"r\" , \"g\" , \"b\" ]] def main (): cld = pd . read_csv ( \"./cloud.orig.csv\" , header = None , sep = \" \" ) rea = pd . read_csv ( \"./nuvola_spost_utm.csv\" , sep = \";\" , decimal = \",\" )[ [ \"X_UTM\" , \"Y_UTM\" , \"Height\" , \"Spostament\" ] ] # ESEMPIO 1 # Smooth --- Il peso dei vicini \u00e8 alto, la distanza di influenza \u00e8 alta e i limiti di colore sono # impostati tra min e max dei valori in ingresso # res = paint ( cld , rea , distance = 10 , group = 10 , degree = 2 , cmap = [ \"red\" , \"green\" , \"blue\" ], vmin = None , vmax = None , ) # ESEMPIO 2 # N-N secco --- Un solo vicino che assegna il colore. I limiti di colore pi\u00f9 stretti del range dei # valori in ingresso # ### res=paint(cld,rea,distance=10,group=1,degree=0,cmap=['red','orange','yellow'],vmin=-2.5,vmax=2.5) # QUI USO open3d perch\u00e8 \u00e8 molto comodo pcl = o3d . geometry . PointCloud () pcl . points = o3d . utility . Vector3dVector ( res [[ \"x\" , \"y\" , \"z\" ]] . values ) pcl . colors = o3d . utility . Vector3dVector ( res [[ \"r\" , \"g\" , \"b\" ]] . values ) o3d . visualization . draw_geometries ([ pcl ]) if __name__ == \"__main__\" : main ()","title":"Module hielen2.ext.source_tinsar.cloudpainter"},{"location":"reference/hielen2/ext/source_tinsar/cloudpainter/#functions","text":"","title":"Functions"},{"location":"reference/hielen2/ext/source_tinsar/cloudpainter/#colorize","text":"def colorize ( vals , cmap = [ 'red' , 'green' , 'blue' ], vmin = None , vmax = None ) Maps each value in the input array with the appropriate RGBA color. See matplotlib.colors.Colormap returns: ndarray with shape (n,4) containing the color tuples ['r','g','b','a'] color channels values are normalized in range (0,1) params: vals - array of values. cmap - See matplotlib.colors.Colormap object or colour list. default ['red','green','blue']. vmax - max limit value for colormap. If None is passed, vals.max(). will be assumed, otherwise vals exceding this parameter will be clipped vmin - min limit value for colormap. If None is passed, vals.min() will be assumed, otherwise vals under this parameter will be clipped View Source def colorize ( vals , cmap = [ \"red\" , \"green\" , \"blue\" ], vmin = None , vmax = None ): \"\"\" Maps each value in the input array with the appropriate RGBA color. See matplotlib.colors.Colormap returns: ndarray with shape (n,4) containing the color tuples ['r','g','b','a'] color channels values are normalized in range (0,1) params: vals - array of values. cmap - See matplotlib.colors.Colormap object or colour list. default ['red','green','blue']. vmax - max limit value for colormap. If None is passed, vals.max(). will be assumed, otherwise vals exceding this parameter will be clipped vmin - min limit value for colormap. If None is passed, vals.min() will be assumed, otherwise vals under this parameter will be clipped \"\"\" vmin = vmin or vals . min () vmax = vmax or vals . max () norm = Normalize ( vmin = vmin , vmax = vmax , clip = True ) if not isinstance ( cmap , Colormap ): cmap = LinearSegmentedColormap . from_list ( \"mycmap\" , cmap ) mapper = ScalarMappable ( norm = norm , cmap = cmap ) cols = mapper . to_rgba ( vals ) return cols","title":"colorize"},{"location":"reference/hielen2/ext/source_tinsar/cloudpainter/#main","text":"def main ( ) View Source def main () : cld = pd . read_csv ( \"./cloud.orig.csv\" , header = None , sep = \" \" ) rea = pd . read_csv ( \"./nuvola_spost_utm.csv\" , sep = \";\" , decimal = \",\" ) [ [\"X_UTM\", \"Y_UTM\", \"Height\", \"Spostament\" ] ] # ESEMPIO 1 # Smooth --- Il peso dei vicini \u00e8 alto, la distanza di influenza \u00e8 alta e i limiti di colore sono # impostati tra min e max dei valori in ingresso # res = paint ( cld , rea , distance = 10 , group = 10 , degree = 2 , cmap =[ \"red\", \"green\", \"blue\" ] , vmin = None , vmax = None , ) # ESEMPIO 2 # N - N secco --- Un solo vicino che assegna il colore. I limiti di colore pi\u00f9 stretti del range dei # valori in ingresso # ### res = paint ( cld , rea , distance = 10 , group = 1 , degree = 0 , cmap =[ 'red','orange','yellow' ] , vmin =- 2.5 , vmax = 2.5 ) # QUI USO open3d perch\u00e8 \u00e8 molto comodo pcl = o3d . geometry . PointCloud () pcl . points = o3d . utility . Vector3dVector ( res [ [\"x\", \"y\", \"z\" ] ] . values ) pcl . colors = o3d . utility . Vector3dVector ( res [ [\"r\", \"g\", \"b\" ] ] . values ) o3d . visualization . draw_geometries ( [ pcl ] )","title":"main"},{"location":"reference/hielen2/ext/source_tinsar/cloudpainter/#paint","text":"def paint ( basecld , valcld , distance = 10 , group = 1 , degree = 0 , cmap = [ 'red' , 'green' , 'blue' ], vmin = None , vmax = None ) Assigns a color to each point of a base cloud, merging the information of a second valorized cloud overlapping the first one. See cloudpainter.valorize and cloudpainter.colorize for futher informations result: pandas.DataFrame containing ['x','y','z','v','r','g','b'] tuples for each point in the base cloud. Points with no neighbours will be assigned with [0.9,0.9,0.9] for ['r','g','b'] and np.nan for ['v'] params: basecld - pandas.DataFrame or numpy.ndarray with shape (n,3), representing the coordinates of the points of the base cloud. ['x','y','z'] valcld - pandas.DataFrame or numpy.ndarray with shape (n,4), representing the coordinates of the points of the value cloud and the value of each of them. ['x','y','z','v'] distance - maximum search range for neighbours group - maximum number of neighbours to search for degree - degree of contribution loss over the distance for each neighbour value. Each value of the neighbours is weighted as: 1 / d ** degree where d is the distance between the neighbour and the base cloud point . Degree 0 implies the arithmetic mean of all the neighbour values found , regardless the relative distance . cmap - matplotlib.colors.Colormap object or colour list. default ['red','green','blue']. vmax - max limit value for colormap. If None is passed, vals.max(). will be assumed, otherwise vals exceding this parameter will be clipped vmin - min limit value for colormap. If None is passed, vals.min() will be assumed, otherwise vals under this parameter will be clipped View Source def paint ( basecld , valcld , distance = 10 , group = 1 , degree = 0 , cmap = [ \"red\" , \"green\" , \"blue\" ], vmin = None , vmax = None , ): \"\"\" Assigns a color to each point of a base cloud, merging the information of a second valorized cloud overlapping the first one. See cloudpainter.valorize and cloudpainter.colorize for futher informations result: pandas.DataFrame containing ['x','y','z','v','r','g','b'] tuples for each point in the base cloud. Points with no neighbours will be assigned with [0.9,0.9,0.9] for ['r','g','b'] and np.nan for ['v'] params: basecld - pandas.DataFrame or numpy.ndarray with shape (n,3), representing the coordinates of the points of the base cloud. ['x','y','z'] valcld - pandas.DataFrame or numpy.ndarray with shape (n,4), representing the coordinates of the points of the value cloud and the value of each of them. ['x','y','z','v'] distance - maximum search range for neighbours group - maximum number of neighbours to search for degree - degree of contribution loss over the distance for each neighbour value. Each value of the neighbours is weighted as: 1/d**degree where d is the distance between the neighbour and the base cloud point. Degree 0 implies the arithmetic mean of all the neighbour values found, regardless the relative distance. cmap - matplotlib.colors.Colormap object or colour list. default ['red','green','blue']. vmax - max limit value for colormap. If None is passed, vals.max(). will be assumed, otherwise vals exceding this parameter will be clipped vmin - min limit value for colormap. If None is passed, vals.min() will be assumed, otherwise vals under this parameter will be clipped \"\"\" basecld = pd . DataFrame ( basecld ) basecld . columns = [ \"x\" , \"y\" , \"z\" ] valcld = pd . DataFrame ( valcld ) valcld . columns = [ \"x\" , \"y\" , \"z\" , \"v\" ] values = valorize ( basecld , valcld , distance = distance , group = group , degree = degree ) values . name = \"v\" colors = pd . DataFrame ( colorize ( values , cmap = cmap , vmin = vmin , vmax = vmax ), columns = [ \"r\" , \"g\" , \"b\" , \"a\" ], index = values . index , )[[ \"r\" , \"g\" , \"b\" ]] result = basecld . join ( colors , how = \"left\" ). replace ( np . nan , 0 . 9 ) result = result . join ( values , how = \"left\" ) return result [[ \"x\" , \"y\" , \"z\" , \"v\" , \"r\" , \"g\" , \"b\" ]]","title":"paint"},{"location":"reference/hielen2/ext/source_tinsar/cloudpainter/#valorize","text":"def valorize ( basecld , valcld , distance = 10 , group = 1 , degree = 0 ) Assigns values to input base cloud points, overlapping the input values cloud and calculating, for each point in base cloud, the [distance based, weighted] mean of the values of N nearest neighbours, taken from the input values cloud. returns: pandas.Series containing calculated values for all the points in the base cloud which has at least one neighbour within the fixed distance params: basecld - pandas.DataFrame or numpy.ndarray with shape (n,3), representing the coordinates of the points of the base cloud. ['x','y','z'] valcld - pandas.DataFrame or numpy.ndarray with shape (n,4), representing the coordinates of the points of the value cloud and the value of each of them. ['x','y','z','v'] distance - maximum search range for neighbours group - maximum number of neighbours to search for degree - degree of contribution loss over the distance for each neighbour value. Each value of the neighbours is weighted as: 1 / d ** degree where d is the distance between the neighbour and the base cloud point . Degree 0 implies the arithmetic mean of all the neighbour values found , regardless the relative distance . i . e : N1 ----------P----N2 Given two neighbours , N1 and N2 , for a fixed point P where : d ( N1 ) = 10 ; v ( N1 ) =- 15 d ( N2 ) = 4 ; v ( N2 ) = 3 v ( P ) = ( - 15 / 10 ** d + 3 / 4 ** d ) / ( 1 / 10 ** d + 1 / 4 ** d ) being d the degree , we have : d = 0 : v ( P ) = - 6 < -- arimetic mean d = 1 : v ( P ) = - 2 . 14 d = 2 : v ( P ) = 0 . 51 d = 3 : v ( P ) = 1 . 91 d = 4 : v ( P ) = 2 . 55 d = 5 : v ( P ) = 2 . 81 .. d = 9 : v ( P ) = 2 . 99 .. d ( x ): v ( P ) = 3 < -- convergence to the closest's value Note: with group=1 and degree=0, each base cloud point assumes the exact value of the unique closest neighbour, if it exists. View Source def valorize ( basecld , valcld , distance = 10 , group = 1 , degree = 0 ): \"\"\" Assigns values to input base cloud points, overlapping the input values cloud and calculating, for each point in base cloud, the [distance based, weighted] mean of the values of N nearest neighbours, taken from the input values cloud. returns: pandas.Series containing calculated values for all the points in the base cloud which has at least one neighbour within the fixed distance params: basecld - pandas.DataFrame or numpy.ndarray with shape (n,3), representing the coordinates of the points of the base cloud. ['x','y','z'] valcld - pandas.DataFrame or numpy.ndarray with shape (n,4), representing the coordinates of the points of the value cloud and the value of each of them. ['x','y','z','v'] distance - maximum search range for neighbours group - maximum number of neighbours to search for degree - degree of contribution loss over the distance for each neighbour value. Each value of the neighbours is weighted as: 1/d**degree where d is the distance between the neighbour and the base cloud point. Degree 0 implies the arithmetic mean of all the neighbour values found, regardless the relative distance. i.e: N1----------P----N2 Given two neighbours, N1 and N2, for a fixed point P where: d(N1)=10; v(N1)=-15 d(N2)=4; v(N2)=3 v(P) = (-15/10**d+3/4**d)/(1/10**d+1/4**d) being d the degree, we have: d=0 : v(P) = -6 <-- arimetic mean d=1 : v(P) = -2.14 d=2 : v(P) = 0.51 d=3 : v(P) = 1.91 d=4 : v(P) = 2.55 d=5 : v(P) = 2.81 .. d=9 : v(P) = 2.99 .. d(x): v(P) = 3 <-- convergence to the closest's value Note: with group=1 and degree=0, each base cloud point assumes the exact value of the unique closest neighbour, if it exists. \"\"\" basecld = pd . DataFrame ( basecld ) basecld . columns = [ \"x\" , \"y\" , \"z\" ] valcld = pd . DataFrame ( valcld ) valcld . columns = [ \"x\" , \"y\" , \"z\" , \"v\" ] ## Calculating the Series of distance ( dist ) and value clouds relative ## ids ( idsv ). the position of each cell in the arrays reflects the cells ## in the base cloud . k = KDTree ( valcld [[ \"x\" , \"y\" , \"z\" ]]. values ) dist , idsv = k . query ( basecld . values , group , distance_upper_bound = distance ) dist = pd . DataFrame ( dist ). stack () dist . name = \"dist\" idsv = pd . DataFrame ( idsv ). stack () idsv . name = \"idsv\" ## Here we construct the DataFrame contains relation beetween each point ## in base cloud ( base cloud index ) and his neighbous ( value cloud ids , ## distance and neighbour group progressive ). Then we clean the infinite ## distances ( points with no neighbours ) values = dist . to_frame (). join ( idsv ) values = values [ values [ \"dist\" ] != np . inf ] # Indexind on 'idsv' , allows to join with the value cloud and add the 'v' # info values = values . reset_index (). set_index ( \"idsv\" ). sort_index () values = values . join ( valcld [ \"v\" ], how = \"left\" ) values . columns = [ \"cldid\" , \"instance\" , \"dist\" , \"displ\" ] ## Indexing on 'cldid' and 'instance' , allow to make DataFrame comparable ## with base cloud values = values . set_index ([ \"cldid\" , \"instance\" ]). sort_index () ## Here we calculte the [ distance based , weighted ] mean values [ \"weight\" ] = 1 / np . power ( values [ \"dist\" ], degree ) values [ \"contrib\" ] = values [ \"displ\" ] * values [ \"weight\" ] values = values . groupby ( \"cldid\" ). apply ( lambda x : sum ( x [ \"contrib\" ]) / sum ( x [ \"weight\" ]) ) return values","title":"valorize"}]}