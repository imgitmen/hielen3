{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"HIELEN Hielen (HIerarchical ELaboration ENgine) \u00e8 una suite di api REST dedicata alla rappresentazione e alla gestione delle evoluzioni temporali di fenomeni dotati di caratteristiche spaziali. Essa \u00e8 stata modellata sulle esigenze del monitoraggio strutturale, ambientale e geognostico, con l'obiettivo di astrarre lo strato fisico degli acquisitori installati sul campo e fornire un ambiente omogeneo per l'analisi dei dati relativi all'evoluzione dei fenomeni monitorati. Note generali sulle API 1. Costruzione della URL In questo documento si far\u00e0 riferimento alle specifiche api in questo modo: PROTOCOLLO /{nomeapi} intendendo con questa scrittura il protocollo da utilizzare per la chiamata (vedi punto 2) e il punto d'ingresso della specifica api che dovr\u00e0 essere utlizzato nella url , accodandolo allo hostname e all' endpoint specifici. es.: supponedo hostname = www.hostname.com endopoint = api/hielen nomeapi = features la costruzione della url sar\u00e0 la seguente www.hostname.com/api/hielen/features dove la parte www.hostname.com/api/hielen sar\u00e0 il punto d'ingresso per tutte le api della specifica installazione e dipender\u00e0 esclusivamente dalla configurazione del webserver che ospita la suite 2. Utilizzo dei potocolli standard HTTP Le API seguno le direttive REST e dunque ognuna di esse sfrutta i diversi protocolli http per svolgere azioni differenti. In generale: POST per la creazione di un nuovo elemento GET per il recupero di informazioni di uno o pi\u00f9 elementi PUT per la modifica di un elemento DELETE per l'eliminazione di un elemento ad esempio POST www.hostname.com/api/hielen/features?... potr\u00e0 essere utilizzato per creare un elemento di tipo feature. mentre GET www.hostname.com/api/hielen/features/uuid_feature servir\u00e0 a recuperare le informazioni della feature individuata da uuid_feature 3. Risposta standard delle API Dove non diversamente specificato, le api rispondono con un json in questo formato: { \"meta\": { \"response\": ..., \"message\": ..., \"data_type\": ..., }, \"data\": ... } dove: il campo meta contine informazioni relative all'esecuzione della richiesta . il sottocampo response pu\u00f2 assumere i valori error oppure ok . il sottocampo message contiene l'eventuale messaggio di errore. il sottocampo data_type contiene la marcatura dell'api richiesta (es.: \"GET /api/hielen/features\"). il campo data contiene la risposta prodotta dall'esecuzione, generalmente un json, se essa \u00e8 andata a buon fine. Struttura generale delle API Protocollo Nome API Descrizione GET /prototypes informazioni sulle tipologie di feature implementate GET /actionschemata schemi di base per agire sulle features POST /features creazione di una nuova feature GET /features recupero di informazioni sulle features PUT /features modifica di una feature DELETE /features eliminazione di una feature POST /actions azione specifica su una featrue GET /actions recupero di informazioni sull'azione eseguita su una feature PUT /actions modifica di un'azione precedentemente eseguita su una feature DELETE /actions eliminazione di un'azione precedemente eseguita su una feature GET /query interfaccia di interrogazione dei dati","title":"Home"},{"location":"#hielen","text":"Hielen (HIerarchical ELaboration ENgine) \u00e8 una suite di api REST dedicata alla rappresentazione e alla gestione delle evoluzioni temporali di fenomeni dotati di caratteristiche spaziali. Essa \u00e8 stata modellata sulle esigenze del monitoraggio strutturale, ambientale e geognostico, con l'obiettivo di astrarre lo strato fisico degli acquisitori installati sul campo e fornire un ambiente omogeneo per l'analisi dei dati relativi all'evoluzione dei fenomeni monitorati.","title":"HIELEN"},{"location":"#note-generali-sulle-api","text":"","title":"Note generali sulle API"},{"location":"#1-costruzione-della-url","text":"In questo documento si far\u00e0 riferimento alle specifiche api in questo modo: PROTOCOLLO /{nomeapi} intendendo con questa scrittura il protocollo da utilizzare per la chiamata (vedi punto 2) e il punto d'ingresso della specifica api che dovr\u00e0 essere utlizzato nella url , accodandolo allo hostname e all' endpoint specifici. es.: supponedo hostname = www.hostname.com endopoint = api/hielen nomeapi = features la costruzione della url sar\u00e0 la seguente www.hostname.com/api/hielen/features dove la parte www.hostname.com/api/hielen sar\u00e0 il punto d'ingresso per tutte le api della specifica installazione e dipender\u00e0 esclusivamente dalla configurazione del webserver che ospita la suite","title":"1. Costruzione della URL"},{"location":"#2-utilizzo-dei-potocolli-standard-http","text":"Le API seguno le direttive REST e dunque ognuna di esse sfrutta i diversi protocolli http per svolgere azioni differenti. In generale: POST per la creazione di un nuovo elemento GET per il recupero di informazioni di uno o pi\u00f9 elementi PUT per la modifica di un elemento DELETE per l'eliminazione di un elemento ad esempio POST www.hostname.com/api/hielen/features?... potr\u00e0 essere utilizzato per creare un elemento di tipo feature. mentre GET www.hostname.com/api/hielen/features/uuid_feature servir\u00e0 a recuperare le informazioni della feature individuata da uuid_feature","title":"2.  Utilizzo dei potocolli standard HTTP"},{"location":"#3-risposta-standard-delle-api","text":"Dove non diversamente specificato, le api rispondono con un json in questo formato: { \"meta\": { \"response\": ..., \"message\": ..., \"data_type\": ..., }, \"data\": ... } dove: il campo meta contine informazioni relative all'esecuzione della richiesta . il sottocampo response pu\u00f2 assumere i valori error oppure ok . il sottocampo message contiene l'eventuale messaggio di errore. il sottocampo data_type contiene la marcatura dell'api richiesta (es.: \"GET /api/hielen/features\"). il campo data contiene la risposta prodotta dall'esecuzione, generalmente un json, se essa \u00e8 andata a buon fine.","title":"3.  Risposta standard delle API"},{"location":"#struttura-generale-delle-api","text":"Protocollo Nome API Descrizione GET /prototypes informazioni sulle tipologie di feature implementate GET /actionschemata schemi di base per agire sulle features POST /features creazione di una nuova feature GET /features recupero di informazioni sulle features PUT /features modifica di una feature DELETE /features eliminazione di una feature POST /actions azione specifica su una featrue GET /actions recupero di informazioni sull'azione eseguita su una feature PUT /actions modifica di un'azione precedentemente eseguita su una feature DELETE /actions eliminazione di un'azione precedemente eseguita su una feature GET /query interfaccia di interrogazione dei dati","title":"Struttura generale delle API"},{"location":"BACKLOG/","text":"MODULO PRICIPALE: astrazione setup di configurazione : Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 x bassa Completo Features Prototypes o Interfaccia di modulo: Integrare informazioni capability: [series,map,cloud] e cachable (non sempre \u00e8 vantaggioso usare la cache) x alta Completo Revisione dell'ambiente di produzione e accenzione delle istanze. x media Completo Mapserver: istanza mapserver con workers (vedi Ecoplame) per la gestione delle mappe statiche tassellate (chiamate wms standard) x bassa Completo inserire \"suggerimenti\" nei prototipi delle azioni da passare nella nella risposta alla chiamata \"/actionSchemata\" x bassa Completo API: DELETE /action/{feature}/{config} 2 alta Completo Revisione del modello di Source con sottoclassi source->data->map->cloud: Ogni sottoclasse estende le funzionalit\u00e0 in modo da avere livlli di capabilities gerarchici (\"cloud\" \u2283 \"map\" \u2283 \"data\"). Di fatto si pu\u00f2 intendere ogni tipologia di elaborazione come timeseries la cui produzione \u00e8 legata alla specifica capability della tipologia di sorgente (es: le mappe elaborate del parametro \"displacement\" di una specifica feature da una certa data ad un'altra ). 2 Completo da rifinire Completare la Progettazione/Implementazione per la generazione delle istanze delle serie dati associate alla feature sulla base dei prototipi. Da gestire in modo omegeneo le info accessorie generate ad esepio dalle configurazioni. x alta Completo Impelementazione del modulo astratto datacache. Necessario per lo storing delle serie dati. Attualmente implementato con jsson e csv su flesystem. Potr\u00e0 essere implementato con Redis. x media Completo Gestione del colorrange di riferimento per ogni possibile parametro. gestione delle serie dati Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 x media Completo Rivedere il modello di interrogazione omogeneo per data, maps, cloud: inserire la gestione degli slice temporali, Integrazione dell'interrogazione basata su GeoJeson nell'API x alta Completo Intergrazione dei modelli di calcolo estempranei gestione delle immagini generate Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 x media Completo introduzoine del path \"map\" e gestione nel sitema, questo path vine esposto per mapserver x bassa Completo gestione di mapserver come fast-cgi astrazione interrogazione data : Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 2 bassa Completo convergere al modello omgeneo 1 media Completo implementazione della sottoclasse data di source. hielen2.source.Data(hielen2.source.Source) astrazione interrogazione mappa Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 1 bassa Completo convergere al modello omgeneo 1 bassa Completo Implementazione modello di astrazione e API per moduli con capability \"mappa\": classe estesa di source: hielen2.source.Map(hielen2.source.Data) possa essere richiamato dal layer di astrazione e che fornisca in uscita un'immagine georiferita da inserie un path ben codificato. Contestualmente viene prodotto un mapfile associato da passare a mapserver al momento dell'interrogazione (Integrato SM) astrazione interrogazione cloud Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 x alta Completo convergere al modello omgeneo 4 bassa Completo Implementazione API di interrogazione cloud: Attualmente il \"prodotto\" atteso \u00e8 una pagina html generata in automatico da fornire in front-end. 3 media Completo Potree: installazione e gestione del software, Implementazione modulo wrapper (Integrare nel sistema lo sviluppo di GC) MODULO ESTESO hielen2.ext.source_PhotoMonitoring azione config : Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 x media Completo Attivit\u00e0 di configurazione e persistenza dati x alta Completo gestione delle immagini (crs, formati, salvataggi, indicizzazione) azione feed : Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 x bassa Completo Aggancio del codice gi\u00e0 implementato come prototipo per Tisma + revisione interrogazione dati Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 1 bassa Completo Aggancio del codice gi\u00e0 implementato come prototipo per Tisma 3 media Completo Estrazione dati su interpolazione areale (interrogazione su bounding box) interrogazione mappa Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 1 media Completo Agganco del codice gi\u00e0 implementato come prototipo per Tisma + revisione 2 bassa Completo associare colorrange in uscita MODULO ESTESO hielen2.ext.source_TinSAR azione config : Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 3 media Completo Analisi info master cloud, strutture di persistenza (verificare matrici sparse), potree run (Integrare sviluppo GC) 3 bassa Completo Salvataggio delle info sul modello di source_PhotoMonitoring azione feed : Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 4 media Completo Analisi file in ingresso ed elaborazione file in ingresso 4 media Completo Aggiornamento strutture di persistenza interrogazione series Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 5 media Completo Interazione tramite modello di astrazione (interrogazione tramite GeoJeson mutuabile da source_Photomonitoring). Nota : Estrazione puntuale del front-end parzialmente implementata (Integrare sviluppo GC + DD). Estendere con estrazione punti in area e volume (Potree ritorna sempre un set di punti) interrogazione mappa Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 x alta Completo Proiezione della nuvola su piano x,y: Da trovare un modello efficiente di proiezione. Una volta proiettata l'immagine il resto rientra nel modello generale. interrogazione cloud Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 5 media Completo Restituire in output il prodotto \"html\" della nuvola di punti. Nota : Produzione html parzialmente implementato da sviluppo di GC. ALTRO SENZA PRIORITA' Gestione degli schemi del db: Definendo gli schemi Marshmallow per le tabelle dei DB \u00e8 possibile utilizzare Dump e Load per aggirare la non seriabilit\u00e0 di datetime Moduli HielenSource : attualmente, per comodit\u00e0, vengono sviluppati come sotto moduli di hielen2 ma il modo corretto \u00e8 quello di separare lo sviluppo. Sar\u00e0 sempre possibile farlo dal momento che le strutture vengono sviluppate con l'obiettivo della separazione. Implementare procedura di testing delle api verificare il default dei campi marshmallow (sembra non prenderlo in considerazione, prob non arriva null ma \"\") POST /prototypes Migliorare l'output dei doc del JsonValidable Gestire i filed Nested nei doc del JsonValidable","title":"Backlog"},{"location":"BACKLOG/#modulo-pricipale","text":"","title":"MODULO PRICIPALE:"},{"location":"BACKLOG/#astrazione-setup-di-configurazione","text":"Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 x bassa Completo Features Prototypes o Interfaccia di modulo: Integrare informazioni capability: [series,map,cloud] e cachable (non sempre \u00e8 vantaggioso usare la cache) x alta Completo Revisione dell'ambiente di produzione e accenzione delle istanze. x media Completo Mapserver: istanza mapserver con workers (vedi Ecoplame) per la gestione delle mappe statiche tassellate (chiamate wms standard) x bassa Completo inserire \"suggerimenti\" nei prototipi delle azioni da passare nella nella risposta alla chiamata \"/actionSchemata\" x bassa Completo API: DELETE /action/{feature}/{config} 2 alta Completo Revisione del modello di Source con sottoclassi source->data->map->cloud: Ogni sottoclasse estende le funzionalit\u00e0 in modo da avere livlli di capabilities gerarchici (\"cloud\" \u2283 \"map\" \u2283 \"data\"). Di fatto si pu\u00f2 intendere ogni tipologia di elaborazione come timeseries la cui produzione \u00e8 legata alla specifica capability della tipologia di sorgente (es: le mappe elaborate del parametro \"displacement\" di una specifica feature da una certa data ad un'altra ). 2 Completo da rifinire Completare la Progettazione/Implementazione per la generazione delle istanze delle serie dati associate alla feature sulla base dei prototipi. Da gestire in modo omegeneo le info accessorie generate ad esepio dalle configurazioni. x alta Completo Impelementazione del modulo astratto datacache. Necessario per lo storing delle serie dati. Attualmente implementato con jsson e csv su flesystem. Potr\u00e0 essere implementato con Redis. x media Completo Gestione del colorrange di riferimento per ogni possibile parametro.","title":"astrazione setup di configurazione:"},{"location":"BACKLOG/#gestione-delle-serie-dati","text":"Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 x media Completo Rivedere il modello di interrogazione omogeneo per data, maps, cloud: inserire la gestione degli slice temporali, Integrazione dell'interrogazione basata su GeoJeson nell'API x alta Completo Intergrazione dei modelli di calcolo estempranei","title":"gestione delle serie dati"},{"location":"BACKLOG/#gestione-delle-immagini-generate","text":"Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 x media Completo introduzoine del path \"map\" e gestione nel sitema, questo path vine esposto per mapserver x bassa Completo gestione di mapserver come fast-cgi","title":"gestione delle immagini generate"},{"location":"BACKLOG/#astrazione-interrogazione-data","text":"Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 2 bassa Completo convergere al modello omgeneo 1 media Completo implementazione della sottoclasse data di source. hielen2.source.Data(hielen2.source.Source)","title":"astrazione interrogazione data:"},{"location":"BACKLOG/#astrazione-interrogazione-mappa","text":"Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 1 bassa Completo convergere al modello omgeneo 1 bassa Completo Implementazione modello di astrazione e API per moduli con capability \"mappa\": classe estesa di source: hielen2.source.Map(hielen2.source.Data) possa essere richiamato dal layer di astrazione e che fornisca in uscita un'immagine georiferita da inserie un path ben codificato. Contestualmente viene prodotto un mapfile associato da passare a mapserver al momento dell'interrogazione (Integrato SM)","title":"astrazione interrogazione mappa"},{"location":"BACKLOG/#astrazione-interrogazione-cloud","text":"Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 x alta Completo convergere al modello omgeneo 4 bassa Completo Implementazione API di interrogazione cloud: Attualmente il \"prodotto\" atteso \u00e8 una pagina html generata in automatico da fornire in front-end. 3 media Completo Potree: installazione e gestione del software, Implementazione modulo wrapper (Integrare nel sistema lo sviluppo di GC)","title":"astrazione interrogazione cloud"},{"location":"BACKLOG/#modulo-esteso-hielen2extsource_photomonitoring","text":"","title":"MODULO ESTESO hielen2.ext.source_PhotoMonitoring"},{"location":"BACKLOG/#azione-config","text":"Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 x media Completo Attivit\u00e0 di configurazione e persistenza dati x alta Completo gestione delle immagini (crs, formati, salvataggi, indicizzazione)","title":"azione config:"},{"location":"BACKLOG/#azione-feed","text":"Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 x bassa Completo Aggancio del codice gi\u00e0 implementato come prototipo per Tisma + revisione","title":"azione feed:"},{"location":"BACKLOG/#interrogazione-dati","text":"Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 1 bassa Completo Aggancio del codice gi\u00e0 implementato come prototipo per Tisma 3 media Completo Estrazione dati su interpolazione areale (interrogazione su bounding box)","title":"interrogazione dati"},{"location":"BACKLOG/#interrogazione-mappa","text":"Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 1 media Completo Agganco del codice gi\u00e0 implementato come prototipo per Tisma + revisione 2 bassa Completo associare colorrange in uscita","title":"interrogazione mappa"},{"location":"BACKLOG/#modulo-esteso-hielen2extsource_tinsar","text":"","title":"MODULO ESTESO hielen2.ext.source_TinSAR"},{"location":"BACKLOG/#azione-config_1","text":"Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 3 media Completo Analisi info master cloud, strutture di persistenza (verificare matrici sparse), potree run (Integrare sviluppo GC) 3 bassa Completo Salvataggio delle info sul modello di source_PhotoMonitoring","title":"azione config:"},{"location":"BACKLOG/#azione-feed_1","text":"Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 4 media Completo Analisi file in ingresso ed elaborazione file in ingresso 4 media Completo Aggiornamento strutture di persistenza","title":"azione feed:"},{"location":"BACKLOG/#interrogazione-series","text":"Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 5 media Completo Interazione tramite modello di astrazione (interrogazione tramite GeoJeson mutuabile da source_Photomonitoring). Nota : Estrazione puntuale del front-end parzialmente implementata (Integrare sviluppo GC + DD). Estendere con estrazione punti in area e volume (Potree ritorna sempre un set di punti)","title":"interrogazione series"},{"location":"BACKLOG/#interrogazione-mappa_1","text":"Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 x alta Completo Proiezione della nuvola su piano x,y: Da trovare un modello efficiente di proiezione. Una volta proiettata l'immagine il resto rientra nel modello generale.","title":"interrogazione mappa"},{"location":"BACKLOG/#interrogazione-cloud","text":"Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 5 media Completo Restituire in output il prodotto \"html\" della nuvola di punti. Nota : Produzione html parzialmente implementato da sviluppo di GC.","title":"interrogazione cloud"},{"location":"BACKLOG/#altro-senza-priorita","text":"Gestione degli schemi del db: Definendo gli schemi Marshmallow per le tabelle dei DB \u00e8 possibile utilizzare Dump e Load per aggirare la non seriabilit\u00e0 di datetime Moduli HielenSource : attualmente, per comodit\u00e0, vengono sviluppati come sotto moduli di hielen2 ma il modo corretto \u00e8 quello di separare lo sviluppo. Sar\u00e0 sempre possibile farlo dal momento che le strutture vengono sviluppate con l'obiettivo della separazione. Implementare procedura di testing delle api verificare il default dei campi marshmallow (sembra non prenderlo in considerazione, prob non arriva null ma \"\") POST /prototypes Migliorare l'output dei doc del JsonValidable Gestire i filed Nested nei doc del JsonValidable","title":"ALTRO SENZA PRIORITA'"},{"location":"CHANGELOG/","text":"CHANGELOG v3.3.21 19 Gennaio 2024 unificazione delle tabelle di log inserite tutte in hielen.json in base alla commessa v3.3.12 28 Febbraio 2023 inserito \" ALIAS \" per agganciare serie dati a parmaetri diversi v3.3.11 16 Febbraio 2023 migliorato instrument imporved, inserito offset iniziale nucleo di batch per tipologie spefcifiche v3.3.10 31 Gennaio 2023 rivisto il filtro valid_range applicato automaticamente a tutte le serie gestito anche per datadiagram sistemato il clean cache per datadiagram v3.3.9 15 Gennaio 2023 gestione della configurazione ed elaborazione della serie valore valore v3.3.8 12 Dicembre 2022 introdotta la serie datadiagram per le elaborazioni valore valore v3.3.5 12 Novembre 2022 modifche minori v3.3.1 12 Ottobre 2022 inserimento dell'entry \"query\" in hielen3.db v3.3.0 10 Ottobre 2022 inserita la tabella eventi impelmentato check per canale v3.2.9 30 Settembre 2022 sistemate threshold canale (chiave uuid,label,tipo(UPPER,LOWER)) definto json di configurazione generale dei canali come collezione di oggetti rilassato il concetto di operando di una serie permettendo valori arbitrari e non solo uuid di serie (viene riconoesciuto il formato uuid e caricata la serie) implementati gli sghembi v3.2.5 definito srumento generico con configurazione multipli canali v3.2.4 5 Giugno 2022 inserito management soglie (sigolo valore) multiple e range apertura grafici v3.2.3 24 Maggio 2022 rivisto l'output di query con uscita json secondo le specifiche di dygraph per il frontend: { \"id1\":[ [\"data\",valore], [\"data\",valore], ... ], \"id2\":[ [\"data\",valore], [\"data\",valore], ... ], ... } v3.2.2 18 Maggio 2022 introdotto concetto di ordinal dei parametri associati alle feature: modificato hielen3.Feature, hielen3.ext.feature_instrument_piezometer modificato database: aggiunta colonna ordinal alla tabella feature_parameter e modificata la vista v_features_parameter per ordinare i parametri v3.2.1 17 Maggio 2022 feature piezometer feature shapearray v3.2.0 10 Maggio 2022 ristrutturato in modello di astrazione delle feature implementazione del modulo di base hielen3.ext.feature_instrument implementazione del module di base hielen3.ext.feature_datetree_filesystem_source che permette la configurazione delle sorgenti basate su strutture di files organizzate secondo il pattern SOURCE/YYYY/MM/DD v3.1.6 21 Aprile 2022 implementazione dell'api GET /queue/ implementazione della capability \"stream\" gestione delle richieste kynetics v3.1.0 5 Marzo 2022 modifica api POST /feature/ : non prende pi\u00f9 il parametro \"uid\" . Il campo \"uid\" della feature viene ora generato dalla chiamata, secondo gli standard di \"uuid\". modifica definizione della classe hielen3.api.feature.FeaturePropertiesSchema : rinominato il campo \"context\" in \"milieu\" . Questo coinvolge la chiamata API POST /feature/ in quanto la classe modificata gestisce e valida il json da passare al parametro properies dell'API. modifica api POST,GET,PUT,DELETE /feature/ : rinominato il parametro \"cntxt\" in \"milieu\" . La parola \"milieu\" al contrario di \"context\" non d\u00e0 problemi di interpretazione al sottostante strato di \"Hug\" (per questo motivo era stata utilizzata \"cntxt\"). In questo modo vengono uniformati i parmametri di queste API con il campo della classe di gestione delle properties. NOTA Da reintegrare reintegrare seconda met\u00e0 2021 -> inizio 2022 v2.0.10 10 Maggio 2021 Integrazione di ColorMap, e Config Time Operands 7 Maggio 2021 Introduzione della classe marshmallow \"ColorMap\" per la serializzazione delle informazioni custom di colorazione dei dati: tra i vari campi che possono essere ritornati da actionschemata ora ne esiste uno chiamato ColorMap . Es.: PhotoMonitoring actionschemata Come funziona ColorMap : Incontrando il campo definito come \"ColorMap\" all'interno di una risposta di actionschemata , il front-end aprir\u00e0 l'interfaccia di scelta dei colori. Il risultato dell'interazione dovr\u00e0 essere sintetizzato in un json da fronire come parametro all'azione corrispondente. Il json dovr\u00e0 essere nella forma di un array di lunghezza variabile di COPPIE (valore,colore): [ [ valore, colore ], [ valore, colore, ] ... ] dove: valore \u00e8 un numero di qualsiasi genere con punto decimale colore \u00e8 una stringa di colore hex esempio: [ [ -0.25, '#FFFF00' ], [ -0.125, '#00FF00' ], [ 0, '#0000FF' ], [ 0.5, '#FF00FF' ], [ 1, '#AEBD00' ], ] Un array del genere verrebbe inteso in questo modo: [-inf,-0.25) : [-0.25,-0.125) : --> [-0.125,0.0) : --> [0.0,0.5) : --> [0.5,1.0) : --> [1.0,inf) : L'informazione sulla colormap pu\u00f2 essere associata ad ongi singola serire dati e pu\u00f2 essere fornita in front-end su richiesta: allo scopo L'API features \u00e8 stata modificata in modo da fornire la colormap insieme con i parametri delle features specificando l'opzione info=parameters,... esempio (vedi chiamata) : { ..., \"parameters\": [ { \"series\": \"2b6c9efb4e83f64e757ce862f8b6c2e0\", \"param\": \"East-West_Displacement\", \"unit\": \"mm\", \"cmap\": [ [ -0.25, \"#FFFF00\", 0 ], [ -0.125, \"#00FF00\", 10 ], [ 0, \"#0000FF\", 20 ], [ 0.5, \"#FF00FF\", 60 ], [ 1, \"#AEBD00\", 100 ] ] }, ... ], ... } dove ogni cmap \u00e8 un array ordinato di triplette utile alla creazione della relativa colorbar. Ogni tipletta fornisce questa infromazione: cmap[x][0] : etichetta del valore, possibilmente da piazzare sulla colorbar alla giusta posizione. cmap[x][1] : colore in esadecimale. cmap[x][2] : posizione dell'ancora del gradiente per il rispettivo colore, nonch\u00e9 per l'eventuale etichetta del valore. La posizione \u00e8 espressa in percentuale sull'intera colorbar. 30 Aprile 2021 Gestione generalizzata degli operandi \"config time\" per i parametri: Ora la classe Source espone dei metodi per dare la possibilit\u00e0 alle sotto classi di definire operandi di elaborazione custom. v2.0.9 22 Aprile 2021 implementata l'interrogazione tramite GeoJson Correzione di molti bugs Aggancio della query dati v2.0.8 2 Aprile 2021 implementato il modello di cache per la gestione dei dati prodotti debug delle nuove funzionalit\u00e0 31 Marzo 2021 inserita la nuova entit\u00e0 db \"feaures_info\" riviste le api /features/ /actions/ /query/ rivisto il codice di hielen2.source hielen2.query introdotto il modulo hielen2.mapmanager per la gestione della generazione dei mapfile rivisto il codice di hielen2.ext.source_photomonitoring 29 Marzo 2021 inserito il concetto di \"info\" nelle richieste a feature: Con questo parametro si riescono a centralizzare le chiamate che si focalizzano sulle feature e si separano le informazioni di secondo livello ad esse legate. In questo modo la risposta di default risulta piuttosto leggera ma diventa uno strumento potente e versatile specificando esplicitamente l'estrazione di iformazioni accessorie. Attualmente il parametro \"info\" accetta un array in cui pu\u00f2 essere richiesta l'estrazione di queste info: geometry : il GeoJson della geometria della feature capabilities : le possibili interrogazioni effetuabili sulla feature \u00e8 un array che contiene uno o pi\u00f9 di questi valori: \"data\",\"map\",\"cloud\". la feature risponder\u00e0 a chiamate del tipo /query/{capability} . Nel caso l'array fosse vuoto la feature non risponderebbe ad alcuna interrogazione. parameters : l'elenco dei parametri associati alla feature come riportati dal'API GET /parametes/ . Quest'ultima API diviene inutile e sar\u00e0 eliminata in futuro timeline : la timeline dei dati associati ai parametri della feature. Utile per lo pi\u00f9 per le query map e cloud data : informazioni specifiche di per la capability \"data\" map : informazioni specifiche per la capability \"map\" (il formato \u00e8 esattamente quello del nodo \"map\" del backbone di geoframe) cloud : informazioni specifiche per la capability \"cloud\" 23 Marzo 2021 unificata la struttura di backend che gestisce le chiamate alle serie (dati, mappe e in futuro clouds): Eliminati moduli hielen2.data.data_access_layer e hielen2.maps.data_access_layer e sostituiti entrambi con hielen2.query , il modulo dichiara la classe hielen2.quert.Series che prevede il parametro capability per distingure tra [\"data\",\"map\",\"cloud\"]. riviste le api GET /maps/ e GET /data/ , unificate sotto l'api GET /query/ in questo modo: GET /query/data/ GET /query/map GET /query/cloud/ (futura) la parametrizzazione di \"datamap\" viene modificata eliminando \"timeto\" e \"timefrom\" ed inserendo \"times\" come slice temporale (vedi 11 Marzo 2021) ATTENZIONE: Nel caso venga richesto in risposta un mimetype \"txt\" il separatore dei campi passa da \",\" a \";\" 19 Marzo 2021 Revisione dell'ambiente di produzione e accenzione delle istanze su server Nhazca. Mapserver: istanza mapserver con workers (vedi Ecoplame) per la gestione delle mappe statiche tassellate (chiamate wms standard) v2.0.7 15 Marzo 2021 API: GET /maps/ per la generazione delle mappe. 11 Marzo 2011 Introdotti gli slice temporali come estenzione di marshmallow.field mappati sulla classe slice di python: Provides python object which performs selection on narry. It axcept a three filed string separated by \":\". \":\" presence is managed as: \"start:stop:step\" ie.: \"start:stop\" - extracts from start to stop \"start:\" - extracts from start to max \"start\" - extract exactly start implementato /maps/data_access_layer.py per la gestione angostica delle mappe (utilizzo della datacache) 3 Marzo 2021 API: DELETE /actions/{feature}/{*} agganciata a datacache (vengono tolte dalla cache le elaborazioni dipendenti da config) API: DELETE /features/{feature} pulizia cache e serie dati 25 Febbraio 2021 Impelementazione del modulo astratto datacache. Necessario per lo storing delle serie dati. Attualmente implementato con json e csv su flesystem. Potr\u00e0 essere implementato con Redis. 18 Febbraio 2021 Implementazione metodo astratto map che viene invocato in modo agnostico sull'istanza di un tipo con capability \"map\" per produrre le immagini elaborate. Risponde in modo standard creando l'immagine in posizione definita. Nota: Deve diventare metodo di classe 12 Febbraio 2021 Revisione del modello di Source con sottoclassi source->data->map->cloud: Ogni sottoclasse estende le funzionalit\u00e0 in modo da avere livlli di capabilities gerarchici (\"cloud\" \u2283 \"map\" \u2283 \"data\"). Di fatto si pu\u00f2 intendere ogni tipologia di elaborazione come timeseries la cui produzione \u00e8 legata alla specifica capability della tipologia di sorgente (es: le mappe elaborate del parametro \"displacement\" di una specifica feature da una certa data ad un'altra ). Esteso il concetto di interrogazione con risultanza di series per data, maps, e clouds v2.0.6 7 Febbraio 2021 Sviluppo Tinsar Implementata la richiesta di Nhazca: - Anticipata analisi di potree e generazione / colorazione clouds. - Implementato mockup 3D funzionante - Compilazione e utilizzo di PotreConverter 27 Gennaio 2021 Inserita la validazione dei campi delle action 25 Gennaio 2021 Inserito il campo \"hint\" nella risposta di GET /actionschemata[/{feature}[/{action}]] Implementata astrazione di DELETE /actions/{feature}/{action}/ . Prima della rimozione della specifica azione dal db, vengono chimati i metodi preposti alla gestione della rimozione delle informazioni in cache, che si presuppone siano implemetati dai relativi moduli. I moduli possono implementare questi metodi solo se necessario. Sintassi: Invocando il metodo deleteActionValues(self,action,timestamp) della superclasse Hielen2.Source, essa tenter\u00e0 di utilizzare il metodo della sottoclasse il cui nome \u00e8 cotruito dal'unione della parola \"delete\" + il nome dell'azione con la prima lettera maiuscola: es: \"deleteConfig\". la superclasse passer\u00e0 sempre un timestamp per individuare l'azione specifica Implementato il metodo \"deleteConfig\" della classe Hielen2.ext.source_PhotoMonitoring Corretto bug minore di gestione delle azioni in caso esse producano errori non preventivati. 22 Gennaio 2021 Ristrutturata la pagina di TODO , inserita categorizzazione e valutazione delle tempistica delle attivit\u00e0 20 Gennaio 2021 modulo hielen2.ext.source_PhotoMonitoring : rimodellato sulla base del modulo hielen2.source . definite le classi schema per le azioni: ## action 'config' (Completamente Funzionante) class ConfigSchema ( ActionSchema ): master_image = LocalFile ( required = True , allow_none = False ) step_size = fields . Str ( required = False , default = \"8\" ) window_size_change = fields . Str ( required = False , default = \"0\" ) geo_reference_file = LocalFile ( required = False , default = None ) crs = fields . Str ( required = False , default = None ) ## action 'feed' class FeedSchema ( ActionSchema ): reference_time = fields . Str ( required = False , allow_none = False ) NS_displacement = LocalFile ( required = False , allow_none = False ) EW_displacement = LocalFile ( required = False , allow_none = False ) Coer = LocalFile ( required = False , allow_none = False ) 18 Gennaio 2021 Revisione concettuale delle API e modifiche: GET /parametes : lo schema di ritorno \u00e8 il seguente (semplicemente \"param\" al posto di \"name\" ): { ..., \"data\": { \"ARCCE01\": [ { \"series\": \"ARCCE01_Rotazione_X\", \"param\": \"Rotazione X\", \"unit\": \"mm/m\"}, ..... } ] } actionSchemata \u00e8 l'api che fornir\u00e0 gli schemi per le azioni e va a sostituire quella che era \"prototypes\". Questa esiste ancora e mantiene il legame tra prototipo e modulo ma pi\u00f9 che altro le informazioni che stanno nella relativa tabella mi servono per il back-end GET ../actionschemata[/{prototypes}[/{actions}]] action come prima, \u00e8 l'api che gestisce le azioni: La versione POST nella sostanza non \u00e8 cambiata a parte il fatto che un'azione dichiarer\u00e0 sempre un timestamp per default. Ma questa cosa al front-end non interessa dal momento che le info le recupera da actionSchemanta. E' invece importante nella scrittura dei plugin perch\u00e9 in questo modo le azioni possono essere gestite temporalmente. La versione GET , invece cambia sostanzialmente: non fornir\u00e0 pi\u00f9 i default per la post MA potr\u00e0 fornire una serie temporale di azioni associate a dei valori di elaborazione che danno informazioni all'utente. in questo formato: GET ../actions[/{feature}[/{action}]] ritorna: [ { \"timestamp\":....,\"value\":.... }, { \"timestamp\":...., \"value\":.... }, .... ] esempio: GET ../actions/featurecode/config { \"meta\": { \"response\": \"ok\", \"message\": \"\", \"data_type\": \"GET /actions/ciaociaociao4/config\" }, \"data\": [ [ { \"timestamp\": \"2020-12-30 01:00:05\", \"value\": { \"master_image\": \"TIFF image data, little-endian, direntries=14, height=1842, bps=16, compression=none, PhotometricIntepretation=BlackIsZero, width=3545\", \"step_size\": \"35\", \"window_size_change\": \"10\", \"transform\": [ 15.0, 0.0, 464947.5, 0.0, -15.0, 7977067.5 ], \"cache\": \"20201230010005\", \"crs\": null } }, { \"timestamp\": \"2020-12-30 01:00:07\", \"value\": { \"master_image\": \"TIFF image data, little-endian, direntries=16, height=1842, bps=16, compression=none, PhotometricIntepretation=BlackIsZero, width=3545\", \"timestamp\": \"2020-12-30 01:00:07\", \"step_size\": \"35\", \"window_size_change\": \"10\", \"transform\": [ 15.0, 0.0, 464947.5, 0.0, -15.0, 7977067.5 ], \"cache\": \"20201230010007\", \"crs\": \"EPSG:32622\" } } ] ] } 15 Gennaio 2021 modulo hielene2.source : Implementato il metodo sourceFactory per la generazione degli ogetti HeielenSource in base ai prototipi che sfrutta il cariacmanto dinamico dei moduli specifici (metodo loadModule ) Implementati i metodi e le classi per la gestione agnostica delle azioni ed il recupero degli schemi: getActionSchema , moduleAction , HielenSource.execAction , HielenSource.getActionValues Implementata la gestione dell'ambiente di cache dedicato alle singole istanze di HielenSource: HielenSource.makeCachePath , HielenSource.getRelativePath Definita la classe primitiva per i modelli di schema per le azioni che impone la definizione della marcatura temporale: class ActionSchema ( Schema ): timestamp = fields . Str ( required = True , allow_none = False ) 13 Gennaio 2021 rimodellato il db: dalla tabella \"features\" sono state eliminate le colonne \"a priori\" delle azioni. Queste ultime sono state inserite in una nuova tabella \"actions\" con chiave multipla (\"feature\",\"action\",\"timestamp\"). Rivista l'interfaccia db per permettere l'interrogazione su chiave multipla 10 Gennaio 2021 Progettazione della gestione temporale delle azioni e separazione del concetto di form da quello di risultato della azione: ogni azione ha uno schema di input e dei risultati in output con uno schema non necessariamente coincidente. Quello che viene fornito alle form sono i dati necessari ad intraprendere un'azione. I risultati dell'azione devono essere registrati con una marcatura temporale. In questo modo ogni azione \u00e8 univocamente determinata e gestibile con un modello del tipo (\"feature\",\"action\",\"timestamp\"), con una cardinalit\u00e0 1-a-molti tra features e azioni Portata a termine la migrazione della gestione delle azioni che vengono ora completamente affidate ai singoli moduli. L'iterfaccia di alto livello \u00e8 ora in grado di gestire agonsticamente le chiamate ad azioni arbitrarie purch\u00e8 ben definite all'interno dei moduli. In questo modo cade il vincolo di definizione do azione \"a priori\" 30 Dicembre 2020 sviluppo (non completo) di config hielen2.ext.PhotoMonitoring: Implementato il metodo di recupero e settaggio delle informazioni geometriche/geografiche dell'immagine in ingresso Aggancio del codice originale per la gesgione del netcdf (in debug) 22 Dicembre 20202 Delineata la gestione di mappa delle immagini prodotte: Ogni immagine prodotta sar\u00e0 sempre associata al suo crs e la matrice di trasformazione affine, anche nele caso in cui queste informazioni non dovessero essere passate in configurazione. In questo caso si assume un piano cartesiano con udm in m e una matrice identit\u00e0 per le trasformazioni affini. Sar\u00e0 dunque sempre possibile gestire le immagini come mappe (slippy maps) e sfruttare la tassellazione, il cacheing dei tasselli. 20 Dicembre 2020 Modificata l'api POST /actions/{feature}/{form} in modo da interrogare la Source (per ora solo PhotoMonitoring) sulla definizione delle azioni: Implementate le classi di Schema per config e feed per il modulo hielen2.ext.PhotoMonitoring . ATTENZIONE per config : introdotto il campo \"timestamp\", eliminati i campi espliciti relativi al word_file ( word_file mantenuto), modificato il campo epsg in csr . 15 Dicembre 2020 Delineato il modello di scrittura dei Source plugin secondo un template univoco. Ogni plugin potr\u00e0 essere un modulo python definito come segue: deve definire tante classi marshmallow.Schema quante sono le azioni che vengono prese in carico dal Template. Marsmallow \u00e8 un serializzatore di oggetti python. Lo schema definito servir\u00e0 per definire i campi in ingresso per ogni azione e fare i check dei valori in ingresso. Il nome delle classi Schema deve seguire questa sintassi: class {Action}Schema(marshmallow.Schema) dove {Action} \u00e8 il nome dell'azione (es.: config, feed, ..) con l'iniziale maiuscola . Nella classe vengono definiti i tipi dei campi ( marshmallow.fields cfr. https://marshmallow.readthedocs.io/en/stable/ ). ATTENZIONE: in caso fosse necessario l'ingresso di file o comunque oggetti blob dovr\u00e0 essere utilizzato come field la classe hielen2.utils.LocalFile . In questo modo il sistema risolver\u00e0 la chiamata API salvando in locale lo stream dei dati associato a quel determinato field, il quale sar\u00e0 accessibile al template attraverso un path che verr\u00e0 fornito insieme agli altri campi al momento della chiamata del metodo di gestione dell'azione (vedi sotto). deve implementare una classe Source(hielen2.datalink.HielenSource) che esponga tanti metodi quante sono le dichiarazioni di Schema seguendo questa sintassi: il metodo di gestione dell'azione deve chiamarsi come l'azione stessa ( tutto in minuscolo ). Le classi estese sfrutteranno il metodo __init__ della superclasse in modo da avere a disposizione tutto quello di cui necessitano. Questo modello permette di svincolare i template dalla necessit\u00e0 di conoscere a priori le azioni ammmissibili per il sistema. Infatti, facendo introspezione su un template che segua le regole di sintassi sar\u00e0 sempre possibile conoscere le azioni definite ed esternalizzarle al front-end che in base alle definizioni delle classi di Schema delle azioni, sar\u00e0 sempre in grado di instanziare una form adeguata. v2.0.5 9 Dicembre 2020 Implementata working POST /actions/{feature}/{form} tramite content-type/multipart dinamico definito dal prototipo: L'api \u00e8 collegata ai moduli reali delle tipologie definiti come templates, con la funzionalit\u00e0 minima di salvare i parametri in ingresso. I moduli sono in fase di sviluppo e man mano che vengono implementati le funzionalit\u00e0 aumenteranno. Implementato Loading dinamico dei moduli di elaborazione definiti come estensioni di hielen2.datalink.HielenSource Implementata working GET /actions/{feature}[/{form}] : Per ogni form richiesta, risponde con tutti i parametri definiti nel relativo prototipo, riempiti con i valori definiti tramite la POST della stessa api. I valori non precedentemente forniti vengono impostati a null Riveduta e corretta GET prototypes/{prototype}/forms[/form] : ATTENZIONE adesso risponde con TUTTI i campi dentro il dizionario \"args\" e comunica i campi obbligatori attraverso l'array \"mandatory\". Questa struttura \u00e8 pi\u00f9 versatile in quanto, una volta definito il set completo degli argomenti, \u00e8 possibile definire un numero arbitrario di sottoinsiemi predicativi non necessariamente distiniti: Oltre al sottoinsieme \"mandatory\" si potrebbe, ad esempio, definire un sottoinsieme di immutabili. Qui sotto una struttura di esempio: { \"data\": { \"args\": { \"epsg\": \"string\", \"master_image\": \"file\", \"negative_pixel_y_size\": \"string\", \"pixel_x_size\": \"string\", \"rotation_about_the_x_axis\": \"string\", \"rotation_about_the_y_axis\": \"string\", \"step_size\": \"string\", \"window_size_change\": \"string\", \"world_file\": \"file\", \"x_coordinate_of_upper_left_pixel_center\": \"string\", \"y_coordinate_of_upper_left_pixel_center\": \"string\" }, \"mandatory\": [ \"master_image\", \"step_size\", \"window_size_change\" ] }, \"meta\": { \"data_type\": \"GET /prototypes/PhotoMonitoring/forms/config\", \"message\": \"\", \"response\": \"ok\" } } 7 Dicembre 2020 Rimodellato il feature db per contenere gli argomenti delle actions Riveduto il feature_proto db: Inserito il modulo di riferimento tra le info del prototipo (il modulo contenete la classe estesa di hielen2.datalink.HielenSource ) Definita la superclasse hielen2.datalink.HielenSource con definizione univoca di __init__ con questo footprint: (self,featureobject,environment) . La classe definisce inotre i metodi astratti che vengono utilizzati dal sistema che ogni estensione di questa dovr\u00e0 implementare. 2 Dicembre 2020 Struttura definitiva delle features: { \"properties\":\"...\" \"parameters\":\"...\" \"geometry\":\"...\" } dove: properties mantiene tutte le info della feature. Quelle di base: uid , type , classification , location , description e quelle definite per le specifiche azioni definite per la tipologia. In particolare quella di configurzione. parameters mantiene la struttura di accesso alle info e ai dati dei parametri definiti per la feature. geometry fornisce le informazioni geometriche della feature. Rivedute le api /actions , /parameters , /features ( /data da rivedere) 24 Novembre 2020 Implementate dummy /actions/{feature}/ e /actions/{feature}/{form} 23 Novembre 2020 Riorganizzato il db delle features per permettere una gestione pi\u00f9 razionale 19 Novembre 2020 riorganizzata la struttura per la gestione delle classi estese che necessitano di dynamic loading: nel modulo himada2.ext (cartella) vengono raccoliti per comodit\u00e0 gli oggetti che saranno implementati man mano come estensione di superclassi astratte appositamente definite: per ora hielen2.datalink.Source e hielen2.datalink.DB e hielen2.datalink.DataCache. Oltre alle classi in hielen2.ext, il sitema potr\u00e0 utilizzare moduli esterni che estendano le superclassi elencate. inserito 'timestamp' nello schema json accettato da POST /feature e PUT /feature . risolto bug minore di incoerenza su GET /data/{feature} e /data/{feature}/{parameter} . Quest'ultima continua ad accettare uno tra i nomi dei parametri della feature. Entrambe rispondo intestando le colonne in uscita con lo uid della serie, come GET /data/ . 17 Novembre 2020 Implementata dummy POST /actions/{feature}/{form} : v2.0.4 16 Novembre 2020 per coerenza rivisti i parametri di POST /feature : uid:<string> prototype:<string> properties:<json schema Properties> geometry:<json schema GeoJson> analogo discorso per PUT /feature/{uid} : properties:<json schema Properties> geometry:<json schema GeoJson> sistemata la risposta di GET /feature , modificando il livello di \"geometry\" implementata api PUT /features/{uid} . Accetta il paramentro properties con uno schema analogo al parmetro feature di POST /features con queste differenze: nello schema della PUT, uid e prototype NON vengono accettati perch\u00e8 sono campi chiave della feature e non possono essere modificati . lo uid della feature deve essere specificato come url e non come parametro. introduzione dello Schema GeoJson per la validazione modificata POST /features/ per accettare un GeoJson nell'attibuto geometry del Json principale feature 13 Novembre 2020 rinominazione DELETE /elements -> DELETE /features . eliminazione degli alias GET /features/{context} e /features/{context}/{uid} a causa del conflitto l'entry point DELETE /features . Il passaggio del context sar\u00e0 esclusivmante attraverso il parametro cntxt ( nota : questo nome \u00e8 dovuto alla collisione del nome con il campo 'context' dell'oggetto request). In caso lo possiamo cambiare. introduzione dell'alias /features/{uid} per il recupero delle info della specifica Feature. 12 Novembre 2020 ovunque nel mondo il parmetro 'uuid' (universal unique id) diventa 'uid'. rinominazione POST /elements -> POST /features . rinominazione GET /elements -> GET /parameters e modifica uscita in questo schema: { <feature1_UID>:[ { \"series\":<feature1_param1_series_UID>, \"param\":<feature1_param1_name>, \"um\":<feature1_param1_measurement_unit> }, ... { \"series\":<feature1_paramN_series_UID, \"param\":<feature1_paramN_name>, \"um\":<feature1_paramN_meaurement_unit> } ], ... <featureX_UID>:[ { \"series\":<featureX_param1_series_UID>, \"param\":<featureX_param1_name>, \"um\":<featureX_param1_measurement_unit> }, ... { \"series\":<featureX_paramM_series_UID, \"param\":<featureX_paramM_name>, \"um\":<featureX_paramM_meaurement_unit> } ] } introduzione api /features con lo schema usato da Daniele e SimoneD: GET /features GET /features/{context}/ GET /features/{context}/{feature} uscita : nota 1: NON viene introdotto \"context\" , come invece preventivato nota 2: \"cod\" diventa \"label\" . nota 3: \"date\" diventa \"timestamp\" nota 3: dalle properties vengono elminate \"z\" e \"mslm\" . nota 4: \"state\" viene mantenuto ma per ora \u00e8 inutilizzato { \"features\": [ { \"type\": \"Feature\", \"properties\": { \"uid\": ..., \"label\": ..., \"context\":..., \"date\": ..., \"type\": ..., \"style\": ..., \"state\": ... }, \"geometry\": <GeoJson Validable> }, ... { \"type\": \"Feature\", \"properties\": { \"uid\": ..., \"label\": ..., \"context\": ..., \"date\": ..., \"type\": ..., \"style\": ..., \"state\": ... }, \"geometry\": <GeoJson Validable> } ] } v2.0.3 11 Novembre 2020 Modificata api POST /elements : la variabile element \u00e8 descritta dalla Classe hielen2.api.data.ElementSchema e validata. In paricolare \u00e8 stato introdotto l'attibuto context Modifcata api GET /data : la variabile datamap \u00e8 descritta dalla Classe hielen2.api.data.DataMapSchema e validata. 9 Novembre 2020 Introdotta la classe hielen2.utils.JsonValidable, per la validazione e documentazione automatica dei parametri delle api (JSON Schema descrition) corretti bug minori in hielen2.datalink 6 Novembre 2020 L'interfaccia DB \u00e8 ora thread safe!!! (almeno per il dummy json db) v2.0.2 4 Novembre 2020 Implementata la documentazione automatica delle api Implementate le api POST ../elements e DELETE ../elements L'uscita per tutte le api element (e per tutte le api con risposta json in generale), seguir\u00e0 questo schema: { \"meta\": { \"data_type\": \"DELETE /elements/ciao\", \"response\": \"ok\" \"message\": \"\", }, \"data\":{ ... } } L'api /series diventa /data e cambia il suo comportamento: la variabile di tipo json datamap si aspetta il campo series invece di parameters . In questo campo devono essere inseriti i codici delle serie e non pi\u00f9 il costrutto \"codice_elemento:parametro_elemento\". I codici delle serie si possono recuperarare dall'api /elements (vedi Nota successiva) L'api /elements cambia la sua risposta e per ogni parametro nella lista parameters degli elementi viene agiunto il codice della serie di riferimento che pu\u00f2 essere fornito senza modifiche a /data : { \"series\":<seriescode>, \"name\":<seriesname>, \"um\":<seriesunit> } GET /series GET /series/{el} GET /series/{el}/{param} GET /prototypes GET /prototypes/{type} GET /prototypes/{type}/forms GET /prototypes/{type}/forms/{form} POST /elements GET /elements GET /elements/{el} DELETE /elements/{el}","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"","title":"CHANGELOG"},{"location":"CHANGELOG/#v3321","text":"","title":"v3.3.21"},{"location":"CHANGELOG/#19-gennaio-2024","text":"unificazione delle tabelle di log inserite tutte in hielen.json in base alla commessa","title":"19 Gennaio 2024"},{"location":"CHANGELOG/#v3312","text":"","title":"v3.3.12"},{"location":"CHANGELOG/#28-febbraio-2023","text":"inserito \" ALIAS \" per agganciare serie dati a parmaetri diversi","title":"28 Febbraio 2023"},{"location":"CHANGELOG/#v3311","text":"","title":"v3.3.11"},{"location":"CHANGELOG/#16-febbraio-2023","text":"migliorato instrument imporved, inserito offset iniziale nucleo di batch per tipologie spefcifiche","title":"16 Febbraio 2023"},{"location":"CHANGELOG/#v3310","text":"","title":"v3.3.10"},{"location":"CHANGELOG/#31-gennaio-2023","text":"rivisto il filtro valid_range applicato automaticamente a tutte le serie gestito anche per datadiagram sistemato il clean cache per datadiagram","title":"31 Gennaio 2023"},{"location":"CHANGELOG/#v339","text":"","title":"v3.3.9"},{"location":"CHANGELOG/#15-gennaio-2023","text":"gestione della configurazione ed elaborazione della serie valore valore","title":"15 Gennaio 2023"},{"location":"CHANGELOG/#v338","text":"","title":"v3.3.8"},{"location":"CHANGELOG/#12-dicembre-2022","text":"introdotta la serie datadiagram per le elaborazioni valore valore","title":"12 Dicembre 2022"},{"location":"CHANGELOG/#v335","text":"","title":"v3.3.5"},{"location":"CHANGELOG/#12-novembre-2022","text":"modifche minori","title":"12 Novembre 2022"},{"location":"CHANGELOG/#v331","text":"","title":"v3.3.1"},{"location":"CHANGELOG/#12-ottobre-2022","text":"inserimento dell'entry \"query\" in hielen3.db","title":"12 Ottobre 2022"},{"location":"CHANGELOG/#v330","text":"","title":"v3.3.0"},{"location":"CHANGELOG/#10-ottobre-2022","text":"inserita la tabella eventi impelmentato check per canale","title":"10 Ottobre 2022"},{"location":"CHANGELOG/#v329","text":"","title":"v3.2.9"},{"location":"CHANGELOG/#30-settembre-2022","text":"sistemate threshold canale (chiave uuid,label,tipo(UPPER,LOWER)) definto json di configurazione generale dei canali come collezione di oggetti rilassato il concetto di operando di una serie permettendo valori arbitrari e non solo uuid di serie (viene riconoesciuto il formato uuid e caricata la serie) implementati gli sghembi","title":"30 Settembre 2022"},{"location":"CHANGELOG/#v325","text":"definito srumento generico con configurazione multipli canali","title":"v3.2.5"},{"location":"CHANGELOG/#v324","text":"","title":"v3.2.4"},{"location":"CHANGELOG/#5-giugno-2022","text":"inserito management soglie (sigolo valore) multiple e range apertura grafici","title":"5 Giugno 2022"},{"location":"CHANGELOG/#v323","text":"","title":"v3.2.3"},{"location":"CHANGELOG/#24-maggio-2022","text":"rivisto l'output di query con uscita json secondo le specifiche di dygraph per il frontend: { \"id1\":[ [\"data\",valore], [\"data\",valore], ... ], \"id2\":[ [\"data\",valore], [\"data\",valore], ... ], ... }","title":"24 Maggio 2022"},{"location":"CHANGELOG/#v322","text":"","title":"v3.2.2"},{"location":"CHANGELOG/#18-maggio-2022","text":"introdotto concetto di ordinal dei parametri associati alle feature: modificato hielen3.Feature, hielen3.ext.feature_instrument_piezometer modificato database: aggiunta colonna ordinal alla tabella feature_parameter e modificata la vista v_features_parameter per ordinare i parametri","title":"18 Maggio 2022"},{"location":"CHANGELOG/#v321","text":"","title":"v3.2.1"},{"location":"CHANGELOG/#17-maggio-2022","text":"feature piezometer feature shapearray","title":"17 Maggio 2022"},{"location":"CHANGELOG/#v320","text":"","title":"v3.2.0"},{"location":"CHANGELOG/#10-maggio-2022","text":"ristrutturato in modello di astrazione delle feature implementazione del modulo di base hielen3.ext.feature_instrument implementazione del module di base hielen3.ext.feature_datetree_filesystem_source che permette la configurazione delle sorgenti basate su strutture di files organizzate secondo il pattern SOURCE/YYYY/MM/DD","title":"10 Maggio 2022"},{"location":"CHANGELOG/#v316","text":"","title":"v3.1.6"},{"location":"CHANGELOG/#21-aprile-2022","text":"implementazione dell'api GET /queue/ implementazione della capability \"stream\" gestione delle richieste kynetics","title":"21 Aprile 2022"},{"location":"CHANGELOG/#v310","text":"","title":"v3.1.0"},{"location":"CHANGELOG/#5-marzo-2022","text":"modifica api POST /feature/ : non prende pi\u00f9 il parametro \"uid\" . Il campo \"uid\" della feature viene ora generato dalla chiamata, secondo gli standard di \"uuid\". modifica definizione della classe hielen3.api.feature.FeaturePropertiesSchema : rinominato il campo \"context\" in \"milieu\" . Questo coinvolge la chiamata API POST /feature/ in quanto la classe modificata gestisce e valida il json da passare al parametro properies dell'API. modifica api POST,GET,PUT,DELETE /feature/ : rinominato il parametro \"cntxt\" in \"milieu\" . La parola \"milieu\" al contrario di \"context\" non d\u00e0 problemi di interpretazione al sottostante strato di \"Hug\" (per questo motivo era stata utilizzata \"cntxt\"). In questo modo vengono uniformati i parmametri di queste API con il campo della classe di gestione delle properties.","title":"5 Marzo 2022"},{"location":"CHANGELOG/#nota","text":"Da reintegrare reintegrare seconda met\u00e0 2021 -> inizio 2022","title":"NOTA"},{"location":"CHANGELOG/#v2010","text":"","title":"v2.0.10"},{"location":"CHANGELOG/#10-maggio-2021","text":"Integrazione di ColorMap, e Config Time Operands","title":"10 Maggio 2021"},{"location":"CHANGELOG/#7-maggio-2021","text":"Introduzione della classe marshmallow \"ColorMap\" per la serializzazione delle informazioni custom di colorazione dei dati: tra i vari campi che possono essere ritornati da actionschemata ora ne esiste uno chiamato ColorMap . Es.: PhotoMonitoring actionschemata Come funziona ColorMap : Incontrando il campo definito come \"ColorMap\" all'interno di una risposta di actionschemata , il front-end aprir\u00e0 l'interfaccia di scelta dei colori. Il risultato dell'interazione dovr\u00e0 essere sintetizzato in un json da fronire come parametro all'azione corrispondente. Il json dovr\u00e0 essere nella forma di un array di lunghezza variabile di COPPIE (valore,colore): [ [ valore, colore ], [ valore, colore, ] ... ] dove: valore \u00e8 un numero di qualsiasi genere con punto decimale colore \u00e8 una stringa di colore hex esempio: [ [ -0.25, '#FFFF00' ], [ -0.125, '#00FF00' ], [ 0, '#0000FF' ], [ 0.5, '#FF00FF' ], [ 1, '#AEBD00' ], ] Un array del genere verrebbe inteso in questo modo: [-inf,-0.25) : [-0.25,-0.125) : --> [-0.125,0.0) : --> [0.0,0.5) : --> [0.5,1.0) : --> [1.0,inf) : L'informazione sulla colormap pu\u00f2 essere associata ad ongi singola serire dati e pu\u00f2 essere fornita in front-end su richiesta: allo scopo L'API features \u00e8 stata modificata in modo da fornire la colormap insieme con i parametri delle features specificando l'opzione info=parameters,... esempio (vedi chiamata) : { ..., \"parameters\": [ { \"series\": \"2b6c9efb4e83f64e757ce862f8b6c2e0\", \"param\": \"East-West_Displacement\", \"unit\": \"mm\", \"cmap\": [ [ -0.25, \"#FFFF00\", 0 ], [ -0.125, \"#00FF00\", 10 ], [ 0, \"#0000FF\", 20 ], [ 0.5, \"#FF00FF\", 60 ], [ 1, \"#AEBD00\", 100 ] ] }, ... ], ... } dove ogni cmap \u00e8 un array ordinato di triplette utile alla creazione della relativa colorbar. Ogni tipletta fornisce questa infromazione: cmap[x][0] : etichetta del valore, possibilmente da piazzare sulla colorbar alla giusta posizione. cmap[x][1] : colore in esadecimale. cmap[x][2] : posizione dell'ancora del gradiente per il rispettivo colore, nonch\u00e9 per l'eventuale etichetta del valore. La posizione \u00e8 espressa in percentuale sull'intera colorbar.","title":"7 Maggio 2021"},{"location":"CHANGELOG/#30-aprile-2021","text":"Gestione generalizzata degli operandi \"config time\" per i parametri: Ora la classe Source espone dei metodi per dare la possibilit\u00e0 alle sotto classi di definire operandi di elaborazione custom.","title":"30 Aprile 2021"},{"location":"CHANGELOG/#v209","text":"","title":"v2.0.9"},{"location":"CHANGELOG/#22-aprile-2021","text":"implementata l'interrogazione tramite GeoJson Correzione di molti bugs Aggancio della query dati","title":"22 Aprile 2021"},{"location":"CHANGELOG/#v208","text":"","title":"v2.0.8"},{"location":"CHANGELOG/#2-aprile-2021","text":"implementato il modello di cache per la gestione dei dati prodotti debug delle nuove funzionalit\u00e0","title":"2 Aprile 2021"},{"location":"CHANGELOG/#31-marzo-2021","text":"inserita la nuova entit\u00e0 db \"feaures_info\" riviste le api /features/ /actions/ /query/ rivisto il codice di hielen2.source hielen2.query introdotto il modulo hielen2.mapmanager per la gestione della generazione dei mapfile rivisto il codice di hielen2.ext.source_photomonitoring","title":"31 Marzo 2021"},{"location":"CHANGELOG/#29-marzo-2021","text":"inserito il concetto di \"info\" nelle richieste a feature: Con questo parametro si riescono a centralizzare le chiamate che si focalizzano sulle feature e si separano le informazioni di secondo livello ad esse legate. In questo modo la risposta di default risulta piuttosto leggera ma diventa uno strumento potente e versatile specificando esplicitamente l'estrazione di iformazioni accessorie. Attualmente il parametro \"info\" accetta un array in cui pu\u00f2 essere richiesta l'estrazione di queste info: geometry : il GeoJson della geometria della feature capabilities : le possibili interrogazioni effetuabili sulla feature \u00e8 un array che contiene uno o pi\u00f9 di questi valori: \"data\",\"map\",\"cloud\". la feature risponder\u00e0 a chiamate del tipo /query/{capability} . Nel caso l'array fosse vuoto la feature non risponderebbe ad alcuna interrogazione. parameters : l'elenco dei parametri associati alla feature come riportati dal'API GET /parametes/ . Quest'ultima API diviene inutile e sar\u00e0 eliminata in futuro timeline : la timeline dei dati associati ai parametri della feature. Utile per lo pi\u00f9 per le query map e cloud data : informazioni specifiche di per la capability \"data\" map : informazioni specifiche per la capability \"map\" (il formato \u00e8 esattamente quello del nodo \"map\" del backbone di geoframe) cloud : informazioni specifiche per la capability \"cloud\"","title":"29 Marzo 2021"},{"location":"CHANGELOG/#23-marzo-2021","text":"unificata la struttura di backend che gestisce le chiamate alle serie (dati, mappe e in futuro clouds): Eliminati moduli hielen2.data.data_access_layer e hielen2.maps.data_access_layer e sostituiti entrambi con hielen2.query , il modulo dichiara la classe hielen2.quert.Series che prevede il parametro capability per distingure tra [\"data\",\"map\",\"cloud\"]. riviste le api GET /maps/ e GET /data/ , unificate sotto l'api GET /query/ in questo modo: GET /query/data/ GET /query/map GET /query/cloud/ (futura) la parametrizzazione di \"datamap\" viene modificata eliminando \"timeto\" e \"timefrom\" ed inserendo \"times\" come slice temporale (vedi 11 Marzo 2021) ATTENZIONE: Nel caso venga richesto in risposta un mimetype \"txt\" il separatore dei campi passa da \",\" a \";\"","title":"23 Marzo 2021"},{"location":"CHANGELOG/#19-marzo-2021","text":"Revisione dell'ambiente di produzione e accenzione delle istanze su server Nhazca. Mapserver: istanza mapserver con workers (vedi Ecoplame) per la gestione delle mappe statiche tassellate (chiamate wms standard)","title":"19 Marzo 2021"},{"location":"CHANGELOG/#v207","text":"","title":"v2.0.7"},{"location":"CHANGELOG/#15-marzo-2021","text":"API: GET /maps/ per la generazione delle mappe.","title":"15 Marzo 2021"},{"location":"CHANGELOG/#11-marzo-2011","text":"Introdotti gli slice temporali come estenzione di marshmallow.field mappati sulla classe slice di python: Provides python object which performs selection on narry. It axcept a three filed string separated by \":\". \":\" presence is managed as: \"start:stop:step\" ie.: \"start:stop\" - extracts from start to stop \"start:\" - extracts from start to max \"start\" - extract exactly start implementato /maps/data_access_layer.py per la gestione angostica delle mappe (utilizzo della datacache)","title":"11 Marzo 2011"},{"location":"CHANGELOG/#3-marzo-2021","text":"API: DELETE /actions/{feature}/{*} agganciata a datacache (vengono tolte dalla cache le elaborazioni dipendenti da config) API: DELETE /features/{feature} pulizia cache e serie dati","title":"3 Marzo 2021"},{"location":"CHANGELOG/#25-febbraio-2021","text":"Impelementazione del modulo astratto datacache. Necessario per lo storing delle serie dati. Attualmente implementato con json e csv su flesystem. Potr\u00e0 essere implementato con Redis.","title":"25 Febbraio 2021"},{"location":"CHANGELOG/#18-febbraio-2021","text":"Implementazione metodo astratto map che viene invocato in modo agnostico sull'istanza di un tipo con capability \"map\" per produrre le immagini elaborate. Risponde in modo standard creando l'immagine in posizione definita. Nota: Deve diventare metodo di classe","title":"18 Febbraio 2021"},{"location":"CHANGELOG/#12-febbraio-2021","text":"Revisione del modello di Source con sottoclassi source->data->map->cloud: Ogni sottoclasse estende le funzionalit\u00e0 in modo da avere livlli di capabilities gerarchici (\"cloud\" \u2283 \"map\" \u2283 \"data\"). Di fatto si pu\u00f2 intendere ogni tipologia di elaborazione come timeseries la cui produzione \u00e8 legata alla specifica capability della tipologia di sorgente (es: le mappe elaborate del parametro \"displacement\" di una specifica feature da una certa data ad un'altra ). Esteso il concetto di interrogazione con risultanza di series per data, maps, e clouds","title":"12 Febbraio 2021"},{"location":"CHANGELOG/#v206","text":"","title":"v2.0.6"},{"location":"CHANGELOG/#7-febbraio-2021","text":"Sviluppo Tinsar Implementata la richiesta di Nhazca: - Anticipata analisi di potree e generazione / colorazione clouds. - Implementato mockup 3D funzionante - Compilazione e utilizzo di PotreConverter","title":"7 Febbraio 2021"},{"location":"CHANGELOG/#27-gennaio-2021","text":"Inserita la validazione dei campi delle action","title":"27 Gennaio 2021"},{"location":"CHANGELOG/#25-gennaio-2021","text":"Inserito il campo \"hint\" nella risposta di GET /actionschemata[/{feature}[/{action}]] Implementata astrazione di DELETE /actions/{feature}/{action}/ . Prima della rimozione della specifica azione dal db, vengono chimati i metodi preposti alla gestione della rimozione delle informazioni in cache, che si presuppone siano implemetati dai relativi moduli. I moduli possono implementare questi metodi solo se necessario. Sintassi: Invocando il metodo deleteActionValues(self,action,timestamp) della superclasse Hielen2.Source, essa tenter\u00e0 di utilizzare il metodo della sottoclasse il cui nome \u00e8 cotruito dal'unione della parola \"delete\" + il nome dell'azione con la prima lettera maiuscola: es: \"deleteConfig\". la superclasse passer\u00e0 sempre un timestamp per individuare l'azione specifica Implementato il metodo \"deleteConfig\" della classe Hielen2.ext.source_PhotoMonitoring Corretto bug minore di gestione delle azioni in caso esse producano errori non preventivati.","title":"25 Gennaio 2021"},{"location":"CHANGELOG/#22-gennaio-2021","text":"Ristrutturata la pagina di TODO , inserita categorizzazione e valutazione delle tempistica delle attivit\u00e0","title":"22 Gennaio 2021"},{"location":"CHANGELOG/#20-gennaio-2021","text":"modulo hielen2.ext.source_PhotoMonitoring : rimodellato sulla base del modulo hielen2.source . definite le classi schema per le azioni: ## action 'config' (Completamente Funzionante) class ConfigSchema ( ActionSchema ): master_image = LocalFile ( required = True , allow_none = False ) step_size = fields . Str ( required = False , default = \"8\" ) window_size_change = fields . Str ( required = False , default = \"0\" ) geo_reference_file = LocalFile ( required = False , default = None ) crs = fields . Str ( required = False , default = None ) ## action 'feed' class FeedSchema ( ActionSchema ): reference_time = fields . Str ( required = False , allow_none = False ) NS_displacement = LocalFile ( required = False , allow_none = False ) EW_displacement = LocalFile ( required = False , allow_none = False ) Coer = LocalFile ( required = False , allow_none = False )","title":"20 Gennaio 2021"},{"location":"CHANGELOG/#18-gennaio-2021","text":"Revisione concettuale delle API e modifiche: GET /parametes : lo schema di ritorno \u00e8 il seguente (semplicemente \"param\" al posto di \"name\" ): { ..., \"data\": { \"ARCCE01\": [ { \"series\": \"ARCCE01_Rotazione_X\", \"param\": \"Rotazione X\", \"unit\": \"mm/m\"}, ..... } ] } actionSchemata \u00e8 l'api che fornir\u00e0 gli schemi per le azioni e va a sostituire quella che era \"prototypes\". Questa esiste ancora e mantiene il legame tra prototipo e modulo ma pi\u00f9 che altro le informazioni che stanno nella relativa tabella mi servono per il back-end GET ../actionschemata[/{prototypes}[/{actions}]] action come prima, \u00e8 l'api che gestisce le azioni: La versione POST nella sostanza non \u00e8 cambiata a parte il fatto che un'azione dichiarer\u00e0 sempre un timestamp per default. Ma questa cosa al front-end non interessa dal momento che le info le recupera da actionSchemanta. E' invece importante nella scrittura dei plugin perch\u00e9 in questo modo le azioni possono essere gestite temporalmente. La versione GET , invece cambia sostanzialmente: non fornir\u00e0 pi\u00f9 i default per la post MA potr\u00e0 fornire una serie temporale di azioni associate a dei valori di elaborazione che danno informazioni all'utente. in questo formato: GET ../actions[/{feature}[/{action}]] ritorna: [ { \"timestamp\":....,\"value\":.... }, { \"timestamp\":...., \"value\":.... }, .... ] esempio: GET ../actions/featurecode/config { \"meta\": { \"response\": \"ok\", \"message\": \"\", \"data_type\": \"GET /actions/ciaociaociao4/config\" }, \"data\": [ [ { \"timestamp\": \"2020-12-30 01:00:05\", \"value\": { \"master_image\": \"TIFF image data, little-endian, direntries=14, height=1842, bps=16, compression=none, PhotometricIntepretation=BlackIsZero, width=3545\", \"step_size\": \"35\", \"window_size_change\": \"10\", \"transform\": [ 15.0, 0.0, 464947.5, 0.0, -15.0, 7977067.5 ], \"cache\": \"20201230010005\", \"crs\": null } }, { \"timestamp\": \"2020-12-30 01:00:07\", \"value\": { \"master_image\": \"TIFF image data, little-endian, direntries=16, height=1842, bps=16, compression=none, PhotometricIntepretation=BlackIsZero, width=3545\", \"timestamp\": \"2020-12-30 01:00:07\", \"step_size\": \"35\", \"window_size_change\": \"10\", \"transform\": [ 15.0, 0.0, 464947.5, 0.0, -15.0, 7977067.5 ], \"cache\": \"20201230010007\", \"crs\": \"EPSG:32622\" } } ] ] }","title":"18 Gennaio 2021"},{"location":"CHANGELOG/#15-gennaio-2021","text":"modulo hielene2.source : Implementato il metodo sourceFactory per la generazione degli ogetti HeielenSource in base ai prototipi che sfrutta il cariacmanto dinamico dei moduli specifici (metodo loadModule ) Implementati i metodi e le classi per la gestione agnostica delle azioni ed il recupero degli schemi: getActionSchema , moduleAction , HielenSource.execAction , HielenSource.getActionValues Implementata la gestione dell'ambiente di cache dedicato alle singole istanze di HielenSource: HielenSource.makeCachePath , HielenSource.getRelativePath Definita la classe primitiva per i modelli di schema per le azioni che impone la definizione della marcatura temporale: class ActionSchema ( Schema ): timestamp = fields . Str ( required = True , allow_none = False )","title":"15 Gennaio 2021"},{"location":"CHANGELOG/#13-gennaio-2021","text":"rimodellato il db: dalla tabella \"features\" sono state eliminate le colonne \"a priori\" delle azioni. Queste ultime sono state inserite in una nuova tabella \"actions\" con chiave multipla (\"feature\",\"action\",\"timestamp\"). Rivista l'interfaccia db per permettere l'interrogazione su chiave multipla","title":"13 Gennaio 2021"},{"location":"CHANGELOG/#10-gennaio-2021","text":"Progettazione della gestione temporale delle azioni e separazione del concetto di form da quello di risultato della azione: ogni azione ha uno schema di input e dei risultati in output con uno schema non necessariamente coincidente. Quello che viene fornito alle form sono i dati necessari ad intraprendere un'azione. I risultati dell'azione devono essere registrati con una marcatura temporale. In questo modo ogni azione \u00e8 univocamente determinata e gestibile con un modello del tipo (\"feature\",\"action\",\"timestamp\"), con una cardinalit\u00e0 1-a-molti tra features e azioni Portata a termine la migrazione della gestione delle azioni che vengono ora completamente affidate ai singoli moduli. L'iterfaccia di alto livello \u00e8 ora in grado di gestire agonsticamente le chiamate ad azioni arbitrarie purch\u00e8 ben definite all'interno dei moduli. In questo modo cade il vincolo di definizione do azione \"a priori\"","title":"10 Gennaio 2021"},{"location":"CHANGELOG/#30-dicembre-2020","text":"sviluppo (non completo) di config hielen2.ext.PhotoMonitoring: Implementato il metodo di recupero e settaggio delle informazioni geometriche/geografiche dell'immagine in ingresso Aggancio del codice originale per la gesgione del netcdf (in debug)","title":"30 Dicembre 2020"},{"location":"CHANGELOG/#22-dicembre-20202","text":"Delineata la gestione di mappa delle immagini prodotte: Ogni immagine prodotta sar\u00e0 sempre associata al suo crs e la matrice di trasformazione affine, anche nele caso in cui queste informazioni non dovessero essere passate in configurazione. In questo caso si assume un piano cartesiano con udm in m e una matrice identit\u00e0 per le trasformazioni affini. Sar\u00e0 dunque sempre possibile gestire le immagini come mappe (slippy maps) e sfruttare la tassellazione, il cacheing dei tasselli.","title":"22 Dicembre 20202"},{"location":"CHANGELOG/#20-dicembre-2020","text":"Modificata l'api POST /actions/{feature}/{form} in modo da interrogare la Source (per ora solo PhotoMonitoring) sulla definizione delle azioni: Implementate le classi di Schema per config e feed per il modulo hielen2.ext.PhotoMonitoring . ATTENZIONE per config : introdotto il campo \"timestamp\", eliminati i campi espliciti relativi al word_file ( word_file mantenuto), modificato il campo epsg in csr .","title":"20 Dicembre 2020"},{"location":"CHANGELOG/#15-dicembre-2020","text":"Delineato il modello di scrittura dei Source plugin secondo un template univoco. Ogni plugin potr\u00e0 essere un modulo python definito come segue: deve definire tante classi marshmallow.Schema quante sono le azioni che vengono prese in carico dal Template. Marsmallow \u00e8 un serializzatore di oggetti python. Lo schema definito servir\u00e0 per definire i campi in ingresso per ogni azione e fare i check dei valori in ingresso. Il nome delle classi Schema deve seguire questa sintassi: class {Action}Schema(marshmallow.Schema) dove {Action} \u00e8 il nome dell'azione (es.: config, feed, ..) con l'iniziale maiuscola . Nella classe vengono definiti i tipi dei campi ( marshmallow.fields cfr. https://marshmallow.readthedocs.io/en/stable/ ). ATTENZIONE: in caso fosse necessario l'ingresso di file o comunque oggetti blob dovr\u00e0 essere utilizzato come field la classe hielen2.utils.LocalFile . In questo modo il sistema risolver\u00e0 la chiamata API salvando in locale lo stream dei dati associato a quel determinato field, il quale sar\u00e0 accessibile al template attraverso un path che verr\u00e0 fornito insieme agli altri campi al momento della chiamata del metodo di gestione dell'azione (vedi sotto). deve implementare una classe Source(hielen2.datalink.HielenSource) che esponga tanti metodi quante sono le dichiarazioni di Schema seguendo questa sintassi: il metodo di gestione dell'azione deve chiamarsi come l'azione stessa ( tutto in minuscolo ). Le classi estese sfrutteranno il metodo __init__ della superclasse in modo da avere a disposizione tutto quello di cui necessitano. Questo modello permette di svincolare i template dalla necessit\u00e0 di conoscere a priori le azioni ammmissibili per il sistema. Infatti, facendo introspezione su un template che segua le regole di sintassi sar\u00e0 sempre possibile conoscere le azioni definite ed esternalizzarle al front-end che in base alle definizioni delle classi di Schema delle azioni, sar\u00e0 sempre in grado di instanziare una form adeguata.","title":"15 Dicembre 2020"},{"location":"CHANGELOG/#v205","text":"","title":"v2.0.5"},{"location":"CHANGELOG/#9-dicembre-2020","text":"Implementata working POST /actions/{feature}/{form} tramite content-type/multipart dinamico definito dal prototipo: L'api \u00e8 collegata ai moduli reali delle tipologie definiti come templates, con la funzionalit\u00e0 minima di salvare i parametri in ingresso. I moduli sono in fase di sviluppo e man mano che vengono implementati le funzionalit\u00e0 aumenteranno. Implementato Loading dinamico dei moduli di elaborazione definiti come estensioni di hielen2.datalink.HielenSource Implementata working GET /actions/{feature}[/{form}] : Per ogni form richiesta, risponde con tutti i parametri definiti nel relativo prototipo, riempiti con i valori definiti tramite la POST della stessa api. I valori non precedentemente forniti vengono impostati a null Riveduta e corretta GET prototypes/{prototype}/forms[/form] : ATTENZIONE adesso risponde con TUTTI i campi dentro il dizionario \"args\" e comunica i campi obbligatori attraverso l'array \"mandatory\". Questa struttura \u00e8 pi\u00f9 versatile in quanto, una volta definito il set completo degli argomenti, \u00e8 possibile definire un numero arbitrario di sottoinsiemi predicativi non necessariamente distiniti: Oltre al sottoinsieme \"mandatory\" si potrebbe, ad esempio, definire un sottoinsieme di immutabili. Qui sotto una struttura di esempio: { \"data\": { \"args\": { \"epsg\": \"string\", \"master_image\": \"file\", \"negative_pixel_y_size\": \"string\", \"pixel_x_size\": \"string\", \"rotation_about_the_x_axis\": \"string\", \"rotation_about_the_y_axis\": \"string\", \"step_size\": \"string\", \"window_size_change\": \"string\", \"world_file\": \"file\", \"x_coordinate_of_upper_left_pixel_center\": \"string\", \"y_coordinate_of_upper_left_pixel_center\": \"string\" }, \"mandatory\": [ \"master_image\", \"step_size\", \"window_size_change\" ] }, \"meta\": { \"data_type\": \"GET /prototypes/PhotoMonitoring/forms/config\", \"message\": \"\", \"response\": \"ok\" } }","title":"9 Dicembre 2020"},{"location":"CHANGELOG/#7-dicembre-2020","text":"Rimodellato il feature db per contenere gli argomenti delle actions Riveduto il feature_proto db: Inserito il modulo di riferimento tra le info del prototipo (il modulo contenete la classe estesa di hielen2.datalink.HielenSource ) Definita la superclasse hielen2.datalink.HielenSource con definizione univoca di __init__ con questo footprint: (self,featureobject,environment) . La classe definisce inotre i metodi astratti che vengono utilizzati dal sistema che ogni estensione di questa dovr\u00e0 implementare.","title":"7 Dicembre 2020"},{"location":"CHANGELOG/#2-dicembre-2020","text":"Struttura definitiva delle features: { \"properties\":\"...\" \"parameters\":\"...\" \"geometry\":\"...\" } dove: properties mantiene tutte le info della feature. Quelle di base: uid , type , classification , location , description e quelle definite per le specifiche azioni definite per la tipologia. In particolare quella di configurzione. parameters mantiene la struttura di accesso alle info e ai dati dei parametri definiti per la feature. geometry fornisce le informazioni geometriche della feature. Rivedute le api /actions , /parameters , /features ( /data da rivedere)","title":"2 Dicembre 2020"},{"location":"CHANGELOG/#24-novembre-2020","text":"Implementate dummy /actions/{feature}/ e /actions/{feature}/{form}","title":"24 Novembre 2020"},{"location":"CHANGELOG/#23-novembre-2020","text":"Riorganizzato il db delle features per permettere una gestione pi\u00f9 razionale","title":"23 Novembre 2020"},{"location":"CHANGELOG/#19-novembre-2020","text":"riorganizzata la struttura per la gestione delle classi estese che necessitano di dynamic loading: nel modulo himada2.ext (cartella) vengono raccoliti per comodit\u00e0 gli oggetti che saranno implementati man mano come estensione di superclassi astratte appositamente definite: per ora hielen2.datalink.Source e hielen2.datalink.DB e hielen2.datalink.DataCache. Oltre alle classi in hielen2.ext, il sitema potr\u00e0 utilizzare moduli esterni che estendano le superclassi elencate. inserito 'timestamp' nello schema json accettato da POST /feature e PUT /feature . risolto bug minore di incoerenza su GET /data/{feature} e /data/{feature}/{parameter} . Quest'ultima continua ad accettare uno tra i nomi dei parametri della feature. Entrambe rispondo intestando le colonne in uscita con lo uid della serie, come GET /data/ .","title":"19 Novembre 2020"},{"location":"CHANGELOG/#17-novembre-2020","text":"Implementata dummy POST /actions/{feature}/{form} :","title":"17 Novembre 2020"},{"location":"CHANGELOG/#v204","text":"","title":"v2.0.4"},{"location":"CHANGELOG/#16-novembre-2020","text":"per coerenza rivisti i parametri di POST /feature : uid:<string> prototype:<string> properties:<json schema Properties> geometry:<json schema GeoJson> analogo discorso per PUT /feature/{uid} : properties:<json schema Properties> geometry:<json schema GeoJson> sistemata la risposta di GET /feature , modificando il livello di \"geometry\" implementata api PUT /features/{uid} . Accetta il paramentro properties con uno schema analogo al parmetro feature di POST /features con queste differenze: nello schema della PUT, uid e prototype NON vengono accettati perch\u00e8 sono campi chiave della feature e non possono essere modificati . lo uid della feature deve essere specificato come url e non come parametro. introduzione dello Schema GeoJson per la validazione modificata POST /features/ per accettare un GeoJson nell'attibuto geometry del Json principale feature","title":"16 Novembre 2020"},{"location":"CHANGELOG/#13-novembre-2020","text":"rinominazione DELETE /elements -> DELETE /features . eliminazione degli alias GET /features/{context} e /features/{context}/{uid} a causa del conflitto l'entry point DELETE /features . Il passaggio del context sar\u00e0 esclusivmante attraverso il parametro cntxt ( nota : questo nome \u00e8 dovuto alla collisione del nome con il campo 'context' dell'oggetto request). In caso lo possiamo cambiare. introduzione dell'alias /features/{uid} per il recupero delle info della specifica Feature.","title":"13 Novembre 2020"},{"location":"CHANGELOG/#12-novembre-2020","text":"ovunque nel mondo il parmetro 'uuid' (universal unique id) diventa 'uid'. rinominazione POST /elements -> POST /features . rinominazione GET /elements -> GET /parameters e modifica uscita in questo schema: { <feature1_UID>:[ { \"series\":<feature1_param1_series_UID>, \"param\":<feature1_param1_name>, \"um\":<feature1_param1_measurement_unit> }, ... { \"series\":<feature1_paramN_series_UID, \"param\":<feature1_paramN_name>, \"um\":<feature1_paramN_meaurement_unit> } ], ... <featureX_UID>:[ { \"series\":<featureX_param1_series_UID>, \"param\":<featureX_param1_name>, \"um\":<featureX_param1_measurement_unit> }, ... { \"series\":<featureX_paramM_series_UID, \"param\":<featureX_paramM_name>, \"um\":<featureX_paramM_meaurement_unit> } ] } introduzione api /features con lo schema usato da Daniele e SimoneD: GET /features GET /features/{context}/ GET /features/{context}/{feature} uscita : nota 1: NON viene introdotto \"context\" , come invece preventivato nota 2: \"cod\" diventa \"label\" . nota 3: \"date\" diventa \"timestamp\" nota 3: dalle properties vengono elminate \"z\" e \"mslm\" . nota 4: \"state\" viene mantenuto ma per ora \u00e8 inutilizzato { \"features\": [ { \"type\": \"Feature\", \"properties\": { \"uid\": ..., \"label\": ..., \"context\":..., \"date\": ..., \"type\": ..., \"style\": ..., \"state\": ... }, \"geometry\": <GeoJson Validable> }, ... { \"type\": \"Feature\", \"properties\": { \"uid\": ..., \"label\": ..., \"context\": ..., \"date\": ..., \"type\": ..., \"style\": ..., \"state\": ... }, \"geometry\": <GeoJson Validable> } ] }","title":"12 Novembre 2020"},{"location":"CHANGELOG/#v203","text":"","title":"v2.0.3"},{"location":"CHANGELOG/#11-novembre-2020","text":"Modificata api POST /elements : la variabile element \u00e8 descritta dalla Classe hielen2.api.data.ElementSchema e validata. In paricolare \u00e8 stato introdotto l'attibuto context Modifcata api GET /data : la variabile datamap \u00e8 descritta dalla Classe hielen2.api.data.DataMapSchema e validata.","title":"11 Novembre 2020"},{"location":"CHANGELOG/#9-novembre-2020","text":"Introdotta la classe hielen2.utils.JsonValidable, per la validazione e documentazione automatica dei parametri delle api (JSON Schema descrition) corretti bug minori in hielen2.datalink","title":"9 Novembre 2020"},{"location":"CHANGELOG/#6-novembre-2020","text":"L'interfaccia DB \u00e8 ora thread safe!!! (almeno per il dummy json db)","title":"6 Novembre 2020"},{"location":"CHANGELOG/#v202","text":"","title":"v2.0.2"},{"location":"CHANGELOG/#4-novembre-2020","text":"Implementata la documentazione automatica delle api Implementate le api POST ../elements e DELETE ../elements L'uscita per tutte le api element (e per tutte le api con risposta json in generale), seguir\u00e0 questo schema: { \"meta\": { \"data_type\": \"DELETE /elements/ciao\", \"response\": \"ok\" \"message\": \"\", }, \"data\":{ ... } } L'api /series diventa /data e cambia il suo comportamento: la variabile di tipo json datamap si aspetta il campo series invece di parameters . In questo campo devono essere inseriti i codici delle serie e non pi\u00f9 il costrutto \"codice_elemento:parametro_elemento\". I codici delle serie si possono recuperarare dall'api /elements (vedi Nota successiva) L'api /elements cambia la sua risposta e per ogni parametro nella lista parameters degli elementi viene agiunto il codice della serie di riferimento che pu\u00f2 essere fornito senza modifiche a /data : { \"series\":<seriescode>, \"name\":<seriesname>, \"um\":<seriesunit> } GET /series GET /series/{el} GET /series/{el}/{param} GET /prototypes GET /prototypes/{type} GET /prototypes/{type}/forms GET /prototypes/{type}/forms/{form} POST /elements GET /elements GET /elements/{el} DELETE /elements/{el}","title":"4 Novembre 2020"},{"location":"MODELLO/","text":"Con Priorit\u00e0 Structure gestore della configurazione di base: modulo utilizzo stato datalink.py livello di astrazione db, interfacce json completo, integrabile utils.py strumenti accessori completo, integrabile source.py astrazione dei moduli di gestione completo, integrabile modello db: tabella descrizione stato features_proto prototipi features info sui moduli completa features persistenza delle features completa actions persistenza delle azioni completa series_proto prototipi serie dati per configurazione dinamica implementazione series peristenza info di elaborazione serie dati avanzato series_cache persistenza serie dati elaborate runtime json utilizzato per mockup modello api: Configurazione Abstraction layer: Produzione Interrogazione First Header Second Header Content from cell 1 Content from cell 2 Content in the first column Content in the second column Configurazione hielen2.ext.PhotoMonitoring (netCDF) definizione array dimensionali X,Y: 1- creo gli array di dimensione adeguata, 2- applico la matrice di trasformazione affine, 3- applico la proiezione da crs in input a EPSG:3857 salvare file in filecache/{uid}/multidim.nc (dati) definire percorso di salvataggio tiles: filecache/{uid}/{map}/ (tiles mappe) salvare il primo tile a risoluzione adeguata: filecache/{uid}/{map}/base.png salvataggio (stoccaggio) dell'immagine di base in filecache/{uid} (eventualmente compressa) Feed hielen2.ext.PhotoMonitoring analisi dei file csv in ingresso (NS, EW, Correlation se esiste) aggirnamento di filecache/{uid}/multidim.nc Configurazione hielen2.ext.TinSAR analisi della formato della master cloud salvataggio (stoccaggio) della nuvola di base recupero info geografiche in caso non esistano info di proiezione geografica si considera spazio cartesiano con coordinate con adeguate alla nuvola base (da verificare) configurare file netCDF e salvarlo in filecache/{uid}/multidim.nc (dati) definire percorso di salvataggio tiles: filecache/{uid}/{map}/ (tiles mappe) configurare cartella di cache per potree filecache/{uid}/{cloud} (potree) Feed hielen2.ext.TinSAR Analisi file in ingresso aggiornamento filecache/{uid}/multidim.nc aggiornamento filecache/{uid}/{cloud} v2.0.6 Interfacce delle Informazioni con risposta mockup. Intento: agganciare lavoro Daniele GET /bases GET /bases/{feature} GET /timelines GET /timelines/{feature} GET /data/ estensione del modello di datamap per accettare GeoGeson v2.0.7 Rivistazione del modulo PhotMonitoring come \"source\". Intento: agganciare le serie dati prodotte dall'elaborazione Photmonitoring alle interfacce v2.0.8 Implementazione del modulo TinSar come \"source\". Intento: agganciare le serie dati prodotte dall'elaborazione TinSar alle interfacce v2.0.9 Implementazione delle chiamate di mappa GET /maps/[/z/x/y] GET /maps/{feature}/[z/x/y] v2.0.10 Implementazione chiamate cloud GET /cloud/{feature} Senza priorit\u00e0 Moduli HielenSource : attualmente, per comodit\u00e0, vengono sviluppati come sotto moduli di hielen2 ma il modo corretto \u00e8 quello di separare lo sviluppo. Sar\u00e0 sempre possibile farlo dal momento che le strutture vengono sviluppate con l'obiettivo della separazione. ~~ Moduli HielenSource : Definire in backend le form come Marshmallow.Schema in modo da condividere la struttura tra moduli e api~~ Obiettivo: assegnare una timestamp ad ogni informazione: le properties degli ogetti dovranno essere delle serie dati. Concetto di informazione minima. Implementare procedura di testing delle api verificare il default dei campi marshmallow (sembra non prenderlo in considerazione, prob non arriva null ma \"\") POST /prototypes Migliorare l'output dei doc del JsonValidable Gestire i filed Nested nei doc del JsonValidable","title":"MODELLO"},{"location":"MODELLO/#con-priorita","text":"","title":"Con Priorit\u00e0"},{"location":"MODELLO/#structure","text":"gestore della configurazione di base: modulo utilizzo stato datalink.py livello di astrazione db, interfacce json completo, integrabile utils.py strumenti accessori completo, integrabile source.py astrazione dei moduli di gestione completo, integrabile modello db: tabella descrizione stato features_proto prototipi features info sui moduli completa features persistenza delle features completa actions persistenza delle azioni completa series_proto prototipi serie dati per configurazione dinamica implementazione series peristenza info di elaborazione serie dati avanzato series_cache persistenza serie dati elaborate runtime json utilizzato per mockup modello api:","title":"Structure"},{"location":"MODELLO/#configurazione","text":"Abstraction layer:","title":"Configurazione"},{"location":"MODELLO/#produzione","text":"","title":"Produzione"},{"location":"MODELLO/#interrogazione","text":"First Header Second Header Content from cell 1 Content from cell 2 Content in the first column Content in the second column","title":"Interrogazione"},{"location":"MODELLO/#configurazione-hielen2extphotomonitoring-netcdf","text":"definizione array dimensionali X,Y: 1- creo gli array di dimensione adeguata, 2- applico la matrice di trasformazione affine, 3- applico la proiezione da crs in input a EPSG:3857 salvare file in filecache/{uid}/multidim.nc (dati) definire percorso di salvataggio tiles: filecache/{uid}/{map}/ (tiles mappe) salvare il primo tile a risoluzione adeguata: filecache/{uid}/{map}/base.png salvataggio (stoccaggio) dell'immagine di base in filecache/{uid} (eventualmente compressa)","title":"Configurazione hielen2.ext.PhotoMonitoring (netCDF)"},{"location":"MODELLO/#feed-hielen2extphotomonitoring","text":"analisi dei file csv in ingresso (NS, EW, Correlation se esiste) aggirnamento di filecache/{uid}/multidim.nc","title":"Feed hielen2.ext.PhotoMonitoring"},{"location":"MODELLO/#configurazione-hielen2exttinsar","text":"analisi della formato della master cloud salvataggio (stoccaggio) della nuvola di base recupero info geografiche in caso non esistano info di proiezione geografica si considera spazio cartesiano con coordinate con adeguate alla nuvola base (da verificare) configurare file netCDF e salvarlo in filecache/{uid}/multidim.nc (dati) definire percorso di salvataggio tiles: filecache/{uid}/{map}/ (tiles mappe) configurare cartella di cache per potree filecache/{uid}/{cloud} (potree)","title":"Configurazione hielen2.ext.TinSAR"},{"location":"MODELLO/#feed-hielen2exttinsar","text":"Analisi file in ingresso aggiornamento filecache/{uid}/multidim.nc aggiornamento filecache/{uid}/{cloud}","title":"Feed hielen2.ext.TinSAR"},{"location":"MODELLO/#v206-interfacce-delle-informazioni-con-risposta-mockup-intento-agganciare-lavoro-daniele","text":"GET /bases GET /bases/{feature} GET /timelines GET /timelines/{feature} GET /data/ estensione del modello di datamap per accettare GeoGeson","title":"v2.0.6 Interfacce delle Informazioni con risposta mockup. Intento: agganciare lavoro Daniele"},{"location":"MODELLO/#v207-rivistazione-del-modulo-photmonitoring-come-source-intento-agganciare-le-serie-dati-prodotte-dallelaborazione-photmonitoring-alle-interfacce","text":"","title":"v2.0.7 Rivistazione del modulo PhotMonitoring come \"source\". Intento: agganciare le serie dati prodotte dall'elaborazione Photmonitoring alle interfacce"},{"location":"MODELLO/#v208-implementazione-del-modulo-tinsar-come-source-intento-agganciare-le-serie-dati-prodotte-dallelaborazione-tinsar-alle-interfacce","text":"","title":"v2.0.8 Implementazione del modulo TinSar come \"source\". Intento: agganciare le serie dati prodotte dall'elaborazione TinSar alle interfacce"},{"location":"MODELLO/#v209-implementazione-delle-chiamate-di-mappa","text":"GET /maps/[/z/x/y] GET /maps/{feature}/[z/x/y]","title":"v2.0.9 Implementazione delle chiamate di mappa"},{"location":"MODELLO/#v2010-implementazione-chiamate-cloud","text":"GET /cloud/{feature}","title":"v2.0.10 Implementazione chiamate cloud"},{"location":"MODELLO/#senza-priorita","text":"Moduli HielenSource : attualmente, per comodit\u00e0, vengono sviluppati come sotto moduli di hielen2 ma il modo corretto \u00e8 quello di separare lo sviluppo. Sar\u00e0 sempre possibile farlo dal momento che le strutture vengono sviluppate con l'obiettivo della separazione. ~~ Moduli HielenSource : Definire in backend le form come Marshmallow.Schema in modo da condividere la struttura tra moduli e api~~ Obiettivo: assegnare una timestamp ad ogni informazione: le properties degli ogetti dovranno essere delle serie dati. Concetto di informazione minima. Implementare procedura di testing delle api verificare il default dei campi marshmallow (sembra non prenderlo in considerazione, prob non arriva null ma \"\") POST /prototypes Migliorare l'output dei doc del JsonValidable Gestire i filed Nested nei doc del JsonValidable","title":"Senza priorit\u00e0"},{"location":"TODO/","text":"MODULO PRICIPALE: Documentazione API online Giorni/Uomo effettivi Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 xx alta bassa completo Start-up sistema di documentazione xx alta bassa alta Sistemazione documentazione online. MODULO PRINCIPALE Giorni/Uomo effettivi Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 xx alta bassa - Spostare la gestione delle tipologie fuori dal db (tabella feature_type) xx alta media - Implementare la gestione dello header in configurazione in modo da creare i giusti canali per il logger xx bassa bassa - Ragionare sullo split della tabella log su db specifico o automazione della configurzione del db in fase di configurazione applicazione xx alta bassa - Implementazione dell'associazione serie feature / canale sorgente da interfacca xx alta bassa - Ragionare sulla sincronizzazione dei log (tempo sitema, tempo logger, correzione)","title":"TODO"},{"location":"TODO/#modulo-pricipale","text":"","title":"MODULO PRICIPALE:"},{"location":"TODO/#documentazione-api-online","text":"Giorni/Uomo effettivi Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 xx alta bassa completo Start-up sistema di documentazione xx alta bassa alta Sistemazione documentazione online.","title":"Documentazione API online"},{"location":"TODO/#modulo-principale","text":"Giorni/Uomo effettivi Priorit\u00e0 Complessit\u00e0 Copertura Attivit\u00e0 xx alta bassa - Spostare la gestione delle tipologie fuori dal db (tabella feature_type) xx alta media - Implementare la gestione dello header in configurazione in modo da creare i giusti canali per il logger xx bassa bassa - Ragionare sullo split della tabella log su db specifico o automazione della configurzione del db in fase di configurazione applicazione xx alta bassa - Implementazione dell'associazione serie feature / canale sorgente da interfacca xx alta bassa - Ragionare sulla sincronizzazione dei log (tempo sitema, tempo logger, correzione)","title":"MODULO PRINCIPALE"},{"location":"docs/API%20Reference/actions/","text":"Actions POST /actions/{feature}/{action} params : feature : Basic text / string value action : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage : Esecuzione delle azioni Richiede l'esecuzione di una specifica azione su una feature, fornendo tutte le informazioni necessarie attraverso una form dinamica dedicata. Oltre ai due parametri feature e form , timestamp , indicati nella url, accetta un multipart/form-data basato sulla specifica form, selezionata tramite i due parametri espliciti. Tutto il content \u00e8 scaricato attarverso i chunk dello stream ('100 continue') per evitare il timeout dei workers in caso di contenuti di grandi dimensioni. Possibili risposte: 200 OK : Nel caso in cui l'azione vada a buon fine. L'azione richiesta viene presa in carico ma potrebbe avere un tempo di esecuzione arbitrario. L'azione quindi viene splittata su un altro processo. 404 Not Found : Nel caso la feature non esista o non sia definita per essa l'azione richiesta. 500 Internal Server Error : Nel caso pessimo che il modulo dichiarato non esista. 501 Not Implemented' : Nel caso la tipologia non fornisse ancora l'iplementazione di uno o tutti i moduli di gestione E' stato implementato il meccanismo minimo di gestione che prevede il salvataggio delle info fornite che possono essere fornite tali e quali in uscita (vedi metodo GET dell'api). Questo meccanismo permette di svluppare i moduli a partire da un template con risposta di default. PUT /actions/{feature}/{action} params : feature : Basic text / string value action : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage : Esecuzione delle azioni Richiede l'esecuzione di una specifica azione su una feature, fornendo tutte le informazioni necessarie attraverso una form dinamica dedicata. Oltre ai due parametri feature e form , timestamp , indicati nella url, accetta un multipart/form-data basato sulla specifica form, selezionata tramite i due parametri espliciti. Tutto il content \u00e8 scaricato attarverso i chunk dello stream ('100 continue') per evitare il timeout dei workers in caso di contenuti di grandi dimensioni. Possibili risposte: 200 OK : Nel caso in cui l'azione vada a buon fine. L'azione richiesta viene presa in carico ma potrebbe avere un tempo di esecuzione arbitrario. L'azione quindi viene splittata su un altro processo. 404 Not Found : Nel caso la feature non esista o non sia definita per essa l'azione richiesta. 500 Internal Server Error : Nel caso pessimo che il modulo dichiarato non esista. 501 Not Implemented' : Nel caso la tipologia non fornisse ancora l'iplementazione di uno o tutti i moduli di gestione E' stato implementato il meccanismo minimo di gestione che prevede il salvataggio delle info fornite che possono essere fornite tali e quali in uscita (vedi metodo GET dell'api). Questo meccanismo permette di svluppare i moduli a partire da un template con risposta di default.","title":"Actions"},{"location":"docs/API%20Reference/actions/#actions","text":"","title":"Actions"},{"location":"docs/API%20Reference/actions/#post-actionsfeatureaction","text":"params : feature : Basic text / string value action : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage : Esecuzione delle azioni Richiede l'esecuzione di una specifica azione su una feature, fornendo tutte le informazioni necessarie attraverso una form dinamica dedicata. Oltre ai due parametri feature e form , timestamp , indicati nella url, accetta un multipart/form-data basato sulla specifica form, selezionata tramite i due parametri espliciti. Tutto il content \u00e8 scaricato attarverso i chunk dello stream ('100 continue') per evitare il timeout dei workers in caso di contenuti di grandi dimensioni. Possibili risposte: 200 OK : Nel caso in cui l'azione vada a buon fine. L'azione richiesta viene presa in carico ma potrebbe avere un tempo di esecuzione arbitrario. L'azione quindi viene splittata su un altro processo. 404 Not Found : Nel caso la feature non esista o non sia definita per essa l'azione richiesta. 500 Internal Server Error : Nel caso pessimo che il modulo dichiarato non esista. 501 Not Implemented' : Nel caso la tipologia non fornisse ancora l'iplementazione di uno o tutti i moduli di gestione E' stato implementato il meccanismo minimo di gestione che prevede il salvataggio delle info fornite che possono essere fornite tali e quali in uscita (vedi metodo GET dell'api). Questo meccanismo permette di svluppare i moduli a partire da un template con risposta di default.","title":"POST   /actions/{feature}/{action}"},{"location":"docs/API%20Reference/actions/#put-actionsfeatureaction","text":"params : feature : Basic text / string value action : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage : Esecuzione delle azioni Richiede l'esecuzione di una specifica azione su una feature, fornendo tutte le informazioni necessarie attraverso una form dinamica dedicata. Oltre ai due parametri feature e form , timestamp , indicati nella url, accetta un multipart/form-data basato sulla specifica form, selezionata tramite i due parametri espliciti. Tutto il content \u00e8 scaricato attarverso i chunk dello stream ('100 continue') per evitare il timeout dei workers in caso di contenuti di grandi dimensioni. Possibili risposte: 200 OK : Nel caso in cui l'azione vada a buon fine. L'azione richiesta viene presa in carico ma potrebbe avere un tempo di esecuzione arbitrario. L'azione quindi viene splittata su un altro processo. 404 Not Found : Nel caso la feature non esista o non sia definita per essa l'azione richiesta. 500 Internal Server Error : Nel caso pessimo che il modulo dichiarato non esista. 501 Not Implemented' : Nel caso la tipologia non fornisse ancora l'iplementazione di uno o tutti i moduli di gestione E' stato implementato il meccanismo minimo di gestione che prevede il salvataggio delle info fornite che possono essere fornite tali e quali in uscita (vedi metodo GET dell'api). Questo meccanismo permette di svluppare i moduli a partire da un template con risposta di default.","title":"PUT    /actions/{feature}/{action}"},{"location":"docs/API%20Reference/actionschemata/","text":"Actionschemata GET /actionschemata/ params : prototypes : Basic text / string value actions : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage : Recupero dello schema dei parametri per inizializare le forms delle azioni ritorna una struttura json di questo tipo: { \"NomePrototipo1\": { \"action1\": { \"args\": { \"arg1.1\": \"type_arg1.1\", \"arg1.2\": \"type_arg1.2\", ... }, \"mandatory\": [ args keys sublist ] }, \"action2\": { \"args\": { \"arg2.1\": \"type_arg2.1\", \"arg2.2\": \"type_arg2.2\", ... }, }, ... }, \"NomePrototipo3\": { ... }, ... }, GET /actionschemata/{prototype} params : prototype : Basic text / string value actions : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage : Alias per il recupero di tutte le informazioni di uno specifico prototipo GET /actionschemata/{prototype}/{action} params : prototype : Basic text / string value action : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage : Alias per il recupero di tutte le informazioni delle form di uno specifico prototipo","title":"ActionSchemata"},{"location":"docs/API%20Reference/actionschemata/#actionschemata","text":"","title":"Actionschemata"},{"location":"docs/API%20Reference/actionschemata/#get-actionschemata","text":"params : prototypes : Basic text / string value actions : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage : Recupero dello schema dei parametri per inizializare le forms delle azioni ritorna una struttura json di questo tipo: { \"NomePrototipo1\": { \"action1\": { \"args\": { \"arg1.1\": \"type_arg1.1\", \"arg1.2\": \"type_arg1.2\", ... }, \"mandatory\": [ args keys sublist ] }, \"action2\": { \"args\": { \"arg2.1\": \"type_arg2.1\", \"arg2.2\": \"type_arg2.2\", ... }, }, ... }, \"NomePrototipo3\": { ... }, ... },","title":"GET    /actionschemata/"},{"location":"docs/API%20Reference/actionschemata/#get-actionschemataprototype","text":"params : prototype : Basic text / string value actions : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage : Alias per il recupero di tutte le informazioni di uno specifico prototipo","title":"GET    /actionschemata/{prototype}"},{"location":"docs/API%20Reference/actionschemata/#get-actionschemataprototypeaction","text":"params : prototype : Basic text / string value action : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage : Alias per il recupero di tutte le informazioni delle form di uno specifico prototipo","title":"GET    /actionschemata/{prototype}/{action}"},{"location":"docs/API%20Reference/awskineresources/","text":"Awskineresources GET /awskineresources/ params : uids : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage : GET /awskineresources/{uid} params : uid : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage :","title":"Awskineresources"},{"location":"docs/API%20Reference/awskineresources/#awskineresources","text":"","title":"Awskineresources"},{"location":"docs/API%20Reference/awskineresources/#get-awskineresources","text":"params : uids : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage :","title":"GET    /awskineresources/"},{"location":"docs/API%20Reference/awskineresources/#get-awskineresourcesuid","text":"params : uid : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage :","title":"GET    /awskineresources/{uid}"},{"location":"docs/API%20Reference/features/","text":"Features POST /features/ params : prototype : Basic text / string value properties : JSON Schema { style : str|bytes, timestamp : str|bytes, context : str|bytes, label : str|bytes, description : str|bytes, location : str|bytes, status : str|bytes} geometry : JSON Schema {} result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage : DESCRIZIONE: Creazione delle Features. Ogni feature viene creata sulla il suo il suo prototipo prototype ed in fase di creazione viene creato il campo uid . Questi due campi sono immutabli. Vedi PUT feature PARAMETRI: prototype : Definisce il tipo della feature e accetta uno dei valori recuperabili attraverso l'API GET prototype properties : Json dei campi anagrafici della feature, utilizzati dal sistema. Nessuno di essi \u00e8 obbligatorio. Lo schema \u00e8 il seguente: { \"context\": \"Stringa: gruppo in cui inserire la feature\", \"label\": \"Stringa: etichetta mnemonica della feature\", \"description\": \"Stringa: descrizione della feature\", \"location\": \"Stringa: descrizione mnemonica della posizioni\", \"style\": \"Stringa: informazioni per le direttive csv\", \"status\": \"Stringa: informaizoni di stato\", \"timestamp\": \"Stringa: data di creazione della feature nel formato YYYY-MM-DD HH:MM:SS\" } geometry : Accetta un GeoJson OUTPUT: Se la feature viene creata correttamente la sua struttura viene restituita all'interno del campo data del json di risposta standard RESPONSE CODES: 409 Conflict : Nel caso in cui il uid fornito esista gi\u00e0. 404 Not Found : Nel caso in cui il prototipo richiesto non esista. 201 Created : Nel caso in cui la feature venga creata correttamente. GET /features/ params : uids : Basic text / string value cntxt : Basic text / string value info : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage : DESCRIZIONE: Recupero delle informazioni delle features. PARAMETRI: uids : Lista \"comma separated\" degli id delle features da recuperare. Nel caso in cui non venisse fornito alcun valore, verrebbe fornita in output l'intera lista delle features presenti nel sistema. cntxt : Lista \"comma separated\" dei gruppi di features da recuperare. Se presente agisce da filtro rispetto al risultato elaborato in base al parametro \"uids\" info : Lista \"comma separated\" delle informazioni relative ad ogni feature da includere nella risposta. In generale dei sottoalberi Json. Le classi di informazione disponibili sono: capabilities : tipi di interrogazioni eseguibili sulla feature: elenco comprendente una, nessuna o pi\u00f9 voci tra queste: data , map , cloud . Vedi GET query parameters : parametri (timeseries) associati alla feature, interrogabili tramite GET query timeline : eventuale timeline globale dei parametri della feature ESEMPIO: GET features?cntxt=619d00137303c&info=parameters,capabilities OUTPUT: All'interno del campo data del json di risposta standard viene restituito un oggetto \"chiave, valore\" json che \u00e9 interpretabile come GeoJson estraendo la lista dei values. L'oggetto contiene tutte le features che rientrano nei criteri di ricerca. Quindi un struttura di questo tipo: \"features\": { \"1285beb4\": { \"type\": \"Feature\", \"properties\": { \"uid\": \"1285beb4\", \"classification\": \"Source\", \"context\": \"619d00137303c\", \"description\": null, \"label\": \"CAM1\", \"location\": null, \"status\": \"0\", \"style\": \"9cecce36\", \"timestamp\": \"2021-11-10 00:00:00\", \"type\": \"PhotoMonitoring\", \"inmap\": null }, \"parameters\": [ { \"series\": \"06578ff5509871eef7e62f8d2bc175de\", \"param\": \"Displacement\", \"unit\": \"mm\", }, { \"series\": \"2388b145eed5036e78afff43114cf7f7\", \"param\": \"Correlation_Coefficient\", \"unit\": \"number\", }, ], \"timeline\": [ \"2021-11-04T15:11:45\" ], \"capabilities\": [ \"map\" ] }, } RESPONSE CODES: 200 OK : Nel caso vengano trovate features corrispondenti ai criteri di ricerca 404 Not Found : Nel caso in cui nessuna feature risponda ai criteri di ricerca GET /features/{uid} params : uid : Basic text / string value cntxt : Basic text / string value info : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage : DESCRIZIONE: Alias di recupero informazioni della specifica feature PARAMETRI: info : Lista \"comma separated\" delle informazioni relative ad ogni feature da includere nella risposta. In generale dei sottoalberi Json. Le classi di informazione disponibili sono: capabilities : tipi di interrogazioni eseguibili sulla feature: elenco comprendente una, nessuna o pi\u00f9 voci tra queste: data , map , cloud . Vedi GET query parameters : parametri (timeseries) associati alla feature, interrogabili tramite GET query timeline : eventuale timeline globale dei parametri della feature ESEMPIO: GET features/1285beb4&info=parameters,capabilities OUTPUT: Vedi GET features RESPONSE CODES: 200 OK : Nel caso vengano trovate features corrispondenti ai criteri di ricerca 404 Not Found : Nel caso in cui nessuna feature risponda ai criteri di ricerca PUT /features/{uid} params : uid : Basic text / string value properties : JSON Schema { style : str|bytes, timestamp : str|bytes, context : str|bytes, label : str|bytes, description : str|bytes, location : str|bytes, status : str|bytes} geometry : JSON Schema {} result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage : Modifica delle properties di una feature Possibili risposte: 404 Not Found : Nel caso in cui il prototipo richiesto non esista. 200 Ok : Nel caso in cui la feature venga modificata correttamente. DELETE /features/{uid} params : uid : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage : Cancellazione delle Features Se la feature viene cancellata correttamente ne restituisce la struttura Possibili risposte: 404 Not Found : Nel caso in cui il prototipo richiesto non esista. 200 Accepted : Nel caso in cui la feature venga eliminata correttamente.","title":"Features"},{"location":"docs/API%20Reference/features/#features","text":"","title":"Features"},{"location":"docs/API%20Reference/features/#post-features","text":"params : prototype : Basic text / string value properties : JSON Schema { style : str|bytes, timestamp : str|bytes, context : str|bytes, label : str|bytes, description : str|bytes, location : str|bytes, status : str|bytes} geometry : JSON Schema {} result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage : DESCRIZIONE: Creazione delle Features. Ogni feature viene creata sulla il suo il suo prototipo prototype ed in fase di creazione viene creato il campo uid . Questi due campi sono immutabli. Vedi PUT feature PARAMETRI: prototype : Definisce il tipo della feature e accetta uno dei valori recuperabili attraverso l'API GET prototype properties : Json dei campi anagrafici della feature, utilizzati dal sistema. Nessuno di essi \u00e8 obbligatorio. Lo schema \u00e8 il seguente: { \"context\": \"Stringa: gruppo in cui inserire la feature\", \"label\": \"Stringa: etichetta mnemonica della feature\", \"description\": \"Stringa: descrizione della feature\", \"location\": \"Stringa: descrizione mnemonica della posizioni\", \"style\": \"Stringa: informazioni per le direttive csv\", \"status\": \"Stringa: informaizoni di stato\", \"timestamp\": \"Stringa: data di creazione della feature nel formato YYYY-MM-DD HH:MM:SS\" } geometry : Accetta un GeoJson OUTPUT: Se la feature viene creata correttamente la sua struttura viene restituita all'interno del campo data del json di risposta standard RESPONSE CODES: 409 Conflict : Nel caso in cui il uid fornito esista gi\u00e0. 404 Not Found : Nel caso in cui il prototipo richiesto non esista. 201 Created : Nel caso in cui la feature venga creata correttamente.","title":"POST   /features/"},{"location":"docs/API%20Reference/features/#get-features","text":"params : uids : Basic text / string value cntxt : Basic text / string value info : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage : DESCRIZIONE: Recupero delle informazioni delle features. PARAMETRI: uids : Lista \"comma separated\" degli id delle features da recuperare. Nel caso in cui non venisse fornito alcun valore, verrebbe fornita in output l'intera lista delle features presenti nel sistema. cntxt : Lista \"comma separated\" dei gruppi di features da recuperare. Se presente agisce da filtro rispetto al risultato elaborato in base al parametro \"uids\" info : Lista \"comma separated\" delle informazioni relative ad ogni feature da includere nella risposta. In generale dei sottoalberi Json. Le classi di informazione disponibili sono: capabilities : tipi di interrogazioni eseguibili sulla feature: elenco comprendente una, nessuna o pi\u00f9 voci tra queste: data , map , cloud . Vedi GET query parameters : parametri (timeseries) associati alla feature, interrogabili tramite GET query timeline : eventuale timeline globale dei parametri della feature ESEMPIO: GET features?cntxt=619d00137303c&info=parameters,capabilities OUTPUT: All'interno del campo data del json di risposta standard viene restituito un oggetto \"chiave, valore\" json che \u00e9 interpretabile come GeoJson estraendo la lista dei values. L'oggetto contiene tutte le features che rientrano nei criteri di ricerca. Quindi un struttura di questo tipo: \"features\": { \"1285beb4\": { \"type\": \"Feature\", \"properties\": { \"uid\": \"1285beb4\", \"classification\": \"Source\", \"context\": \"619d00137303c\", \"description\": null, \"label\": \"CAM1\", \"location\": null, \"status\": \"0\", \"style\": \"9cecce36\", \"timestamp\": \"2021-11-10 00:00:00\", \"type\": \"PhotoMonitoring\", \"inmap\": null }, \"parameters\": [ { \"series\": \"06578ff5509871eef7e62f8d2bc175de\", \"param\": \"Displacement\", \"unit\": \"mm\", }, { \"series\": \"2388b145eed5036e78afff43114cf7f7\", \"param\": \"Correlation_Coefficient\", \"unit\": \"number\", }, ], \"timeline\": [ \"2021-11-04T15:11:45\" ], \"capabilities\": [ \"map\" ] }, } RESPONSE CODES: 200 OK : Nel caso vengano trovate features corrispondenti ai criteri di ricerca 404 Not Found : Nel caso in cui nessuna feature risponda ai criteri di ricerca","title":"GET    /features/"},{"location":"docs/API%20Reference/features/#get-featuresuid","text":"params : uid : Basic text / string value cntxt : Basic text / string value info : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage : DESCRIZIONE: Alias di recupero informazioni della specifica feature PARAMETRI: info : Lista \"comma separated\" delle informazioni relative ad ogni feature da includere nella risposta. In generale dei sottoalberi Json. Le classi di informazione disponibili sono: capabilities : tipi di interrogazioni eseguibili sulla feature: elenco comprendente una, nessuna o pi\u00f9 voci tra queste: data , map , cloud . Vedi GET query parameters : parametri (timeseries) associati alla feature, interrogabili tramite GET query timeline : eventuale timeline globale dei parametri della feature ESEMPIO: GET features/1285beb4&info=parameters,capabilities OUTPUT: Vedi GET features RESPONSE CODES: 200 OK : Nel caso vengano trovate features corrispondenti ai criteri di ricerca 404 Not Found : Nel caso in cui nessuna feature risponda ai criteri di ricerca","title":"GET    /features/{uid}"},{"location":"docs/API%20Reference/features/#put-featuresuid","text":"params : uid : Basic text / string value properties : JSON Schema { style : str|bytes, timestamp : str|bytes, context : str|bytes, label : str|bytes, description : str|bytes, location : str|bytes, status : str|bytes} geometry : JSON Schema {} result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage : Modifica delle properties di una feature Possibili risposte: 404 Not Found : Nel caso in cui il prototipo richiesto non esista. 200 Ok : Nel caso in cui la feature venga modificata correttamente.","title":"PUT    /features/{uid}"},{"location":"docs/API%20Reference/features/#delete-featuresuid","text":"params : uid : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage : Cancellazione delle Features Se la feature viene cancellata correttamente ne restituisce la struttura Possibili risposte: 404 Not Found : Nel caso in cui il prototipo richiesto non esista. 200 Accepted : Nel caso in cui la feature venga eliminata correttamente.","title":"DELETE /features/{uid}"},{"location":"docs/API%20Reference/hls/","text":"Hls POST /hls/ params : resource : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage : POST /hls/{resource} params : resource : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage :","title":"Hls"},{"location":"docs/API%20Reference/hls/#hls","text":"","title":"Hls"},{"location":"docs/API%20Reference/hls/#post-hls","text":"params : resource : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage :","title":"POST   /hls/"},{"location":"docs/API%20Reference/hls/#post-hlsresource","text":"params : resource : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage :","title":"POST   /hls/{resource}"},{"location":"docs/API%20Reference/prototypes/","text":"Prototypes GET /prototypes/ params : result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage : Ritorna l'elenco dei prototipi disponibili come array json GET /prototypes/{prototype} params : prototype : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage : Ritorna informazioni dettagliate sullo specifico prototipo","title":"Prototypes"},{"location":"docs/API%20Reference/prototypes/#prototypes","text":"","title":"Prototypes"},{"location":"docs/API%20Reference/prototypes/#get-prototypes","text":"params : result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage : Ritorna l'elenco dei prototipi disponibili come array json","title":"GET    /prototypes/"},{"location":"docs/API%20Reference/prototypes/#get-prototypesprototype","text":"params : prototype : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage : Ritorna informazioni dettagliate sullo specifico prototipo","title":"GET    /prototypes/{prototype}"},{"location":"docs/API%20Reference/query/","text":"Query GET /query/{capability} params : capability : Basic text / string value datamap : JSON Schema [{ series : [str|bytes], times : , refresh : bool, geometry : [], timeref : str|bytes}] content_type : Basic text / string value result : format : Supports any of the following formats: JSON (Javascript Serialized Object Notation), Free form UTF-8 text, A dynamically retrieved file content_type : application/json; charset=utf-8, text/plain; charset=utf-8, file/dynamic usage : GET /query/{capability}/{feature}/ params : capability : Basic text / string value feature : Basic text / string value par : Basic text / string value times : Basic text / string value timeref : Basic text / string value refresh : Basic text / string value geometry : Basic text / string value content_type : Basic text / string value result : format : Supports any of the following formats: JSON (Javascript Serialized Object Notation), Free form UTF-8 text, A dynamically retrieved file content_type : application/json; charset=utf-8, text/plain; charset=utf-8, file/dynamic usage : GET /query/{capability}/{feature}/{par} params : capability : Basic text / string value feature : Basic text / string value par : Basic text / string value times : Basic text / string value timeref : Basic text / string value refresh : Basic text / string value geometry : Basic text / string value content_type : Basic text / string value result : format : Supports any of the following formats: JSON (Javascript Serialized Object Notation), Free form UTF-8 text, A dynamically retrieved file content_type : application/json; charset=utf-8, text/plain; charset=utf-8, file/dynamic usage :","title":"Query"},{"location":"docs/API%20Reference/query/#query","text":"","title":"Query"},{"location":"docs/API%20Reference/query/#get-querycapability","text":"params : capability : Basic text / string value datamap : JSON Schema [{ series : [str|bytes], times : , refresh : bool, geometry : [], timeref : str|bytes}] content_type : Basic text / string value result : format : Supports any of the following formats: JSON (Javascript Serialized Object Notation), Free form UTF-8 text, A dynamically retrieved file content_type : application/json; charset=utf-8, text/plain; charset=utf-8, file/dynamic usage :","title":"GET    /query/{capability}"},{"location":"docs/API%20Reference/query/#get-querycapabilityfeature","text":"params : capability : Basic text / string value feature : Basic text / string value par : Basic text / string value times : Basic text / string value timeref : Basic text / string value refresh : Basic text / string value geometry : Basic text / string value content_type : Basic text / string value result : format : Supports any of the following formats: JSON (Javascript Serialized Object Notation), Free form UTF-8 text, A dynamically retrieved file content_type : application/json; charset=utf-8, text/plain; charset=utf-8, file/dynamic usage :","title":"GET    /query/{capability}/{feature}/"},{"location":"docs/API%20Reference/query/#get-querycapabilityfeaturepar","text":"params : capability : Basic text / string value feature : Basic text / string value par : Basic text / string value times : Basic text / string value timeref : Basic text / string value refresh : Basic text / string value geometry : Basic text / string value content_type : Basic text / string value result : format : Supports any of the following formats: JSON (Javascript Serialized Object Notation), Free form UTF-8 text, A dynamically retrieved file content_type : application/json; charset=utf-8, text/plain; charset=utf-8, file/dynamic usage :","title":"GET    /query/{capability}/{feature}/{par}"},{"location":"docs/API%20Reference/query2/","text":"Query2 GET /query2/{capability} params : capability : Basic text / string value datamap : JSON Schema [{ series : [str|bytes], times : , refresh : bool, geometry : [], timeref : str|bytes}] content_type : Basic text / string value result : format : Supports any of the following formats: JSON (Javascript Serialized Object Notation), Free form UTF-8 text, A dynamically retrieved file content_type : application/json; charset=utf-8, text/plain; charset=utf-8, file/dynamic usage : GET /query2/{capability}/{feature}/ params : capability : Basic text / string value feature : Basic text / string value par : Basic text / string value times : Basic text / string value timeref : Basic text / string value refresh : Basic text / string value geometry : Basic text / string value content_type : Basic text / string value result : format : Supports any of the following formats: JSON (Javascript Serialized Object Notation), Free form UTF-8 text, A dynamically retrieved file content_type : application/json; charset=utf-8, text/plain; charset=utf-8, file/dynamic usage : GET /query2/{capability}/{feature}/{par} params : capability : Basic text / string value feature : Basic text / string value par : Basic text / string value times : Basic text / string value timeref : Basic text / string value refresh : Basic text / string value geometry : Basic text / string value content_type : Basic text / string value result : format : Supports any of the following formats: JSON (Javascript Serialized Object Notation), Free form UTF-8 text, A dynamically retrieved file content_type : application/json; charset=utf-8, text/plain; charset=utf-8, file/dynamic usage :","title":"Query2"},{"location":"docs/API%20Reference/query2/#query2","text":"","title":"Query2"},{"location":"docs/API%20Reference/query2/#get-query2capability","text":"params : capability : Basic text / string value datamap : JSON Schema [{ series : [str|bytes], times : , refresh : bool, geometry : [], timeref : str|bytes}] content_type : Basic text / string value result : format : Supports any of the following formats: JSON (Javascript Serialized Object Notation), Free form UTF-8 text, A dynamically retrieved file content_type : application/json; charset=utf-8, text/plain; charset=utf-8, file/dynamic usage :","title":"GET    /query2/{capability}"},{"location":"docs/API%20Reference/query2/#get-query2capabilityfeature","text":"params : capability : Basic text / string value feature : Basic text / string value par : Basic text / string value times : Basic text / string value timeref : Basic text / string value refresh : Basic text / string value geometry : Basic text / string value content_type : Basic text / string value result : format : Supports any of the following formats: JSON (Javascript Serialized Object Notation), Free form UTF-8 text, A dynamically retrieved file content_type : application/json; charset=utf-8, text/plain; charset=utf-8, file/dynamic usage :","title":"GET    /query2/{capability}/{feature}/"},{"location":"docs/API%20Reference/query2/#get-query2capabilityfeaturepar","text":"params : capability : Basic text / string value feature : Basic text / string value par : Basic text / string value times : Basic text / string value timeref : Basic text / string value refresh : Basic text / string value geometry : Basic text / string value content_type : Basic text / string value result : format : Supports any of the following formats: JSON (Javascript Serialized Object Notation), Free form UTF-8 text, A dynamically retrieved file content_type : application/json; charset=utf-8, text/plain; charset=utf-8, file/dynamic usage :","title":"GET    /query2/{capability}/{feature}/{par}"},{"location":"docs/API%20Reference/queue/","text":"Queue GET /queue/{queue} params : queue : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage :","title":"Queue"},{"location":"docs/API%20Reference/queue/#queue","text":"","title":"Queue"},{"location":"docs/API%20Reference/queue/#get-queuequeue","text":"params : queue : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage :","title":"GET    /queue/{queue}"},{"location":"docs/API%20Reference/samplerate/","text":"Samplerate GET /samplerate/ params : features : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage : GET /samplerate/{feature} params : feature : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage : POST /samplerate/{feature} params : feature : Basic text / string value newrate : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage :","title":"Samplerate"},{"location":"docs/API%20Reference/samplerate/#samplerate","text":"","title":"Samplerate"},{"location":"docs/API%20Reference/samplerate/#get-samplerate","text":"params : features : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage :","title":"GET    /samplerate/"},{"location":"docs/API%20Reference/samplerate/#get-sampleratefeature","text":"params : feature : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage :","title":"GET    /samplerate/{feature}"},{"location":"docs/API%20Reference/samplerate/#post-sampleratefeature","text":"params : feature : Basic text / string value newrate : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage :","title":"POST   /samplerate/{feature}"},{"location":"docs/API%20Reference/status/","text":"Status GET /status/ params : uids : Basic text / string value cntxt : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage : GET /status/{uid} params : uid : Basic text / string value cntxt : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage :","title":"Status"},{"location":"docs/API%20Reference/status/#status","text":"","title":"Status"},{"location":"docs/API%20Reference/status/#get-status","text":"params : uids : Basic text / string value cntxt : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage :","title":"GET    /status/"},{"location":"docs/API%20Reference/status/#get-statusuid","text":"params : uid : Basic text / string value cntxt : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage :","title":"GET    /status/{uid}"},{"location":"docs/API%20Reference/status2/","text":"Status2 GET /status2/ params : uids : Basic text / string value cntxt : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage : GET /status2/{uid} params : uid : Basic text / string value cntxt : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage :","title":"Status2"},{"location":"docs/API%20Reference/status2/#status2","text":"","title":"Status2"},{"location":"docs/API%20Reference/status2/#get-status2","text":"params : uids : Basic text / string value cntxt : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage :","title":"GET    /status2/"},{"location":"docs/API%20Reference/status2/#get-status2uid","text":"params : uid : Basic text / string value cntxt : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 usage :","title":"GET    /status2/{uid}"},{"location":"reference/hielen3/","text":"Module hielen3 View Source # coding=utf-8 __name__ = 'hielen3' __version__ = '3.3.21' __author__ = 'Alessandro Modesti' __email__ = 'it@img-srl.com' __description__ = 'Multidimention Hierarichical Elaboration Engine' __license__ = 'MIT' __uri__ = '' import warnings import json from .datalink import dbinit # , cacheinit def _initconf ( confile , envfile ): env = None with open ( envfile ) as ef : env = json . load ( ef ) with open ( confile ) as cf : confstr = cf . read () for k , w in env . items (): if not isinstance ( w , str ): w = json . dumps ( w ) placeholder = \"{{\" + k + \"}}\" confstr = confstr . replace ( placeholder , w ) return json . loads ( confstr ) conf = _initconf ( \"./conf/hielen.json\" , \"./conf/env.json\" ) db = dbinit ( conf ) def int_or_str ( value ): try : return int ( value ) except ValueError : return value VERSION = tuple ( map ( int_or_str , __version__ . split ( \".\" ))) __all__ = [ \"conf\" , \"db\" ] Sub-modules hielen3.api hielen3.cloudmanager hielen3.datalink hielen3.ext hielen3.feature hielen3.geje hielen3.mapmanager hielen3.serializaction hielen3.series hielen3.series_good hielen3.sourcestorage hielen3.tools hielen3.utils Variables conf db","title":"Index"},{"location":"reference/hielen3/#module-hielen3","text":"View Source # coding=utf-8 __name__ = 'hielen3' __version__ = '3.3.21' __author__ = 'Alessandro Modesti' __email__ = 'it@img-srl.com' __description__ = 'Multidimention Hierarichical Elaboration Engine' __license__ = 'MIT' __uri__ = '' import warnings import json from .datalink import dbinit # , cacheinit def _initconf ( confile , envfile ): env = None with open ( envfile ) as ef : env = json . load ( ef ) with open ( confile ) as cf : confstr = cf . read () for k , w in env . items (): if not isinstance ( w , str ): w = json . dumps ( w ) placeholder = \"{{\" + k + \"}}\" confstr = confstr . replace ( placeholder , w ) return json . loads ( confstr ) conf = _initconf ( \"./conf/hielen.json\" , \"./conf/env.json\" ) db = dbinit ( conf ) def int_or_str ( value ): try : return int ( value ) except ValueError : return value VERSION = tuple ( map ( int_or_str , __version__ . split ( \".\" ))) __all__ = [ \"conf\" , \"db\" ]","title":"Module hielen3"},{"location":"reference/hielen3/#sub-modules","text":"hielen3.api hielen3.cloudmanager hielen3.datalink hielen3.ext hielen3.feature hielen3.geje hielen3.mapmanager hielen3.serializaction hielen3.series hielen3.series_good hielen3.sourcestorage hielen3.tools hielen3.utils","title":"Sub-modules"},{"location":"reference/hielen3/#variables","text":"conf db","title":"Variables"},{"location":"reference/hielen3/cloudmanager/","text":"Module hielen3.cloudmanager View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 #!/usr/bin/env python # coding=utf-8 from hielen3 import conf from abc import ABC , abstractmethod from pathlib import Path , os from hielen3.sourcestorage import SourceStorage from glob import glob import re import json class Cloudmanager ( ABC ): def __init__ ( self , feature , basepath , * args , ** kwargs ): basepath = Path ( feature ) / basepath self . cloudbaseurl = Path ( conf [ 'cloudurl' ] ) / 'viewer.html' self . cloudcache = SourceStorage ( conf [ 'syscache' ][ 'cloudcache' ], str ( basepath )) self . basepath = basepath \"\"\" @property def mapfile(self): return self.mapcache / \"mapfile.map\" @property def mapurl(self): return self.mapbaseurl / \"mapfile.map\" @abstractmethod def setMFparams(): pass \"\"\" @abstractmethod def geturl (): pass class PotreeCM ( Cloudmanager ): def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) def makePotree ( self , lazfile , cloudname , subpath = None ): targhetpath = self . cloudcache / ( subpath or \"\" ) / cloudname return os . system ( f \" { conf [ 'potreeconverter' ] } { lazfile } -o { targhetpath } \" ) def geturl ( self , subpath , cloud = None ): if cloud is None : cloud = \"*\" sub = self . cloudcache / subpath clouds = [] clswitch = {} #basepath = self.cloudcache / 'base' / 'metadata.json' #metto la base se esiste #if basepath.exists(): # clouds['base']=str(basepath).replace(conf['syscache']['cloudcache'],\"resources\") on = 1 for p in self . cloudcache . glob ( '*' ): if p . is_dir () and ( p / 'metadata.json' ) . exists (): relpath = str ( p / 'metadata.json' ) . replace ( conf [ 'syscache' ][ 'cloudcache' ], \"resources\" ) clouds . append ({ \"name\" : p . name , \"path\" : relpath , \"switch\" : on }) on = 0 on = 1 #cerco le altre clouds for p in sub . glob ( cloud ): if p . is_dir () and ( p / 'metadata.json' ) . exists (): relpath = str ( p / 'metadata.json' ) . replace ( conf [ 'syscache' ][ 'cloudcache' ], \"resources\" ) clouds . append ({ \"name\" : p . name , \"path\" : relpath , \"switch\" : on }) on = 0 url = str ( self . cloudbaseurl ) + \"?clouds=\" + json . dumps ( clouds ) return url Variables conf Classes Cloudmanager class Cloudmanager ( feature , basepath , * args , ** kwargs ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Cloudmanager ( ABC ) : def __init__ ( self , feature , basepath , * args , ** kwargs ) : basepath = Path ( feature ) / basepath self . cloudbaseurl = Path ( conf [ 'cloudurl' ] ) / 'viewer.html' self . cloudcache = SourceStorage ( conf [ 'syscache' ][ 'cloudcache' ] , str ( basepath )) self . basepath = basepath \"\"\" @property def mapfile(self): return self.mapcache / \" mapfile . map \" @property def mapurl(self): return self.mapbaseurl / \" mapfile . map \" @abstractmethod def setMFparams(): pass \"\"\" @abstractmethod def geturl () : pass Ancestors (in MRO) abc.ABC Descendants hielen3.cloudmanager.PotreeCM Methods geturl def geturl ( ) View Source @abstractmethod def geturl () : pass PotreeCM class PotreeCM ( * args , ** kwargs ) Helper class that provides a standard way to create an ABC using inheritance. View Source class PotreeCM ( Cloudmanager ): def __init__ ( self ,* args ,** kwargs ): super (). __init__ (* args ,** kwargs ) def makePotree ( self , lazfile , cloudname , subpath = None ): targhetpath = self . cloudcache / ( subpath or \"\" ) / cloudname return os . system ( f \"{conf['potreeconverter']} {lazfile} -o {targhetpath}\" ) def geturl ( self , subpath , cloud = None ): if cloud is None: cloud = \"*\" sub = self . cloudcache / subpath clouds =[] clswitch ={} #basepath = self.cloudcache / 'base' / 'metadata.json' #metto la base se esiste #if basepath.exists(): # clouds['base']=str(basepath).replace(conf['syscache']['cloudcache'],\"resources\") on = 1 for p in self . cloudcache . glob ( '*' ): if p . is_dir () and ( p / 'metadata.json' ). exists (): relpath = str ( p / 'metadata.json' ). replace ( conf [ 'syscache' ][ 'cloudcache' ], \"resources\" ) clouds . append ({ \"name\" : p . name , \"path\" : relpath , \"switch\" : on }) on = 0 on = 1 #cerco le altre clouds for p in sub . glob ( cloud ): if p . is_dir () and ( p / 'metadata.json' ). exists (): relpath = str ( p / 'metadata.json' ). replace ( conf [ 'syscache' ][ 'cloudcache' ], \"resources\" ) clouds . append ({ \"name\" : p . name , \"path\" : relpath , \"switch\" : on }) on = 0 url = str ( self . cloudbaseurl )+ \"?clouds=\" + json . dumps ( clouds ) return url Ancestors (in MRO) hielen3.cloudmanager.Cloudmanager abc.ABC Methods geturl def geturl ( self , subpath , cloud = None ) View Source def geturl ( self , subpath , cloud = None ) : if cloud is None : cloud = \"*\" sub = self . cloudcache / subpath clouds = [] clswitch = {} # basepath = self . cloudcache / 'base' / 'metadata.json' # metto la base se esiste # if basepath . exists () : # clouds [ 'base' ] = str ( basepath ) . replace ( conf [ 'syscache' ][ 'cloudcache' ], \"resources\" ) on = 1 for p in self . cloudcache . glob ( '*' ) : if p . is_dir () and ( p / 'metadata.json' ) . exists () : relpath = str ( p / 'metadata.json' ) . replace ( conf [ 'syscache' ][ 'cloudcache' ], \"resources\" ) clouds . append ( { \"name\" : p . name , \"path\" : relpath , \"switch\" : on } ) on = 0 on = 1 # cerco le altre clouds for p in sub . glob ( cloud ) : if p . is_dir () and ( p / 'metadata.json' ) . exists () : relpath = str ( p / 'metadata.json' ) . replace ( conf [ 'syscache' ][ 'cloudcache' ], \"resources\" ) clouds . append ( { \"name\" : p . name , \"path\" : relpath , \"switch\" : on } ) on = 0 url = str ( self . cloudbaseurl ) + \"?clouds=\" + json . dumps ( clouds ) return url makePotree def makePotree ( self , lazfile , cloudname , subpath = None ) View Source def makePotree ( self , lazfile , cloudname , subpath = None ) : targhetpath = self . cloudcache / ( subpath or \"\" ) / cloudname return os . system ( f \"{conf['potreeconverter']} {lazfile} -o {targhetpath}\" )","title":"Cloudmanager"},{"location":"reference/hielen3/cloudmanager/#module-hielen3cloudmanager","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 #!/usr/bin/env python # coding=utf-8 from hielen3 import conf from abc import ABC , abstractmethod from pathlib import Path , os from hielen3.sourcestorage import SourceStorage from glob import glob import re import json class Cloudmanager ( ABC ): def __init__ ( self , feature , basepath , * args , ** kwargs ): basepath = Path ( feature ) / basepath self . cloudbaseurl = Path ( conf [ 'cloudurl' ] ) / 'viewer.html' self . cloudcache = SourceStorage ( conf [ 'syscache' ][ 'cloudcache' ], str ( basepath )) self . basepath = basepath \"\"\" @property def mapfile(self): return self.mapcache / \"mapfile.map\" @property def mapurl(self): return self.mapbaseurl / \"mapfile.map\" @abstractmethod def setMFparams(): pass \"\"\" @abstractmethod def geturl (): pass class PotreeCM ( Cloudmanager ): def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) def makePotree ( self , lazfile , cloudname , subpath = None ): targhetpath = self . cloudcache / ( subpath or \"\" ) / cloudname return os . system ( f \" { conf [ 'potreeconverter' ] } { lazfile } -o { targhetpath } \" ) def geturl ( self , subpath , cloud = None ): if cloud is None : cloud = \"*\" sub = self . cloudcache / subpath clouds = [] clswitch = {} #basepath = self.cloudcache / 'base' / 'metadata.json' #metto la base se esiste #if basepath.exists(): # clouds['base']=str(basepath).replace(conf['syscache']['cloudcache'],\"resources\") on = 1 for p in self . cloudcache . glob ( '*' ): if p . is_dir () and ( p / 'metadata.json' ) . exists (): relpath = str ( p / 'metadata.json' ) . replace ( conf [ 'syscache' ][ 'cloudcache' ], \"resources\" ) clouds . append ({ \"name\" : p . name , \"path\" : relpath , \"switch\" : on }) on = 0 on = 1 #cerco le altre clouds for p in sub . glob ( cloud ): if p . is_dir () and ( p / 'metadata.json' ) . exists (): relpath = str ( p / 'metadata.json' ) . replace ( conf [ 'syscache' ][ 'cloudcache' ], \"resources\" ) clouds . append ({ \"name\" : p . name , \"path\" : relpath , \"switch\" : on }) on = 0 url = str ( self . cloudbaseurl ) + \"?clouds=\" + json . dumps ( clouds ) return url","title":"Module hielen3.cloudmanager"},{"location":"reference/hielen3/cloudmanager/#variables","text":"conf","title":"Variables"},{"location":"reference/hielen3/cloudmanager/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/cloudmanager/#cloudmanager","text":"class Cloudmanager ( feature , basepath , * args , ** kwargs ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Cloudmanager ( ABC ) : def __init__ ( self , feature , basepath , * args , ** kwargs ) : basepath = Path ( feature ) / basepath self . cloudbaseurl = Path ( conf [ 'cloudurl' ] ) / 'viewer.html' self . cloudcache = SourceStorage ( conf [ 'syscache' ][ 'cloudcache' ] , str ( basepath )) self . basepath = basepath \"\"\" @property def mapfile(self): return self.mapcache / \" mapfile . map \" @property def mapurl(self): return self.mapbaseurl / \" mapfile . map \" @abstractmethod def setMFparams(): pass \"\"\" @abstractmethod def geturl () : pass","title":"Cloudmanager"},{"location":"reference/hielen3/cloudmanager/#ancestors-in-mro","text":"abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/cloudmanager/#descendants","text":"hielen3.cloudmanager.PotreeCM","title":"Descendants"},{"location":"reference/hielen3/cloudmanager/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/cloudmanager/#geturl","text":"def geturl ( ) View Source @abstractmethod def geturl () : pass","title":"geturl"},{"location":"reference/hielen3/cloudmanager/#potreecm","text":"class PotreeCM ( * args , ** kwargs ) Helper class that provides a standard way to create an ABC using inheritance. View Source class PotreeCM ( Cloudmanager ): def __init__ ( self ,* args ,** kwargs ): super (). __init__ (* args ,** kwargs ) def makePotree ( self , lazfile , cloudname , subpath = None ): targhetpath = self . cloudcache / ( subpath or \"\" ) / cloudname return os . system ( f \"{conf['potreeconverter']} {lazfile} -o {targhetpath}\" ) def geturl ( self , subpath , cloud = None ): if cloud is None: cloud = \"*\" sub = self . cloudcache / subpath clouds =[] clswitch ={} #basepath = self.cloudcache / 'base' / 'metadata.json' #metto la base se esiste #if basepath.exists(): # clouds['base']=str(basepath).replace(conf['syscache']['cloudcache'],\"resources\") on = 1 for p in self . cloudcache . glob ( '*' ): if p . is_dir () and ( p / 'metadata.json' ). exists (): relpath = str ( p / 'metadata.json' ). replace ( conf [ 'syscache' ][ 'cloudcache' ], \"resources\" ) clouds . append ({ \"name\" : p . name , \"path\" : relpath , \"switch\" : on }) on = 0 on = 1 #cerco le altre clouds for p in sub . glob ( cloud ): if p . is_dir () and ( p / 'metadata.json' ). exists (): relpath = str ( p / 'metadata.json' ). replace ( conf [ 'syscache' ][ 'cloudcache' ], \"resources\" ) clouds . append ({ \"name\" : p . name , \"path\" : relpath , \"switch\" : on }) on = 0 url = str ( self . cloudbaseurl )+ \"?clouds=\" + json . dumps ( clouds ) return url","title":"PotreeCM"},{"location":"reference/hielen3/cloudmanager/#ancestors-in-mro_1","text":"hielen3.cloudmanager.Cloudmanager abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/cloudmanager/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/cloudmanager/#geturl_1","text":"def geturl ( self , subpath , cloud = None ) View Source def geturl ( self , subpath , cloud = None ) : if cloud is None : cloud = \"*\" sub = self . cloudcache / subpath clouds = [] clswitch = {} # basepath = self . cloudcache / 'base' / 'metadata.json' # metto la base se esiste # if basepath . exists () : # clouds [ 'base' ] = str ( basepath ) . replace ( conf [ 'syscache' ][ 'cloudcache' ], \"resources\" ) on = 1 for p in self . cloudcache . glob ( '*' ) : if p . is_dir () and ( p / 'metadata.json' ) . exists () : relpath = str ( p / 'metadata.json' ) . replace ( conf [ 'syscache' ][ 'cloudcache' ], \"resources\" ) clouds . append ( { \"name\" : p . name , \"path\" : relpath , \"switch\" : on } ) on = 0 on = 1 # cerco le altre clouds for p in sub . glob ( cloud ) : if p . is_dir () and ( p / 'metadata.json' ) . exists () : relpath = str ( p / 'metadata.json' ) . replace ( conf [ 'syscache' ][ 'cloudcache' ], \"resources\" ) clouds . append ( { \"name\" : p . name , \"path\" : relpath , \"switch\" : on } ) on = 0 url = str ( self . cloudbaseurl ) + \"?clouds=\" + json . dumps ( clouds ) return url","title":"geturl"},{"location":"reference/hielen3/cloudmanager/#makepotree","text":"def makePotree ( self , lazfile , cloudname , subpath = None ) View Source def makePotree ( self , lazfile , cloudname , subpath = None ) : targhetpath = self . cloudcache / ( subpath or \"\" ) / cloudname return os . system ( f \"{conf['potreeconverter']} {lazfile} -o {targhetpath}\" )","title":"makePotree"},{"location":"reference/hielen3/datalink/","text":"Module hielen3.datalink View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 #!/usr/bin/env python # coding=utf-8 from sqlalchemy import create_engine from pandas import DataFrame , Series , read_json , NaT , read_csv , read_sql , concat from abc import ABC , abstractmethod from geojson import Point , loads from hielen3.utils import loadjsonfile , savejsonfile , newinstanceof , hashfile from filelock import Timeout , FileLock from numpy import nan from pathlib import Path from hashlib import md5 from shutil import rmtree from json import loads , dumps from numbers import Number import os import re def dbinit ( conf ): out = {} for k , w in conf [ \"db\" ] . items (): out [ k ] = newinstanceof ( w . pop ( \"klass\" ), ** w ) return out class DB ( ABC ): @abstractmethod def __init__ ( self , connection ): pass @abstractmethod def __getitem__ ( self , key ): pass @abstractmethod def __setitem__ ( self , key , value ): pass @abstractmethod def pop ( self , key ): pass class JsonDB ( DB ): def __init__ ( self , connection , schema , lock_timeout_seconds = 10 ): self . jsonfile = connection self . lock = FileLock ( f \" { connection } .lock\" , timeout = lock_timeout_seconds ) self . md5file = f \" { connection } .md5\" self . md5 = None self . schema = schema self . __chk_and_reload_jsondb ( force = True ) def __brute_load_jsondb ( self ): try : self . db = read_json ( self . jsonfile , orient = 'table' , convert_dates = False ) self . db . replace ({ nan : None , NaT : None }, inplace = True ) except Exception as e : self . db = DataFrame () if self . db . empty : self . db = DataFrame ({}, columns = self . schema [ 'columns' ]) self . db = self . db . set_index ( self . schema [ 'primary_key' ]) def __chk_and_reload_jsondb ( self , force = False ): \"\"\" Needs to check for json-database file changes in a thread safe way!! \"\"\" md5 = None error = None try : self . lock . acquire () try : if force : raise FileNotFoundError () with open ( self . md5file ) as o : md5 = o . read () if not md5 == self . md5 : self . md5 = md5 self . __brute_load_jsondb () except FileNotFoundError as e : ## refershing hash self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) self . __brute_load_jsondb () finally : self . lock . release () except Timeout : pass def save ( self ): try : self . lock . acquire () try : self . db . to_json ( self . jsonfile , orient = 'table' ) self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) finally : self . lock . release () except Timeout as e : # Just to remind Timout error here raise e def __write_jsondb ( self , key , value ): \"\"\" Needs to lock for writing json-database \"\"\" item = None error = None try : self . lock . acquire () try : self . __chk_and_reload_jsondb () if value is None : # Request to remove key, raises KeyError item = self . __getitem__ ( key ) try : self . db = self . db . drop ( key , axis = 0 ) except KeyError : raise KeyError ( f \"key { key } to remove does not exist\" ) else : # Request to insert key, raises ValueError primarykey = self . schema [ 'primary_key' ] if not isinstance ( key ,( list , set , tuple )): key = [ key ] if key . __len__ () < primarykey . __len__ (): raise ValueError ( f \"key { key !r} is not fully determinated\" ) keydict = dict ( zip ( self . schema [ 'primary_key' ], key )) value . update ( keydict ) df = DataFrame ([ value . values ()]) df . columns = value . keys () df = df . set_index ( self . schema [ 'primary_key' ]) try : self . db = self . db . append ( df , verify_integrity = True ) . sort_index () except ValueError : raise ValueError ( f \"key { key } to insert exists\" ) self . db . replace ({ nan : None , NaT : None }, inplace = True ) item = self . __brute_getitem ( key ) self . save () except Exception as e : error = e finally : self . lock . release () except Timeout as e : error = e if error is not None : raise error return item def __brute_getitem ( self , key = None ): out = None if key is None : out = self . db else : out = self . db . loc [ key ] if isinstance ( out , Series ): out = out . to_frame () . T out . index . names = self . schema [ 'primary_key' ] out = out . reset_index () . to_dict ( orient = 'records' ) if out . __len__ () == 1 : out = out [ 0 ] return out def __getitem__ ( self , key = None ): self . __chk_and_reload_jsondb () if isinstance ( key , list ): try : key = list ( filter ( None , key )) except TypeError : pass return self . __brute_getitem ( key ) def pop ( self , key ): return self . __write_jsondb ( key , None ) def __setitem__ ( self , key = None , value = None ): self . __write_jsondb ( key , value ) class seriescode (): def __init__ ( self , * args , ** kwargs ): self . h = [ * args ] self . h . extend ( list ( kwargs . values ())) self . h = '' . join ([ str ( a ) for a in self . h ]) self . h = md5 ( f ' { self . h } ' . encode () ) . hexdigest () def __repr__ ( self ): return self . h class fsHielenCache ( JsonDB ): def __init__ ( self , connection , lock_timeout_seconds = 10 ): self . cachepath = connection self . lts = lock_timeout_seconds schema = { \"columns\" :[ \"uid\" , \"info\" ], \"primary_key\" :[ \"uid\" ]} connfile = str ( Path ( connection ) / \"index.json\" ) super () . __init__ ( connfile , schema , self . lts ) def __getitem__ ( self , key ): info = super () . __getitem__ ( key ) return CsvCache ( self . cachepath , key , self . lts ) . get ( force_reload = True ) def __setitem__ ( self , key , value ): if value is not None and not isinstance ( value , Series ): raise ValueError ( \"pandas.Series required\" ) try : assert isinstance ( key , str ) assert key . __len__ () == 32 except AssertionError as e : raise ValueError ( f \"key { key } doesn't seems to match requirement format\" ) #testing existence (stops if exits) if value is not None : super () . __setitem__ ( key ,{}) item = CsvCache ( self . cachepath , key , self . lts ) os . makedirs ( item . cachepath , exist_ok = True ) item . update ( value ) #TODO MAKE STATITICS statistics = {} self . db . loc [ key ] = statistics else : super () . __setitem__ ( key , None ) try : CsvCache ( self . cachepath , key , self . lts ) . drop () except FileNotFoundError as e : pass def update ( self , key , value ): if value is not None and not isinstance ( value , Series ): #if value is not None and not isinstance(value,DataFrame): raise ValueError ( \"pandas.Series required\" ) if value is not None : info = super () . __getitem__ ( key ) item = CsvCache ( self . cachepath , key , self . lts ) item . update ( value ) #TODO MAKE STATITICS statistics = {} self . db . loc [ key ] = statistics class CsvCache (): def __init__ ( self , cachepath , item , lock_timeout_seconds = 10 ): self . cachepath = Path ( cachepath ) / item [ 0 : 8 ] / item [ 8 : 16 ] / item [ 16 : 24 ] / item [ 24 : 32 ] self . db = None self . csv = str ( self . cachepath / f \" { item } .csv\" ) self . lock = FileLock ( f \" { self . csv } .lock\" , timeout = lock_timeout_seconds ) self . md5file = f \" { self . csv } .md5\" self . md5 = None #self.__chk_and_reload_cache(force=True) def __repr__ ( self ): return self . db . __repr__ () def __brute_load_cache ( self ): try : self . db = read_csv ( self . csv , header = None , sep = \";\" , index_col = 0 , parse_dates = True )[ 1 ] except Exception as e : self . db = Series () self . db . name = \"s\" def __chk_and_reload_cache ( self , force = False ): \"\"\" Needs to check for cache file changes in a thread safe way!! \"\"\" md5 = None error = None try : self . lock . acquire () try : if force : raise FileNotFoundError () with open ( self . md5file ) as o : md5 = o . read () if not md5 == self . md5 : self . md5 = md5 self . __brute_load_cache () except FileNotFoundError as e : ## refershing hash try : self . md5 = hashfile ( self . csv ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) except FileNotFoundError as e : pass self . __brute_load_cache () finally : self . lock . release () except Timeout : pass def save ( self ): try : self . lock . acquire () try : self . db . to_csv ( self . csv , header = None , sep = \";\" ) self . md5 = hashfile ( self . csv ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) finally : self . lock . release () except Timeout as e : # Just to remind Timout error here raise e def drop ( self ): try : self . lock . acquire () try : os . unlink ( self . csv ) os . unlink ( self . md5file ) self . db = None finally : self . lock . release () except Timeout as e : # Just to remind Timout error here raise e def update ( self , value : Series ): \"\"\" Needs to lock for writing json-database \"\"\" error = None try : self . lock . acquire () try : self . __chk_and_reload_cache () self . db . drop ( value . index , errors = 'ignore' , inplace = True ) value . name = 's' self . db = self . db . append ( value ) . sort_index () self . save () except Exception as e : error = e finally : self . lock . release () except Timeout as e : error = e if error is not None : raise error def get ( self , force_reload = False ): self . __chk_and_reload_cache ( force = force_reload ) return self . db class Mariadb ( DB ): geotypes = ( 'point' , 'linestring' , 'polygon' , 'multipoint' , 'multilinestring' , 'multipolygon' , 'geometrycollection' , 'geometry' ) @property def engine ( self ): def getengine ( dialect = 'mariadb' , usr = 'editor' , pwd = 'rincostocastico' , host = '127.0.0.1' , port = 13231 , db = 'geoframe' ): connstr = ' {} :// {} : {} @ {} : {} / {} ' . format ( dialect , usr , pwd , host , port , db ) return create_engine ( connstr , echo = False ) return getengine ( ** self . conn ) def __init__ ( self , connection , table = None , askey = None ): self . conn = connection if table is not None : table = table . split ( \".\" ) self . schema = table [ 0 ] self . table = table [ 1 ] keysquery = f ''' select COLUMN_NAME from information_schema.key_column_usage where TABLE_SCHEMA = { self . schema !r} and TABLE_NAME = { self . table !r} and CONSTRAINT_NAME = 'PRIMARY' order by ORDINAL_POSITION ''' columnquery = f ''' select COLUMN_NAME, COLUMN_TYPE from information_schema.columns where TABLE_SCHEMA = { self . schema !r} and TABLE_NAME = { self . table !r} order by ORDINAL_POSITION ''' e = self . engine with e . connect () as connection : self . columnstypes = dict ( connection . execute ( columnquery ) . all ()) self . keys = [ l [ 0 ] for l in connection . execute ( keysquery ) . all () ] e . dispose () self . columns = list ( self . columnstypes . keys ()) self . selectfields = [ w in Mariadb . geotypes and f \"ifnull(st_asgeojson( { k } ),'null') as { k !r} \" or k for k , w in self . columnstypes . items () ] if askey is not None : if not isinstance ( askey ,( tuple , list )): askey = [ askey ] self . keys . extend ([ k for k in askey if k not in self . keys and k in self . columns ]) self . values = [ k for k in self . columns if k not in self . keys ] def save ( self ): pass @abstractmethod def __getitem__ ( self , key = None ): pass @abstractmethod def __setitem__ ( self , key = None , value = None ): pass @abstractmethod def pop ( self , key ): pass class MariadbQuery ( Mariadb ): def __init__ ( self , connection ): super () . __init__ ( connection ) def __getitem__ ( self , stat = None ): e = self . engine with e . begin () as connection : connection . execute ( 'start transaction' ) out = read_sql ( stat , connection , coerce_float = True , ) e . dispose () for c in out . columns : try : out [ c ] = out [ c ] . apply ( loads ) if out [ c ] . dtype == 'datetime64[ns]' : out [ c ] = out [ c ] . apply ( str ) except Exception as e : pass return out . copy () def __setitem__ ( self , key , value ): pass def pop ( self , stat ): return self . __getitem__ ( stat ) class MariadbTable ( Mariadb ): def __init__ ( self , connection , table , askey = None ): super () . __init__ ( connection , table , askey ) def query ( self , sqlcond = None ): stat = f 'SELECT { \",\" . join ( self . selectfields ) } FROM { self . table } ' if sqlcond is not None and sqlcond . __len__ () > 0 : stat = f ' { stat } WHERE { sqlcond } ' e = self . engine with e . begin () as connection : connection . execute ( 'start transaction' ) out = read_sql ( stat , connection , coerce_float = True , index_col = self . keys ) e . dispose () if out . empty : raise KeyError ( sqlcond ) try : out = out . to_frame () except Exception as e : pass for c in out . columns : try : out [ c ] = out [ c ] . apply ( loads ) if out [ c ] . dtype == 'datetime64[ns]' : out [ c ] = out [ c ] . apply ( str ) except Exception as e : pass ind = out . index . copy () out = out . reset_index () out . index = ind return out . copy () def __getitem__ ( self , key = None , delete = False ): templatecond = { w : None for w in self . keys } if key is None : key = slice ( None , None , None ) def __makekeydict__ ( k ): out = templatecond . copy () if not isinstance ( k ,( tuple , list , dict )): k = [ k ] if isinstance ( k , tuple ): k = list ( k ) if isinstance ( k , list ): keyl = min ( self . keys . __len__ (), k . __len__ ()) k = dict ( zip ( self . keys [: keyl ], k [: keyl ])) if isinstance ( k , dict ): k = { w : v for w , v in k . items () if w in self . keys } out . update ( k ) return out if not isinstance ( key ,( list , tuple , dict )): key = [( key ,)] if isinstance ( key , dict ): key = [ key ] if isinstance ( key , tuple ) and key . __len__ () == 1 : key = [( key [ 0 ], None )] if isinstance ( key , tuple ): key = [ key ] conds = [ __makekeydict__ ( k ) for k in list ( key ) ] sqlarr = [] for clausule in conds : clausulearr = [] for cond in clausule . keys (): if clausule [ cond ] is not None : if isinstance ( clausule [ cond ], slice ): key = clausule [ cond ] wstart = '' con = '' wstop = '' if key . start is not None and key . stop is not None : con = 'AND' if key . start is not None : wstart = f ' { cond } >= { key . start !r} ' if key . stop is not None : wstop = f ' { cond } <= { key . stop !r} ' if key . start is not None or key . stop is not None : sqlcond = f ' { wstart } { con } { wstop } ' clausulearr . append ( sqlcond ) elif isinstance ( clausule [ cond ],( list , tuple , set )): condarr = \",\" . join ( map ( lambda x : f ' { x !r} ' , clausule [ cond ])) clausulearr . append ( f ' { cond } in ( { condarr } )' ) else : clausulearr . append ( f ' { cond } = { clausule [ cond ] !r} ' ) if clausulearr . __len__ (): sqlarr . append ( '(' + ' AND ' . join ( clausulearr ) + ')' ) if sqlarr . __len__ (): sqlcond = ' OR ' . join ( sqlarr ) else : if delete : raise KeyError ( \"No condition provided for deletion!\" ) sqlcond = 1 e = self . engine with e . begin () as connection : stat = f 'SELECT { \",\" . join ( self . selectfields ) } FROM { self . table } WHERE { sqlcond } FOR UPDATE' connection . execute ( 'start transaction' ) out = read_sql ( stat , connection , coerce_float = True , index_col = self . keys ) if not out . empty and delete : stat = f 'DELETE FROM { self . table } WHERE { sqlcond } ' connection . execute ( stat ) e . dispose () if out . empty : raise KeyError ( sqlcond ) try : out = out . to_frame () except Exception as e : pass for c in out . columns : try : out [ c ] = out [ c ] . apply ( loads ) if out [ c ] . dtype == 'datetime64[ns]' : out [ c ] = out [ c ] . apply ( str ) except Exception as e : pass ind = out . index . copy () out = out . reset_index () out . index = ind return out . copy () def __parse_set_kw__ ( self , key = None , value = None ): if isinstance ( key , slice ): raise ValueError ( 'slice key not supported' ) if key is None : key = {} if not isinstance ( key ,( list , tuple , dict )): key = [ key ] if isinstance ( key ,( list , tuple )): keyl = min ( self . keys . __len__ (), key . __len__ ()) key = dict ( zip ( self . keys [: keyl ], key [: keyl ])) if not isinstance ( value ,( list , tuple , dict )): value = [ value ] if isinstance ( value ,( list , tuple )): valuel = min ( self . values . __len__ (), value . __len__ ()) value = dict ( zip ( self . values [: valuel ], value [: valuel ])) if isinstance ( key , dict ): v = value . copy () for k in value . keys (): if k in self . keys : key [ k ] = v . pop ( k ) value = v key = { k : f \" { w !r} \" for k , w in key . items () if k in self . keys } if key . __len__ () != self . keys . __len__ (): raise ValueError ( 'table key not full qualified' ) value = { k : w for k , w in value . items () if k in self . values } return ( key , value ) def __exec_set_kw__ ( self , key , value ): for k in value . keys (): try : if isinstance ( value [ k ],( list , dict , tuple )): value [ k ] = dumps ( value [ k ]) except Exception as e : pass # print (f\"{value[k]!r}\",value[k].__class__) ## DEBUG if self . columnstypes [ k ] in Mariadb . geotypes : value [ k ] = f \"ST_GeomFromGeoJSON( { value [ k ] !r} )\" elif value [ k ] is None : value [ k ] = \"NULL\" else : value [ k ] = f \" { value [ k ] !r} \" if value . __len__ (): columns = ',' . join ([ * self . keys , * list ( value . keys ())]) values = [ * list ( key . values ()), * list ( value . values ())] updates = \", \" . join ( map ( lambda x : f \" { x } =VALUE( { x } )\" , value . keys ())) else : columns = ',' . join ( key . keys ()) values = list ( key . values ()) updates = f \" { self . values [ 0 ] } = { self . values [ 0 ] } \" vvv = \",\" . join ( values ) # stat=f\"INSERT INTO {self.table} ({columns}) VALUES ({vvv}) ON DUPLICATE KEY UPDATE {updates}\".replace(\"None\",\"NULL\")i stat = f \"INSERT INTO { self . table } ( { columns } ) VALUES ( { vvv } ) ON DUPLICATE KEY UPDATE { updates } \" e = self . engine with e . begin () as connection : connection . execute ( stat ) e . dispose () def __setitem__ ( self , key = None , value = None ): key , value = self . __parse_set_kw__ ( key , value ) self . __exec_set_kw__ ( key , value ) def pop ( self , key ): return self . __getitem__ ( key , delete = True ) class MariadbHielenGeo ( MariadbTable ): def __init__ ( self , connection , table , geo_col = 'geometry' , elev_col = None , askey = None ): super () . __init__ ( connection , table , askey ) if not geo_col in self . columns : raise ValueError ( f \"colum { geo_col } not in table { self . table } \" ) if not self . columnstypes [ geo_col ] in Mariadb . geotypes : raise ValueError ( f \"colum { geo_col } has not geographic type\" ) if elev_col is not None and not elev_col in self . columns : raise ValueError ( f \"colum { elev_col } not in table { self . table } \" ) if elev_col is None and 'elevation' in self . columns : elev_col = 'elevation' self . geo_col = geo_col self . elev_col = elev_col def __man_na_coords__ ( xy , z ): if not isinstance ( xy ,( list , set , tuple )): xy = [ 0 , 0 ] return Point ([ isinstance ( a , Number ) and a or 0 for a in [ * xy , z ]]) def __manage_geo_col__ ( self , frame = None ): if frame is not None and self . elev_col is not None : xy = frame [ self . geo_col ] . apply ( Series , dtype = \"object\" ) #['coordinates'] \"\"\" xy=frame[self.geo_col].to_frame().apply(lambda x: x['geometry'],result_type='expand',axis=1)['coordinates'] \"\"\" xy = xy [ 'coordinates' ] managed = concat ([ xy , frame [ self . elev_col ] . replace ( nan , 0 )], axis = 1 ) frame [ self . geo_col ] = managed . apply ( lambda x : MariadbHielenGeo . __man_na_coords__ ( x [ 'coordinates' ], x [ self . elev_col ]), axis = 1 ) frame = frame . drop ( self . elev_col , axis = 1 ) return frame def query ( self , sqlcond = None ): frame = super () . query ( sqlcond ) try : frame = self . __manage_geo_col__ ( frame ) except Exception as e : pass return frame def __getitem__ ( self , key = None , delete = False ): frame = super () . __getitem__ ( key , delete ) try : frame = self . __manage_geo_col__ ( frame ) except Exception as e : pass return frame def __setitem__ ( self , key = None , value = None ): key , value = self . __parse_set_kw__ ( key , value ) try : value [ self . elev_col ] = value [ self . geo_col ][ 'coordinates' ][ 2 ] except Exception as e : pass self . __exec_set_kw__ ( key , value ) class MariadbHielenCache ( Mariadb ): def __init__ ( self , connection , table ): super () . __init__ ( connection , table ) def __parsekey__ ( key , keysnames : list ): out = { k : None for k in keysnames } if isinstance ( key , dict ): out . update ( key ) if not isinstance ( key ,( list , slice , tuple )) and key is not None : key = [ key ] if isinstance ( key ,( list , slice )): out [ \"series\" ] = key if isinstance ( key , tuple ): key = list ( key ) if not isinstance ( key [ 0 ],( list , slice )) and key [ 0 ] is not None : key [ 0 ] = [ key [ 0 ]] out [ \"series\" ] = key [ 0 ] if not isinstance ( key [ 1 ],( list , slice )) and key [ 1 ] is not None : key [ 1 ] = [ key [ 1 ]] out [ \"timestamp\" ] = key [ 1 ] return out def __setsqlcond__ ( key , column ): sqlcond = None if isinstance ( key , str ): key = [ key ] if isinstance ( key , list ): key = filter ( None , key ) sqlcond = f \" { column } in ( { ',' . join ( map ( lambda x : f ' { x !r} ' , key )) } )\" if isinstance ( key , slice ): wstart = \"\" con = \"\" wstop = \"\" if key . start is not None and key . stop is not None : con = \"AND\" if key . start is not None : wstart = f \" { column } >= { key . start !r} \" if key . stop is not None : wstop = f \" { column } <= { key . stop !r} \" if key . start is not None or key . stop is not None : sqlcond = f \" { wstart } { con } { wstop } \" return sqlcond def __getitem__ ( self , key , delete = False ): \"\"\" WARNING: In case of slice selection with a not None step parmeter the deletion process, if requested, not minds the step for row selection and all the deleted row will be returned in output. \"\"\" key = MariadbHielenCache . __parsekey__ ( key , self . keys ) sercond = MariadbHielenCache . __setsqlcond__ ( key [ \"series\" ], \"series\" ) timecond = MariadbHielenCache . __setsqlcond__ ( key [ \"timestamp\" ], \"timestamp\" ) if sercond is not None and timecond is not None : sqlcond = f \" { sercond } AND { timecond } \" if sercond is not None and timecond is None : sqlcond = f \" { sercond } \" if sercond is None and timecond is not None : sqlcond = f \" { timecond } \" if sercond is None and timecond is None : raise KeyError ( 'No condition provided' ) e = self . engine with e . begin () as connection : stat = f \"SELECT * FROM { self . table } WHERE { sqlcond } FOR UPDATE\" connection . execute ( 'start transaction' ) out = read_sql ( stat , connection , coerce_float = True , index_col = [ 'timestamp' , 'series' ] ) . unstack ( 'series' ) . droplevel ( 0 , axis = 1 ) if not out . empty and delete : stat = f 'DELETE FROM { self . table } WHERE { sqlcond } ' connection . execute ( stat ) e . dispose () return out . copy () e . dispose () try : if key [ \"series\" ] is not None and isinstance ( key [ \"series\" ], slice ): out = out . T [ key [ \"series\" ]] . T if key [ \"timestamp\" ] is not None and isinstance ( key [ \"timestamp\" ], slice ): out = out [ key [ \"timestamp\" ]] except KeyError : raise KeyError ( key ) if out . empty : raise KeyError ( key ) return out . copy () def __setitem__ ( self , key , value ): if value is not None and not isinstance ( value ,( Series , DataFrame )): raise ValueError ( \"pandas.Series or pandas.DataFrame required\" ) key = MariadbHielenCache . __parsekey__ ( key , self . keys ) try : value = value . to_frame () value . columns . name = 'series' except Exception as e : pass if key [ \"series\" ] is not None : if isinstance ( key [ \"series\" ], slice ): value = value . T [ key [ \"series\" ]] . T else : value = value [ key [ \"series\" ]] if key [ \"timestamp\" ] is not None : value = value [ key [ \"timestamp\" ]] if value is not None and not value . empty : value = value . stack () value . name = 'value' value = value . reset_index () if value . empty : return value = value [[ 'series' , 'timestamp' , 'value' ]] stat = re . sub ( \",\\($\" , \"\" , re . sub ( \"^\" , \"(\" , value . to_csv ( header = None , index = None , quoting = 1 , lineterminator = \"),(\" ))) stat = f \"INSERT INTO { self . table } (series,timestamp,value) VALUES \" + stat + \" ON DUPLICATE KEY UPDATE value = VALUES(value)\" e = self . engine with e . begin () as connection : connection . execute ( stat ) e . dispose () def pop ( self , key ): return self . __getitem__ ( key , delete = True ) Variables nan Functions dbinit def dbinit ( conf ) View Source def dbinit ( conf ) : out = {} for k , w in conf [ \"db\" ] . items () : out [ k ] = newinstanceof ( w . pop ( \"klass\" ), ** w ) return out Classes CsvCache class CsvCache ( cachepath , item , lock_timeout_seconds = 10 ) View Source class CsvCache (): def __init__ ( self , cachepath , item , lock_timeout_seconds = 10 ): self . cachepath = Path ( cachepath ) / item [ 0 : 8 ] / item [ 8 : 16 ] / item [ 16 : 24 ] / item [ 24 : 32 ] self . db = None self . csv = str ( self . cachepath / f \"{item}.csv\" ) self . lock = FileLock ( f \"{self.csv}.lock\" , timeout = lock_timeout_seconds ) self . md5file = f \"{self.csv}.md5\" self . md5 = None #self.__chk_and_reload_cache(force=True) def __repr__ ( self ): return self . db . __repr__ () def __brute_load_cache ( self ): try : self . db = read_csv ( self . csv , header = None , sep = \";\" , index_col = 0 , parse_dates = True )[ 1 ] except Exception as e : self . db = Series () self . db . name = \"s\" def __chk_and_reload_cache ( self , force = False ): \"\"\" Needs to check for cache file changes in a thread safe way!! \"\"\" md5 = None error = None try : self . lock . acquire () try : if force : raise FileNotFoundError () with open ( self . md5file ) as o : md5 = o . read () if not md5 == self . md5 : self . md5 = md5 self . __brute_load_cache () except FileNotFoundError as e : ## refershing hash try : self . md5 = hashfile ( self . csv ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) except FileNotFoundError as e : pass self . __brute_load_cache () finally : self . lock . release () except Timeout : pass def save ( self ): try : self . lock . acquire () try : self . db . to_csv ( self . csv , header = None , sep = \";\" ) self . md5 = hashfile ( self . csv ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) finally : self . lock . release () except Timeout as e : # Just to remind Timout error here raise e def drop ( self ): try : self . lock . acquire () try : os . unlink ( self . csv ) os . unlink ( self . md5file ) self . db = None finally : self . lock . release () except Timeout as e : # Just to remind Timout error here raise e def update ( self , value : Series ): \"\"\" Needs to lock for writing json-database \"\"\" error = None try : self . lock . acquire () try : self . __chk_and_reload_cache () self . db . drop ( value . index , errors = 'ignore' , inplace = True ) value . name = 's' self . db = self . db . append ( value ) . sort_index () self . save () except Exception as e : error = e finally : self . lock . release () except Timeout as e : error = e if error is not None : raise error def get ( self , force_reload = False ): self . __chk_and_reload_cache ( force = force_reload ) return self . db Methods drop def drop ( self ) View Source def drop ( self ) : try : self . lock . acquire () try : os . unlink ( self . csv ) os . unlink ( self . md5file ) self . db = None finally : self . lock . release () except Timeout as e : # Just to remind Timout error here raise e get def get ( self , force_reload = False ) View Source def get ( self , force_reload = False ): self . __chk_and_reload_cache ( force = force_reload ) return self . db save def save ( self ) View Source def save ( self ): try : self . lock . acquire () try : self . db . to_csv ( self . csv , header = None , sep = \";\" ) self . md5 = hashfile ( self . csv ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) finally : self . lock . release () except Timeout as e : # Just to remind Timout error here raise e update def update ( self , value : pandas . core . series . Series ) Needs to lock for writing json-database View Source def update ( self , value : Series ): \"\"\" Needs to lock for writing json-database \"\"\" error = None try : self . lock . acquire () try : self . __chk_and_reload_cache () self . db . drop ( value . index , errors = 'ignore' , inplace = True ) value . name = 's' self . db = self . db . append ( value ) . sort_index () self . save () except Exception as e : error = e finally : self . lock . release () except Timeout as e : error = e if error is not None : raise error DB class DB ( connection ) Helper class that provides a standard way to create an ABC using inheritance. View Source class DB ( ABC ) : @abstractmethod def __init__ ( self , connection ) : pass @abstractmethod def __getitem__ ( self , key ) : pass @abstractmethod def __setitem__ ( self , key , value ) : pass @abstractmethod def pop ( self , key ) : pass Ancestors (in MRO) abc.ABC Descendants hielen3.datalink.JsonDB hielen3.datalink.Mariadb Methods pop def pop ( self , key ) View Source @abstractmethod def pop ( self , key ) : pass JsonDB class JsonDB ( connection , schema , lock_timeout_seconds = 10 ) Helper class that provides a standard way to create an ABC using inheritance. View Source class JsonDB ( DB ) : def __init__ ( self , connection , schema , lock_timeout_seconds = 10 ) : self . jsonfile = connection self . lock = FileLock ( f \"{connection}.lock\" , timeout = lock_timeout_seconds ) self . md5file = f \"{connection}.md5\" self . md5 = None self . schema = schema self . __chk_and_reload_jsondb ( force = True ) def __brute_load_jsondb ( self ) : try : self . db = read_json ( self . jsonfile , orient = 'table' , convert_dates = False ) self . db . replace ( { nan : None , NaT : None } , inplace = True ) except Exception as e : self . db = DataFrame () if self . db . empty : self . db = DataFrame ( {} , columns = self . schema [ 'columns' ] ) self . db = self . db . set_index ( self . schema [ 'primary_key' ] ) def __chk_and_reload_jsondb ( self , force = False ) : \"\"\" Needs to check for json-database file changes in a thread safe way!! \"\"\" md5 = None error = None try : self . lock . acquire () try : if force : raise FileNotFoundError () with open ( self . md5file ) as o : md5 = o . read () if not md5 == self . md5 : self . md5 = md5 self . __brute_load_jsondb () except FileNotFoundError as e : ## refershing hash self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) self . __brute_load_jsondb () finally : self . lock . release () except Timeout : pass def save ( self ) : try : self . lock . acquire () try : self . db . to_json ( self . jsonfile , orient = 'table' ) self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) finally : self . lock . release () except Timeout as e : # Just to remind Timout error here raise e def __write_jsondb ( self , key , value ) : \"\"\" Needs to lock for writing json-database \"\"\" item = None error = None try : self . lock . acquire () try : self . __chk_and_reload_jsondb () if value is None : # Request to remove key , raises KeyError item = self . __getitem__ ( key ) try : self . db = self . db . drop ( key , axis = 0 ) except KeyError : raise KeyError ( f \"key {key} to remove does not exist\" ) else : # Request to insert key , raises ValueError primarykey = self . schema [ 'primary_key' ] if not isinstance ( key ,( list , set , tuple )) : key =[ key ] if key . __len__ () < primarykey . __len__ () : raise ValueError ( f \"key {key!r} is not fully determinated\" ) keydict = dict ( zip ( self . schema [ 'primary_key' ] , key )) value . update ( keydict ) df = DataFrame ( [ value.values() ] ) df . columns = value . keys () df = df . set_index ( self . schema [ 'primary_key' ] ) try : self . db = self . db . append ( df , verify_integrity = True ). sort_index () except ValueError : raise ValueError ( f \"key {key} to insert exists\" ) self . db . replace ( { nan : None , NaT : None } , inplace = True ) item = self . __brute_getitem ( key ) self . save () except Exception as e : error = e finally : self . lock . release () except Timeout as e : error = e if error is not None : raise error return item def __brute_getitem ( self , key = None ) : out = None if key is None : out = self . db else : out = self . db . loc [ key ] if isinstance ( out , Series ) : out = out . to_frame (). T out . index . names = self . schema [ 'primary_key' ] out = out . reset_index (). to_dict ( orient = 'records' ) if out . __len__ () == 1 : out = out [ 0 ] return out def __getitem__ ( self , key = None ) : self . __chk_and_reload_jsondb () if isinstance ( key , list ) : try : key = list ( filter ( None , key )) except TypeError : pass return self . __brute_getitem ( key ) def pop ( self , key ) : return self . __write_jsondb ( key , None ) def __setitem__ ( self , key = None , value = None ) : self . __write_jsondb ( key , value ) Ancestors (in MRO) hielen3.datalink.DB abc.ABC Descendants hielen3.datalink.fsHielenCache Methods pop def pop ( self , key ) View Source def pop ( self , key ) : return self . __write_jsondb ( key , None ) save def save ( self ) View Source def save(self): try: self.lock.acquire() try: self.db.to_json(self.jsonfile,orient='table') self.md5 = hashfile(self.jsonfile) with open(self.md5file, \"w\") as o: o.write(self.md5) finally: self.lock.release() except Timeout as e: # Just to remind Timout error here raise e Mariadb class Mariadb ( connection , table = None , askey = None ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Mariadb ( DB ) : geotypes = ( 'point' , 'linestring' , 'polygon' , 'multipoint' , 'multilinestring' , 'multipolygon' , 'geometrycollection' , 'geometry' ) @property def engine ( self ) : def getengine ( dialect = 'mariadb' , usr = 'editor' , pwd = 'rincostocastico' , host = '127.0.0.1' , port = 13231 , db = 'geoframe' ) : connstr = '{}://{}:{}@{}:{}/{}' . format ( dialect , usr , pwd , host , port , db ) return create_engine ( connstr , echo = False ) return getengine ( ** self . conn ) def __init__ ( self , connection , table = None , askey = None ) : self . conn = connection if table is not None : table = table . split ( \".\" ) self . schema = table [ 0 ] self . table = table [ 1 ] keysquery = f ''' select COLUMN_NAME from information_schema.key_column_usage where TABLE_SCHEMA = {self.schema!r} and TABLE_NAME = {self.table!r} and CONSTRAINT_NAME = ' PRIMARY ' order by ORDINAL_POSITION ''' columnquery = f ''' select COLUMN_NAME, COLUMN_TYPE from information_schema.columns where TABLE_SCHEMA = {self.schema!r} and TABLE_NAME = {self.table!r} order by ORDINAL_POSITION ''' e = self . engine with e . connect () as connection : self . columnstypes = dict ( connection . execute ( columnquery ). all ()) self . keys = [ l[0 ] for l in connection . execute ( keysquery ). all () ] e . dispose () self . columns = list ( self . columnstypes . keys ()) self . selectfields = [ w in Mariadb.geotypes and f\"ifnull(st_asgeojson({k}),'null') as {k!r}\" or k for k,w in self.columnstypes.items() ] if askey is not None : if not isinstance ( askey ,( tuple , list )) : askey =[ askey ] self . keys . extend ( [ k for k in askey if k not in self.keys and k in self.columns ] ) self . values = [ k for k in self.columns if k not in self.keys ] def save ( self ) : pass @abstractmethod def __getitem__ ( self , key = None ) : pass @abstractmethod def __setitem__ ( self , key = None , value = None ) : pass @abstractmethod def pop ( self , key ) : pass Ancestors (in MRO) hielen3.datalink.DB abc.ABC Descendants hielen3.datalink.MariadbQuery hielen3.datalink.MariadbTable hielen3.datalink.MariadbHielenCache Class variables geotypes Instance variables engine Methods pop def pop ( self , key ) View Source @abstractmethod def pop ( self , key ) : pass save def save ( self ) View Source def save(self): pass MariadbHielenCache class MariadbHielenCache ( connection , table ) Helper class that provides a standard way to create an ABC using inheritance. View Source class MariadbHielenCache ( Mariadb ) : def __init__ ( self , connection , table ) : super (). __init__ ( connection , table ) def __parsekey__ ( key , keysnames : list ) : out = { k : None for k in keysnames } if isinstance ( key , dict ) : out . update ( key ) if not isinstance ( key ,( list , slice , tuple )) and key is not None : key =[ key ] if isinstance ( key ,( list , slice )) : out [ \"series\" ]= key if isinstance ( key , tuple ) : key = list ( key ) if not isinstance ( key [ 0 ] ,( list , slice )) and key [ 0 ] is not None : key [ 0 ]=[ key[0 ] ] out [ \"series\" ]= key [ 0 ] if not isinstance ( key [ 1 ] ,( list , slice )) and key [ 1 ] is not None : key [ 1 ]=[ key[1 ] ] out [ \"timestamp\" ]= key [ 1 ] return out def __setsqlcond__ ( key , column ) : sqlcond = None if isinstance ( key , str ) : key =[ key ] if isinstance ( key , list ) : key = filter ( None , key ) sqlcond = f \"{column} in ({','.join(map(lambda x: f'{x!r}',key))})\" if isinstance ( key , slice ) : wstart = \"\" con = \"\" wstop = \"\" if key . start is not None and key . stop is not None : con = \"AND\" if key . start is not None : wstart = f \"{column} >= {key.start!r}\" if key . stop is not None : wstop = f \"{column} <= {key.stop!r}\" if key . start is not None or key . stop is not None : sqlcond = f \"{wstart} {con} {wstop}\" return sqlcond def __getitem__ ( self , key , delete = False ) : \"\"\" WARNING: In case of slice selection with a not None step parmeter the deletion process, if requested, not minds the step for row selection and all the deleted row will be returned in output. \"\"\" key = MariadbHielenCache . __parsekey__ ( key , self . keys ) sercond = MariadbHielenCache . __setsqlcond__ ( key [ \"series\" ] , \"series\" ) timecond = MariadbHielenCache . __setsqlcond__ ( key [ \"timestamp\" ] , \"timestamp\" ) if sercond is not None and timecond is not None : sqlcond = f \"{sercond} AND {timecond}\" if sercond is not None and timecond is None : sqlcond = f \"{sercond}\" if sercond is None and timecond is not None : sqlcond = f \"{timecond}\" if sercond is None and timecond is None : raise KeyError ( 'No condition provided' ) e = self . engine with e . begin () as connection : stat = f \"SELECT * FROM {self.table} WHERE {sqlcond} FOR UPDATE\" connection . execute ( 'start transaction' ) out = read_sql ( stat , connection , coerce_float = True , index_col =[ 'timestamp','series' ] ). unstack ( 'series' ). droplevel ( 0 , axis = 1 ) if not out . empty and delete : stat = f 'DELETE FROM {self.table} WHERE {sqlcond}' connection . execute ( stat ) e . dispose () return out . copy () e . dispose () try : if key [ \"series\" ] is not None and isinstance ( key [ \"series\" ] , slice ) : out = out . T [ key[\"series\" ] ] . T if key [ \"timestamp\" ] is not None and isinstance ( key [ \"timestamp\" ] , slice ) : out = out [ key[\"timestamp\" ] ] except KeyError : raise KeyError ( key ) if out . empty : raise KeyError ( key ) return out . copy () def __setitem__ ( self , key , value ) : if value is not None and not isinstance ( value ,( Series , DataFrame )) : raise ValueError ( \"pandas.Series or pandas.DataFrame required\" ) key = MariadbHielenCache . __parsekey__ ( key , self . keys ) try : value = value . to_frame () value . columns . name = 'series' except Exception as e : pass if key [ \"series\" ] is not None : if isinstance ( key [ \"series\" ] , slice ) : value = value . T [ key[\"series\" ] ] . T else : value = value [ key[\"series\" ] ] if key [ \"timestamp\" ] is not None : value = value [ key[\"timestamp\" ] ] if value is not None and not value . empty : value = value . stack () value . name = 'value' value = value . reset_index () if value . empty : return value = value [ ['series','timestamp','value' ] ] stat = re . sub ( \",\\($\" , \"\" , re . sub ( \"^\" , \"(\" , value . to_csv ( header = None , index = None , quoting = 1 , lineterminator = \"),(\" ))) stat = f \"INSERT INTO {self.table} (series,timestamp,value) VALUES \" + stat + \" ON DUPLICATE KEY UPDATE value = VALUES(value)\" e = self . engine with e . begin () as connection : connection . execute ( stat ) e . dispose () def pop ( self , key ) : return self . __getitem__ ( key , delete = True ) Ancestors (in MRO) hielen3.datalink.Mariadb hielen3.datalink.DB abc.ABC Class variables geotypes Instance variables engine Methods pop def pop ( self , key ) View Source def pop ( self , key ) : return self . __getitem__ ( key , delete = True ) save def save ( self ) View Source def save(self): pass MariadbHielenGeo class MariadbHielenGeo ( connection , table , geo_col = 'geometry' , elev_col = None , askey = None ) Helper class that provides a standard way to create an ABC using inheritance. View Source class MariadbHielenGeo ( MariadbTable ) : def __init__ ( self , connection , table , geo_col = 'geometry' , elev_col = None , askey = None ) : super (). __init__ ( connection , table , askey ) if not geo_col in self . columns : raise ValueError ( f \"colum {geo_col} not in table {self.table}\" ) if not self . columnstypes [ geo_col ] in Mariadb . geotypes : raise ValueError ( f \"colum {geo_col} has not geographic type\" ) if elev_col is not None and not elev_col in self . columns : raise ValueError ( f \"colum {elev_col} not in table {self.table}\" ) if elev_col is None and 'elevation' in self . columns : elev_col = 'elevation' self . geo_col = geo_col self . elev_col = elev_col def __man_na_coords__ ( xy , z ) : if not isinstance ( xy ,( list , set , tuple )) : xy =[ 0,0 ] return Point ( [ isinstance(a,Number) and a or 0 for a in [*xy,z ] ] ) def __manage_geo_col__ ( self , frame = None ) : if frame is not None and self . elev_col is not None : xy = frame [ self.geo_col ] . apply ( Series , dtype = \"object\" ) # [ 'coordinates' ] \"\"\" xy=frame[self.geo_col].to_frame().apply(lambda x: x['geometry'],result_type='expand',axis=1)['coordinates'] \"\"\" xy = xy [ 'coordinates' ] managed = concat ( [ xy,frame[self.elev_col ] . replace ( nan , 0 ) ] , axis = 1 ) frame [ self.geo_col ]= managed . apply ( lambda x : MariadbHielenGeo . __man_na_coords__ ( x [ 'coordinates' ] , x [ self.elev_col ] ), axis = 1 ) frame = frame . drop ( self . elev_col , axis = 1 ) return frame def query ( self , sqlcond = None ) : frame = super (). query ( sqlcond ) try : frame = self . __manage_geo_col__ ( frame ) except Exception as e : pass return frame def __getitem__ ( self , key = None , delete = False ) : frame = super (). __getitem__ ( key , delete ) try : frame = self . __manage_geo_col__ ( frame ) except Exception as e : pass return frame def __setitem__ ( self , key = None , value = None ) : key , value = self . __parse_set_kw__ ( key , value ) try : value [ self.elev_col ]= value [ self.geo_col ][ 'coordinates' ][ 2 ] except Exception as e : pass self . __exec_set_kw__ ( key , value ) Ancestors (in MRO) hielen3.datalink.MariadbTable hielen3.datalink.Mariadb hielen3.datalink.DB abc.ABC Class variables geotypes Instance variables engine Methods pop def pop ( self , key ) View Source def pop ( self , key ) : return self . __getitem__ ( key , delete = True ) query def query ( self , sqlcond = None ) View Source def query ( self , sqlcond = None ) : frame = super () . query ( sqlcond ) try : frame = self . __manage_geo_col__ ( frame ) except Exception as e : pass return frame save def save ( self ) View Source def save(self): pass MariadbQuery class MariadbQuery ( connection ) Helper class that provides a standard way to create an ABC using inheritance. View Source class MariadbQuery ( Mariadb ) : def __init__ ( self , connection ) : super (). __init__ ( connection ) def __getitem__ ( self , stat = None ) : e = self . engine with e . begin () as connection : connection . execute ( 'start transaction' ) out = read_sql ( stat , connection , coerce_float = True , ) e . dispose () for c in out . columns : try : out [ c ] = out [ c ] . apply ( loads ) if out [ c ] . dtype == 'datetime64[ns]' : out [ c ]= out [ c ] . apply ( str ) except Exception as e : pass return out . copy () def __setitem__ ( self , key , value ) : pass def pop ( self , stat ) : return self . __getitem__ ( stat ) Ancestors (in MRO) hielen3.datalink.Mariadb hielen3.datalink.DB abc.ABC Class variables geotypes Instance variables engine Methods pop def pop ( self , stat ) View Source def pop ( self , stat ) : return self . __getitem__ ( stat ) save def save ( self ) View Source def save(self): pass MariadbTable class MariadbTable ( connection , table , askey = None ) Helper class that provides a standard way to create an ABC using inheritance. View Source class MariadbTable ( Mariadb ) : def __init__ ( self , connection , table , askey = None ) : super (). __init__ ( connection , table , askey ) def query ( self , sqlcond = None ) : stat = f 'SELECT {\",\".join(self.selectfields)} FROM {self.table}' if sqlcond is not None and sqlcond . __len__ () > 0 : stat = f '{stat} WHERE {sqlcond}' e = self . engine with e . begin () as connection : connection . execute ( 'start transaction' ) out = read_sql ( stat , connection , coerce_float = True , index_col = self . keys ) e . dispose () if out . empty : raise KeyError ( sqlcond ) try : out = out . to_frame () except Exception as e : pass for c in out . columns : try : out [ c ] = out [ c ] . apply ( loads ) if out [ c ] . dtype == 'datetime64[ns]' : out [ c ]= out [ c ] . apply ( str ) except Exception as e : pass ind = out . index . copy () out = out . reset_index () out . index = ind return out . copy () def __getitem__ ( self , key = None , delete = False ) : templatecond = { w : None for w in self . keys } if key is None : key = slice ( None , None , None ) def __makekeydict__ ( k ) : out = templatecond . copy () if not isinstance ( k ,( tuple , list , dict )) : k =[ k ] if isinstance ( k , tuple ) : k = list ( k ) if isinstance ( k , list ) : keyl = min ( self . keys . __len__ (), k . __len__ ()) k = dict ( zip ( self . keys [ :keyl ] , k [ :keyl ] )) if isinstance ( k , dict ) : k = { w : v for w , v in k . items () if w in self . keys } out . update ( k ) return out if not isinstance ( key ,( list , tuple , dict )) : key =[ (key,) ] if isinstance ( key , dict ) : key =[ key ] if isinstance ( key , tuple ) and key . __len__ () == 1 : key =[ (key[0 ] , None ) ] if isinstance ( key , tuple ) : key =[ key ] conds =[ __makekeydict__(k) for k in list(key) ] sqlarr = [] for clausule in conds : clausulearr = [] for cond in clausule . keys () : if clausule [ cond ] is not None : if isinstance ( clausule [ cond ] , slice ) : key = clausule [ cond ] wstart = '' con = '' wstop = '' if key . start is not None and key . stop is not None : con = 'AND' if key . start is not None : wstart = f '{cond} >= {key.start!r}' if key . stop is not None : wstop = f '{cond} <= {key.stop!r}' if key . start is not None or key . stop is not None : sqlcond = f '{wstart} {con} {wstop}' clausulearr . append ( sqlcond ) elif isinstance ( clausule [ cond ] ,( list , tuple , set )) : condarr = \",\" . join ( map ( lambda x : f '{x!r}' , clausule [ cond ] )) clausulearr . append ( f '{cond} in ({condarr})' ) else : clausulearr . append ( f '{cond}={clausule[cond]!r}' ) if clausulearr . __len__ () : sqlarr . append ( '(' + ' AND ' . join ( clausulearr ) + ')' ) if sqlarr . __len__ () : sqlcond = ' OR ' . join ( sqlarr ) else : if delete : raise KeyError ( \"No condition provided for deletion!\" ) sqlcond = 1 e = self . engine with e . begin () as connection : stat = f 'SELECT {\",\".join(self.selectfields)} FROM {self.table} WHERE {sqlcond} FOR UPDATE' connection . execute ( 'start transaction' ) out = read_sql ( stat , connection , coerce_float = True , index_col = self . keys ) if not out . empty and delete : stat = f 'DELETE FROM {self.table} WHERE {sqlcond}' connection . execute ( stat ) e . dispose () if out . empty : raise KeyError ( sqlcond ) try : out = out . to_frame () except Exception as e : pass for c in out . columns : try : out [ c ] = out [ c ] . apply ( loads ) if out [ c ] . dtype == 'datetime64[ns]' : out [ c ]= out [ c ] . apply ( str ) except Exception as e : pass ind = out . index . copy () out = out . reset_index () out . index = ind return out . copy () def __parse_set_kw__ ( self , key = None , value = None ) : if isinstance ( key , slice ) : raise ValueError ( 'slice key not supported' ) if key is None : key = {} if not isinstance ( key ,( list , tuple , dict )) : key =[ key ] if isinstance ( key ,( list , tuple )) : keyl = min ( self . keys . __len__ (), key . __len__ ()) key = dict ( zip ( self . keys [ :keyl ] , key [ :keyl ] )) if not isinstance ( value ,( list , tuple , dict )) : value =[ value ] if isinstance ( value ,( list , tuple )) : valuel = min ( self . values . __len__ (), value . __len__ ()) value = dict ( zip ( self . values [ :valuel ] , value [ :valuel ] )) if isinstance ( key , dict ) : v = value . copy () for k in value . keys () : if k in self . keys : key [ k ]= v . pop ( k ) value = v key = { k : f \"{w!r}\" for k , w in key . items () if k in self . keys } if key . __len__ () != self . keys . __len__ () : raise ValueError ( 'table key not full qualified' ) value = { k : w for k , w in value . items () if k in self . values } return ( key , value ) def __exec_set_kw__ ( self , key , value ) : for k in value . keys () : try : if isinstance ( value [ k ] ,( list , dict , tuple )) : value [ k ]= dumps ( value [ k ] ) except Exception as e : pass # print ( f \"{value[k]!r}\" , value [ k ] . __class__ ) ## DEBUG if self . columnstypes [ k ] in Mariadb . geotypes : value [ k ]= f \"ST_GeomFromGeoJSON({value[k]!r})\" elif value [ k ] is None : value [ k ] = \"NULL\" else : value [ k ]= f \"{value[k]!r}\" if value . __len__ () : columns = ',' . join ( [ *self.keys,*list(value.keys()) ] ) values =[ *list(key.values()),*list(value.values()) ] updates = \", \" . join ( map ( lambda x : f \"{x}=VALUE({x})\" , value . keys ())) else : columns = ',' . join ( key . keys ()) values = list ( key . values ()) updates = f \"{self.values[0]}={self.values[0]}\" vvv = \",\" . join ( values ) # stat = f \"INSERT INTO {self.table} ({columns}) VALUES ({vvv}) ON DUPLICATE KEY UPDATE {updates}\" . replace ( \"None\" , \"NULL\" ) i stat = f \"INSERT INTO {self.table} ({columns}) VALUES ({vvv}) ON DUPLICATE KEY UPDATE {updates}\" e = self . engine with e . begin () as connection : connection . execute ( stat ) e . dispose () def __setitem__ ( self , key = None , value = None ) : key , value = self . __parse_set_kw__ ( key , value ) self . __exec_set_kw__ ( key , value ) def pop ( self , key ) : return self . __getitem__ ( key , delete = True ) Ancestors (in MRO) hielen3.datalink.Mariadb hielen3.datalink.DB abc.ABC Descendants hielen3.datalink.MariadbHielenGeo Class variables geotypes Instance variables engine Methods pop def pop ( self , key ) View Source def pop ( self , key ) : return self . __getitem__ ( key , delete = True ) query def query ( self , sqlcond = None ) View Source def query ( self , sqlcond = None ) : stat = f 'SELECT {\",\".join(self.selectfields)} FROM {self.table}' if sqlcond is not None and sqlcond . __len__ () > 0 : stat = f '{stat} WHERE {sqlcond}' e = self . engine with e . begin () as connection : connection . execute ( 'start transaction' ) out = read_sql ( stat , connection , coerce_float = True , index_col = self . keys ) e . dispose () if out . empty : raise KeyError ( sqlcond ) try : out = out . to_frame () except Exception as e : pass for c in out . columns : try : out [ c ] = out [ c ] . apply ( loads ) if out [ c ] . dtype == 'datetime64[ns]' : out [ c ]= out [ c ] . apply ( str ) except Exception as e : pass ind = out . index . copy () out = out . reset_index () out . index = ind return out . copy () save def save ( self ) View Source def save(self): pass fsHielenCache class fsHielenCache ( connection , lock_timeout_seconds = 10 ) Helper class that provides a standard way to create an ABC using inheritance. View Source class fsHielenCache ( JsonDB ) : def __init__ ( self , connection , lock_timeout_seconds = 10 ) : self . cachepath = connection self . lts = lock_timeout_seconds schema = { \"columns\" : [ \"uid\",\"info\" ] , \"primary_key\" : [ \"uid\" ] } connfile = str ( Path ( connection ) / \"index.json\" ) super (). __init__ ( connfile , schema , self . lts ) def __getitem__ ( self , key ) : info = super (). __getitem__ ( key ) return CsvCache ( self . cachepath , key , self . lts ). get ( force_reload = True ) def __setitem__ ( self , key , value ) : if value is not None and not isinstance ( value , Series ) : raise ValueError ( \"pandas.Series required\" ) try : assert isinstance ( key , str ) assert key . __len__ () == 32 except AssertionError as e : raise ValueError ( f \"key {key} doesn't seems to match requirement format\" ) #testing existence ( stops if exits ) if value is not None : super (). __setitem__ ( key , {} ) item = CsvCache ( self . cachepath , key , self . lts ) os . makedirs ( item . cachepath , exist_ok = True ) item . update ( value ) #TODO MAKE STATITICS statistics = {} self . db . loc [ key ]= statistics else : super (). __setitem__ ( key , None ) try : CsvCache ( self . cachepath , key , self . lts ). drop () except FileNotFoundError as e : pass def update ( self , key , value ) : if value is not None and not isinstance ( value , Series ) : #if value is not None and not isinstance ( value , DataFrame ) : raise ValueError ( \"pandas.Series required\" ) if value is not None : info = super (). __getitem__ ( key ) item = CsvCache ( self . cachepath , key , self . lts ) item . update ( value ) #TODO MAKE STATITICS statistics = {} self . db . loc [ key ]= statistics Ancestors (in MRO) hielen3.datalink.JsonDB hielen3.datalink.DB abc.ABC Methods pop def pop ( self , key ) View Source def pop ( self , key ) : return self . __write_jsondb ( key , None ) save def save ( self ) View Source def save(self): try: self.lock.acquire() try: self.db.to_json(self.jsonfile,orient='table') self.md5 = hashfile(self.jsonfile) with open(self.md5file, \"w\") as o: o.write(self.md5) finally: self.lock.release() except Timeout as e: # Just to remind Timout error here raise e update def update ( self , key , value ) View Source def update ( self , key , value ) : if value is not None and not isinstance ( value , Series ) : #if value is not None and not isinstance ( value , DataFrame ) : raise ValueError ( \"pandas.Series required\" ) if value is not None : info = super (). __getitem__ ( key ) item = CsvCache ( self . cachepath , key , self . lts ) item . update ( value ) #TODO MAKE STATITICS statistics = {} self . db . loc [ key ]= statistics seriescode class seriescode ( * args , ** kwargs ) View Source class seriescode (): def __init__ ( self ,* args ,** kwargs ): self . h =[ * args ] self . h . extend ( list ( kwargs . values ())) self . h = '' . join ([ str ( a ) for a in self . h ]) self . h = md5 ( f' { self . h }'. encode () ). hexdigest () def __repr__ ( self ): return self . h","title":"Datalink"},{"location":"reference/hielen3/datalink/#module-hielen3datalink","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 #!/usr/bin/env python # coding=utf-8 from sqlalchemy import create_engine from pandas import DataFrame , Series , read_json , NaT , read_csv , read_sql , concat from abc import ABC , abstractmethod from geojson import Point , loads from hielen3.utils import loadjsonfile , savejsonfile , newinstanceof , hashfile from filelock import Timeout , FileLock from numpy import nan from pathlib import Path from hashlib import md5 from shutil import rmtree from json import loads , dumps from numbers import Number import os import re def dbinit ( conf ): out = {} for k , w in conf [ \"db\" ] . items (): out [ k ] = newinstanceof ( w . pop ( \"klass\" ), ** w ) return out class DB ( ABC ): @abstractmethod def __init__ ( self , connection ): pass @abstractmethod def __getitem__ ( self , key ): pass @abstractmethod def __setitem__ ( self , key , value ): pass @abstractmethod def pop ( self , key ): pass class JsonDB ( DB ): def __init__ ( self , connection , schema , lock_timeout_seconds = 10 ): self . jsonfile = connection self . lock = FileLock ( f \" { connection } .lock\" , timeout = lock_timeout_seconds ) self . md5file = f \" { connection } .md5\" self . md5 = None self . schema = schema self . __chk_and_reload_jsondb ( force = True ) def __brute_load_jsondb ( self ): try : self . db = read_json ( self . jsonfile , orient = 'table' , convert_dates = False ) self . db . replace ({ nan : None , NaT : None }, inplace = True ) except Exception as e : self . db = DataFrame () if self . db . empty : self . db = DataFrame ({}, columns = self . schema [ 'columns' ]) self . db = self . db . set_index ( self . schema [ 'primary_key' ]) def __chk_and_reload_jsondb ( self , force = False ): \"\"\" Needs to check for json-database file changes in a thread safe way!! \"\"\" md5 = None error = None try : self . lock . acquire () try : if force : raise FileNotFoundError () with open ( self . md5file ) as o : md5 = o . read () if not md5 == self . md5 : self . md5 = md5 self . __brute_load_jsondb () except FileNotFoundError as e : ## refershing hash self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) self . __brute_load_jsondb () finally : self . lock . release () except Timeout : pass def save ( self ): try : self . lock . acquire () try : self . db . to_json ( self . jsonfile , orient = 'table' ) self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) finally : self . lock . release () except Timeout as e : # Just to remind Timout error here raise e def __write_jsondb ( self , key , value ): \"\"\" Needs to lock for writing json-database \"\"\" item = None error = None try : self . lock . acquire () try : self . __chk_and_reload_jsondb () if value is None : # Request to remove key, raises KeyError item = self . __getitem__ ( key ) try : self . db = self . db . drop ( key , axis = 0 ) except KeyError : raise KeyError ( f \"key { key } to remove does not exist\" ) else : # Request to insert key, raises ValueError primarykey = self . schema [ 'primary_key' ] if not isinstance ( key ,( list , set , tuple )): key = [ key ] if key . __len__ () < primarykey . __len__ (): raise ValueError ( f \"key { key !r} is not fully determinated\" ) keydict = dict ( zip ( self . schema [ 'primary_key' ], key )) value . update ( keydict ) df = DataFrame ([ value . values ()]) df . columns = value . keys () df = df . set_index ( self . schema [ 'primary_key' ]) try : self . db = self . db . append ( df , verify_integrity = True ) . sort_index () except ValueError : raise ValueError ( f \"key { key } to insert exists\" ) self . db . replace ({ nan : None , NaT : None }, inplace = True ) item = self . __brute_getitem ( key ) self . save () except Exception as e : error = e finally : self . lock . release () except Timeout as e : error = e if error is not None : raise error return item def __brute_getitem ( self , key = None ): out = None if key is None : out = self . db else : out = self . db . loc [ key ] if isinstance ( out , Series ): out = out . to_frame () . T out . index . names = self . schema [ 'primary_key' ] out = out . reset_index () . to_dict ( orient = 'records' ) if out . __len__ () == 1 : out = out [ 0 ] return out def __getitem__ ( self , key = None ): self . __chk_and_reload_jsondb () if isinstance ( key , list ): try : key = list ( filter ( None , key )) except TypeError : pass return self . __brute_getitem ( key ) def pop ( self , key ): return self . __write_jsondb ( key , None ) def __setitem__ ( self , key = None , value = None ): self . __write_jsondb ( key , value ) class seriescode (): def __init__ ( self , * args , ** kwargs ): self . h = [ * args ] self . h . extend ( list ( kwargs . values ())) self . h = '' . join ([ str ( a ) for a in self . h ]) self . h = md5 ( f ' { self . h } ' . encode () ) . hexdigest () def __repr__ ( self ): return self . h class fsHielenCache ( JsonDB ): def __init__ ( self , connection , lock_timeout_seconds = 10 ): self . cachepath = connection self . lts = lock_timeout_seconds schema = { \"columns\" :[ \"uid\" , \"info\" ], \"primary_key\" :[ \"uid\" ]} connfile = str ( Path ( connection ) / \"index.json\" ) super () . __init__ ( connfile , schema , self . lts ) def __getitem__ ( self , key ): info = super () . __getitem__ ( key ) return CsvCache ( self . cachepath , key , self . lts ) . get ( force_reload = True ) def __setitem__ ( self , key , value ): if value is not None and not isinstance ( value , Series ): raise ValueError ( \"pandas.Series required\" ) try : assert isinstance ( key , str ) assert key . __len__ () == 32 except AssertionError as e : raise ValueError ( f \"key { key } doesn't seems to match requirement format\" ) #testing existence (stops if exits) if value is not None : super () . __setitem__ ( key ,{}) item = CsvCache ( self . cachepath , key , self . lts ) os . makedirs ( item . cachepath , exist_ok = True ) item . update ( value ) #TODO MAKE STATITICS statistics = {} self . db . loc [ key ] = statistics else : super () . __setitem__ ( key , None ) try : CsvCache ( self . cachepath , key , self . lts ) . drop () except FileNotFoundError as e : pass def update ( self , key , value ): if value is not None and not isinstance ( value , Series ): #if value is not None and not isinstance(value,DataFrame): raise ValueError ( \"pandas.Series required\" ) if value is not None : info = super () . __getitem__ ( key ) item = CsvCache ( self . cachepath , key , self . lts ) item . update ( value ) #TODO MAKE STATITICS statistics = {} self . db . loc [ key ] = statistics class CsvCache (): def __init__ ( self , cachepath , item , lock_timeout_seconds = 10 ): self . cachepath = Path ( cachepath ) / item [ 0 : 8 ] / item [ 8 : 16 ] / item [ 16 : 24 ] / item [ 24 : 32 ] self . db = None self . csv = str ( self . cachepath / f \" { item } .csv\" ) self . lock = FileLock ( f \" { self . csv } .lock\" , timeout = lock_timeout_seconds ) self . md5file = f \" { self . csv } .md5\" self . md5 = None #self.__chk_and_reload_cache(force=True) def __repr__ ( self ): return self . db . __repr__ () def __brute_load_cache ( self ): try : self . db = read_csv ( self . csv , header = None , sep = \";\" , index_col = 0 , parse_dates = True )[ 1 ] except Exception as e : self . db = Series () self . db . name = \"s\" def __chk_and_reload_cache ( self , force = False ): \"\"\" Needs to check for cache file changes in a thread safe way!! \"\"\" md5 = None error = None try : self . lock . acquire () try : if force : raise FileNotFoundError () with open ( self . md5file ) as o : md5 = o . read () if not md5 == self . md5 : self . md5 = md5 self . __brute_load_cache () except FileNotFoundError as e : ## refershing hash try : self . md5 = hashfile ( self . csv ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) except FileNotFoundError as e : pass self . __brute_load_cache () finally : self . lock . release () except Timeout : pass def save ( self ): try : self . lock . acquire () try : self . db . to_csv ( self . csv , header = None , sep = \";\" ) self . md5 = hashfile ( self . csv ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) finally : self . lock . release () except Timeout as e : # Just to remind Timout error here raise e def drop ( self ): try : self . lock . acquire () try : os . unlink ( self . csv ) os . unlink ( self . md5file ) self . db = None finally : self . lock . release () except Timeout as e : # Just to remind Timout error here raise e def update ( self , value : Series ): \"\"\" Needs to lock for writing json-database \"\"\" error = None try : self . lock . acquire () try : self . __chk_and_reload_cache () self . db . drop ( value . index , errors = 'ignore' , inplace = True ) value . name = 's' self . db = self . db . append ( value ) . sort_index () self . save () except Exception as e : error = e finally : self . lock . release () except Timeout as e : error = e if error is not None : raise error def get ( self , force_reload = False ): self . __chk_and_reload_cache ( force = force_reload ) return self . db class Mariadb ( DB ): geotypes = ( 'point' , 'linestring' , 'polygon' , 'multipoint' , 'multilinestring' , 'multipolygon' , 'geometrycollection' , 'geometry' ) @property def engine ( self ): def getengine ( dialect = 'mariadb' , usr = 'editor' , pwd = 'rincostocastico' , host = '127.0.0.1' , port = 13231 , db = 'geoframe' ): connstr = ' {} :// {} : {} @ {} : {} / {} ' . format ( dialect , usr , pwd , host , port , db ) return create_engine ( connstr , echo = False ) return getengine ( ** self . conn ) def __init__ ( self , connection , table = None , askey = None ): self . conn = connection if table is not None : table = table . split ( \".\" ) self . schema = table [ 0 ] self . table = table [ 1 ] keysquery = f ''' select COLUMN_NAME from information_schema.key_column_usage where TABLE_SCHEMA = { self . schema !r} and TABLE_NAME = { self . table !r} and CONSTRAINT_NAME = 'PRIMARY' order by ORDINAL_POSITION ''' columnquery = f ''' select COLUMN_NAME, COLUMN_TYPE from information_schema.columns where TABLE_SCHEMA = { self . schema !r} and TABLE_NAME = { self . table !r} order by ORDINAL_POSITION ''' e = self . engine with e . connect () as connection : self . columnstypes = dict ( connection . execute ( columnquery ) . all ()) self . keys = [ l [ 0 ] for l in connection . execute ( keysquery ) . all () ] e . dispose () self . columns = list ( self . columnstypes . keys ()) self . selectfields = [ w in Mariadb . geotypes and f \"ifnull(st_asgeojson( { k } ),'null') as { k !r} \" or k for k , w in self . columnstypes . items () ] if askey is not None : if not isinstance ( askey ,( tuple , list )): askey = [ askey ] self . keys . extend ([ k for k in askey if k not in self . keys and k in self . columns ]) self . values = [ k for k in self . columns if k not in self . keys ] def save ( self ): pass @abstractmethod def __getitem__ ( self , key = None ): pass @abstractmethod def __setitem__ ( self , key = None , value = None ): pass @abstractmethod def pop ( self , key ): pass class MariadbQuery ( Mariadb ): def __init__ ( self , connection ): super () . __init__ ( connection ) def __getitem__ ( self , stat = None ): e = self . engine with e . begin () as connection : connection . execute ( 'start transaction' ) out = read_sql ( stat , connection , coerce_float = True , ) e . dispose () for c in out . columns : try : out [ c ] = out [ c ] . apply ( loads ) if out [ c ] . dtype == 'datetime64[ns]' : out [ c ] = out [ c ] . apply ( str ) except Exception as e : pass return out . copy () def __setitem__ ( self , key , value ): pass def pop ( self , stat ): return self . __getitem__ ( stat ) class MariadbTable ( Mariadb ): def __init__ ( self , connection , table , askey = None ): super () . __init__ ( connection , table , askey ) def query ( self , sqlcond = None ): stat = f 'SELECT { \",\" . join ( self . selectfields ) } FROM { self . table } ' if sqlcond is not None and sqlcond . __len__ () > 0 : stat = f ' { stat } WHERE { sqlcond } ' e = self . engine with e . begin () as connection : connection . execute ( 'start transaction' ) out = read_sql ( stat , connection , coerce_float = True , index_col = self . keys ) e . dispose () if out . empty : raise KeyError ( sqlcond ) try : out = out . to_frame () except Exception as e : pass for c in out . columns : try : out [ c ] = out [ c ] . apply ( loads ) if out [ c ] . dtype == 'datetime64[ns]' : out [ c ] = out [ c ] . apply ( str ) except Exception as e : pass ind = out . index . copy () out = out . reset_index () out . index = ind return out . copy () def __getitem__ ( self , key = None , delete = False ): templatecond = { w : None for w in self . keys } if key is None : key = slice ( None , None , None ) def __makekeydict__ ( k ): out = templatecond . copy () if not isinstance ( k ,( tuple , list , dict )): k = [ k ] if isinstance ( k , tuple ): k = list ( k ) if isinstance ( k , list ): keyl = min ( self . keys . __len__ (), k . __len__ ()) k = dict ( zip ( self . keys [: keyl ], k [: keyl ])) if isinstance ( k , dict ): k = { w : v for w , v in k . items () if w in self . keys } out . update ( k ) return out if not isinstance ( key ,( list , tuple , dict )): key = [( key ,)] if isinstance ( key , dict ): key = [ key ] if isinstance ( key , tuple ) and key . __len__ () == 1 : key = [( key [ 0 ], None )] if isinstance ( key , tuple ): key = [ key ] conds = [ __makekeydict__ ( k ) for k in list ( key ) ] sqlarr = [] for clausule in conds : clausulearr = [] for cond in clausule . keys (): if clausule [ cond ] is not None : if isinstance ( clausule [ cond ], slice ): key = clausule [ cond ] wstart = '' con = '' wstop = '' if key . start is not None and key . stop is not None : con = 'AND' if key . start is not None : wstart = f ' { cond } >= { key . start !r} ' if key . stop is not None : wstop = f ' { cond } <= { key . stop !r} ' if key . start is not None or key . stop is not None : sqlcond = f ' { wstart } { con } { wstop } ' clausulearr . append ( sqlcond ) elif isinstance ( clausule [ cond ],( list , tuple , set )): condarr = \",\" . join ( map ( lambda x : f ' { x !r} ' , clausule [ cond ])) clausulearr . append ( f ' { cond } in ( { condarr } )' ) else : clausulearr . append ( f ' { cond } = { clausule [ cond ] !r} ' ) if clausulearr . __len__ (): sqlarr . append ( '(' + ' AND ' . join ( clausulearr ) + ')' ) if sqlarr . __len__ (): sqlcond = ' OR ' . join ( sqlarr ) else : if delete : raise KeyError ( \"No condition provided for deletion!\" ) sqlcond = 1 e = self . engine with e . begin () as connection : stat = f 'SELECT { \",\" . join ( self . selectfields ) } FROM { self . table } WHERE { sqlcond } FOR UPDATE' connection . execute ( 'start transaction' ) out = read_sql ( stat , connection , coerce_float = True , index_col = self . keys ) if not out . empty and delete : stat = f 'DELETE FROM { self . table } WHERE { sqlcond } ' connection . execute ( stat ) e . dispose () if out . empty : raise KeyError ( sqlcond ) try : out = out . to_frame () except Exception as e : pass for c in out . columns : try : out [ c ] = out [ c ] . apply ( loads ) if out [ c ] . dtype == 'datetime64[ns]' : out [ c ] = out [ c ] . apply ( str ) except Exception as e : pass ind = out . index . copy () out = out . reset_index () out . index = ind return out . copy () def __parse_set_kw__ ( self , key = None , value = None ): if isinstance ( key , slice ): raise ValueError ( 'slice key not supported' ) if key is None : key = {} if not isinstance ( key ,( list , tuple , dict )): key = [ key ] if isinstance ( key ,( list , tuple )): keyl = min ( self . keys . __len__ (), key . __len__ ()) key = dict ( zip ( self . keys [: keyl ], key [: keyl ])) if not isinstance ( value ,( list , tuple , dict )): value = [ value ] if isinstance ( value ,( list , tuple )): valuel = min ( self . values . __len__ (), value . __len__ ()) value = dict ( zip ( self . values [: valuel ], value [: valuel ])) if isinstance ( key , dict ): v = value . copy () for k in value . keys (): if k in self . keys : key [ k ] = v . pop ( k ) value = v key = { k : f \" { w !r} \" for k , w in key . items () if k in self . keys } if key . __len__ () != self . keys . __len__ (): raise ValueError ( 'table key not full qualified' ) value = { k : w for k , w in value . items () if k in self . values } return ( key , value ) def __exec_set_kw__ ( self , key , value ): for k in value . keys (): try : if isinstance ( value [ k ],( list , dict , tuple )): value [ k ] = dumps ( value [ k ]) except Exception as e : pass # print (f\"{value[k]!r}\",value[k].__class__) ## DEBUG if self . columnstypes [ k ] in Mariadb . geotypes : value [ k ] = f \"ST_GeomFromGeoJSON( { value [ k ] !r} )\" elif value [ k ] is None : value [ k ] = \"NULL\" else : value [ k ] = f \" { value [ k ] !r} \" if value . __len__ (): columns = ',' . join ([ * self . keys , * list ( value . keys ())]) values = [ * list ( key . values ()), * list ( value . values ())] updates = \", \" . join ( map ( lambda x : f \" { x } =VALUE( { x } )\" , value . keys ())) else : columns = ',' . join ( key . keys ()) values = list ( key . values ()) updates = f \" { self . values [ 0 ] } = { self . values [ 0 ] } \" vvv = \",\" . join ( values ) # stat=f\"INSERT INTO {self.table} ({columns}) VALUES ({vvv}) ON DUPLICATE KEY UPDATE {updates}\".replace(\"None\",\"NULL\")i stat = f \"INSERT INTO { self . table } ( { columns } ) VALUES ( { vvv } ) ON DUPLICATE KEY UPDATE { updates } \" e = self . engine with e . begin () as connection : connection . execute ( stat ) e . dispose () def __setitem__ ( self , key = None , value = None ): key , value = self . __parse_set_kw__ ( key , value ) self . __exec_set_kw__ ( key , value ) def pop ( self , key ): return self . __getitem__ ( key , delete = True ) class MariadbHielenGeo ( MariadbTable ): def __init__ ( self , connection , table , geo_col = 'geometry' , elev_col = None , askey = None ): super () . __init__ ( connection , table , askey ) if not geo_col in self . columns : raise ValueError ( f \"colum { geo_col } not in table { self . table } \" ) if not self . columnstypes [ geo_col ] in Mariadb . geotypes : raise ValueError ( f \"colum { geo_col } has not geographic type\" ) if elev_col is not None and not elev_col in self . columns : raise ValueError ( f \"colum { elev_col } not in table { self . table } \" ) if elev_col is None and 'elevation' in self . columns : elev_col = 'elevation' self . geo_col = geo_col self . elev_col = elev_col def __man_na_coords__ ( xy , z ): if not isinstance ( xy ,( list , set , tuple )): xy = [ 0 , 0 ] return Point ([ isinstance ( a , Number ) and a or 0 for a in [ * xy , z ]]) def __manage_geo_col__ ( self , frame = None ): if frame is not None and self . elev_col is not None : xy = frame [ self . geo_col ] . apply ( Series , dtype = \"object\" ) #['coordinates'] \"\"\" xy=frame[self.geo_col].to_frame().apply(lambda x: x['geometry'],result_type='expand',axis=1)['coordinates'] \"\"\" xy = xy [ 'coordinates' ] managed = concat ([ xy , frame [ self . elev_col ] . replace ( nan , 0 )], axis = 1 ) frame [ self . geo_col ] = managed . apply ( lambda x : MariadbHielenGeo . __man_na_coords__ ( x [ 'coordinates' ], x [ self . elev_col ]), axis = 1 ) frame = frame . drop ( self . elev_col , axis = 1 ) return frame def query ( self , sqlcond = None ): frame = super () . query ( sqlcond ) try : frame = self . __manage_geo_col__ ( frame ) except Exception as e : pass return frame def __getitem__ ( self , key = None , delete = False ): frame = super () . __getitem__ ( key , delete ) try : frame = self . __manage_geo_col__ ( frame ) except Exception as e : pass return frame def __setitem__ ( self , key = None , value = None ): key , value = self . __parse_set_kw__ ( key , value ) try : value [ self . elev_col ] = value [ self . geo_col ][ 'coordinates' ][ 2 ] except Exception as e : pass self . __exec_set_kw__ ( key , value ) class MariadbHielenCache ( Mariadb ): def __init__ ( self , connection , table ): super () . __init__ ( connection , table ) def __parsekey__ ( key , keysnames : list ): out = { k : None for k in keysnames } if isinstance ( key , dict ): out . update ( key ) if not isinstance ( key ,( list , slice , tuple )) and key is not None : key = [ key ] if isinstance ( key ,( list , slice )): out [ \"series\" ] = key if isinstance ( key , tuple ): key = list ( key ) if not isinstance ( key [ 0 ],( list , slice )) and key [ 0 ] is not None : key [ 0 ] = [ key [ 0 ]] out [ \"series\" ] = key [ 0 ] if not isinstance ( key [ 1 ],( list , slice )) and key [ 1 ] is not None : key [ 1 ] = [ key [ 1 ]] out [ \"timestamp\" ] = key [ 1 ] return out def __setsqlcond__ ( key , column ): sqlcond = None if isinstance ( key , str ): key = [ key ] if isinstance ( key , list ): key = filter ( None , key ) sqlcond = f \" { column } in ( { ',' . join ( map ( lambda x : f ' { x !r} ' , key )) } )\" if isinstance ( key , slice ): wstart = \"\" con = \"\" wstop = \"\" if key . start is not None and key . stop is not None : con = \"AND\" if key . start is not None : wstart = f \" { column } >= { key . start !r} \" if key . stop is not None : wstop = f \" { column } <= { key . stop !r} \" if key . start is not None or key . stop is not None : sqlcond = f \" { wstart } { con } { wstop } \" return sqlcond def __getitem__ ( self , key , delete = False ): \"\"\" WARNING: In case of slice selection with a not None step parmeter the deletion process, if requested, not minds the step for row selection and all the deleted row will be returned in output. \"\"\" key = MariadbHielenCache . __parsekey__ ( key , self . keys ) sercond = MariadbHielenCache . __setsqlcond__ ( key [ \"series\" ], \"series\" ) timecond = MariadbHielenCache . __setsqlcond__ ( key [ \"timestamp\" ], \"timestamp\" ) if sercond is not None and timecond is not None : sqlcond = f \" { sercond } AND { timecond } \" if sercond is not None and timecond is None : sqlcond = f \" { sercond } \" if sercond is None and timecond is not None : sqlcond = f \" { timecond } \" if sercond is None and timecond is None : raise KeyError ( 'No condition provided' ) e = self . engine with e . begin () as connection : stat = f \"SELECT * FROM { self . table } WHERE { sqlcond } FOR UPDATE\" connection . execute ( 'start transaction' ) out = read_sql ( stat , connection , coerce_float = True , index_col = [ 'timestamp' , 'series' ] ) . unstack ( 'series' ) . droplevel ( 0 , axis = 1 ) if not out . empty and delete : stat = f 'DELETE FROM { self . table } WHERE { sqlcond } ' connection . execute ( stat ) e . dispose () return out . copy () e . dispose () try : if key [ \"series\" ] is not None and isinstance ( key [ \"series\" ], slice ): out = out . T [ key [ \"series\" ]] . T if key [ \"timestamp\" ] is not None and isinstance ( key [ \"timestamp\" ], slice ): out = out [ key [ \"timestamp\" ]] except KeyError : raise KeyError ( key ) if out . empty : raise KeyError ( key ) return out . copy () def __setitem__ ( self , key , value ): if value is not None and not isinstance ( value ,( Series , DataFrame )): raise ValueError ( \"pandas.Series or pandas.DataFrame required\" ) key = MariadbHielenCache . __parsekey__ ( key , self . keys ) try : value = value . to_frame () value . columns . name = 'series' except Exception as e : pass if key [ \"series\" ] is not None : if isinstance ( key [ \"series\" ], slice ): value = value . T [ key [ \"series\" ]] . T else : value = value [ key [ \"series\" ]] if key [ \"timestamp\" ] is not None : value = value [ key [ \"timestamp\" ]] if value is not None and not value . empty : value = value . stack () value . name = 'value' value = value . reset_index () if value . empty : return value = value [[ 'series' , 'timestamp' , 'value' ]] stat = re . sub ( \",\\($\" , \"\" , re . sub ( \"^\" , \"(\" , value . to_csv ( header = None , index = None , quoting = 1 , lineterminator = \"),(\" ))) stat = f \"INSERT INTO { self . table } (series,timestamp,value) VALUES \" + stat + \" ON DUPLICATE KEY UPDATE value = VALUES(value)\" e = self . engine with e . begin () as connection : connection . execute ( stat ) e . dispose () def pop ( self , key ): return self . __getitem__ ( key , delete = True )","title":"Module hielen3.datalink"},{"location":"reference/hielen3/datalink/#variables","text":"nan","title":"Variables"},{"location":"reference/hielen3/datalink/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/datalink/#dbinit","text":"def dbinit ( conf ) View Source def dbinit ( conf ) : out = {} for k , w in conf [ \"db\" ] . items () : out [ k ] = newinstanceof ( w . pop ( \"klass\" ), ** w ) return out","title":"dbinit"},{"location":"reference/hielen3/datalink/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/datalink/#csvcache","text":"class CsvCache ( cachepath , item , lock_timeout_seconds = 10 ) View Source class CsvCache (): def __init__ ( self , cachepath , item , lock_timeout_seconds = 10 ): self . cachepath = Path ( cachepath ) / item [ 0 : 8 ] / item [ 8 : 16 ] / item [ 16 : 24 ] / item [ 24 : 32 ] self . db = None self . csv = str ( self . cachepath / f \"{item}.csv\" ) self . lock = FileLock ( f \"{self.csv}.lock\" , timeout = lock_timeout_seconds ) self . md5file = f \"{self.csv}.md5\" self . md5 = None #self.__chk_and_reload_cache(force=True) def __repr__ ( self ): return self . db . __repr__ () def __brute_load_cache ( self ): try : self . db = read_csv ( self . csv , header = None , sep = \";\" , index_col = 0 , parse_dates = True )[ 1 ] except Exception as e : self . db = Series () self . db . name = \"s\" def __chk_and_reload_cache ( self , force = False ): \"\"\" Needs to check for cache file changes in a thread safe way!! \"\"\" md5 = None error = None try : self . lock . acquire () try : if force : raise FileNotFoundError () with open ( self . md5file ) as o : md5 = o . read () if not md5 == self . md5 : self . md5 = md5 self . __brute_load_cache () except FileNotFoundError as e : ## refershing hash try : self . md5 = hashfile ( self . csv ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) except FileNotFoundError as e : pass self . __brute_load_cache () finally : self . lock . release () except Timeout : pass def save ( self ): try : self . lock . acquire () try : self . db . to_csv ( self . csv , header = None , sep = \";\" ) self . md5 = hashfile ( self . csv ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) finally : self . lock . release () except Timeout as e : # Just to remind Timout error here raise e def drop ( self ): try : self . lock . acquire () try : os . unlink ( self . csv ) os . unlink ( self . md5file ) self . db = None finally : self . lock . release () except Timeout as e : # Just to remind Timout error here raise e def update ( self , value : Series ): \"\"\" Needs to lock for writing json-database \"\"\" error = None try : self . lock . acquire () try : self . __chk_and_reload_cache () self . db . drop ( value . index , errors = 'ignore' , inplace = True ) value . name = 's' self . db = self . db . append ( value ) . sort_index () self . save () except Exception as e : error = e finally : self . lock . release () except Timeout as e : error = e if error is not None : raise error def get ( self , force_reload = False ): self . __chk_and_reload_cache ( force = force_reload ) return self . db","title":"CsvCache"},{"location":"reference/hielen3/datalink/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/datalink/#drop","text":"def drop ( self ) View Source def drop ( self ) : try : self . lock . acquire () try : os . unlink ( self . csv ) os . unlink ( self . md5file ) self . db = None finally : self . lock . release () except Timeout as e : # Just to remind Timout error here raise e","title":"drop"},{"location":"reference/hielen3/datalink/#get","text":"def get ( self , force_reload = False ) View Source def get ( self , force_reload = False ): self . __chk_and_reload_cache ( force = force_reload ) return self . db","title":"get"},{"location":"reference/hielen3/datalink/#save","text":"def save ( self ) View Source def save ( self ): try : self . lock . acquire () try : self . db . to_csv ( self . csv , header = None , sep = \";\" ) self . md5 = hashfile ( self . csv ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) finally : self . lock . release () except Timeout as e : # Just to remind Timout error here raise e","title":"save"},{"location":"reference/hielen3/datalink/#update","text":"def update ( self , value : pandas . core . series . Series ) Needs to lock for writing json-database View Source def update ( self , value : Series ): \"\"\" Needs to lock for writing json-database \"\"\" error = None try : self . lock . acquire () try : self . __chk_and_reload_cache () self . db . drop ( value . index , errors = 'ignore' , inplace = True ) value . name = 's' self . db = self . db . append ( value ) . sort_index () self . save () except Exception as e : error = e finally : self . lock . release () except Timeout as e : error = e if error is not None : raise error","title":"update"},{"location":"reference/hielen3/datalink/#db","text":"class DB ( connection ) Helper class that provides a standard way to create an ABC using inheritance. View Source class DB ( ABC ) : @abstractmethod def __init__ ( self , connection ) : pass @abstractmethod def __getitem__ ( self , key ) : pass @abstractmethod def __setitem__ ( self , key , value ) : pass @abstractmethod def pop ( self , key ) : pass","title":"DB"},{"location":"reference/hielen3/datalink/#ancestors-in-mro","text":"abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/datalink/#descendants","text":"hielen3.datalink.JsonDB hielen3.datalink.Mariadb","title":"Descendants"},{"location":"reference/hielen3/datalink/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/datalink/#pop","text":"def pop ( self , key ) View Source @abstractmethod def pop ( self , key ) : pass","title":"pop"},{"location":"reference/hielen3/datalink/#jsondb","text":"class JsonDB ( connection , schema , lock_timeout_seconds = 10 ) Helper class that provides a standard way to create an ABC using inheritance. View Source class JsonDB ( DB ) : def __init__ ( self , connection , schema , lock_timeout_seconds = 10 ) : self . jsonfile = connection self . lock = FileLock ( f \"{connection}.lock\" , timeout = lock_timeout_seconds ) self . md5file = f \"{connection}.md5\" self . md5 = None self . schema = schema self . __chk_and_reload_jsondb ( force = True ) def __brute_load_jsondb ( self ) : try : self . db = read_json ( self . jsonfile , orient = 'table' , convert_dates = False ) self . db . replace ( { nan : None , NaT : None } , inplace = True ) except Exception as e : self . db = DataFrame () if self . db . empty : self . db = DataFrame ( {} , columns = self . schema [ 'columns' ] ) self . db = self . db . set_index ( self . schema [ 'primary_key' ] ) def __chk_and_reload_jsondb ( self , force = False ) : \"\"\" Needs to check for json-database file changes in a thread safe way!! \"\"\" md5 = None error = None try : self . lock . acquire () try : if force : raise FileNotFoundError () with open ( self . md5file ) as o : md5 = o . read () if not md5 == self . md5 : self . md5 = md5 self . __brute_load_jsondb () except FileNotFoundError as e : ## refershing hash self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) self . __brute_load_jsondb () finally : self . lock . release () except Timeout : pass def save ( self ) : try : self . lock . acquire () try : self . db . to_json ( self . jsonfile , orient = 'table' ) self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , \"w\" ) as o : o . write ( self . md5 ) finally : self . lock . release () except Timeout as e : # Just to remind Timout error here raise e def __write_jsondb ( self , key , value ) : \"\"\" Needs to lock for writing json-database \"\"\" item = None error = None try : self . lock . acquire () try : self . __chk_and_reload_jsondb () if value is None : # Request to remove key , raises KeyError item = self . __getitem__ ( key ) try : self . db = self . db . drop ( key , axis = 0 ) except KeyError : raise KeyError ( f \"key {key} to remove does not exist\" ) else : # Request to insert key , raises ValueError primarykey = self . schema [ 'primary_key' ] if not isinstance ( key ,( list , set , tuple )) : key =[ key ] if key . __len__ () < primarykey . __len__ () : raise ValueError ( f \"key {key!r} is not fully determinated\" ) keydict = dict ( zip ( self . schema [ 'primary_key' ] , key )) value . update ( keydict ) df = DataFrame ( [ value.values() ] ) df . columns = value . keys () df = df . set_index ( self . schema [ 'primary_key' ] ) try : self . db = self . db . append ( df , verify_integrity = True ). sort_index () except ValueError : raise ValueError ( f \"key {key} to insert exists\" ) self . db . replace ( { nan : None , NaT : None } , inplace = True ) item = self . __brute_getitem ( key ) self . save () except Exception as e : error = e finally : self . lock . release () except Timeout as e : error = e if error is not None : raise error return item def __brute_getitem ( self , key = None ) : out = None if key is None : out = self . db else : out = self . db . loc [ key ] if isinstance ( out , Series ) : out = out . to_frame (). T out . index . names = self . schema [ 'primary_key' ] out = out . reset_index (). to_dict ( orient = 'records' ) if out . __len__ () == 1 : out = out [ 0 ] return out def __getitem__ ( self , key = None ) : self . __chk_and_reload_jsondb () if isinstance ( key , list ) : try : key = list ( filter ( None , key )) except TypeError : pass return self . __brute_getitem ( key ) def pop ( self , key ) : return self . __write_jsondb ( key , None ) def __setitem__ ( self , key = None , value = None ) : self . __write_jsondb ( key , value )","title":"JsonDB"},{"location":"reference/hielen3/datalink/#ancestors-in-mro_1","text":"hielen3.datalink.DB abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/datalink/#descendants_1","text":"hielen3.datalink.fsHielenCache","title":"Descendants"},{"location":"reference/hielen3/datalink/#methods_2","text":"","title":"Methods"},{"location":"reference/hielen3/datalink/#pop_1","text":"def pop ( self , key ) View Source def pop ( self , key ) : return self . __write_jsondb ( key , None )","title":"pop"},{"location":"reference/hielen3/datalink/#save_1","text":"def save ( self ) View Source def save(self): try: self.lock.acquire() try: self.db.to_json(self.jsonfile,orient='table') self.md5 = hashfile(self.jsonfile) with open(self.md5file, \"w\") as o: o.write(self.md5) finally: self.lock.release() except Timeout as e: # Just to remind Timout error here raise e","title":"save"},{"location":"reference/hielen3/datalink/#mariadb","text":"class Mariadb ( connection , table = None , askey = None ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Mariadb ( DB ) : geotypes = ( 'point' , 'linestring' , 'polygon' , 'multipoint' , 'multilinestring' , 'multipolygon' , 'geometrycollection' , 'geometry' ) @property def engine ( self ) : def getengine ( dialect = 'mariadb' , usr = 'editor' , pwd = 'rincostocastico' , host = '127.0.0.1' , port = 13231 , db = 'geoframe' ) : connstr = '{}://{}:{}@{}:{}/{}' . format ( dialect , usr , pwd , host , port , db ) return create_engine ( connstr , echo = False ) return getengine ( ** self . conn ) def __init__ ( self , connection , table = None , askey = None ) : self . conn = connection if table is not None : table = table . split ( \".\" ) self . schema = table [ 0 ] self . table = table [ 1 ] keysquery = f ''' select COLUMN_NAME from information_schema.key_column_usage where TABLE_SCHEMA = {self.schema!r} and TABLE_NAME = {self.table!r} and CONSTRAINT_NAME = ' PRIMARY ' order by ORDINAL_POSITION ''' columnquery = f ''' select COLUMN_NAME, COLUMN_TYPE from information_schema.columns where TABLE_SCHEMA = {self.schema!r} and TABLE_NAME = {self.table!r} order by ORDINAL_POSITION ''' e = self . engine with e . connect () as connection : self . columnstypes = dict ( connection . execute ( columnquery ). all ()) self . keys = [ l[0 ] for l in connection . execute ( keysquery ). all () ] e . dispose () self . columns = list ( self . columnstypes . keys ()) self . selectfields = [ w in Mariadb.geotypes and f\"ifnull(st_asgeojson({k}),'null') as {k!r}\" or k for k,w in self.columnstypes.items() ] if askey is not None : if not isinstance ( askey ,( tuple , list )) : askey =[ askey ] self . keys . extend ( [ k for k in askey if k not in self.keys and k in self.columns ] ) self . values = [ k for k in self.columns if k not in self.keys ] def save ( self ) : pass @abstractmethod def __getitem__ ( self , key = None ) : pass @abstractmethod def __setitem__ ( self , key = None , value = None ) : pass @abstractmethod def pop ( self , key ) : pass","title":"Mariadb"},{"location":"reference/hielen3/datalink/#ancestors-in-mro_2","text":"hielen3.datalink.DB abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/datalink/#descendants_2","text":"hielen3.datalink.MariadbQuery hielen3.datalink.MariadbTable hielen3.datalink.MariadbHielenCache","title":"Descendants"},{"location":"reference/hielen3/datalink/#class-variables","text":"geotypes","title":"Class variables"},{"location":"reference/hielen3/datalink/#instance-variables","text":"engine","title":"Instance variables"},{"location":"reference/hielen3/datalink/#methods_3","text":"","title":"Methods"},{"location":"reference/hielen3/datalink/#pop_2","text":"def pop ( self , key ) View Source @abstractmethod def pop ( self , key ) : pass","title":"pop"},{"location":"reference/hielen3/datalink/#save_2","text":"def save ( self ) View Source def save(self): pass","title":"save"},{"location":"reference/hielen3/datalink/#mariadbhielencache","text":"class MariadbHielenCache ( connection , table ) Helper class that provides a standard way to create an ABC using inheritance. View Source class MariadbHielenCache ( Mariadb ) : def __init__ ( self , connection , table ) : super (). __init__ ( connection , table ) def __parsekey__ ( key , keysnames : list ) : out = { k : None for k in keysnames } if isinstance ( key , dict ) : out . update ( key ) if not isinstance ( key ,( list , slice , tuple )) and key is not None : key =[ key ] if isinstance ( key ,( list , slice )) : out [ \"series\" ]= key if isinstance ( key , tuple ) : key = list ( key ) if not isinstance ( key [ 0 ] ,( list , slice )) and key [ 0 ] is not None : key [ 0 ]=[ key[0 ] ] out [ \"series\" ]= key [ 0 ] if not isinstance ( key [ 1 ] ,( list , slice )) and key [ 1 ] is not None : key [ 1 ]=[ key[1 ] ] out [ \"timestamp\" ]= key [ 1 ] return out def __setsqlcond__ ( key , column ) : sqlcond = None if isinstance ( key , str ) : key =[ key ] if isinstance ( key , list ) : key = filter ( None , key ) sqlcond = f \"{column} in ({','.join(map(lambda x: f'{x!r}',key))})\" if isinstance ( key , slice ) : wstart = \"\" con = \"\" wstop = \"\" if key . start is not None and key . stop is not None : con = \"AND\" if key . start is not None : wstart = f \"{column} >= {key.start!r}\" if key . stop is not None : wstop = f \"{column} <= {key.stop!r}\" if key . start is not None or key . stop is not None : sqlcond = f \"{wstart} {con} {wstop}\" return sqlcond def __getitem__ ( self , key , delete = False ) : \"\"\" WARNING: In case of slice selection with a not None step parmeter the deletion process, if requested, not minds the step for row selection and all the deleted row will be returned in output. \"\"\" key = MariadbHielenCache . __parsekey__ ( key , self . keys ) sercond = MariadbHielenCache . __setsqlcond__ ( key [ \"series\" ] , \"series\" ) timecond = MariadbHielenCache . __setsqlcond__ ( key [ \"timestamp\" ] , \"timestamp\" ) if sercond is not None and timecond is not None : sqlcond = f \"{sercond} AND {timecond}\" if sercond is not None and timecond is None : sqlcond = f \"{sercond}\" if sercond is None and timecond is not None : sqlcond = f \"{timecond}\" if sercond is None and timecond is None : raise KeyError ( 'No condition provided' ) e = self . engine with e . begin () as connection : stat = f \"SELECT * FROM {self.table} WHERE {sqlcond} FOR UPDATE\" connection . execute ( 'start transaction' ) out = read_sql ( stat , connection , coerce_float = True , index_col =[ 'timestamp','series' ] ). unstack ( 'series' ). droplevel ( 0 , axis = 1 ) if not out . empty and delete : stat = f 'DELETE FROM {self.table} WHERE {sqlcond}' connection . execute ( stat ) e . dispose () return out . copy () e . dispose () try : if key [ \"series\" ] is not None and isinstance ( key [ \"series\" ] , slice ) : out = out . T [ key[\"series\" ] ] . T if key [ \"timestamp\" ] is not None and isinstance ( key [ \"timestamp\" ] , slice ) : out = out [ key[\"timestamp\" ] ] except KeyError : raise KeyError ( key ) if out . empty : raise KeyError ( key ) return out . copy () def __setitem__ ( self , key , value ) : if value is not None and not isinstance ( value ,( Series , DataFrame )) : raise ValueError ( \"pandas.Series or pandas.DataFrame required\" ) key = MariadbHielenCache . __parsekey__ ( key , self . keys ) try : value = value . to_frame () value . columns . name = 'series' except Exception as e : pass if key [ \"series\" ] is not None : if isinstance ( key [ \"series\" ] , slice ) : value = value . T [ key[\"series\" ] ] . T else : value = value [ key[\"series\" ] ] if key [ \"timestamp\" ] is not None : value = value [ key[\"timestamp\" ] ] if value is not None and not value . empty : value = value . stack () value . name = 'value' value = value . reset_index () if value . empty : return value = value [ ['series','timestamp','value' ] ] stat = re . sub ( \",\\($\" , \"\" , re . sub ( \"^\" , \"(\" , value . to_csv ( header = None , index = None , quoting = 1 , lineterminator = \"),(\" ))) stat = f \"INSERT INTO {self.table} (series,timestamp,value) VALUES \" + stat + \" ON DUPLICATE KEY UPDATE value = VALUES(value)\" e = self . engine with e . begin () as connection : connection . execute ( stat ) e . dispose () def pop ( self , key ) : return self . __getitem__ ( key , delete = True )","title":"MariadbHielenCache"},{"location":"reference/hielen3/datalink/#ancestors-in-mro_3","text":"hielen3.datalink.Mariadb hielen3.datalink.DB abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/datalink/#class-variables_1","text":"geotypes","title":"Class variables"},{"location":"reference/hielen3/datalink/#instance-variables_1","text":"engine","title":"Instance variables"},{"location":"reference/hielen3/datalink/#methods_4","text":"","title":"Methods"},{"location":"reference/hielen3/datalink/#pop_3","text":"def pop ( self , key ) View Source def pop ( self , key ) : return self . __getitem__ ( key , delete = True )","title":"pop"},{"location":"reference/hielen3/datalink/#save_3","text":"def save ( self ) View Source def save(self): pass","title":"save"},{"location":"reference/hielen3/datalink/#mariadbhielengeo","text":"class MariadbHielenGeo ( connection , table , geo_col = 'geometry' , elev_col = None , askey = None ) Helper class that provides a standard way to create an ABC using inheritance. View Source class MariadbHielenGeo ( MariadbTable ) : def __init__ ( self , connection , table , geo_col = 'geometry' , elev_col = None , askey = None ) : super (). __init__ ( connection , table , askey ) if not geo_col in self . columns : raise ValueError ( f \"colum {geo_col} not in table {self.table}\" ) if not self . columnstypes [ geo_col ] in Mariadb . geotypes : raise ValueError ( f \"colum {geo_col} has not geographic type\" ) if elev_col is not None and not elev_col in self . columns : raise ValueError ( f \"colum {elev_col} not in table {self.table}\" ) if elev_col is None and 'elevation' in self . columns : elev_col = 'elevation' self . geo_col = geo_col self . elev_col = elev_col def __man_na_coords__ ( xy , z ) : if not isinstance ( xy ,( list , set , tuple )) : xy =[ 0,0 ] return Point ( [ isinstance(a,Number) and a or 0 for a in [*xy,z ] ] ) def __manage_geo_col__ ( self , frame = None ) : if frame is not None and self . elev_col is not None : xy = frame [ self.geo_col ] . apply ( Series , dtype = \"object\" ) # [ 'coordinates' ] \"\"\" xy=frame[self.geo_col].to_frame().apply(lambda x: x['geometry'],result_type='expand',axis=1)['coordinates'] \"\"\" xy = xy [ 'coordinates' ] managed = concat ( [ xy,frame[self.elev_col ] . replace ( nan , 0 ) ] , axis = 1 ) frame [ self.geo_col ]= managed . apply ( lambda x : MariadbHielenGeo . __man_na_coords__ ( x [ 'coordinates' ] , x [ self.elev_col ] ), axis = 1 ) frame = frame . drop ( self . elev_col , axis = 1 ) return frame def query ( self , sqlcond = None ) : frame = super (). query ( sqlcond ) try : frame = self . __manage_geo_col__ ( frame ) except Exception as e : pass return frame def __getitem__ ( self , key = None , delete = False ) : frame = super (). __getitem__ ( key , delete ) try : frame = self . __manage_geo_col__ ( frame ) except Exception as e : pass return frame def __setitem__ ( self , key = None , value = None ) : key , value = self . __parse_set_kw__ ( key , value ) try : value [ self.elev_col ]= value [ self.geo_col ][ 'coordinates' ][ 2 ] except Exception as e : pass self . __exec_set_kw__ ( key , value )","title":"MariadbHielenGeo"},{"location":"reference/hielen3/datalink/#ancestors-in-mro_4","text":"hielen3.datalink.MariadbTable hielen3.datalink.Mariadb hielen3.datalink.DB abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/datalink/#class-variables_2","text":"geotypes","title":"Class variables"},{"location":"reference/hielen3/datalink/#instance-variables_2","text":"engine","title":"Instance variables"},{"location":"reference/hielen3/datalink/#methods_5","text":"","title":"Methods"},{"location":"reference/hielen3/datalink/#pop_4","text":"def pop ( self , key ) View Source def pop ( self , key ) : return self . __getitem__ ( key , delete = True )","title":"pop"},{"location":"reference/hielen3/datalink/#query","text":"def query ( self , sqlcond = None ) View Source def query ( self , sqlcond = None ) : frame = super () . query ( sqlcond ) try : frame = self . __manage_geo_col__ ( frame ) except Exception as e : pass return frame","title":"query"},{"location":"reference/hielen3/datalink/#save_4","text":"def save ( self ) View Source def save(self): pass","title":"save"},{"location":"reference/hielen3/datalink/#mariadbquery","text":"class MariadbQuery ( connection ) Helper class that provides a standard way to create an ABC using inheritance. View Source class MariadbQuery ( Mariadb ) : def __init__ ( self , connection ) : super (). __init__ ( connection ) def __getitem__ ( self , stat = None ) : e = self . engine with e . begin () as connection : connection . execute ( 'start transaction' ) out = read_sql ( stat , connection , coerce_float = True , ) e . dispose () for c in out . columns : try : out [ c ] = out [ c ] . apply ( loads ) if out [ c ] . dtype == 'datetime64[ns]' : out [ c ]= out [ c ] . apply ( str ) except Exception as e : pass return out . copy () def __setitem__ ( self , key , value ) : pass def pop ( self , stat ) : return self . __getitem__ ( stat )","title":"MariadbQuery"},{"location":"reference/hielen3/datalink/#ancestors-in-mro_5","text":"hielen3.datalink.Mariadb hielen3.datalink.DB abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/datalink/#class-variables_3","text":"geotypes","title":"Class variables"},{"location":"reference/hielen3/datalink/#instance-variables_3","text":"engine","title":"Instance variables"},{"location":"reference/hielen3/datalink/#methods_6","text":"","title":"Methods"},{"location":"reference/hielen3/datalink/#pop_5","text":"def pop ( self , stat ) View Source def pop ( self , stat ) : return self . __getitem__ ( stat )","title":"pop"},{"location":"reference/hielen3/datalink/#save_5","text":"def save ( self ) View Source def save(self): pass","title":"save"},{"location":"reference/hielen3/datalink/#mariadbtable","text":"class MariadbTable ( connection , table , askey = None ) Helper class that provides a standard way to create an ABC using inheritance. View Source class MariadbTable ( Mariadb ) : def __init__ ( self , connection , table , askey = None ) : super (). __init__ ( connection , table , askey ) def query ( self , sqlcond = None ) : stat = f 'SELECT {\",\".join(self.selectfields)} FROM {self.table}' if sqlcond is not None and sqlcond . __len__ () > 0 : stat = f '{stat} WHERE {sqlcond}' e = self . engine with e . begin () as connection : connection . execute ( 'start transaction' ) out = read_sql ( stat , connection , coerce_float = True , index_col = self . keys ) e . dispose () if out . empty : raise KeyError ( sqlcond ) try : out = out . to_frame () except Exception as e : pass for c in out . columns : try : out [ c ] = out [ c ] . apply ( loads ) if out [ c ] . dtype == 'datetime64[ns]' : out [ c ]= out [ c ] . apply ( str ) except Exception as e : pass ind = out . index . copy () out = out . reset_index () out . index = ind return out . copy () def __getitem__ ( self , key = None , delete = False ) : templatecond = { w : None for w in self . keys } if key is None : key = slice ( None , None , None ) def __makekeydict__ ( k ) : out = templatecond . copy () if not isinstance ( k ,( tuple , list , dict )) : k =[ k ] if isinstance ( k , tuple ) : k = list ( k ) if isinstance ( k , list ) : keyl = min ( self . keys . __len__ (), k . __len__ ()) k = dict ( zip ( self . keys [ :keyl ] , k [ :keyl ] )) if isinstance ( k , dict ) : k = { w : v for w , v in k . items () if w in self . keys } out . update ( k ) return out if not isinstance ( key ,( list , tuple , dict )) : key =[ (key,) ] if isinstance ( key , dict ) : key =[ key ] if isinstance ( key , tuple ) and key . __len__ () == 1 : key =[ (key[0 ] , None ) ] if isinstance ( key , tuple ) : key =[ key ] conds =[ __makekeydict__(k) for k in list(key) ] sqlarr = [] for clausule in conds : clausulearr = [] for cond in clausule . keys () : if clausule [ cond ] is not None : if isinstance ( clausule [ cond ] , slice ) : key = clausule [ cond ] wstart = '' con = '' wstop = '' if key . start is not None and key . stop is not None : con = 'AND' if key . start is not None : wstart = f '{cond} >= {key.start!r}' if key . stop is not None : wstop = f '{cond} <= {key.stop!r}' if key . start is not None or key . stop is not None : sqlcond = f '{wstart} {con} {wstop}' clausulearr . append ( sqlcond ) elif isinstance ( clausule [ cond ] ,( list , tuple , set )) : condarr = \",\" . join ( map ( lambda x : f '{x!r}' , clausule [ cond ] )) clausulearr . append ( f '{cond} in ({condarr})' ) else : clausulearr . append ( f '{cond}={clausule[cond]!r}' ) if clausulearr . __len__ () : sqlarr . append ( '(' + ' AND ' . join ( clausulearr ) + ')' ) if sqlarr . __len__ () : sqlcond = ' OR ' . join ( sqlarr ) else : if delete : raise KeyError ( \"No condition provided for deletion!\" ) sqlcond = 1 e = self . engine with e . begin () as connection : stat = f 'SELECT {\",\".join(self.selectfields)} FROM {self.table} WHERE {sqlcond} FOR UPDATE' connection . execute ( 'start transaction' ) out = read_sql ( stat , connection , coerce_float = True , index_col = self . keys ) if not out . empty and delete : stat = f 'DELETE FROM {self.table} WHERE {sqlcond}' connection . execute ( stat ) e . dispose () if out . empty : raise KeyError ( sqlcond ) try : out = out . to_frame () except Exception as e : pass for c in out . columns : try : out [ c ] = out [ c ] . apply ( loads ) if out [ c ] . dtype == 'datetime64[ns]' : out [ c ]= out [ c ] . apply ( str ) except Exception as e : pass ind = out . index . copy () out = out . reset_index () out . index = ind return out . copy () def __parse_set_kw__ ( self , key = None , value = None ) : if isinstance ( key , slice ) : raise ValueError ( 'slice key not supported' ) if key is None : key = {} if not isinstance ( key ,( list , tuple , dict )) : key =[ key ] if isinstance ( key ,( list , tuple )) : keyl = min ( self . keys . __len__ (), key . __len__ ()) key = dict ( zip ( self . keys [ :keyl ] , key [ :keyl ] )) if not isinstance ( value ,( list , tuple , dict )) : value =[ value ] if isinstance ( value ,( list , tuple )) : valuel = min ( self . values . __len__ (), value . __len__ ()) value = dict ( zip ( self . values [ :valuel ] , value [ :valuel ] )) if isinstance ( key , dict ) : v = value . copy () for k in value . keys () : if k in self . keys : key [ k ]= v . pop ( k ) value = v key = { k : f \"{w!r}\" for k , w in key . items () if k in self . keys } if key . __len__ () != self . keys . __len__ () : raise ValueError ( 'table key not full qualified' ) value = { k : w for k , w in value . items () if k in self . values } return ( key , value ) def __exec_set_kw__ ( self , key , value ) : for k in value . keys () : try : if isinstance ( value [ k ] ,( list , dict , tuple )) : value [ k ]= dumps ( value [ k ] ) except Exception as e : pass # print ( f \"{value[k]!r}\" , value [ k ] . __class__ ) ## DEBUG if self . columnstypes [ k ] in Mariadb . geotypes : value [ k ]= f \"ST_GeomFromGeoJSON({value[k]!r})\" elif value [ k ] is None : value [ k ] = \"NULL\" else : value [ k ]= f \"{value[k]!r}\" if value . __len__ () : columns = ',' . join ( [ *self.keys,*list(value.keys()) ] ) values =[ *list(key.values()),*list(value.values()) ] updates = \", \" . join ( map ( lambda x : f \"{x}=VALUE({x})\" , value . keys ())) else : columns = ',' . join ( key . keys ()) values = list ( key . values ()) updates = f \"{self.values[0]}={self.values[0]}\" vvv = \",\" . join ( values ) # stat = f \"INSERT INTO {self.table} ({columns}) VALUES ({vvv}) ON DUPLICATE KEY UPDATE {updates}\" . replace ( \"None\" , \"NULL\" ) i stat = f \"INSERT INTO {self.table} ({columns}) VALUES ({vvv}) ON DUPLICATE KEY UPDATE {updates}\" e = self . engine with e . begin () as connection : connection . execute ( stat ) e . dispose () def __setitem__ ( self , key = None , value = None ) : key , value = self . __parse_set_kw__ ( key , value ) self . __exec_set_kw__ ( key , value ) def pop ( self , key ) : return self . __getitem__ ( key , delete = True )","title":"MariadbTable"},{"location":"reference/hielen3/datalink/#ancestors-in-mro_6","text":"hielen3.datalink.Mariadb hielen3.datalink.DB abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/datalink/#descendants_3","text":"hielen3.datalink.MariadbHielenGeo","title":"Descendants"},{"location":"reference/hielen3/datalink/#class-variables_4","text":"geotypes","title":"Class variables"},{"location":"reference/hielen3/datalink/#instance-variables_4","text":"engine","title":"Instance variables"},{"location":"reference/hielen3/datalink/#methods_7","text":"","title":"Methods"},{"location":"reference/hielen3/datalink/#pop_6","text":"def pop ( self , key ) View Source def pop ( self , key ) : return self . __getitem__ ( key , delete = True )","title":"pop"},{"location":"reference/hielen3/datalink/#query_1","text":"def query ( self , sqlcond = None ) View Source def query ( self , sqlcond = None ) : stat = f 'SELECT {\",\".join(self.selectfields)} FROM {self.table}' if sqlcond is not None and sqlcond . __len__ () > 0 : stat = f '{stat} WHERE {sqlcond}' e = self . engine with e . begin () as connection : connection . execute ( 'start transaction' ) out = read_sql ( stat , connection , coerce_float = True , index_col = self . keys ) e . dispose () if out . empty : raise KeyError ( sqlcond ) try : out = out . to_frame () except Exception as e : pass for c in out . columns : try : out [ c ] = out [ c ] . apply ( loads ) if out [ c ] . dtype == 'datetime64[ns]' : out [ c ]= out [ c ] . apply ( str ) except Exception as e : pass ind = out . index . copy () out = out . reset_index () out . index = ind return out . copy ()","title":"query"},{"location":"reference/hielen3/datalink/#save_6","text":"def save ( self ) View Source def save(self): pass","title":"save"},{"location":"reference/hielen3/datalink/#fshielencache","text":"class fsHielenCache ( connection , lock_timeout_seconds = 10 ) Helper class that provides a standard way to create an ABC using inheritance. View Source class fsHielenCache ( JsonDB ) : def __init__ ( self , connection , lock_timeout_seconds = 10 ) : self . cachepath = connection self . lts = lock_timeout_seconds schema = { \"columns\" : [ \"uid\",\"info\" ] , \"primary_key\" : [ \"uid\" ] } connfile = str ( Path ( connection ) / \"index.json\" ) super (). __init__ ( connfile , schema , self . lts ) def __getitem__ ( self , key ) : info = super (). __getitem__ ( key ) return CsvCache ( self . cachepath , key , self . lts ). get ( force_reload = True ) def __setitem__ ( self , key , value ) : if value is not None and not isinstance ( value , Series ) : raise ValueError ( \"pandas.Series required\" ) try : assert isinstance ( key , str ) assert key . __len__ () == 32 except AssertionError as e : raise ValueError ( f \"key {key} doesn't seems to match requirement format\" ) #testing existence ( stops if exits ) if value is not None : super (). __setitem__ ( key , {} ) item = CsvCache ( self . cachepath , key , self . lts ) os . makedirs ( item . cachepath , exist_ok = True ) item . update ( value ) #TODO MAKE STATITICS statistics = {} self . db . loc [ key ]= statistics else : super (). __setitem__ ( key , None ) try : CsvCache ( self . cachepath , key , self . lts ). drop () except FileNotFoundError as e : pass def update ( self , key , value ) : if value is not None and not isinstance ( value , Series ) : #if value is not None and not isinstance ( value , DataFrame ) : raise ValueError ( \"pandas.Series required\" ) if value is not None : info = super (). __getitem__ ( key ) item = CsvCache ( self . cachepath , key , self . lts ) item . update ( value ) #TODO MAKE STATITICS statistics = {} self . db . loc [ key ]= statistics","title":"fsHielenCache"},{"location":"reference/hielen3/datalink/#ancestors-in-mro_7","text":"hielen3.datalink.JsonDB hielen3.datalink.DB abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/datalink/#methods_8","text":"","title":"Methods"},{"location":"reference/hielen3/datalink/#pop_7","text":"def pop ( self , key ) View Source def pop ( self , key ) : return self . __write_jsondb ( key , None )","title":"pop"},{"location":"reference/hielen3/datalink/#save_7","text":"def save ( self ) View Source def save(self): try: self.lock.acquire() try: self.db.to_json(self.jsonfile,orient='table') self.md5 = hashfile(self.jsonfile) with open(self.md5file, \"w\") as o: o.write(self.md5) finally: self.lock.release() except Timeout as e: # Just to remind Timout error here raise e","title":"save"},{"location":"reference/hielen3/datalink/#update_1","text":"def update ( self , key , value ) View Source def update ( self , key , value ) : if value is not None and not isinstance ( value , Series ) : #if value is not None and not isinstance ( value , DataFrame ) : raise ValueError ( \"pandas.Series required\" ) if value is not None : info = super (). __getitem__ ( key ) item = CsvCache ( self . cachepath , key , self . lts ) item . update ( value ) #TODO MAKE STATITICS statistics = {} self . db . loc [ key ]= statistics","title":"update"},{"location":"reference/hielen3/datalink/#seriescode","text":"class seriescode ( * args , ** kwargs ) View Source class seriescode (): def __init__ ( self ,* args ,** kwargs ): self . h =[ * args ] self . h . extend ( list ( kwargs . values ())) self . h = '' . join ([ str ( a ) for a in self . h ]) self . h = md5 ( f' { self . h }'. encode () ). hexdigest () def __repr__ ( self ): return self . h","title":"seriescode"},{"location":"reference/hielen3/feature/","text":"Module hielen3.feature View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 #!/usr/bin/env python # coding=utf-8 from abc import ABC , abstractmethod from importlib import import_module from hielen3 import db from hielen3.utils import uuid as newuuid from hielen3.series import HSeries from marshmallow import fields from numpy import datetime64 , isnat from pandas import DataFrame from MySQLdb._exceptions import ProgrammingError import traceback def _agoodtime ( t ): try : t = datetime64 ( t ) assert not isnat ( t ) t = str ( t ) except Exception as e : t = None return t class StringTime ( fields . DateTime ): def _deserialize ( self , value , attr , data , ** kwargs ): return str ( super () . _deserialize ( value , attr , data , ** kwargs )) def _serialize ( self , value , attr , obj , ** kwargs ): return _agoodtime ( value ) class HFeature ( ABC ): @abstractmethod def config ( * args , ** kwargs ): pass def modules ( ftype = None ): r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) def __schemata__ ( mod , actions = None ): print ( mod ) s = DataFrame ( mod . __all__ ) s . columns = [ 'names' ] s = s [ s [ 'names' ] . str . contains ( \"Schema\" )] s . index = s [ \"names\" ] . str . replace ( \"Schema\" , \"\" ) . str . lower () s = s . loc [ actions ] try : s = s . to_frame () . T s . index . name = 'names' except Exception : pass return s . apply ( lambda x : mod . __dict__ [ x [ 'names' ]]() . __hdict__ , axis = 1 ) def actions_schemata ( ftype = None , actions = None ): if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ]))) . to_dict () return s @property def schemata ( self ): self . __test_del__ () if self . __actions_schemata__ is None : self . __actions_schemata__ = HFeature . actions_schemata ( self . ftype )[ self . ftype ] return self . __actions_schemata__ def create ( ftype , ** kwargs ): return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) def retrive ( uuid ): try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) def retrive_label ( label ): feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ] . squeeze () if isinstance ( uuid , str ): return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of { label !r} not found.' ) def update ( uuid , ** kwargs ): try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) def update_label ( uuid , ** kwargs ): feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ] . squeeze () if isinstance ( uuid , str ): return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of { label !r} not found.' ) def drop ( uuid ): HFeature . retrive ( uuid ) . delete () def __featureFactory__ ( uuid = None , ftype = None , ** kwargs ): tosetup = uuid is None geometry = None try : if kwargs [ 'geometry' ]: geometry = kwargs [ 'geometry' ] except KeyError as e : pass kwargs = { k : w for k , w in kwargs . items () if k in db [ 'features' ] . columns } if tosetup : if ftype is None : raise ValueError ( \"Both uuid and ftype are None\" ) kwargs [ \"ftype\" ] = ftype uuid = newuuid () try : uuid = uuid . uuid except Exception as e : pass if kwargs . __len__ (): try : if not kwargs [ 'context' ]: raise KeyError () except KeyError : kwargs [ 'context' ] = 'no-context' db [ 'features' ][ uuid ] = kwargs if geometry : db [ 'features_geometry' ][ uuid ] = { \"geometry\" : geometry } feature = db [ 'features' ][ uuid ] . to_dict ( orient = 'records' )[ 0 ] try : geometry = kwargs [ 'geometry' ] db [ 'features_geometry' ][ uuid ] = geometry except KeyError as e : pass except Exception as e : raise ValueError ( e ) out = HFeature . modules ( feature [ 'ftype' ]) . squeeze () . Feature ( feature ) if tosetup : ## SETUP AND RELOAD out . setup () feature = db [ 'features' ][ uuid ] . to_dict ( orient = 'records' )[ 0 ] out = HFeature . modules ( feature [ 'ftype' ]) . squeeze () . Feature ( feature ) return out class __ParamManager__ (): def __init__ ( self , feature ): self . feature = feature self . parameters = None def set ( self , param , ordinal = None , ** setups ): \"\"\" CASO 1) La serie esiste e ma non \u00e8 associata alla feature (ALIAS in questo caso non riconfiguro - invece s\u00ec) CASO 2) La serie esiste \u00e8 gi\u00e0 associata alla feature e deve essere riconfigurata CASO 3) La serie non esiste e deve essere configurata \"\"\" ser = None alias = True ##### # QUI INSERIRE LA SCELTA DELLA TABELLA IN FASE DI SET try : setups [ 'datatable' ] except Exception as e : try : db [ self . feature . context ] setups [ 'datatable' ] = self . feature . context except Exception as e : pass ##### if self . parameters is None : self . __demand__ () try : # TEST CASO 1 assert setups [ 'operator' ] == '__ALIAS__' except Exception as e : alias = False if alias : ser = HSeries ( setups [ 'operands' ][ '__ALIAS__' ], delayed = False ) #NON DEVE ESSERE RICONFIGURATO IL MODELLO DI CALCOLO try : setups . pop ( 'operator' ) except Exception as e : pass try : setups . pop ( 'operands' ) except Exception as e : pass try : setups . pop ( 'modules' ) except Exception as e : pass else : try : # TEST CASO 2 ser = self [ param ] except Exception as e : pass try : # SE E' GIA ASSOCIATA ALLA FEATURE CANCELLO CACHE ser . clean_cache () except AttributeError as e : pass # RICONFIURO SERIE ser = HSeries . setup ( uuid = ser , ** setups ) # QUI ser \u00e8 completamnte definito self [ param ] = { \"series\" : ser , \"ordinal\" : ordinal } def __len__ ( self ): if self . parameters is None : self . __demand__ () return self . parameters . __len__ () def __demand__ ( self ): try : p = db [ 'features_parameters' ][ self . feature . uuid ][ 'series' ] . droplevel ( 'feature' ) . to_frame () p . columns = [ 'uuid' ] self . parameters = p . apply ( lambda x : HSeries ( ** x ) , axis = 1 ) . to_dict () except KeyError as e : self . parameters = {} def __getitem__ ( self , param ): if self . parameters is None : self . __demand__ () return self . parameters [ param ] def __setitem__ ( self , param , series ): try : ordinal = series [ 'ordinal' ] except Exception as e : ordinal = None try : series = series [ 'series' ] except Exception as e : pass try : series = series . uuid except Exception as e : pass db [ 'features_parameters' ][( self . feature . uuid , param )] = { \"series\" : series , \"ordinal\" : ordinal } self . __demand__ () def pop ( self , param ): try : out = db [ 'features_parameters' ] . pop (( self . feature . uuid , param )) self . __demand__ () return out except KeyError : return None def __repr__ ( self ): self . __demand__ () return self . parameters . __repr__ () def __init__ ( self , feature ): if not isinstance ( feature , dict ): try : feature = db [ 'features' ][ feature ] . to_dict ( orient = 'records' )[ 0 ] except Exception : raise ValueError ( feature ) self . __dict__ . update ( feature ) self . parameters = HFeature . __ParamManager__ ( self ) self . __geometry = None self . __deleted__ = False self . __actions_schemata__ = None def __test_del__ ( self ): if self . __deleted__ : raise Exception ( 'deleted' ) def __repr__ ( self ): self . __test_del__ () return self . __dict__ . __repr__ () @property def geometry ( self ): self . __test_del__ () if self . __geometry is None : try : self . __geometry = db [ 'features_geometry' ][ self . uuid ][ 'geometry' ] . squeeze () except Exception as e : self . __geometry = None return self . __geometry def delete ( self ): self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ] . pop ( self . uuid ) except KeyError as e : pass db [ 'features' ] . pop ( self . uuid ) self . __deleted__ = True return out def truncate_params ( self , params = None ): try : p_series = list ( self . parameters . pop ( params )[ 'series' ]) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series def cleanCache ( self , params = None ): self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ] . values return db [ 'datacache' ] . pop ( list ( params )) except KeyError : return None def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \" { action . capitalize () } Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e @abstractmethod def setup ( self , * args , ** kwargs ): pass \"\"\" def getActionValues(self,action=None,timestamp=None): if action is None: action=slice(None,None) if timestamp is None: timestamp=slice(None,None) try: out = db['actions'][self.uid,action,timestamp] if not isinstance(out,list): out = [out] except KeyError: return [] return out def lastActionBefore(self,action,timestamp=None): c=self.getActionValues(action,slice(None,timestamp,None)) try: c=c[-1] try: return c['value'] except KeyError: return c except Exception as e: return None def deleteActionValues(self, action=None, timestamp=None): out=self.getActionValues(action,timestamp) if not isinstance(out,list): out=[out] for act in out: a=act['action'] t=act['timestamp'] try: self.__getattribute__(f\"clean{a.capitalize()}\")(t) except Exception as e: traceback.print_exc() pass try: db['actions'][self.uid,a,t]=None except Exception as e: raise ValueError(e) return out \"\"\" Variables db isnat Classes HFeature class HFeature ( feature ) Helper class that provides a standard way to create an ABC using inheritance. View Source class HFeature ( ABC ) : @abstractmethod def config ( * args , ** kwargs ) : pass def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) def __schemata__ ( mod , actions = None ) : print ( mod ) s = DataFrame ( mod . __all__ ) s . columns =[ 'names' ] s = s [ s['names' ] . str . contains ( \"Schema\" ) ] s . index = s [ \"names\" ] . str . replace ( \"Schema\" , \"\" ). str . lower () s = s . loc [ actions ] try : s = s . to_frame (). T s . index . name = 'names' except Exception : pass return s . apply ( lambda x : mod . __dict__ [ x['names' ] ] (). __hdict__ , axis = 1 ) def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ). apply ( HFeature . __schemata__ , actions = actions ). stack () s . name = 'info' s = s . reset_index (). set_index ( 'label' ) s = s . groupby ( 'label' ). apply ( lambda x : dict ( zip ( x [ \"names\" ] , x [ \"info\" ] ))). to_dict () return s @property def schemata ( self ) : self . __test_del__ () if self . __actions_schemata__ is None : self . __actions_schemata__ = HFeature . actions_schemata ( self . ftype ) [ self.ftype ] return self . __actions_schemata__ def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) def retrive_label ( label ) : feats = db [ 'features' ][ : ] uuid = feats [ feats['label' ]== label ] [ 'uuid' ] . squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][ : ] uuid = feats [ feats['label' ]== label ] [ 'uuid' ] . squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) def drop ( uuid ) : HFeature . retrive ( uuid ). delete () def __featureFactory__ ( uuid = None , ftype = None , ** kwargs ) : tosetup = uuid is None geometry = None try : if kwargs [ 'geometry' ] : geometry = kwargs [ 'geometry' ] except KeyError as e : pass kwargs = { k : w for k , w in kwargs . items () if k in db [ 'features' ] . columns } if tosetup : if ftype is None : raise ValueError ( \"Both uuid and ftype are None\" ) kwargs [ \"ftype\" ]= ftype uuid = newuuid () try : uuid = uuid . uuid except Exception as e : pass if kwargs . __len__ () : try : if not kwargs [ 'context' ] : raise KeyError () except KeyError : kwargs [ 'context' ]= 'no-context' db [ 'features' ][ uuid ]= kwargs if geometry : db [ 'features_geometry' ][ uuid ]= { \"geometry\" : geometry } feature = db [ 'features' ][ uuid ] . to_dict ( orient = 'records' ) [ 0 ] try : geometry = kwargs [ 'geometry' ] db [ 'features_geometry' ][ uuid ]= geometry except KeyError as e : pass except Exception as e : raise ValueError ( e ) out = HFeature . modules ( feature [ 'ftype' ] ). squeeze (). Feature ( feature ) if tosetup : ## SETUP AND RELOAD out . setup () feature = db [ 'features' ][ uuid ] . to_dict ( orient = 'records' ) [ 0 ] out = HFeature . modules ( feature [ 'ftype' ] ). squeeze (). Feature ( feature ) return out class __ParamManager__ () : def __init__ ( self , feature ) : self . feature = feature self . parameters = None def set ( self , param , ordinal = None , ** setups ) : \"\"\" CASO 1) La serie esiste e ma non \u00e8 associata alla feature (ALIAS in questo caso non riconfiguro - invece s\u00ec) CASO 2) La serie esiste \u00e8 gi\u00e0 associata alla feature e deve essere riconfigurata CASO 3) La serie non esiste e deve essere configurata \"\"\" ser = None alias = True ##### # QUI INSERIRE LA SCELTA DELLA TABELLA IN FASE DI SET try : setups [ 'datatable' ] except Exception as e : try : db [ self.feature.context ] setups [ 'datatable' ] = self . feature . context except Exception as e : pass ##### if self . parameters is None : self . __demand__ () try : # TEST CASO 1 assert setups [ 'operator' ] == '__ALIAS__' except Exception as e : alias = False if alias : ser = HSeries ( setups [ 'operands' ][ '__ALIAS__' ] , delayed = False ) #NON DEVE ESSERE RICONFIGURATO IL MODELLO DI CALCOLO try : setups . pop ( 'operator' ) except Exception as e : pass try : setups . pop ( 'operands' ) except Exception as e : pass try : setups . pop ( 'modules' ) except Exception as e : pass else : try : # TEST CASO 2 ser = self [ param ] except Exception as e : pass try : # SE E ' GIA ASSOCIATA ALLA FEATURE CANCELLO CACHE ser.clean_cache() except AttributeError as e: pass # RICONFIURO SERIE ser=HSeries.setup(uuid=ser,**setups) # QUI ser \u00e8 completamnte definito self[param]={\"series\":ser, \"ordinal\":ordinal} def __len__(self): if self.parameters is None: self.__demand__() return self.parameters.__len__() def __demand__(self): try: p=db[' features_parameters '][self.feature.uuid][' series '].droplevel(' feature ').to_frame() p.columns=[' uuid '] self.parameters=p.apply(lambda x: HSeries(**x) ,axis=1).to_dict() except KeyError as e: self.parameters = {} def __getitem__(self, param): if self.parameters is None: self.__demand__() return self.parameters[param] def __setitem__(self, param, series): try: ordinal=series[' ordinal '] except Exception as e: ordinal=None try: series=series[' series '] except Exception as e: pass try: series=series.uuid except Exception as e: pass db[' features_parameters '][(self.feature.uuid,param)]={\"series\":series,\"ordinal\":ordinal} self.__demand__() def pop(self,param): try: out=db[' features_parameters '].pop((self.feature.uuid,param)) self.__demand__() return out except KeyError: return None def __repr__(self): self.__demand__() return self.parameters.__repr__() def __init__(self, feature): if not isinstance(feature,dict): try: feature=db[' features '][feature].to_dict(orient=' records ')[0] except Exception: raise ValueError(feature) self.__dict__.update(feature) self.parameters=HFeature.__ParamManager__(self) self.__geometry=None self.__deleted__=False self.__actions_schemata__=None def __test_del__(self): if self.__deleted__: raise Exception(' deleted ') def __repr__(self): self.__test_del__() return self.__dict__.__repr__() @property def geometry(self): self.__test_del__() if self.__geometry is None: try: self.__geometry=db[' features_geometry '][self.uuid][' geometry '].squeeze() except Exception as e: self.__geometry = None return self.__geometry def delete(self): self.__test_del__() out=self.__dict__ self.cleanCache() self.parameters.pop(None) try: db[' features_geometry '].pop(self.uuid) except KeyError as e: pass db[' features '].pop(self.uuid) self.__deleted__ = True return out def truncate_params(self,params=None): try: p_series=list(self.parameters.pop(params)[' series ']) self.cleanCache(p_series) except Exception: p_series=[] return p_series def cleanCache(self,params=None): self.__test_del__() try: params=db[' features_parameters '][self.uuid,params][' series '].values return db[' datacache '].pop(list(params)) except KeyError: return None def execute(self,action,**kwargs): self.__test_del__() try: mod=import_module(self.__module__) klass=mod.__getattribute__(f\"{action.capitalize()}Schema\") kwargs=klass().load(kwargs) return self.__getattribute__(action)(**kwargs) except Exception as e: raise e @abstractmethod def setup(self,*args,**kwargs): pass \"\"\" def getActionValues(self,action=None,timestamp=None): if action is None: action=slice(None,None) if timestamp is None: timestamp=slice(None,None) try: out = db[' actions '][self.uid,action,timestamp] if not isinstance(out,list): out = [out] except KeyError: return [] return out def lastActionBefore(self,action,timestamp=None): c=self.getActionValues(action,slice(None,timestamp,None)) try: c=c[-1] try: return c[' value '] except KeyError: return c except Exception as e: return None def deleteActionValues(self, action=None, timestamp=None): out=self.getActionValues(action,timestamp) if not isinstance(out,list): out=[out] for act in out: a=act[' action '] t=act[' timestamp '] try: self.__getattribute__(f\"clean{a.capitalize()}\")(t) except Exception as e: traceback.print_exc() pass try: db[' actions '] [ self.uid,a,t ]= None except Exception as e : raise ValueError ( e ) return out \"\" \" Ancestors (in MRO) abc.ABC Descendants Feature_instrument.Feature Feature_instrument.Feature hielen3.ext.feature_instrument_clinometer.feature.Feature hielen3.ext.feature_instrument_generic.feature.Feature hielen3.ext.feature_instrument_improved.feature.Feature hielen3.ext.feature_instrument_piezometer.feature.Feature hielen3.ext.feature_logger_boviar.logger.Feature hielen3.ext.feature_logger_capetti.logger.Feature hielen3.ext.feature_logger_gestecno.logger.Feature hielen3.ext.feature_logger_move.logger.Feature hielen3.ext.feature_logger_move__.logger.Feature hielen3.ext.feature_logger_move__.feature_logger_move.logger.Feature hielen3.ext.feature_logger_omnialog_temp.logger.Feature hielen3.ext.feature_logger_smartbrik4_0.logger.Feature hielen3.ext.feature_logger_winecap.logger.Feature hielen3.ext.feature_rfilogger.rfilogger.Feature hielen3.ext.feature_rfilogger.rfilogger_good.Feature hielen3.ext.feature_spotted_files_source.logger.Feature Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( * args , ** kwargs ) View Source @abstractmethod def config ( * args , ** kwargs ) : pass create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , * args , ** kwargs ) View Source @abstractmethod def setup ( self , * args , ** kwargs ) : pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) StringTime class StringTime ( format : 'str | None' = None , ** kwargs ) A formatted datetime string. Example: '2014-12-22T03:12:58.019077+00:00' Attributes Name Type Description Default format None Either \"rfc\" (for RFC822), \"iso\" (for ISO8601), \"timestamp\" , \"timestamp_ms\" (for a POSIX timestamp) or a date format string. If None , defaults to \"iso\". \"iso\" kwargs None The same keyword arguments that :class: Field receives. .. versionchanged:: 3.0.0rc9 Does not modify timezone information on (de)serialization. .. versionchanged:: 3.19 Add timestamp as a format. None View Source class StringTime ( fields . DateTime ): def _deserialize ( self , value , attr , data , ** kwargs ): return str ( super (). _deserialize ( value , attr , data , ** kwargs )) def _serialize ( self , value , attr , obj , ** kwargs ): return _agoodtime ( value ) Ancestors (in MRO) marshmallow.fields.DateTime marshmallow.fields.Field marshmallow.base.FieldABC Class variables DEFAULT_FORMAT DESERIALIZATION_FUNCS OBJ_TYPE SCHEMA_OPTS_VAR_NAME SERIALIZATION_FUNCS default_error_messages name parent root Instance variables context The context dictionary for the parent :class: Schema . default missing Methods deserialize def deserialize ( self , value : 'typing.Any' , attr : 'str | None' = None , data : 'typing.Mapping[str, typing.Any] | None' = None , ** kwargs ) Deserialize value . Parameters: Name Type Description Default value None The value to deserialize. None attr None The attribute/key in data to deserialize. None data None The raw input data passed to Schema.load . None kwargs None Field-specific keyword arguments. None Raises: Type Description ValidationError If an invalid value is passed or if a required value is missing. View Source def deserialize ( self , value : typing . Any , attr : str | None = None , data : typing . Mapping [ str , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Deserialize ``value``. :param value: The value to deserialize. :param attr: The attribute/key in `data` to deserialize. :param data: The raw input data passed to `Schema.load`. :param kwargs: Field-specific keyword arguments. :raise ValidationError: If an invalid value is passed or if a required value is missing. \"\" \" # Validate required fields, deserialize, then validate # deserialized value self . _validate_missing ( value ) if value is missing_ : _miss = self . load_default return _miss () if callable ( _miss ) else _miss if self . allow_none and value is None : return None output = self . _deserialize ( value , attr , data , ** kwargs ) self . _validate ( output ) return output fail def fail ( self , key : 'str' , ** kwargs ) Helper method that raises a ValidationError with an error message from self.error_messages . View Source def fail ( self , key : str , ** kwargs ) : \" \"\" Helper method that raises a `ValidationError` with an error message from ``self.error_messages``. .. deprecated:: 3.0.0 Use `make_error <marshmallow.fields.Field.make_error>` instead. \"\" \" warnings . warn ( '`Field.fail` is deprecated. Use `raise self.make_error(\"{}\", ...)` instead.' . format ( key ), RemovedInMarshmallow4Warning , stacklevel = 2 , ) raise self . make_error ( key = key , ** kwargs ) get_value def get_value ( self , obj , attr , accessor = None , default =< marshmallow . missing > ) Return the value for a given key from an object. Parameters: Name Type Description Default obj object The object to get the value from. None attr str The attribute/key in obj to get the value from. None accessor callable A callable used to retrieve the value of attr from the object obj . Defaults to marshmallow.utils.get_value . None View Source def get_value ( self , obj , attr , accessor = None , default = missing_ ) : \" \"\" Return the value for a given key from an object. :param object obj: The object to get the value from. :param str attr: The attribute/key in `obj` to get the value from. :param callable accessor: A callable used to retrieve the value of `attr` from the object `obj`. Defaults to `marshmallow.utils.get_value`. \"\" \" accessor_func = accessor or utils . get_value check_key = attr if self . attribute is None else self . attribute return accessor_func ( obj , check_key , default ) make_error def make_error ( self , key : 'str' , ** kwargs ) -> 'ValidationError' Helper method to make a ValidationError with an error message from self.error_messages . View Source def make_error ( self , key : str , ** kwargs ) -> ValidationError : \" \"\" Helper method to make a `ValidationError` with an error message from ``self.error_messages``. \"\" \" try : msg = self . error_messages [ key ] except KeyError as error : class_name = self . __class__ . __name__ message = ( \"ValidationError raised by `{class_name}`, but error key `{key}` does \" \"not exist in the `error_messages` dictionary.\" ). format ( class_name = class_name , key = key ) raise AssertionError ( message ) from error if isinstance ( msg , ( str , bytes )) : msg = msg . format ( ** kwargs ) return ValidationError ( msg ) serialize def serialize ( self , attr : 'str' , obj : 'typing.Any' , accessor : 'typing.Callable[[typing.Any, str, typing.Any], typing.Any] | None' = None , ** kwargs ) Pulls the value for the given key from the object, applies the field's formatting and returns the result. Parameters: Name Type Description Default attr None The attribute/key to get from the object. None obj None The object to access the attribute/key from. None accessor None Function used to access values from obj . None kwargs None Field-specific keyword arguments. None View Source def serialize ( self , attr : str , obj : typing . Any , accessor : typing . Callable [[ typing . Any , str , typing . Any ] , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Pulls the value for the given key from the object, applies the field's formatting and returns the result. :param attr: The attribute/key to get from the object. :param obj: The object to access the attribute/key from. :param accessor: Function used to access values from ``obj``. :param kwargs: Field-specific keyword arguments. \"\" \" if self . _CHECK_ATTRIBUTE : value = self . get_value ( obj , attr , accessor = accessor ) if value is missing_ : default = self . dump_default value = default () if callable ( default ) else default if value is missing_ : return value else : value = None return self . _serialize ( value , attr , obj , ** kwargs )","title":"Feature"},{"location":"reference/hielen3/feature/#module-hielen3feature","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 #!/usr/bin/env python # coding=utf-8 from abc import ABC , abstractmethod from importlib import import_module from hielen3 import db from hielen3.utils import uuid as newuuid from hielen3.series import HSeries from marshmallow import fields from numpy import datetime64 , isnat from pandas import DataFrame from MySQLdb._exceptions import ProgrammingError import traceback def _agoodtime ( t ): try : t = datetime64 ( t ) assert not isnat ( t ) t = str ( t ) except Exception as e : t = None return t class StringTime ( fields . DateTime ): def _deserialize ( self , value , attr , data , ** kwargs ): return str ( super () . _deserialize ( value , attr , data , ** kwargs )) def _serialize ( self , value , attr , obj , ** kwargs ): return _agoodtime ( value ) class HFeature ( ABC ): @abstractmethod def config ( * args , ** kwargs ): pass def modules ( ftype = None ): r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) def __schemata__ ( mod , actions = None ): print ( mod ) s = DataFrame ( mod . __all__ ) s . columns = [ 'names' ] s = s [ s [ 'names' ] . str . contains ( \"Schema\" )] s . index = s [ \"names\" ] . str . replace ( \"Schema\" , \"\" ) . str . lower () s = s . loc [ actions ] try : s = s . to_frame () . T s . index . name = 'names' except Exception : pass return s . apply ( lambda x : mod . __dict__ [ x [ 'names' ]]() . __hdict__ , axis = 1 ) def actions_schemata ( ftype = None , actions = None ): if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ]))) . to_dict () return s @property def schemata ( self ): self . __test_del__ () if self . __actions_schemata__ is None : self . __actions_schemata__ = HFeature . actions_schemata ( self . ftype )[ self . ftype ] return self . __actions_schemata__ def create ( ftype , ** kwargs ): return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) def retrive ( uuid ): try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) def retrive_label ( label ): feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ] . squeeze () if isinstance ( uuid , str ): return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of { label !r} not found.' ) def update ( uuid , ** kwargs ): try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) def update_label ( uuid , ** kwargs ): feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ] . squeeze () if isinstance ( uuid , str ): return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of { label !r} not found.' ) def drop ( uuid ): HFeature . retrive ( uuid ) . delete () def __featureFactory__ ( uuid = None , ftype = None , ** kwargs ): tosetup = uuid is None geometry = None try : if kwargs [ 'geometry' ]: geometry = kwargs [ 'geometry' ] except KeyError as e : pass kwargs = { k : w for k , w in kwargs . items () if k in db [ 'features' ] . columns } if tosetup : if ftype is None : raise ValueError ( \"Both uuid and ftype are None\" ) kwargs [ \"ftype\" ] = ftype uuid = newuuid () try : uuid = uuid . uuid except Exception as e : pass if kwargs . __len__ (): try : if not kwargs [ 'context' ]: raise KeyError () except KeyError : kwargs [ 'context' ] = 'no-context' db [ 'features' ][ uuid ] = kwargs if geometry : db [ 'features_geometry' ][ uuid ] = { \"geometry\" : geometry } feature = db [ 'features' ][ uuid ] . to_dict ( orient = 'records' )[ 0 ] try : geometry = kwargs [ 'geometry' ] db [ 'features_geometry' ][ uuid ] = geometry except KeyError as e : pass except Exception as e : raise ValueError ( e ) out = HFeature . modules ( feature [ 'ftype' ]) . squeeze () . Feature ( feature ) if tosetup : ## SETUP AND RELOAD out . setup () feature = db [ 'features' ][ uuid ] . to_dict ( orient = 'records' )[ 0 ] out = HFeature . modules ( feature [ 'ftype' ]) . squeeze () . Feature ( feature ) return out class __ParamManager__ (): def __init__ ( self , feature ): self . feature = feature self . parameters = None def set ( self , param , ordinal = None , ** setups ): \"\"\" CASO 1) La serie esiste e ma non \u00e8 associata alla feature (ALIAS in questo caso non riconfiguro - invece s\u00ec) CASO 2) La serie esiste \u00e8 gi\u00e0 associata alla feature e deve essere riconfigurata CASO 3) La serie non esiste e deve essere configurata \"\"\" ser = None alias = True ##### # QUI INSERIRE LA SCELTA DELLA TABELLA IN FASE DI SET try : setups [ 'datatable' ] except Exception as e : try : db [ self . feature . context ] setups [ 'datatable' ] = self . feature . context except Exception as e : pass ##### if self . parameters is None : self . __demand__ () try : # TEST CASO 1 assert setups [ 'operator' ] == '__ALIAS__' except Exception as e : alias = False if alias : ser = HSeries ( setups [ 'operands' ][ '__ALIAS__' ], delayed = False ) #NON DEVE ESSERE RICONFIGURATO IL MODELLO DI CALCOLO try : setups . pop ( 'operator' ) except Exception as e : pass try : setups . pop ( 'operands' ) except Exception as e : pass try : setups . pop ( 'modules' ) except Exception as e : pass else : try : # TEST CASO 2 ser = self [ param ] except Exception as e : pass try : # SE E' GIA ASSOCIATA ALLA FEATURE CANCELLO CACHE ser . clean_cache () except AttributeError as e : pass # RICONFIURO SERIE ser = HSeries . setup ( uuid = ser , ** setups ) # QUI ser \u00e8 completamnte definito self [ param ] = { \"series\" : ser , \"ordinal\" : ordinal } def __len__ ( self ): if self . parameters is None : self . __demand__ () return self . parameters . __len__ () def __demand__ ( self ): try : p = db [ 'features_parameters' ][ self . feature . uuid ][ 'series' ] . droplevel ( 'feature' ) . to_frame () p . columns = [ 'uuid' ] self . parameters = p . apply ( lambda x : HSeries ( ** x ) , axis = 1 ) . to_dict () except KeyError as e : self . parameters = {} def __getitem__ ( self , param ): if self . parameters is None : self . __demand__ () return self . parameters [ param ] def __setitem__ ( self , param , series ): try : ordinal = series [ 'ordinal' ] except Exception as e : ordinal = None try : series = series [ 'series' ] except Exception as e : pass try : series = series . uuid except Exception as e : pass db [ 'features_parameters' ][( self . feature . uuid , param )] = { \"series\" : series , \"ordinal\" : ordinal } self . __demand__ () def pop ( self , param ): try : out = db [ 'features_parameters' ] . pop (( self . feature . uuid , param )) self . __demand__ () return out except KeyError : return None def __repr__ ( self ): self . __demand__ () return self . parameters . __repr__ () def __init__ ( self , feature ): if not isinstance ( feature , dict ): try : feature = db [ 'features' ][ feature ] . to_dict ( orient = 'records' )[ 0 ] except Exception : raise ValueError ( feature ) self . __dict__ . update ( feature ) self . parameters = HFeature . __ParamManager__ ( self ) self . __geometry = None self . __deleted__ = False self . __actions_schemata__ = None def __test_del__ ( self ): if self . __deleted__ : raise Exception ( 'deleted' ) def __repr__ ( self ): self . __test_del__ () return self . __dict__ . __repr__ () @property def geometry ( self ): self . __test_del__ () if self . __geometry is None : try : self . __geometry = db [ 'features_geometry' ][ self . uuid ][ 'geometry' ] . squeeze () except Exception as e : self . __geometry = None return self . __geometry def delete ( self ): self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ] . pop ( self . uuid ) except KeyError as e : pass db [ 'features' ] . pop ( self . uuid ) self . __deleted__ = True return out def truncate_params ( self , params = None ): try : p_series = list ( self . parameters . pop ( params )[ 'series' ]) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series def cleanCache ( self , params = None ): self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ] . values return db [ 'datacache' ] . pop ( list ( params )) except KeyError : return None def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \" { action . capitalize () } Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e @abstractmethod def setup ( self , * args , ** kwargs ): pass \"\"\" def getActionValues(self,action=None,timestamp=None): if action is None: action=slice(None,None) if timestamp is None: timestamp=slice(None,None) try: out = db['actions'][self.uid,action,timestamp] if not isinstance(out,list): out = [out] except KeyError: return [] return out def lastActionBefore(self,action,timestamp=None): c=self.getActionValues(action,slice(None,timestamp,None)) try: c=c[-1] try: return c['value'] except KeyError: return c except Exception as e: return None def deleteActionValues(self, action=None, timestamp=None): out=self.getActionValues(action,timestamp) if not isinstance(out,list): out=[out] for act in out: a=act['action'] t=act['timestamp'] try: self.__getattribute__(f\"clean{a.capitalize()}\")(t) except Exception as e: traceback.print_exc() pass try: db['actions'][self.uid,a,t]=None except Exception as e: raise ValueError(e) return out \"\"\"","title":"Module hielen3.feature"},{"location":"reference/hielen3/feature/#variables","text":"db isnat","title":"Variables"},{"location":"reference/hielen3/feature/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/feature/#hfeature","text":"class HFeature ( feature ) Helper class that provides a standard way to create an ABC using inheritance. View Source class HFeature ( ABC ) : @abstractmethod def config ( * args , ** kwargs ) : pass def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) def __schemata__ ( mod , actions = None ) : print ( mod ) s = DataFrame ( mod . __all__ ) s . columns =[ 'names' ] s = s [ s['names' ] . str . contains ( \"Schema\" ) ] s . index = s [ \"names\" ] . str . replace ( \"Schema\" , \"\" ). str . lower () s = s . loc [ actions ] try : s = s . to_frame (). T s . index . name = 'names' except Exception : pass return s . apply ( lambda x : mod . __dict__ [ x['names' ] ] (). __hdict__ , axis = 1 ) def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ). apply ( HFeature . __schemata__ , actions = actions ). stack () s . name = 'info' s = s . reset_index (). set_index ( 'label' ) s = s . groupby ( 'label' ). apply ( lambda x : dict ( zip ( x [ \"names\" ] , x [ \"info\" ] ))). to_dict () return s @property def schemata ( self ) : self . __test_del__ () if self . __actions_schemata__ is None : self . __actions_schemata__ = HFeature . actions_schemata ( self . ftype ) [ self.ftype ] return self . __actions_schemata__ def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) def retrive_label ( label ) : feats = db [ 'features' ][ : ] uuid = feats [ feats['label' ]== label ] [ 'uuid' ] . squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][ : ] uuid = feats [ feats['label' ]== label ] [ 'uuid' ] . squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) def drop ( uuid ) : HFeature . retrive ( uuid ). delete () def __featureFactory__ ( uuid = None , ftype = None , ** kwargs ) : tosetup = uuid is None geometry = None try : if kwargs [ 'geometry' ] : geometry = kwargs [ 'geometry' ] except KeyError as e : pass kwargs = { k : w for k , w in kwargs . items () if k in db [ 'features' ] . columns } if tosetup : if ftype is None : raise ValueError ( \"Both uuid and ftype are None\" ) kwargs [ \"ftype\" ]= ftype uuid = newuuid () try : uuid = uuid . uuid except Exception as e : pass if kwargs . __len__ () : try : if not kwargs [ 'context' ] : raise KeyError () except KeyError : kwargs [ 'context' ]= 'no-context' db [ 'features' ][ uuid ]= kwargs if geometry : db [ 'features_geometry' ][ uuid ]= { \"geometry\" : geometry } feature = db [ 'features' ][ uuid ] . to_dict ( orient = 'records' ) [ 0 ] try : geometry = kwargs [ 'geometry' ] db [ 'features_geometry' ][ uuid ]= geometry except KeyError as e : pass except Exception as e : raise ValueError ( e ) out = HFeature . modules ( feature [ 'ftype' ] ). squeeze (). Feature ( feature ) if tosetup : ## SETUP AND RELOAD out . setup () feature = db [ 'features' ][ uuid ] . to_dict ( orient = 'records' ) [ 0 ] out = HFeature . modules ( feature [ 'ftype' ] ). squeeze (). Feature ( feature ) return out class __ParamManager__ () : def __init__ ( self , feature ) : self . feature = feature self . parameters = None def set ( self , param , ordinal = None , ** setups ) : \"\"\" CASO 1) La serie esiste e ma non \u00e8 associata alla feature (ALIAS in questo caso non riconfiguro - invece s\u00ec) CASO 2) La serie esiste \u00e8 gi\u00e0 associata alla feature e deve essere riconfigurata CASO 3) La serie non esiste e deve essere configurata \"\"\" ser = None alias = True ##### # QUI INSERIRE LA SCELTA DELLA TABELLA IN FASE DI SET try : setups [ 'datatable' ] except Exception as e : try : db [ self.feature.context ] setups [ 'datatable' ] = self . feature . context except Exception as e : pass ##### if self . parameters is None : self . __demand__ () try : # TEST CASO 1 assert setups [ 'operator' ] == '__ALIAS__' except Exception as e : alias = False if alias : ser = HSeries ( setups [ 'operands' ][ '__ALIAS__' ] , delayed = False ) #NON DEVE ESSERE RICONFIGURATO IL MODELLO DI CALCOLO try : setups . pop ( 'operator' ) except Exception as e : pass try : setups . pop ( 'operands' ) except Exception as e : pass try : setups . pop ( 'modules' ) except Exception as e : pass else : try : # TEST CASO 2 ser = self [ param ] except Exception as e : pass try : # SE E ' GIA ASSOCIATA ALLA FEATURE CANCELLO CACHE ser.clean_cache() except AttributeError as e: pass # RICONFIURO SERIE ser=HSeries.setup(uuid=ser,**setups) # QUI ser \u00e8 completamnte definito self[param]={\"series\":ser, \"ordinal\":ordinal} def __len__(self): if self.parameters is None: self.__demand__() return self.parameters.__len__() def __demand__(self): try: p=db[' features_parameters '][self.feature.uuid][' series '].droplevel(' feature ').to_frame() p.columns=[' uuid '] self.parameters=p.apply(lambda x: HSeries(**x) ,axis=1).to_dict() except KeyError as e: self.parameters = {} def __getitem__(self, param): if self.parameters is None: self.__demand__() return self.parameters[param] def __setitem__(self, param, series): try: ordinal=series[' ordinal '] except Exception as e: ordinal=None try: series=series[' series '] except Exception as e: pass try: series=series.uuid except Exception as e: pass db[' features_parameters '][(self.feature.uuid,param)]={\"series\":series,\"ordinal\":ordinal} self.__demand__() def pop(self,param): try: out=db[' features_parameters '].pop((self.feature.uuid,param)) self.__demand__() return out except KeyError: return None def __repr__(self): self.__demand__() return self.parameters.__repr__() def __init__(self, feature): if not isinstance(feature,dict): try: feature=db[' features '][feature].to_dict(orient=' records ')[0] except Exception: raise ValueError(feature) self.__dict__.update(feature) self.parameters=HFeature.__ParamManager__(self) self.__geometry=None self.__deleted__=False self.__actions_schemata__=None def __test_del__(self): if self.__deleted__: raise Exception(' deleted ') def __repr__(self): self.__test_del__() return self.__dict__.__repr__() @property def geometry(self): self.__test_del__() if self.__geometry is None: try: self.__geometry=db[' features_geometry '][self.uuid][' geometry '].squeeze() except Exception as e: self.__geometry = None return self.__geometry def delete(self): self.__test_del__() out=self.__dict__ self.cleanCache() self.parameters.pop(None) try: db[' features_geometry '].pop(self.uuid) except KeyError as e: pass db[' features '].pop(self.uuid) self.__deleted__ = True return out def truncate_params(self,params=None): try: p_series=list(self.parameters.pop(params)[' series ']) self.cleanCache(p_series) except Exception: p_series=[] return p_series def cleanCache(self,params=None): self.__test_del__() try: params=db[' features_parameters '][self.uuid,params][' series '].values return db[' datacache '].pop(list(params)) except KeyError: return None def execute(self,action,**kwargs): self.__test_del__() try: mod=import_module(self.__module__) klass=mod.__getattribute__(f\"{action.capitalize()}Schema\") kwargs=klass().load(kwargs) return self.__getattribute__(action)(**kwargs) except Exception as e: raise e @abstractmethod def setup(self,*args,**kwargs): pass \"\"\" def getActionValues(self,action=None,timestamp=None): if action is None: action=slice(None,None) if timestamp is None: timestamp=slice(None,None) try: out = db[' actions '][self.uid,action,timestamp] if not isinstance(out,list): out = [out] except KeyError: return [] return out def lastActionBefore(self,action,timestamp=None): c=self.getActionValues(action,slice(None,timestamp,None)) try: c=c[-1] try: return c[' value '] except KeyError: return c except Exception as e: return None def deleteActionValues(self, action=None, timestamp=None): out=self.getActionValues(action,timestamp) if not isinstance(out,list): out=[out] for act in out: a=act[' action '] t=act[' timestamp '] try: self.__getattribute__(f\"clean{a.capitalize()}\")(t) except Exception as e: traceback.print_exc() pass try: db[' actions '] [ self.uid,a,t ]= None except Exception as e : raise ValueError ( e ) return out \"\" \"","title":"HFeature"},{"location":"reference/hielen3/feature/#ancestors-in-mro","text":"abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/feature/#descendants","text":"Feature_instrument.Feature Feature_instrument.Feature hielen3.ext.feature_instrument_clinometer.feature.Feature hielen3.ext.feature_instrument_generic.feature.Feature hielen3.ext.feature_instrument_improved.feature.Feature hielen3.ext.feature_instrument_piezometer.feature.Feature hielen3.ext.feature_logger_boviar.logger.Feature hielen3.ext.feature_logger_capetti.logger.Feature hielen3.ext.feature_logger_gestecno.logger.Feature hielen3.ext.feature_logger_move.logger.Feature hielen3.ext.feature_logger_move__.logger.Feature hielen3.ext.feature_logger_move__.feature_logger_move.logger.Feature hielen3.ext.feature_logger_omnialog_temp.logger.Feature hielen3.ext.feature_logger_smartbrik4_0.logger.Feature hielen3.ext.feature_logger_winecap.logger.Feature hielen3.ext.feature_rfilogger.rfilogger.Feature hielen3.ext.feature_rfilogger.rfilogger_good.Feature hielen3.ext.feature_spotted_files_source.logger.Feature","title":"Descendants"},{"location":"reference/hielen3/feature/#instance-variables","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/feature/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/feature/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/feature/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/feature/#config","text":"def config ( * args , ** kwargs ) View Source @abstractmethod def config ( * args , ** kwargs ) : pass","title":"config"},{"location":"reference/hielen3/feature/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/feature/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/feature/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/feature/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/feature/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/feature/#retrive","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/feature/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/feature/#setup","text":"def setup ( self , * args , ** kwargs ) View Source @abstractmethod def setup ( self , * args , ** kwargs ) : pass","title":"setup"},{"location":"reference/hielen3/feature/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/feature/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/feature/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/feature/#stringtime","text":"class StringTime ( format : 'str | None' = None , ** kwargs ) A formatted datetime string. Example: '2014-12-22T03:12:58.019077+00:00'","title":"StringTime"},{"location":"reference/hielen3/feature/#attributes","text":"Name Type Description Default format None Either \"rfc\" (for RFC822), \"iso\" (for ISO8601), \"timestamp\" , \"timestamp_ms\" (for a POSIX timestamp) or a date format string. If None , defaults to \"iso\". \"iso\" kwargs None The same keyword arguments that :class: Field receives. .. versionchanged:: 3.0.0rc9 Does not modify timezone information on (de)serialization. .. versionchanged:: 3.19 Add timestamp as a format. None View Source class StringTime ( fields . DateTime ): def _deserialize ( self , value , attr , data , ** kwargs ): return str ( super (). _deserialize ( value , attr , data , ** kwargs )) def _serialize ( self , value , attr , obj , ** kwargs ): return _agoodtime ( value )","title":"Attributes"},{"location":"reference/hielen3/feature/#ancestors-in-mro_1","text":"marshmallow.fields.DateTime marshmallow.fields.Field marshmallow.base.FieldABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/feature/#class-variables","text":"DEFAULT_FORMAT DESERIALIZATION_FUNCS OBJ_TYPE SCHEMA_OPTS_VAR_NAME SERIALIZATION_FUNCS default_error_messages name parent root","title":"Class variables"},{"location":"reference/hielen3/feature/#instance-variables_1","text":"context The context dictionary for the parent :class: Schema . default missing","title":"Instance variables"},{"location":"reference/hielen3/feature/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/feature/#deserialize","text":"def deserialize ( self , value : 'typing.Any' , attr : 'str | None' = None , data : 'typing.Mapping[str, typing.Any] | None' = None , ** kwargs ) Deserialize value . Parameters: Name Type Description Default value None The value to deserialize. None attr None The attribute/key in data to deserialize. None data None The raw input data passed to Schema.load . None kwargs None Field-specific keyword arguments. None Raises: Type Description ValidationError If an invalid value is passed or if a required value is missing. View Source def deserialize ( self , value : typing . Any , attr : str | None = None , data : typing . Mapping [ str , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Deserialize ``value``. :param value: The value to deserialize. :param attr: The attribute/key in `data` to deserialize. :param data: The raw input data passed to `Schema.load`. :param kwargs: Field-specific keyword arguments. :raise ValidationError: If an invalid value is passed or if a required value is missing. \"\" \" # Validate required fields, deserialize, then validate # deserialized value self . _validate_missing ( value ) if value is missing_ : _miss = self . load_default return _miss () if callable ( _miss ) else _miss if self . allow_none and value is None : return None output = self . _deserialize ( value , attr , data , ** kwargs ) self . _validate ( output ) return output","title":"deserialize"},{"location":"reference/hielen3/feature/#fail","text":"def fail ( self , key : 'str' , ** kwargs ) Helper method that raises a ValidationError with an error message from self.error_messages . View Source def fail ( self , key : str , ** kwargs ) : \" \"\" Helper method that raises a `ValidationError` with an error message from ``self.error_messages``. .. deprecated:: 3.0.0 Use `make_error <marshmallow.fields.Field.make_error>` instead. \"\" \" warnings . warn ( '`Field.fail` is deprecated. Use `raise self.make_error(\"{}\", ...)` instead.' . format ( key ), RemovedInMarshmallow4Warning , stacklevel = 2 , ) raise self . make_error ( key = key , ** kwargs )","title":"fail"},{"location":"reference/hielen3/feature/#get_value","text":"def get_value ( self , obj , attr , accessor = None , default =< marshmallow . missing > ) Return the value for a given key from an object. Parameters: Name Type Description Default obj object The object to get the value from. None attr str The attribute/key in obj to get the value from. None accessor callable A callable used to retrieve the value of attr from the object obj . Defaults to marshmallow.utils.get_value . None View Source def get_value ( self , obj , attr , accessor = None , default = missing_ ) : \" \"\" Return the value for a given key from an object. :param object obj: The object to get the value from. :param str attr: The attribute/key in `obj` to get the value from. :param callable accessor: A callable used to retrieve the value of `attr` from the object `obj`. Defaults to `marshmallow.utils.get_value`. \"\" \" accessor_func = accessor or utils . get_value check_key = attr if self . attribute is None else self . attribute return accessor_func ( obj , check_key , default )","title":"get_value"},{"location":"reference/hielen3/feature/#make_error","text":"def make_error ( self , key : 'str' , ** kwargs ) -> 'ValidationError' Helper method to make a ValidationError with an error message from self.error_messages . View Source def make_error ( self , key : str , ** kwargs ) -> ValidationError : \" \"\" Helper method to make a `ValidationError` with an error message from ``self.error_messages``. \"\" \" try : msg = self . error_messages [ key ] except KeyError as error : class_name = self . __class__ . __name__ message = ( \"ValidationError raised by `{class_name}`, but error key `{key}` does \" \"not exist in the `error_messages` dictionary.\" ). format ( class_name = class_name , key = key ) raise AssertionError ( message ) from error if isinstance ( msg , ( str , bytes )) : msg = msg . format ( ** kwargs ) return ValidationError ( msg )","title":"make_error"},{"location":"reference/hielen3/feature/#serialize","text":"def serialize ( self , attr : 'str' , obj : 'typing.Any' , accessor : 'typing.Callable[[typing.Any, str, typing.Any], typing.Any] | None' = None , ** kwargs ) Pulls the value for the given key from the object, applies the field's formatting and returns the result. Parameters: Name Type Description Default attr None The attribute/key to get from the object. None obj None The object to access the attribute/key from. None accessor None Function used to access values from obj . None kwargs None Field-specific keyword arguments. None View Source def serialize ( self , attr : str , obj : typing . Any , accessor : typing . Callable [[ typing . Any , str , typing . Any ] , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Pulls the value for the given key from the object, applies the field's formatting and returns the result. :param attr: The attribute/key to get from the object. :param obj: The object to access the attribute/key from. :param accessor: Function used to access values from ``obj``. :param kwargs: Field-specific keyword arguments. \"\" \" if self . _CHECK_ATTRIBUTE : value = self . get_value ( obj , attr , accessor = accessor ) if value is missing_ : default = self . dump_default value = default () if callable ( default ) else default if value is missing_ : return value else : value = None return self . _serialize ( value , attr , obj , ** kwargs )","title":"serialize"},{"location":"reference/hielen3/mapmanager/","text":"Module hielen3.mapmanager View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 #!/usr/bin/env python # coding=utf-8 import mappyfile import re from hielen3 import conf from abc import ABC , abstractmethod from pathlib import Path from hielen3.sourcestorage import SourceStorage class Mapmanager ( ABC ): def __init__ ( self , feature , mapname , * args , ** kwargs ): subpath = Path ( feature ) / mapname self . mapbaseurl = Path ( conf [ 'mapurl' ] ) / subpath self . mapcache = SourceStorage ( conf [ 'syscache' ][ 'mapcache' ], str ( subpath )) @property def mapfile ( self ): return self . mapcache / \"mapfile.map\" @property def mapurl ( self ): return self . mapbaseurl / \"mapfile.map\" @abstractmethod def setMFparams (): pass @abstractmethod def geturl (): pass class Multiraster ( Mapmanager ): def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . maptype = 'multiraster' def setMFparams ( self , bands = 4 , scale = [ '0,255' , '0,255' , '0,255' , '0,255' ], crs = 'EPSG:3857' , lyrext = '-20026376.39 -20048966.10 20026376.39 20048966.10' , datadir = '' , um = 'METERS' , ows_onlineresources = \"http://pippo&\" ): inmapf = conf [ 'maptemplates' ][ self . maptype ] self . mapcache . mkdir () mapfile = mappyfile . open ( inmapf ) mapfile [ \"shapepath\" ] = datadir mapfile [ \"web\" ][ \"metadata\" ][ \"ows_onlineresource\" ] = ows_onlineresources if ( bands == 1 ): scale = [ '0,65536' ] layer = mapfile [ \"layers\" ][ 0 ] tbands = ',' . join ( map ( str ,( range ( 1 , bands + 1 )))) layer [ 'processing' ] = [ f 'BANDS= { tbands } ' ] for i in range ( 0 , bands ): layer [ 'processing' ] . append ( f \"SCALE_ { i + 1 } = { scale [ i ] } \" ) layer [ \"projection\" ] = f \"init= { str ( crs ) . lower () } \" try : um = um . upper () except Exception as e : pass if um is None or not um or um in [ 'UNKNOWN' ]: um = \"METERS\" layer [ \"units\" ] = re . sub ( 'METRES?' , 'METERS' , um . upper ()) layer [ \"metadata\" ][ \"ows_srs\" ] = str ( crs ) . upper () layer [ \"metadata\" ][ \"ows_extent\" ] = lyrext #layer[\"composite\"][\"opacity\"] = opacity mappyfile . save ( mapfile , self . mapfile , 2 ) def geturl ( self , imgname ): url = [ str ( self . mapbaseurl ), \"?SERVICE=WMS&VERSION=1.1.1\" , \"&imgfile=\" + str ( imgname ), \"&layers=imglyr\" , \"&transparent=true\" , \"&format=image/png\" , \"&mode=tile\" , \"&tilemode=gmap\" , \"&tile= {x} + {y} + {z} \" , ] #return urllib.parse.quote(\"\".join(url)) return \"\" . join ( url ) Variables conf Classes Mapmanager class Mapmanager ( feature , mapname , * args , ** kwargs ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Mapmanager ( ABC ) : def __init__ ( self , feature , mapname , * args , ** kwargs ) : subpath = Path ( feature ) / mapname self . mapbaseurl = Path ( conf [ 'mapurl' ] ) / subpath self . mapcache = SourceStorage ( conf [ 'syscache' ][ 'mapcache' ] , str ( subpath )) @property def mapfile ( self ) : return self . mapcache / \"mapfile.map\" @property def mapurl ( self ) : return self . mapbaseurl / \"mapfile.map\" @abstractmethod def setMFparams () : pass @abstractmethod def geturl () : pass Ancestors (in MRO) abc.ABC Descendants hielen3.mapmanager.Multiraster Instance variables mapfile mapurl Methods geturl def geturl ( ) View Source @abstractmethod def geturl () : pass setMFparams def setMFparams ( ) View Source @abstractmethod def setMFparams () : pass Multiraster class Multiraster ( * args , ** kwargs ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Multiraster ( Mapmanager ) : def __init__ ( self , * args , ** kwargs ) : super (). __init__ ( * args , ** kwargs ) self . maptype = 'multiraster' def setMFparams ( self , bands = 4 , scale =[ '0,255','0,255','0,255','0,255' ] , crs = 'EPSG:3857' , lyrext = '-20026376.39 -20048966.10 20026376.39 20048966.10' , datadir = '' , um = 'METERS' , ows_onlineresources = \"http://pippo&\" ) : inmapf = conf [ 'maptemplates' ][ self.maptype ] self . mapcache . mkdir () mapfile = mappyfile . open ( inmapf ) mapfile [ \"shapepath\" ] = datadir mapfile [ \"web\" ][ \"metadata\" ][ \"ows_onlineresource\" ] = ows_onlineresources if ( bands == 1 ) : scale =[ '0,65536' ] layer = mapfile [ \"layers\" ][ 0 ] tbands = ',' . join ( map ( str ,( range ( 1 , bands + 1 )))) layer [ 'processing' ]=[ f'BANDS={tbands}' ] for i in range ( 0 , bands ) : layer [ 'processing' ] . append ( f \"SCALE_{i+1}={scale[i]}\" ) layer [ \"projection\" ] = f \"init={str(crs).lower()}\" try : um = um . upper () except Exception as e : pass if um is None or not um or um in [ 'UNKNOWN' ] : um = \"METERS\" layer [ \"units\" ] = re . sub ( 'METRES?' , 'METERS' , um . upper ()) layer [ \"metadata\" ][ \"ows_srs\" ] = str ( crs ). upper () layer [ \"metadata\" ][ \"ows_extent\" ] = lyrext #layer [ \"composite\" ][ \"opacity\" ] = opacity mappyfile . save ( mapfile , self . mapfile , 2 ) def geturl ( self , imgname ) : url =[ str(self.mapbaseurl), \"?SERVICE=WMS&VERSION=1.1.1\", \"&imgfile=\"+ str(imgname), \"&layers=imglyr\", \"&transparent=true\", \"&format=image/png\", \"&mode=tile\", \"&tilemode=gmap\", \"&tile={x}+{y}+{z}\", ] #return urllib . parse . quote ( \"\" . join ( url )) return \"\" . join ( url ) Ancestors (in MRO) hielen3.mapmanager.Mapmanager abc.ABC Instance variables mapfile mapurl Methods geturl def geturl ( self , imgname ) View Source def geturl ( self , imgname ) : url = [ str ( self . mapbaseurl ) , \"?SERVICE=WMS&VERSION=1.1.1\" , \"&imgfile=\" + str ( imgname ) , \"&layers=imglyr\" , \"&transparent=true\" , \"&format=image/png\" , \"&mode=tile\" , \"&tilemode=gmap\" , \"&tile={x}+{y}+{z}\" , ] # return urllib . parse . quote ( \"\" . join ( url )) return \"\" . join ( url ) setMFparams def setMFparams ( self , bands = 4 , scale = [ '0,255' , '0,255' , '0,255' , '0,255' ], crs = 'EPSG:3857' , lyrext = '-20026376.39 -20048966.10 20026376.39 20048966.10' , datadir = '' , um = 'METERS' , ows_onlineresources = 'http://pippo&' ) View Source def setMFparams ( self , bands = 4 , scale =[ '0,255','0,255','0,255','0,255' ] , crs = 'EPSG:3857' , lyrext = '-20026376.39 -20048966.10 20026376.39 20048966.10' , datadir = '' , um = 'METERS' , ows_onlineresources = \"http://pippo&\" ) : inmapf = conf [ 'maptemplates' ][ self.maptype ] self . mapcache . mkdir () mapfile = mappyfile . open ( inmapf ) mapfile [ \"shapepath\" ] = datadir mapfile [ \"web\" ][ \"metadata\" ][ \"ows_onlineresource\" ] = ows_onlineresources if ( bands == 1 ) : scale =[ '0,65536' ] layer = mapfile [ \"layers\" ][ 0 ] tbands = ',' . join ( map ( str ,( range ( 1 , bands + 1 )))) layer [ 'processing' ]=[ f'BANDS={tbands}' ] for i in range ( 0 , bands ) : layer [ 'processing' ] . append ( f \"SCALE_{i+1}={scale[i]}\" ) layer [ \"projection\" ] = f \"init={str(crs).lower()}\" try : um = um . upper () except Exception as e : pass if um is None or not um or um in [ 'UNKNOWN' ] : um = \"METERS\" layer [ \"units\" ] = re . sub ( 'METRES?' , 'METERS' , um . upper ()) layer [ \"metadata\" ][ \"ows_srs\" ] = str ( crs ). upper () layer [ \"metadata\" ][ \"ows_extent\" ] = lyrext #layer [ \"composite\" ][ \"opacity\" ] = opacity mappyfile . save ( mapfile , self . mapfile , 2 )","title":"Mapmanager"},{"location":"reference/hielen3/mapmanager/#module-hielen3mapmanager","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 #!/usr/bin/env python # coding=utf-8 import mappyfile import re from hielen3 import conf from abc import ABC , abstractmethod from pathlib import Path from hielen3.sourcestorage import SourceStorage class Mapmanager ( ABC ): def __init__ ( self , feature , mapname , * args , ** kwargs ): subpath = Path ( feature ) / mapname self . mapbaseurl = Path ( conf [ 'mapurl' ] ) / subpath self . mapcache = SourceStorage ( conf [ 'syscache' ][ 'mapcache' ], str ( subpath )) @property def mapfile ( self ): return self . mapcache / \"mapfile.map\" @property def mapurl ( self ): return self . mapbaseurl / \"mapfile.map\" @abstractmethod def setMFparams (): pass @abstractmethod def geturl (): pass class Multiraster ( Mapmanager ): def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . maptype = 'multiraster' def setMFparams ( self , bands = 4 , scale = [ '0,255' , '0,255' , '0,255' , '0,255' ], crs = 'EPSG:3857' , lyrext = '-20026376.39 -20048966.10 20026376.39 20048966.10' , datadir = '' , um = 'METERS' , ows_onlineresources = \"http://pippo&\" ): inmapf = conf [ 'maptemplates' ][ self . maptype ] self . mapcache . mkdir () mapfile = mappyfile . open ( inmapf ) mapfile [ \"shapepath\" ] = datadir mapfile [ \"web\" ][ \"metadata\" ][ \"ows_onlineresource\" ] = ows_onlineresources if ( bands == 1 ): scale = [ '0,65536' ] layer = mapfile [ \"layers\" ][ 0 ] tbands = ',' . join ( map ( str ,( range ( 1 , bands + 1 )))) layer [ 'processing' ] = [ f 'BANDS= { tbands } ' ] for i in range ( 0 , bands ): layer [ 'processing' ] . append ( f \"SCALE_ { i + 1 } = { scale [ i ] } \" ) layer [ \"projection\" ] = f \"init= { str ( crs ) . lower () } \" try : um = um . upper () except Exception as e : pass if um is None or not um or um in [ 'UNKNOWN' ]: um = \"METERS\" layer [ \"units\" ] = re . sub ( 'METRES?' , 'METERS' , um . upper ()) layer [ \"metadata\" ][ \"ows_srs\" ] = str ( crs ) . upper () layer [ \"metadata\" ][ \"ows_extent\" ] = lyrext #layer[\"composite\"][\"opacity\"] = opacity mappyfile . save ( mapfile , self . mapfile , 2 ) def geturl ( self , imgname ): url = [ str ( self . mapbaseurl ), \"?SERVICE=WMS&VERSION=1.1.1\" , \"&imgfile=\" + str ( imgname ), \"&layers=imglyr\" , \"&transparent=true\" , \"&format=image/png\" , \"&mode=tile\" , \"&tilemode=gmap\" , \"&tile= {x} + {y} + {z} \" , ] #return urllib.parse.quote(\"\".join(url)) return \"\" . join ( url )","title":"Module hielen3.mapmanager"},{"location":"reference/hielen3/mapmanager/#variables","text":"conf","title":"Variables"},{"location":"reference/hielen3/mapmanager/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/mapmanager/#mapmanager","text":"class Mapmanager ( feature , mapname , * args , ** kwargs ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Mapmanager ( ABC ) : def __init__ ( self , feature , mapname , * args , ** kwargs ) : subpath = Path ( feature ) / mapname self . mapbaseurl = Path ( conf [ 'mapurl' ] ) / subpath self . mapcache = SourceStorage ( conf [ 'syscache' ][ 'mapcache' ] , str ( subpath )) @property def mapfile ( self ) : return self . mapcache / \"mapfile.map\" @property def mapurl ( self ) : return self . mapbaseurl / \"mapfile.map\" @abstractmethod def setMFparams () : pass @abstractmethod def geturl () : pass","title":"Mapmanager"},{"location":"reference/hielen3/mapmanager/#ancestors-in-mro","text":"abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/mapmanager/#descendants","text":"hielen3.mapmanager.Multiraster","title":"Descendants"},{"location":"reference/hielen3/mapmanager/#instance-variables","text":"mapfile mapurl","title":"Instance variables"},{"location":"reference/hielen3/mapmanager/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/mapmanager/#geturl","text":"def geturl ( ) View Source @abstractmethod def geturl () : pass","title":"geturl"},{"location":"reference/hielen3/mapmanager/#setmfparams","text":"def setMFparams ( ) View Source @abstractmethod def setMFparams () : pass","title":"setMFparams"},{"location":"reference/hielen3/mapmanager/#multiraster","text":"class Multiraster ( * args , ** kwargs ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Multiraster ( Mapmanager ) : def __init__ ( self , * args , ** kwargs ) : super (). __init__ ( * args , ** kwargs ) self . maptype = 'multiraster' def setMFparams ( self , bands = 4 , scale =[ '0,255','0,255','0,255','0,255' ] , crs = 'EPSG:3857' , lyrext = '-20026376.39 -20048966.10 20026376.39 20048966.10' , datadir = '' , um = 'METERS' , ows_onlineresources = \"http://pippo&\" ) : inmapf = conf [ 'maptemplates' ][ self.maptype ] self . mapcache . mkdir () mapfile = mappyfile . open ( inmapf ) mapfile [ \"shapepath\" ] = datadir mapfile [ \"web\" ][ \"metadata\" ][ \"ows_onlineresource\" ] = ows_onlineresources if ( bands == 1 ) : scale =[ '0,65536' ] layer = mapfile [ \"layers\" ][ 0 ] tbands = ',' . join ( map ( str ,( range ( 1 , bands + 1 )))) layer [ 'processing' ]=[ f'BANDS={tbands}' ] for i in range ( 0 , bands ) : layer [ 'processing' ] . append ( f \"SCALE_{i+1}={scale[i]}\" ) layer [ \"projection\" ] = f \"init={str(crs).lower()}\" try : um = um . upper () except Exception as e : pass if um is None or not um or um in [ 'UNKNOWN' ] : um = \"METERS\" layer [ \"units\" ] = re . sub ( 'METRES?' , 'METERS' , um . upper ()) layer [ \"metadata\" ][ \"ows_srs\" ] = str ( crs ). upper () layer [ \"metadata\" ][ \"ows_extent\" ] = lyrext #layer [ \"composite\" ][ \"opacity\" ] = opacity mappyfile . save ( mapfile , self . mapfile , 2 ) def geturl ( self , imgname ) : url =[ str(self.mapbaseurl), \"?SERVICE=WMS&VERSION=1.1.1\", \"&imgfile=\"+ str(imgname), \"&layers=imglyr\", \"&transparent=true\", \"&format=image/png\", \"&mode=tile\", \"&tilemode=gmap\", \"&tile={x}+{y}+{z}\", ] #return urllib . parse . quote ( \"\" . join ( url )) return \"\" . join ( url )","title":"Multiraster"},{"location":"reference/hielen3/mapmanager/#ancestors-in-mro_1","text":"hielen3.mapmanager.Mapmanager abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/mapmanager/#instance-variables_1","text":"mapfile mapurl","title":"Instance variables"},{"location":"reference/hielen3/mapmanager/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/mapmanager/#geturl_1","text":"def geturl ( self , imgname ) View Source def geturl ( self , imgname ) : url = [ str ( self . mapbaseurl ) , \"?SERVICE=WMS&VERSION=1.1.1\" , \"&imgfile=\" + str ( imgname ) , \"&layers=imglyr\" , \"&transparent=true\" , \"&format=image/png\" , \"&mode=tile\" , \"&tilemode=gmap\" , \"&tile={x}+{y}+{z}\" , ] # return urllib . parse . quote ( \"\" . join ( url )) return \"\" . join ( url )","title":"geturl"},{"location":"reference/hielen3/mapmanager/#setmfparams_1","text":"def setMFparams ( self , bands = 4 , scale = [ '0,255' , '0,255' , '0,255' , '0,255' ], crs = 'EPSG:3857' , lyrext = '-20026376.39 -20048966.10 20026376.39 20048966.10' , datadir = '' , um = 'METERS' , ows_onlineresources = 'http://pippo&' ) View Source def setMFparams ( self , bands = 4 , scale =[ '0,255','0,255','0,255','0,255' ] , crs = 'EPSG:3857' , lyrext = '-20026376.39 -20048966.10 20026376.39 20048966.10' , datadir = '' , um = 'METERS' , ows_onlineresources = \"http://pippo&\" ) : inmapf = conf [ 'maptemplates' ][ self.maptype ] self . mapcache . mkdir () mapfile = mappyfile . open ( inmapf ) mapfile [ \"shapepath\" ] = datadir mapfile [ \"web\" ][ \"metadata\" ][ \"ows_onlineresource\" ] = ows_onlineresources if ( bands == 1 ) : scale =[ '0,65536' ] layer = mapfile [ \"layers\" ][ 0 ] tbands = ',' . join ( map ( str ,( range ( 1 , bands + 1 )))) layer [ 'processing' ]=[ f'BANDS={tbands}' ] for i in range ( 0 , bands ) : layer [ 'processing' ] . append ( f \"SCALE_{i+1}={scale[i]}\" ) layer [ \"projection\" ] = f \"init={str(crs).lower()}\" try : um = um . upper () except Exception as e : pass if um is None or not um or um in [ 'UNKNOWN' ] : um = \"METERS\" layer [ \"units\" ] = re . sub ( 'METRES?' , 'METERS' , um . upper ()) layer [ \"metadata\" ][ \"ows_srs\" ] = str ( crs ). upper () layer [ \"metadata\" ][ \"ows_extent\" ] = lyrext #layer [ \"composite\" ][ \"opacity\" ] = opacity mappyfile . save ( mapfile , self . mapfile , 2 )","title":"setMFparams"},{"location":"reference/hielen3/serializaction/","text":"Module hielen3.serializaction View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 #!/usr/bin/env python # coding=utf-8 from marshmallow import Schema , fields , ValidationError , INCLUDE from numpy import datetime64 , isnat from hielen3 import conf from pathlib import Path import json from pandas import DataFrame from numpy import array , sqrt , sum , where , amin , nan , round from matplotlib.colors import ColorConverter , Normalize , LinearSegmentedColormap from abc import ABC , abstractmethod ### MARSHMALLOW FIELDS class Style ( fields . String ): \"\"\" \"\"\" pass class FTPPath ( fields . String ): \"\"\" Local FTP Filepath manager used to identify a file into the system. Mainliy usefull for action Schema declaration in hielen3.HielenSource extention \"\"\" def _deserialize ( self , value , attr , data , ** kwargs ): try : return Path ( value ) except Exception as e : raise ValueError ( e ) class LocalFile ( fields . String ): \"\"\" Local Filepath manager used to identify a file into the system. Mainliy usefull for action Schema declaration in hielen3.HielenSource extention \"\"\" pass class LoggerHeader ( fields . List ): \"\"\" Logger Header alias \"\"\" class PolyCoeff ( fields . List ): \"\"\" Polynomial Coefficients list intent: giving list a and value x result will be r=0 for i in range(0, a._len__()): r += a[i]*x**i \"\"\" def __init__ ( self , cls_or_instance = fields . Number , ** kwargs ): super () . __init__ ( cls_or_instance = cls_or_instance , ** kwargs ) def _deserialize ( self , value , attr , data , ** kwargs ): try : if value in ( 'null' , '' ): return \"\" value = json . loads ( value ) if value is not None : value = list ( map ( lambda x : x is not None and x or 0 , value )) value = \",\" . join ( map ( str , value )) return value except Exception as e : raise e raise ValueError ( e ) ''' class LoggerHeader(fields.List): \"\"\" Logger Header manager \"\"\" def __init__(self,cls_or_instance=fields.Tuple( ( fields.String(), #Param fields.Integer(), #Column fields.String(), #Raw_mu fields.String(), #Ing_mu fields.String(), #Signal_cond fields.List(fields.Number()) #Poly coeff ) ),**kwargs): super().__init__(cls_or_instance=cls_or_instance,**kwargs) def _deserialize(self,value, attr, data, **kwargs): try: return json.loads(value) except Exception as e: raise ValueError(e) ''' class ParamsDefinition ( fields . List ): \"\"\" Logger Header manager \"\"\" def __init__ ( self , cls_or_instance = fields . Tuple ( ( fields . String (), #Param fields . Integer (), #Column fields . String () #Ing_mu ) ), ** kwargs ): super () . __init__ ( cls_or_instance = cls_or_instance , ** kwargs ) def _deserialize ( self , value , attr , data , ** kwargs ): try : return json . loads ( value ) except Exception as e : raise ValueError ( e ) class ColorMap ( fields . List ): \"\"\" Colormap manager used to identify a colormap \"\"\" def __init__ ( self , cls_or_instance = fields . Tuple (( fields . String (), fields . Number ())), ** kwargs ): super () . __init__ ( cls_or_instance = cls_or_instance , ** kwargs ) def _deserialize ( self , value , attr , data , ** kwargs ): try : return ColorMap . make_colormap ( json . loads ( value )) except Exception as e : try : assert value [ 'f_cmap' ] return value except Exception as e : raise ValueError ( e ) def valorizeColor ( clmap , color ): c = ColorConverter () try : colframe = DataFrame ([ c . to_rgb ( x [ 1 ]) for x in clmap ]) except ValueError as e : colframe = DataFrame ([ x [ 1 ] for x in clmap ]) colframe = colframe / 255 colframe = colframe . apply ( c . to_rgb , axis = 1 , result_type = 'expand' ) colframe . columns = [ 'r' , 'g' , 'b' ] colframe [ 'values' ] = [ x [ 0 ] for x in clmap ] colors = colframe [[ 'r' , 'g' , 'b' ]] . values colframe = colframe . set_index ([ 'r' , 'g' , 'b' ]) color = array ( color ) try : color = array ( c . to_rgb ( color )) except ValueError as e : color = DataFrame ([ color ], columns = [ 'r' , 'g' , 'b' ]) / 255 color = color . apply ( c . to_rgb , axis = 1 , result_type = 'expand' ) . values distances = sqrt ( sum (( colors - color ) ** 2 , axis = 1 )) index_of_smallest = where ( distances == amin ( distances )) try : return float ( colframe [ 'values' ] . iloc [ index_of_smallest ] . squeeze ()) except Exception as e : return nan def parse_colormap ( incmap ): if incmap is None : return ColorMap . parse_colormap ( ColorMap . make_colormap ()) try : norm = Normalize ( ** incmap [ \"norm\" ]) norm . clip = True except Exception : norm = None cmap = LinearSegmentedColormap ( 'CustomMap' , incmap [ 'b_cmap' ]) return { \"norm\" : norm , \"cmap\" : cmap } def make_colormap ( incmap = None ): if incmap is None : incmap = [[ - 0.25 , \"#FF0000\" ],[ 0 , \"#00FF00\" ],[ 0.25 , \"#0000FF\" ]] a = DataFrame ( incmap , columns = [ \"values\" , \"colors\" ]) . sort_values ( \"values\" ) out = { \"norm\" :{ \"vmin\" : a [ \"values\" ][ 0 ], \"vmax\" : a [ \"values\" ] . iloc [ a . shape [ 0 ] - 1 ]}} n = Normalize ( ** out [ \"norm\" ]) a [ \"values\" ] = round ( a [ \"values\" ], 3 ) a [ \"idx\" ] = n ( a [ \"values\" ]) * 100 cc = a [[ \"idx\" , \"colors\" ]] . values seq = [] c = ColorConverter () for i in range ( cc . __len__ ()): if i == 0 or i == cc . __len__ (): seq . append ( c . to_rgb ( cc [ i ][ 1 ])) else : seq . append ( c . to_rgb ( cc [ i ][ 1 ])) seq . append ( cc [ i ][ 0 ] / 100 ) seq . append ( c . to_rgb ( cc [ i ][ 1 ])) seq = [( None ,) * 3 , 0.0 ] + list ( seq ) + [ 1.0 , ( None ,) * 3 ] linsegcmap = { 'red' : [], 'green' : [], 'blue' : []} for i , item in enumerate ( seq ): if isinstance ( item , float ): r1 , g1 , b1 = seq [ i - 1 ] r2 , g2 , b2 = seq [ i + 1 ] linsegcmap [ 'red' ] . append ([ item , r1 , r2 ]) linsegcmap [ 'green' ] . append ([ item , g1 , g2 ]) linsegcmap [ 'blue' ] . append ([ item , b1 , b2 ]) out [ \"f_cmap\" ] = a . values . tolist () out [ \"b_cmap\" ] = linsegcmap return out class StringTime ( fields . DateTime ): def _agoodtime ( t ): try : t = datetime64 ( t ) assert not isnat ( t ) t = str ( t ) except Exception as e : t = None return t def _deserialize ( self , value , attr , data , ** kwargs ): return str ( super () . _deserialize ( value , attr , data , ** kwargs )) def _serialize ( self , value , attr , obj , ** kwargs ): return StringTime . _agoodtime ( value ) class HSchema ( Schema ): ''' Minimal ancestor class providing mehods ''' class Meta : unknown = INCLUDE @property def __hdict__ ( self ): out = { \"fields\" :{}, \"required\" :[], \"hints\" : self . hints } for k , w in self . dump_fields . items (): out [ 'fields' ][ k ] = w . __class__ . __name__ w . __dict__ [ 'required' ] and out [ \"required\" ] . append ( k ) return out @abstractmethod def _self_hints_ (): pass @property def hints ( self ): out = self . __class__ . _self_hints_ () or {} for c in self . __class__ . __bases__ : try : out . update ( c () . hints ) except AttributeError as e : pass return out timestamp = StringTime ( required = True , allow_none = False ) class ActionSchema ( HSchema ): ''' Minimal ActionSchema object. Used to define at least a timestamp ''' def _self_hints_ (): return { \"Base\" : { 0 : [ \"timestamp\" , \"Reference time\" , False , None ] } } timestamp = StringTime ( required = True , allow_none = False ) \"\"\" class GeoInfoSchema(ActionSchema): ''' Minimal map based ActionSchema object. Used to define geo-info ''' _self_hints = { \"Geo Info\": { 0: [\"master_image\",\"The base image used as reference grid for elaboration or basemap. It can be any image format managed by rasterio pyhton library (GeoTIFF, jp eg, ...). Colometric interpretation will be RGB whit Black alpha mask. Any elaboration image based on the 'master_image' will share geometry and reference system with it.\",False], 1: [\"geo_reference_file\",\"Reference file for the geolocalization of the 'grid' and all the dependent elaboration images. It can be a standard world file (six lines text file) according to http://www.kralidis.ca/gis/worldfile.htm, as well an '.aux.xml' file according to https://desktop.arcgis.com/en/arcmap/10.3/manage-data/raster-and-images/auxiliary-files.htm (just the Coordinate system, the Transformation and the Projection informations are here managed). NOTE: When a valid 'geo_regerence_file' is provided, therein informations overwrite the ones possibly embedded into the 'master_image'\",False], 2:[\"crs\", \"the Coordinate Reference System of the master_image in the string form 'autority:code' (i.e.: 'EPSG:3857'). NOTE: If a valid 'crs' is provided, this value overwrites the ones possibly provided with the 'geo_regerence_file' and/or embeded into the 'master_image'\",False], 3:[\"extent_easting\",\"Easting map extention, according with 'crs' and 'geo_reference_file'. Ignored if 'master_image' is provided\",False], 4:[\"extent_northing\",\"Northing map extention, according with 'crs' and 'geo_reference_file'. Ignored if 'master_image' is provided\",False] } } master_image = FTPPath(required=False, allow_none=True) geo_reference_file = FTPPath(required=False,default=None, allow_none=True) crs=fields.Str(required=False,default=None,allow_none=True) extent_easting=fields.Number(required=False, default=None, allow_none=True, as_string=False) extent_northing=fields.Number(required=False, default=None, allow_none=True, as_string=False) \"\"\" Variables INCLUDE conf isnat nan sqrt Classes ActionSchema class ActionSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ActionSchema ( HSchema ): ''' Minimal ActionSchema object. Used to define at least a timestamp ''' def _self_hints_ (): return { \"Base\" : { 0 : [ \"timestamp\" , \"Reference time\" , False , None ] } } timestamp = StringTime ( required = True , allow_none = False ) Ancestors (in MRO) hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Descendants hielen3.ext.feature_instrument_clinometer.feature.ConfigSchema hielen3.ext.feature_instrument_generic.feature.ConfigSchema hielen3.ext.feature_instrument_improved.feature.ConfigSchema hielen3.ext.feature_instrument_piezometer.feature.ConfigSchema hielen3.ext.feature_logger_boviar.logger.ConfigSchema hielen3.ext.feature_logger_capetti.logger.ConfigSchema hielen3.ext.feature_logger_gestecno.logger.ConfigSchema hielen3.ext.feature_logger_move.logger.ConfigSchema hielen3.ext.feature_logger_move__.logger.ConfigSchema hielen3.ext.feature_logger_move__.feature_logger_move.logger.ConfigSchema hielen3.ext.feature_logger_omnialog_temp.logger.ConfigSchema hielen3.ext.feature_logger_smartbrik4_0.logger.ConfigSchema hielen3.ext.feature_logger_winecap.logger.ConfigSchema hielen3.ext.feature_rfilogger.rfilogger.ConfigSchema hielen3.ext.feature_rfilogger.rfilogger_good.ConfigSchema hielen3.ext.feature_spotted_files_source.logger.ConfigSchema Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages opts timestamp Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} ColorMap class ColorMap ( cls_or_instance =< fields . Tuple ( dump_default =< marshmallow . missing > , attribute = None , validate = None , required = False , load_only = False , dump_only = False , load_default =< marshmallow . missing > , allow_none = False , error_messages = { 'required' : 'Missing data for required field.' , 'null' : 'Field may not be null.' , 'validator_failed' : 'Invalid value.' , 'invalid' : 'Not a valid tuple.' }) > , ** kwargs ) Colormap manager used to identify a colormap View Source class ColorMap ( fields . List ): \"\"\" Colormap manager used to identify a colormap \"\"\" def __init__ ( self , cls_or_instance = fields . Tuple (( fields . String (), fields . Number ())), ** kwargs ): super () . __init__ ( cls_or_instance = cls_or_instance , ** kwargs ) def _deserialize ( self , value , attr , data , ** kwargs ): try : return ColorMap . make_colormap ( json . loads ( value )) except Exception as e : try : assert value [ 'f_cmap' ] return value except Exception as e : raise ValueError ( e ) def valorizeColor ( clmap , color ): c = ColorConverter () try : colframe = DataFrame ([ c . to_rgb ( x [ 1 ]) for x in clmap ]) except ValueError as e : colframe = DataFrame ([ x [ 1 ] for x in clmap ]) colframe = colframe / 255 colframe = colframe . apply ( c . to_rgb , axis = 1 , result_type = 'expand' ) colframe . columns = [ 'r' , 'g' , 'b' ] colframe [ 'values' ] = [ x [ 0 ] for x in clmap ] colors = colframe [[ 'r' , 'g' , 'b' ]] . values colframe = colframe . set_index ([ 'r' , 'g' , 'b' ]) color = array ( color ) try : color = array ( c . to_rgb ( color )) except ValueError as e : color = DataFrame ([ color ], columns = [ 'r' , 'g' , 'b' ]) / 255 color = color . apply ( c . to_rgb , axis = 1 , result_type = 'expand' ) . values distances = sqrt ( sum (( colors - color ) ** 2 , axis = 1 )) index_of_smallest = where ( distances == amin ( distances )) try : return float ( colframe [ 'values' ] . iloc [ index_of_smallest ] . squeeze ()) except Exception as e : return nan def parse_colormap ( incmap ): if incmap is None : return ColorMap . parse_colormap ( ColorMap . make_colormap ()) try : norm = Normalize ( ** incmap [ \"norm\" ]) norm . clip = True except Exception : norm = None cmap = LinearSegmentedColormap ( 'CustomMap' , incmap [ 'b_cmap' ]) return { \"norm\" : norm , \"cmap\" : cmap } def make_colormap ( incmap = None ): if incmap is None : incmap = [[ - 0.25 , \"#FF0000\" ],[ 0 , \"#00FF00\" ],[ 0.25 , \"#0000FF\" ]] a = DataFrame ( incmap , columns = [ \"values\" , \"colors\" ]) . sort_values ( \"values\" ) out = { \"norm\" :{ \"vmin\" : a [ \"values\" ][ 0 ], \"vmax\" : a [ \"values\" ] . iloc [ a . shape [ 0 ] - 1 ]}} n = Normalize ( ** out [ \"norm\" ]) a [ \"values\" ] = round ( a [ \"values\" ], 3 ) a [ \"idx\" ] = n ( a [ \"values\" ]) * 100 cc = a [[ \"idx\" , \"colors\" ]] . values seq = [] c = ColorConverter () for i in range ( cc . __len__ ()): if i == 0 or i == cc . __len__ (): seq . append ( c . to_rgb ( cc [ i ][ 1 ])) else : seq . append ( c . to_rgb ( cc [ i ][ 1 ])) seq . append ( cc [ i ][ 0 ] / 100 ) seq . append ( c . to_rgb ( cc [ i ][ 1 ])) seq = [( None ,) * 3 , 0.0 ] + list ( seq ) + [ 1.0 , ( None ,) * 3 ] linsegcmap = { 'red' : [], 'green' : [], 'blue' : []} for i , item in enumerate ( seq ): if isinstance ( item , float ): r1 , g1 , b1 = seq [ i - 1 ] r2 , g2 , b2 = seq [ i + 1 ] linsegcmap [ 'red' ] . append ([ item , r1 , r2 ]) linsegcmap [ 'green' ] . append ([ item , g1 , g2 ]) linsegcmap [ 'blue' ] . append ([ item , b1 , b2 ]) out [ \"f_cmap\" ] = a . values . tolist () out [ \"b_cmap\" ] = linsegcmap return out Ancestors (in MRO) marshmallow.fields.List marshmallow.fields.Field marshmallow.base.FieldABC Class variables default_error_messages name parent root Instance variables context The context dictionary for the parent :class: Schema . default missing Methods deserialize def deserialize ( self , value : 'typing.Any' , attr : 'str | None' = None , data : 'typing.Mapping[str, typing.Any] | None' = None , ** kwargs ) Deserialize value . Parameters: Name Type Description Default value None The value to deserialize. None attr None The attribute/key in data to deserialize. None data None The raw input data passed to Schema.load . None kwargs None Field-specific keyword arguments. None Raises: Type Description ValidationError If an invalid value is passed or if a required value is missing. View Source def deserialize ( self , value : typing . Any , attr : str | None = None , data : typing . Mapping [ str , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Deserialize ``value``. :param value: The value to deserialize. :param attr: The attribute/key in `data` to deserialize. :param data: The raw input data passed to `Schema.load`. :param kwargs: Field-specific keyword arguments. :raise ValidationError: If an invalid value is passed or if a required value is missing. \"\" \" # Validate required fields, deserialize, then validate # deserialized value self . _validate_missing ( value ) if value is missing_ : _miss = self . load_default return _miss () if callable ( _miss ) else _miss if self . allow_none and value is None : return None output = self . _deserialize ( value , attr , data , ** kwargs ) self . _validate ( output ) return output fail def fail ( self , key : 'str' , ** kwargs ) Helper method that raises a ValidationError with an error message from self.error_messages . View Source def fail ( self , key : str , ** kwargs ) : \" \"\" Helper method that raises a `ValidationError` with an error message from ``self.error_messages``. .. deprecated:: 3.0.0 Use `make_error <marshmallow.fields.Field.make_error>` instead. \"\" \" warnings . warn ( '`Field.fail` is deprecated. Use `raise self.make_error(\"{}\", ...)` instead.' . format ( key ), RemovedInMarshmallow4Warning , stacklevel = 2 , ) raise self . make_error ( key = key , ** kwargs ) get_value def get_value ( self , obj , attr , accessor = None , default =< marshmallow . missing > ) Return the value for a given key from an object. Parameters: Name Type Description Default obj object The object to get the value from. None attr str The attribute/key in obj to get the value from. None accessor callable A callable used to retrieve the value of attr from the object obj . Defaults to marshmallow.utils.get_value . None View Source def get_value ( self , obj , attr , accessor = None , default = missing_ ) : \" \"\" Return the value for a given key from an object. :param object obj: The object to get the value from. :param str attr: The attribute/key in `obj` to get the value from. :param callable accessor: A callable used to retrieve the value of `attr` from the object `obj`. Defaults to `marshmallow.utils.get_value`. \"\" \" accessor_func = accessor or utils . get_value check_key = attr if self . attribute is None else self . attribute return accessor_func ( obj , check_key , default ) make_colormap def make_colormap ( incmap = None ) View Source def make_colormap ( incmap = None ) : if incmap is None : incmap =[ [-0.25,\"#FF0000\" ] , [ 0,\"#00FF00\" ] , [ 0.25,\"#0000FF\" ] ] a = DataFrame ( incmap , columns =[ \"values\",\"colors\" ] ). sort_values ( \"values\" ) out = { \"norm\" :{ \"vmin\" : a [ \"values\" ][ 0 ] , \"vmax\" : a [ \"values\" ] . iloc [ a.shape[0 ]- 1 ]}} n = Normalize ( ** out [ \"norm\" ] ) a [ \"values\" ]= round ( a [ \"values\" ] , 3 ) a [ \"idx\" ]= n ( a [ \"values\" ] ) * 100 cc = a [ [\"idx\",\"colors\" ] ] . values seq = [] c = ColorConverter () for i in range ( cc . __len__ ()) : if i == 0 or i == cc . __len__ () : seq . append ( c . to_rgb ( cc [ i ][ 1 ] )) else : seq . append ( c . to_rgb ( cc [ i ][ 1 ] )) seq . append ( cc [ i ][ 0 ]/ 100 ) seq . append ( c . to_rgb ( cc [ i ][ 1 ] )) seq = [ (None,) * 3, 0.0 ] + list ( seq ) + [ 1.0, (None,) * 3 ] linsegcmap = { 'red' : [] , 'green' : [] , 'blue' : []} for i , item in enumerate ( seq ) : if isinstance ( item , float ) : r1 , g1 , b1 = seq [ i - 1 ] r2 , g2 , b2 = seq [ i + 1 ] linsegcmap [ 'red' ] . append ( [ item, r1, r2 ] ) linsegcmap [ 'green' ] . append ( [ item, g1, g2 ] ) linsegcmap [ 'blue' ] . append ( [ item, b1, b2 ] ) out [ \"f_cmap\" ]= a . values . tolist () out [ \"b_cmap\" ]= linsegcmap return out make_error def make_error ( self , key : 'str' , ** kwargs ) -> 'ValidationError' Helper method to make a ValidationError with an error message from self.error_messages . View Source def make_error ( self , key : str , ** kwargs ) -> ValidationError : \" \"\" Helper method to make a `ValidationError` with an error message from ``self.error_messages``. \"\" \" try : msg = self . error_messages [ key ] except KeyError as error : class_name = self . __class__ . __name__ message = ( \"ValidationError raised by `{class_name}`, but error key `{key}` does \" \"not exist in the `error_messages` dictionary.\" ). format ( class_name = class_name , key = key ) raise AssertionError ( message ) from error if isinstance ( msg , ( str , bytes )) : msg = msg . format ( ** kwargs ) return ValidationError ( msg ) parse_colormap def parse_colormap ( incmap ) View Source def parse_colormap ( incmap ) : if incmap is None : return ColorMap . parse_colormap ( ColorMap . make_colormap ()) try : norm = Normalize ( ** incmap [ \"norm\" ] ) norm . clip = True except Exception : norm = None cmap = LinearSegmentedColormap ( 'CustomMap' , incmap [ 'b_cmap' ] ) return { \"norm\" : norm , \"cmap\" : cmap } serialize def serialize ( self , attr : 'str' , obj : 'typing.Any' , accessor : 'typing.Callable[[typing.Any, str, typing.Any], typing.Any] | None' = None , ** kwargs ) Pulls the value for the given key from the object, applies the field's formatting and returns the result. Parameters: Name Type Description Default attr None The attribute/key to get from the object. None obj None The object to access the attribute/key from. None accessor None Function used to access values from obj . None kwargs None Field-specific keyword arguments. None View Source def serialize ( self , attr : str , obj : typing . Any , accessor : typing . Callable [[ typing . Any , str , typing . Any ] , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Pulls the value for the given key from the object, applies the field's formatting and returns the result. :param attr: The attribute/key to get from the object. :param obj: The object to access the attribute/key from. :param accessor: Function used to access values from ``obj``. :param kwargs: Field-specific keyword arguments. \"\" \" if self . _CHECK_ATTRIBUTE : value = self . get_value ( obj , attr , accessor = accessor ) if value is missing_ : default = self . dump_default value = default () if callable ( default ) else default if value is missing_ : return value else : value = None return self . _serialize ( value , attr , obj , ** kwargs ) valorizeColor def valorizeColor ( clmap , color ) View Source def valorizeColor ( clmap , color ) : c = ColorConverter () try : colframe = DataFrame ( [ c.to_rgb(x[1 ] ) for x in clmap ] ) except ValueError as e : colframe = DataFrame ( [ x[1 ] for x in clmap ] ) colframe = colframe / 255 colframe = colframe . apply ( c . to_rgb , axis = 1 , result_type = 'expand' ) colframe . columns =[ 'r','g','b' ] colframe [ 'values' ] = [ x[0 ] for x in clmap ] colors = colframe [ ['r','g','b' ] ] . values colframe = colframe . set_index ( [ 'r','g','b' ] ) color = array ( color ) try : color = array ( c . to_rgb ( color )) except ValueError as e : color = DataFrame ( [ color ] , columns =[ 'r','g','b' ] ) / 255 color = color . apply ( c . to_rgb , axis = 1 , result_type = 'expand' ). values distances = sqrt ( sum (( colors - color ) ** 2 , axis = 1 )) index_of_smallest = where ( distances == amin ( distances )) try : return float ( colframe [ 'values' ] . iloc [ index_of_smallest ] . squeeze ()) except Exception as e : return nan FTPPath class FTPPath ( * , load_default : 'typing.Any' = < marshmallow . missing > , missing : 'typing.Any' = < marshmallow . missing > , dump_default : 'typing.Any' = < marshmallow . missing > , default : 'typing.Any' = < marshmallow . missing > , data_key : 'str | None' = None , attribute : 'str | None' = None , validate : 'None | (typing.Callable[[typing.Any], typing.Any] | typing.Iterable[typing.Callable[[typing.Any], typing.Any]])' = None , required : 'bool' = False , allow_none : 'bool | None' = None , load_only : 'bool' = False , dump_only : 'bool' = False , error_messages : 'dict[str, str] | None' = None , metadata : 'typing.Mapping[str, typing.Any] | None' = None , ** additional_metadata ) Local FTP Filepath manager used to identify a file into the system. Mainliy usefull for action Schema declaration in hielen3.HielenSource extention View Source class FTPPath ( fields . String ): \"\"\" Local FTP Filepath manager used to identify a file into the system. Mainliy usefull for action Schema declaration in hielen3.HielenSource extention \"\"\" def _deserialize ( self , value , attr , data , ** kwargs ): try: return Path ( value ) except Exception as e: raise ValueError ( e ) Ancestors (in MRO) marshmallow.fields.String marshmallow.fields.Field marshmallow.base.FieldABC Class variables default_error_messages name parent root Instance variables context The context dictionary for the parent :class: Schema . default missing Methods deserialize def deserialize ( self , value : 'typing.Any' , attr : 'str | None' = None , data : 'typing.Mapping[str, typing.Any] | None' = None , ** kwargs ) Deserialize value . Parameters: Name Type Description Default value None The value to deserialize. None attr None The attribute/key in data to deserialize. None data None The raw input data passed to Schema.load . None kwargs None Field-specific keyword arguments. None Raises: Type Description ValidationError If an invalid value is passed or if a required value is missing. View Source def deserialize ( self , value : typing . Any , attr : str | None = None , data : typing . Mapping [ str , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Deserialize ``value``. :param value: The value to deserialize. :param attr: The attribute/key in `data` to deserialize. :param data: The raw input data passed to `Schema.load`. :param kwargs: Field-specific keyword arguments. :raise ValidationError: If an invalid value is passed or if a required value is missing. \"\" \" # Validate required fields, deserialize, then validate # deserialized value self . _validate_missing ( value ) if value is missing_ : _miss = self . load_default return _miss () if callable ( _miss ) else _miss if self . allow_none and value is None : return None output = self . _deserialize ( value , attr , data , ** kwargs ) self . _validate ( output ) return output fail def fail ( self , key : 'str' , ** kwargs ) Helper method that raises a ValidationError with an error message from self.error_messages . View Source def fail ( self , key : str , ** kwargs ) : \" \"\" Helper method that raises a `ValidationError` with an error message from ``self.error_messages``. .. deprecated:: 3.0.0 Use `make_error <marshmallow.fields.Field.make_error>` instead. \"\" \" warnings . warn ( '`Field.fail` is deprecated. Use `raise self.make_error(\"{}\", ...)` instead.' . format ( key ), RemovedInMarshmallow4Warning , stacklevel = 2 , ) raise self . make_error ( key = key , ** kwargs ) get_value def get_value ( self , obj , attr , accessor = None , default =< marshmallow . missing > ) Return the value for a given key from an object. Parameters: Name Type Description Default obj object The object to get the value from. None attr str The attribute/key in obj to get the value from. None accessor callable A callable used to retrieve the value of attr from the object obj . Defaults to marshmallow.utils.get_value . None View Source def get_value ( self , obj , attr , accessor = None , default = missing_ ) : \" \"\" Return the value for a given key from an object. :param object obj: The object to get the value from. :param str attr: The attribute/key in `obj` to get the value from. :param callable accessor: A callable used to retrieve the value of `attr` from the object `obj`. Defaults to `marshmallow.utils.get_value`. \"\" \" accessor_func = accessor or utils . get_value check_key = attr if self . attribute is None else self . attribute return accessor_func ( obj , check_key , default ) make_error def make_error ( self , key : 'str' , ** kwargs ) -> 'ValidationError' Helper method to make a ValidationError with an error message from self.error_messages . View Source def make_error ( self , key : str , ** kwargs ) -> ValidationError : \" \"\" Helper method to make a `ValidationError` with an error message from ``self.error_messages``. \"\" \" try : msg = self . error_messages [ key ] except KeyError as error : class_name = self . __class__ . __name__ message = ( \"ValidationError raised by `{class_name}`, but error key `{key}` does \" \"not exist in the `error_messages` dictionary.\" ). format ( class_name = class_name , key = key ) raise AssertionError ( message ) from error if isinstance ( msg , ( str , bytes )) : msg = msg . format ( ** kwargs ) return ValidationError ( msg ) serialize def serialize ( self , attr : 'str' , obj : 'typing.Any' , accessor : 'typing.Callable[[typing.Any, str, typing.Any], typing.Any] | None' = None , ** kwargs ) Pulls the value for the given key from the object, applies the field's formatting and returns the result. Parameters: Name Type Description Default attr None The attribute/key to get from the object. None obj None The object to access the attribute/key from. None accessor None Function used to access values from obj . None kwargs None Field-specific keyword arguments. None View Source def serialize ( self , attr : str , obj : typing . Any , accessor : typing . Callable [[ typing . Any , str , typing . Any ] , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Pulls the value for the given key from the object, applies the field's formatting and returns the result. :param attr: The attribute/key to get from the object. :param obj: The object to access the attribute/key from. :param accessor: Function used to access values from ``obj``. :param kwargs: Field-specific keyword arguments. \"\" \" if self . _CHECK_ATTRIBUTE : value = self . get_value ( obj , attr , accessor = accessor ) if value is missing_ : default = self . dump_default value = default () if callable ( default ) else default if value is missing_ : return value else : value = None return self . _serialize ( value , attr , obj , ** kwargs ) HSchema class HSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ancestor class providing mehods View Source class HSchema ( Schema ) : ''' Minimal ancestor class providing mehods ''' class Meta : unknown = INCLUDE @property def __hdict__ ( self ) : out = { \"fields\" :{} , \"required\" :[] , \"hints\" : self . hints } for k , w in self . dump_fields . items () : out [ 'fields' ][ k ]= w . __class__ . __name__ w . __dict__ [ 'required' ] and out [ \"required\" ] . append ( k ) return out @abstractmethod def _self_hints_ () : pass @property def hints ( self ) : out = self . __class__ . _self_hints_ () or {} for c in self . __class__ . __bases__ : try : out . update ( c (). hints ) except AttributeError as e : pass return out timestamp = StringTime ( required = True , allow_none = False ) Ancestors (in MRO) marshmallow.schema.Schema marshmallow.base.SchemaABC Descendants hielen3.serializaction.ActionSchema Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages opts timestamp Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} LocalFile class LocalFile ( * , load_default : 'typing.Any' = < marshmallow . missing > , missing : 'typing.Any' = < marshmallow . missing > , dump_default : 'typing.Any' = < marshmallow . missing > , default : 'typing.Any' = < marshmallow . missing > , data_key : 'str | None' = None , attribute : 'str | None' = None , validate : 'None | (typing.Callable[[typing.Any], typing.Any] | typing.Iterable[typing.Callable[[typing.Any], typing.Any]])' = None , required : 'bool' = False , allow_none : 'bool | None' = None , load_only : 'bool' = False , dump_only : 'bool' = False , error_messages : 'dict[str, str] | None' = None , metadata : 'typing.Mapping[str, typing.Any] | None' = None , ** additional_metadata ) Local Filepath manager used to identify a file into the system. Mainliy usefull for action Schema declaration in hielen3.HielenSource extention View Source class LocalFile ( fields . String ): \"\"\" Local Filepath manager used to identify a file into the system. Mainliy usefull for action Schema declaration in hielen3.HielenSource extention \"\"\" pass Ancestors (in MRO) marshmallow.fields.String marshmallow.fields.Field marshmallow.base.FieldABC Class variables default_error_messages name parent root Instance variables context The context dictionary for the parent :class: Schema . default missing Methods deserialize def deserialize ( self , value : 'typing.Any' , attr : 'str | None' = None , data : 'typing.Mapping[str, typing.Any] | None' = None , ** kwargs ) Deserialize value . Parameters: Name Type Description Default value None The value to deserialize. None attr None The attribute/key in data to deserialize. None data None The raw input data passed to Schema.load . None kwargs None Field-specific keyword arguments. None Raises: Type Description ValidationError If an invalid value is passed or if a required value is missing. View Source def deserialize ( self , value : typing . Any , attr : str | None = None , data : typing . Mapping [ str , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Deserialize ``value``. :param value: The value to deserialize. :param attr: The attribute/key in `data` to deserialize. :param data: The raw input data passed to `Schema.load`. :param kwargs: Field-specific keyword arguments. :raise ValidationError: If an invalid value is passed or if a required value is missing. \"\" \" # Validate required fields, deserialize, then validate # deserialized value self . _validate_missing ( value ) if value is missing_ : _miss = self . load_default return _miss () if callable ( _miss ) else _miss if self . allow_none and value is None : return None output = self . _deserialize ( value , attr , data , ** kwargs ) self . _validate ( output ) return output fail def fail ( self , key : 'str' , ** kwargs ) Helper method that raises a ValidationError with an error message from self.error_messages . View Source def fail ( self , key : str , ** kwargs ) : \" \"\" Helper method that raises a `ValidationError` with an error message from ``self.error_messages``. .. deprecated:: 3.0.0 Use `make_error <marshmallow.fields.Field.make_error>` instead. \"\" \" warnings . warn ( '`Field.fail` is deprecated. Use `raise self.make_error(\"{}\", ...)` instead.' . format ( key ), RemovedInMarshmallow4Warning , stacklevel = 2 , ) raise self . make_error ( key = key , ** kwargs ) get_value def get_value ( self , obj , attr , accessor = None , default =< marshmallow . missing > ) Return the value for a given key from an object. Parameters: Name Type Description Default obj object The object to get the value from. None attr str The attribute/key in obj to get the value from. None accessor callable A callable used to retrieve the value of attr from the object obj . Defaults to marshmallow.utils.get_value . None View Source def get_value ( self , obj , attr , accessor = None , default = missing_ ) : \" \"\" Return the value for a given key from an object. :param object obj: The object to get the value from. :param str attr: The attribute/key in `obj` to get the value from. :param callable accessor: A callable used to retrieve the value of `attr` from the object `obj`. Defaults to `marshmallow.utils.get_value`. \"\" \" accessor_func = accessor or utils . get_value check_key = attr if self . attribute is None else self . attribute return accessor_func ( obj , check_key , default ) make_error def make_error ( self , key : 'str' , ** kwargs ) -> 'ValidationError' Helper method to make a ValidationError with an error message from self.error_messages . View Source def make_error ( self , key : str , ** kwargs ) -> ValidationError : \" \"\" Helper method to make a `ValidationError` with an error message from ``self.error_messages``. \"\" \" try : msg = self . error_messages [ key ] except KeyError as error : class_name = self . __class__ . __name__ message = ( \"ValidationError raised by `{class_name}`, but error key `{key}` does \" \"not exist in the `error_messages` dictionary.\" ). format ( class_name = class_name , key = key ) raise AssertionError ( message ) from error if isinstance ( msg , ( str , bytes )) : msg = msg . format ( ** kwargs ) return ValidationError ( msg ) serialize def serialize ( self , attr : 'str' , obj : 'typing.Any' , accessor : 'typing.Callable[[typing.Any, str, typing.Any], typing.Any] | None' = None , ** kwargs ) Pulls the value for the given key from the object, applies the field's formatting and returns the result. Parameters: Name Type Description Default attr None The attribute/key to get from the object. None obj None The object to access the attribute/key from. None accessor None Function used to access values from obj . None kwargs None Field-specific keyword arguments. None View Source def serialize ( self , attr : str , obj : typing . Any , accessor : typing . Callable [[ typing . Any , str , typing . Any ] , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Pulls the value for the given key from the object, applies the field's formatting and returns the result. :param attr: The attribute/key to get from the object. :param obj: The object to access the attribute/key from. :param accessor: Function used to access values from ``obj``. :param kwargs: Field-specific keyword arguments. \"\" \" if self . _CHECK_ATTRIBUTE : value = self . get_value ( obj , attr , accessor = accessor ) if value is missing_ : default = self . dump_default value = default () if callable ( default ) else default if value is missing_ : return value else : value = None return self . _serialize ( value , attr , obj , ** kwargs ) LoggerHeader class LoggerHeader ( cls_or_instance : 'Field | type' , ** kwargs ) Logger Header alias View Source class LoggerHeader ( fields . List ): \"\"\" Logger Header alias \"\"\" Ancestors (in MRO) marshmallow.fields.List marshmallow.fields.Field marshmallow.base.FieldABC Class variables default_error_messages name parent root Instance variables context The context dictionary for the parent :class: Schema . default missing Methods deserialize def deserialize ( self , value : 'typing.Any' , attr : 'str | None' = None , data : 'typing.Mapping[str, typing.Any] | None' = None , ** kwargs ) Deserialize value . Parameters: Name Type Description Default value None The value to deserialize. None attr None The attribute/key in data to deserialize. None data None The raw input data passed to Schema.load . None kwargs None Field-specific keyword arguments. None Raises: Type Description ValidationError If an invalid value is passed or if a required value is missing. View Source def deserialize ( self , value : typing . Any , attr : str | None = None , data : typing . Mapping [ str , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Deserialize ``value``. :param value: The value to deserialize. :param attr: The attribute/key in `data` to deserialize. :param data: The raw input data passed to `Schema.load`. :param kwargs: Field-specific keyword arguments. :raise ValidationError: If an invalid value is passed or if a required value is missing. \"\" \" # Validate required fields, deserialize, then validate # deserialized value self . _validate_missing ( value ) if value is missing_ : _miss = self . load_default return _miss () if callable ( _miss ) else _miss if self . allow_none and value is None : return None output = self . _deserialize ( value , attr , data , ** kwargs ) self . _validate ( output ) return output fail def fail ( self , key : 'str' , ** kwargs ) Helper method that raises a ValidationError with an error message from self.error_messages . View Source def fail ( self , key : str , ** kwargs ) : \" \"\" Helper method that raises a `ValidationError` with an error message from ``self.error_messages``. .. deprecated:: 3.0.0 Use `make_error <marshmallow.fields.Field.make_error>` instead. \"\" \" warnings . warn ( '`Field.fail` is deprecated. Use `raise self.make_error(\"{}\", ...)` instead.' . format ( key ), RemovedInMarshmallow4Warning , stacklevel = 2 , ) raise self . make_error ( key = key , ** kwargs ) get_value def get_value ( self , obj , attr , accessor = None , default =< marshmallow . missing > ) Return the value for a given key from an object. Parameters: Name Type Description Default obj object The object to get the value from. None attr str The attribute/key in obj to get the value from. None accessor callable A callable used to retrieve the value of attr from the object obj . Defaults to marshmallow.utils.get_value . None View Source def get_value ( self , obj , attr , accessor = None , default = missing_ ) : \" \"\" Return the value for a given key from an object. :param object obj: The object to get the value from. :param str attr: The attribute/key in `obj` to get the value from. :param callable accessor: A callable used to retrieve the value of `attr` from the object `obj`. Defaults to `marshmallow.utils.get_value`. \"\" \" accessor_func = accessor or utils . get_value check_key = attr if self . attribute is None else self . attribute return accessor_func ( obj , check_key , default ) make_error def make_error ( self , key : 'str' , ** kwargs ) -> 'ValidationError' Helper method to make a ValidationError with an error message from self.error_messages . View Source def make_error ( self , key : str , ** kwargs ) -> ValidationError : \" \"\" Helper method to make a `ValidationError` with an error message from ``self.error_messages``. \"\" \" try : msg = self . error_messages [ key ] except KeyError as error : class_name = self . __class__ . __name__ message = ( \"ValidationError raised by `{class_name}`, but error key `{key}` does \" \"not exist in the `error_messages` dictionary.\" ). format ( class_name = class_name , key = key ) raise AssertionError ( message ) from error if isinstance ( msg , ( str , bytes )) : msg = msg . format ( ** kwargs ) return ValidationError ( msg ) serialize def serialize ( self , attr : 'str' , obj : 'typing.Any' , accessor : 'typing.Callable[[typing.Any, str, typing.Any], typing.Any] | None' = None , ** kwargs ) Pulls the value for the given key from the object, applies the field's formatting and returns the result. Parameters: Name Type Description Default attr None The attribute/key to get from the object. None obj None The object to access the attribute/key from. None accessor None Function used to access values from obj . None kwargs None Field-specific keyword arguments. None View Source def serialize ( self , attr : str , obj : typing . Any , accessor : typing . Callable [[ typing . Any , str , typing . Any ] , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Pulls the value for the given key from the object, applies the field's formatting and returns the result. :param attr: The attribute/key to get from the object. :param obj: The object to access the attribute/key from. :param accessor: Function used to access values from ``obj``. :param kwargs: Field-specific keyword arguments. \"\" \" if self . _CHECK_ATTRIBUTE : value = self . get_value ( obj , attr , accessor = accessor ) if value is missing_ : default = self . dump_default value = default () if callable ( default ) else default if value is missing_ : return value else : value = None return self . _serialize ( value , attr , obj , ** kwargs ) ParamsDefinition class ParamsDefinition ( cls_or_instance =< fields . Tuple ( dump_default =< marshmallow . missing > , attribute = None , validate = None , required = False , load_only = False , dump_only = False , load_default =< marshmallow . missing > , allow_none = False , error_messages = { 'required' : 'Missing data for required field.' , 'null' : 'Field may not be null.' , 'validator_failed' : 'Invalid value.' , 'invalid' : 'Not a valid tuple.' }) > , ** kwargs ) Logger Header manager View Source class ParamsDefinition ( fields . List ): \"\"\" Logger Header manager \"\"\" def __init__ ( self , cls_or_instance = fields . Tuple ( ( fields . String (), #Param fields . Integer (), #Column fields . String () #Ing_mu ) ), ** kwargs ): super () . __init__ ( cls_or_instance = cls_or_instance , ** kwargs ) def _deserialize ( self , value , attr , data , ** kwargs ): try : return json . loads ( value ) except Exception as e : raise ValueError ( e ) Ancestors (in MRO) marshmallow.fields.List marshmallow.fields.Field marshmallow.base.FieldABC Class variables default_error_messages name parent root Instance variables context The context dictionary for the parent :class: Schema . default missing Methods deserialize def deserialize ( self , value : 'typing.Any' , attr : 'str | None' = None , data : 'typing.Mapping[str, typing.Any] | None' = None , ** kwargs ) Deserialize value . Parameters: Name Type Description Default value None The value to deserialize. None attr None The attribute/key in data to deserialize. None data None The raw input data passed to Schema.load . None kwargs None Field-specific keyword arguments. None Raises: Type Description ValidationError If an invalid value is passed or if a required value is missing. View Source def deserialize ( self , value : typing . Any , attr : str | None = None , data : typing . Mapping [ str , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Deserialize ``value``. :param value: The value to deserialize. :param attr: The attribute/key in `data` to deserialize. :param data: The raw input data passed to `Schema.load`. :param kwargs: Field-specific keyword arguments. :raise ValidationError: If an invalid value is passed or if a required value is missing. \"\" \" # Validate required fields, deserialize, then validate # deserialized value self . _validate_missing ( value ) if value is missing_ : _miss = self . load_default return _miss () if callable ( _miss ) else _miss if self . allow_none and value is None : return None output = self . _deserialize ( value , attr , data , ** kwargs ) self . _validate ( output ) return output fail def fail ( self , key : 'str' , ** kwargs ) Helper method that raises a ValidationError with an error message from self.error_messages . View Source def fail ( self , key : str , ** kwargs ) : \" \"\" Helper method that raises a `ValidationError` with an error message from ``self.error_messages``. .. deprecated:: 3.0.0 Use `make_error <marshmallow.fields.Field.make_error>` instead. \"\" \" warnings . warn ( '`Field.fail` is deprecated. Use `raise self.make_error(\"{}\", ...)` instead.' . format ( key ), RemovedInMarshmallow4Warning , stacklevel = 2 , ) raise self . make_error ( key = key , ** kwargs ) get_value def get_value ( self , obj , attr , accessor = None , default =< marshmallow . missing > ) Return the value for a given key from an object. Parameters: Name Type Description Default obj object The object to get the value from. None attr str The attribute/key in obj to get the value from. None accessor callable A callable used to retrieve the value of attr from the object obj . Defaults to marshmallow.utils.get_value . None View Source def get_value ( self , obj , attr , accessor = None , default = missing_ ) : \" \"\" Return the value for a given key from an object. :param object obj: The object to get the value from. :param str attr: The attribute/key in `obj` to get the value from. :param callable accessor: A callable used to retrieve the value of `attr` from the object `obj`. Defaults to `marshmallow.utils.get_value`. \"\" \" accessor_func = accessor or utils . get_value check_key = attr if self . attribute is None else self . attribute return accessor_func ( obj , check_key , default ) make_error def make_error ( self , key : 'str' , ** kwargs ) -> 'ValidationError' Helper method to make a ValidationError with an error message from self.error_messages . View Source def make_error ( self , key : str , ** kwargs ) -> ValidationError : \" \"\" Helper method to make a `ValidationError` with an error message from ``self.error_messages``. \"\" \" try : msg = self . error_messages [ key ] except KeyError as error : class_name = self . __class__ . __name__ message = ( \"ValidationError raised by `{class_name}`, but error key `{key}` does \" \"not exist in the `error_messages` dictionary.\" ). format ( class_name = class_name , key = key ) raise AssertionError ( message ) from error if isinstance ( msg , ( str , bytes )) : msg = msg . format ( ** kwargs ) return ValidationError ( msg ) serialize def serialize ( self , attr : 'str' , obj : 'typing.Any' , accessor : 'typing.Callable[[typing.Any, str, typing.Any], typing.Any] | None' = None , ** kwargs ) Pulls the value for the given key from the object, applies the field's formatting and returns the result. Parameters: Name Type Description Default attr None The attribute/key to get from the object. None obj None The object to access the attribute/key from. None accessor None Function used to access values from obj . None kwargs None Field-specific keyword arguments. None View Source def serialize ( self , attr : str , obj : typing . Any , accessor : typing . Callable [[ typing . Any , str , typing . Any ] , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Pulls the value for the given key from the object, applies the field's formatting and returns the result. :param attr: The attribute/key to get from the object. :param obj: The object to access the attribute/key from. :param accessor: Function used to access values from ``obj``. :param kwargs: Field-specific keyword arguments. \"\" \" if self . _CHECK_ATTRIBUTE : value = self . get_value ( obj , attr , accessor = accessor ) if value is missing_ : default = self . dump_default value = default () if callable ( default ) else default if value is missing_ : return value else : value = None return self . _serialize ( value , attr , obj , ** kwargs ) PolyCoeff class PolyCoeff ( cls_or_instance =< class ' marshmallow . fields . Number '>, ** kwargs ) Polynomial Coefficients list intent: giving list a and value x result will be r = 0 for i in range ( 0 , a . _len__ ()) : r += a [ i ]* x ** i View Source class PolyCoeff ( fields . List ) : \"\"\" Polynomial Coefficients list intent: giving list a and value x result will be r=0 for i in range(0, a._len__()): r += a[i]*x**i \"\"\" def __init__ ( self , cls_or_instance = fields . Number , ** kwargs ) : super (). __init__ ( cls_or_instance = cls_or_instance , ** kwargs ) def _deserialize ( self , value , attr , data , ** kwargs ) : try : if value in ( 'null' , '' ) : return \"\" value = json . loads ( value ) if value is not None : value = list ( map ( lambda x : x is not None and x or 0 , value )) value = \",\" . join ( map ( str , value )) return value except Exception as e : raise e raise ValueError ( e ) Ancestors (in MRO) marshmallow.fields.List marshmallow.fields.Field marshmallow.base.FieldABC Class variables default_error_messages name parent root Instance variables context The context dictionary for the parent :class: Schema . default missing Methods deserialize def deserialize ( self , value : 'typing.Any' , attr : 'str | None' = None , data : 'typing.Mapping[str, typing.Any] | None' = None , ** kwargs ) Deserialize value . Parameters: Name Type Description Default value None The value to deserialize. None attr None The attribute/key in data to deserialize. None data None The raw input data passed to Schema.load . None kwargs None Field-specific keyword arguments. None Raises: Type Description ValidationError If an invalid value is passed or if a required value is missing. View Source def deserialize ( self , value : typing . Any , attr : str | None = None , data : typing . Mapping [ str , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Deserialize ``value``. :param value: The value to deserialize. :param attr: The attribute/key in `data` to deserialize. :param data: The raw input data passed to `Schema.load`. :param kwargs: Field-specific keyword arguments. :raise ValidationError: If an invalid value is passed or if a required value is missing. \"\" \" # Validate required fields, deserialize, then validate # deserialized value self . _validate_missing ( value ) if value is missing_ : _miss = self . load_default return _miss () if callable ( _miss ) else _miss if self . allow_none and value is None : return None output = self . _deserialize ( value , attr , data , ** kwargs ) self . _validate ( output ) return output fail def fail ( self , key : 'str' , ** kwargs ) Helper method that raises a ValidationError with an error message from self.error_messages . View Source def fail ( self , key : str , ** kwargs ) : \" \"\" Helper method that raises a `ValidationError` with an error message from ``self.error_messages``. .. deprecated:: 3.0.0 Use `make_error <marshmallow.fields.Field.make_error>` instead. \"\" \" warnings . warn ( '`Field.fail` is deprecated. Use `raise self.make_error(\"{}\", ...)` instead.' . format ( key ), RemovedInMarshmallow4Warning , stacklevel = 2 , ) raise self . make_error ( key = key , ** kwargs ) get_value def get_value ( self , obj , attr , accessor = None , default =< marshmallow . missing > ) Return the value for a given key from an object. Parameters: Name Type Description Default obj object The object to get the value from. None attr str The attribute/key in obj to get the value from. None accessor callable A callable used to retrieve the value of attr from the object obj . Defaults to marshmallow.utils.get_value . None View Source def get_value ( self , obj , attr , accessor = None , default = missing_ ) : \" \"\" Return the value for a given key from an object. :param object obj: The object to get the value from. :param str attr: The attribute/key in `obj` to get the value from. :param callable accessor: A callable used to retrieve the value of `attr` from the object `obj`. Defaults to `marshmallow.utils.get_value`. \"\" \" accessor_func = accessor or utils . get_value check_key = attr if self . attribute is None else self . attribute return accessor_func ( obj , check_key , default ) make_error def make_error ( self , key : 'str' , ** kwargs ) -> 'ValidationError' Helper method to make a ValidationError with an error message from self.error_messages . View Source def make_error ( self , key : str , ** kwargs ) -> ValidationError : \" \"\" Helper method to make a `ValidationError` with an error message from ``self.error_messages``. \"\" \" try : msg = self . error_messages [ key ] except KeyError as error : class_name = self . __class__ . __name__ message = ( \"ValidationError raised by `{class_name}`, but error key `{key}` does \" \"not exist in the `error_messages` dictionary.\" ). format ( class_name = class_name , key = key ) raise AssertionError ( message ) from error if isinstance ( msg , ( str , bytes )) : msg = msg . format ( ** kwargs ) return ValidationError ( msg ) serialize def serialize ( self , attr : 'str' , obj : 'typing.Any' , accessor : 'typing.Callable[[typing.Any, str, typing.Any], typing.Any] | None' = None , ** kwargs ) Pulls the value for the given key from the object, applies the field's formatting and returns the result. Parameters: Name Type Description Default attr None The attribute/key to get from the object. None obj None The object to access the attribute/key from. None accessor None Function used to access values from obj . None kwargs None Field-specific keyword arguments. None View Source def serialize ( self , attr : str , obj : typing . Any , accessor : typing . Callable [[ typing . Any , str , typing . Any ] , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Pulls the value for the given key from the object, applies the field's formatting and returns the result. :param attr: The attribute/key to get from the object. :param obj: The object to access the attribute/key from. :param accessor: Function used to access values from ``obj``. :param kwargs: Field-specific keyword arguments. \"\" \" if self . _CHECK_ATTRIBUTE : value = self . get_value ( obj , attr , accessor = accessor ) if value is missing_ : default = self . dump_default value = default () if callable ( default ) else default if value is missing_ : return value else : value = None return self . _serialize ( value , attr , obj , ** kwargs ) StringTime class StringTime ( format : 'str | None' = None , ** kwargs ) A formatted datetime string. Example: '2014-12-22T03:12:58.019077+00:00' Attributes Name Type Description Default format None Either \"rfc\" (for RFC822), \"iso\" (for ISO8601), \"timestamp\" , \"timestamp_ms\" (for a POSIX timestamp) or a date format string. If None , defaults to \"iso\". \"iso\" kwargs None The same keyword arguments that :class: Field receives. .. versionchanged:: 3.0.0rc9 Does not modify timezone information on (de)serialization. .. versionchanged:: 3.19 Add timestamp as a format. None View Source class StringTime ( fields . DateTime ): def _agoodtime ( t ): try: t = datetime64 ( t ) assert not isnat ( t ) t = str ( t ) except Exception as e: t = None return t def _deserialize ( self , value , attr , data , ** kwargs ): return str ( super (). _deserialize ( value , attr , data , ** kwargs )) def _serialize ( self , value , attr , obj , ** kwargs ): return StringTime . _agoodtime ( value ) Ancestors (in MRO) marshmallow.fields.DateTime marshmallow.fields.Field marshmallow.base.FieldABC Class variables DEFAULT_FORMAT DESERIALIZATION_FUNCS OBJ_TYPE SCHEMA_OPTS_VAR_NAME SERIALIZATION_FUNCS default_error_messages name parent root Instance variables context The context dictionary for the parent :class: Schema . default missing Methods deserialize def deserialize ( self , value : 'typing.Any' , attr : 'str | None' = None , data : 'typing.Mapping[str, typing.Any] | None' = None , ** kwargs ) Deserialize value . Parameters: Name Type Description Default value None The value to deserialize. None attr None The attribute/key in data to deserialize. None data None The raw input data passed to Schema.load . None kwargs None Field-specific keyword arguments. None Raises: Type Description ValidationError If an invalid value is passed or if a required value is missing. View Source def deserialize ( self , value : typing . Any , attr : str | None = None , data : typing . Mapping [ str , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Deserialize ``value``. :param value: The value to deserialize. :param attr: The attribute/key in `data` to deserialize. :param data: The raw input data passed to `Schema.load`. :param kwargs: Field-specific keyword arguments. :raise ValidationError: If an invalid value is passed or if a required value is missing. \"\" \" # Validate required fields, deserialize, then validate # deserialized value self . _validate_missing ( value ) if value is missing_ : _miss = self . load_default return _miss () if callable ( _miss ) else _miss if self . allow_none and value is None : return None output = self . _deserialize ( value , attr , data , ** kwargs ) self . _validate ( output ) return output fail def fail ( self , key : 'str' , ** kwargs ) Helper method that raises a ValidationError with an error message from self.error_messages . View Source def fail ( self , key : str , ** kwargs ) : \" \"\" Helper method that raises a `ValidationError` with an error message from ``self.error_messages``. .. deprecated:: 3.0.0 Use `make_error <marshmallow.fields.Field.make_error>` instead. \"\" \" warnings . warn ( '`Field.fail` is deprecated. Use `raise self.make_error(\"{}\", ...)` instead.' . format ( key ), RemovedInMarshmallow4Warning , stacklevel = 2 , ) raise self . make_error ( key = key , ** kwargs ) get_value def get_value ( self , obj , attr , accessor = None , default =< marshmallow . missing > ) Return the value for a given key from an object. Parameters: Name Type Description Default obj object The object to get the value from. None attr str The attribute/key in obj to get the value from. None accessor callable A callable used to retrieve the value of attr from the object obj . Defaults to marshmallow.utils.get_value . None View Source def get_value ( self , obj , attr , accessor = None , default = missing_ ) : \" \"\" Return the value for a given key from an object. :param object obj: The object to get the value from. :param str attr: The attribute/key in `obj` to get the value from. :param callable accessor: A callable used to retrieve the value of `attr` from the object `obj`. Defaults to `marshmallow.utils.get_value`. \"\" \" accessor_func = accessor or utils . get_value check_key = attr if self . attribute is None else self . attribute return accessor_func ( obj , check_key , default ) make_error def make_error ( self , key : 'str' , ** kwargs ) -> 'ValidationError' Helper method to make a ValidationError with an error message from self.error_messages . View Source def make_error ( self , key : str , ** kwargs ) -> ValidationError : \" \"\" Helper method to make a `ValidationError` with an error message from ``self.error_messages``. \"\" \" try : msg = self . error_messages [ key ] except KeyError as error : class_name = self . __class__ . __name__ message = ( \"ValidationError raised by `{class_name}`, but error key `{key}` does \" \"not exist in the `error_messages` dictionary.\" ). format ( class_name = class_name , key = key ) raise AssertionError ( message ) from error if isinstance ( msg , ( str , bytes )) : msg = msg . format ( ** kwargs ) return ValidationError ( msg ) serialize def serialize ( self , attr : 'str' , obj : 'typing.Any' , accessor : 'typing.Callable[[typing.Any, str, typing.Any], typing.Any] | None' = None , ** kwargs ) Pulls the value for the given key from the object, applies the field's formatting and returns the result. Parameters: Name Type Description Default attr None The attribute/key to get from the object. None obj None The object to access the attribute/key from. None accessor None Function used to access values from obj . None kwargs None Field-specific keyword arguments. None View Source def serialize ( self , attr : str , obj : typing . Any , accessor : typing . Callable [[ typing . Any , str , typing . Any ] , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Pulls the value for the given key from the object, applies the field's formatting and returns the result. :param attr: The attribute/key to get from the object. :param obj: The object to access the attribute/key from. :param accessor: Function used to access values from ``obj``. :param kwargs: Field-specific keyword arguments. \"\" \" if self . _CHECK_ATTRIBUTE : value = self . get_value ( obj , attr , accessor = accessor ) if value is missing_ : default = self . dump_default value = default () if callable ( default ) else default if value is missing_ : return value else : value = None return self . _serialize ( value , attr , obj , ** kwargs ) Style class Style ( * , load_default : 'typing.Any' = < marshmallow . missing > , missing : 'typing.Any' = < marshmallow . missing > , dump_default : 'typing.Any' = < marshmallow . missing > , default : 'typing.Any' = < marshmallow . missing > , data_key : 'str | None' = None , attribute : 'str | None' = None , validate : 'None | (typing.Callable[[typing.Any], typing.Any] | typing.Iterable[typing.Callable[[typing.Any], typing.Any]])' = None , required : 'bool' = False , allow_none : 'bool | None' = None , load_only : 'bool' = False , dump_only : 'bool' = False , error_messages : 'dict[str, str] | None' = None , metadata : 'typing.Mapping[str, typing.Any] | None' = None , ** additional_metadata ) View Source class Style ( fields . String ): \"\"\" \"\"\" pass Ancestors (in MRO) marshmallow.fields.String marshmallow.fields.Field marshmallow.base.FieldABC Class variables default_error_messages name parent root Instance variables context The context dictionary for the parent :class: Schema . default missing Methods deserialize def deserialize ( self , value : 'typing.Any' , attr : 'str | None' = None , data : 'typing.Mapping[str, typing.Any] | None' = None , ** kwargs ) Deserialize value . Parameters: Name Type Description Default value None The value to deserialize. None attr None The attribute/key in data to deserialize. None data None The raw input data passed to Schema.load . None kwargs None Field-specific keyword arguments. None Raises: Type Description ValidationError If an invalid value is passed or if a required value is missing. View Source def deserialize ( self , value : typing . Any , attr : str | None = None , data : typing . Mapping [ str , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Deserialize ``value``. :param value: The value to deserialize. :param attr: The attribute/key in `data` to deserialize. :param data: The raw input data passed to `Schema.load`. :param kwargs: Field-specific keyword arguments. :raise ValidationError: If an invalid value is passed or if a required value is missing. \"\" \" # Validate required fields, deserialize, then validate # deserialized value self . _validate_missing ( value ) if value is missing_ : _miss = self . load_default return _miss () if callable ( _miss ) else _miss if self . allow_none and value is None : return None output = self . _deserialize ( value , attr , data , ** kwargs ) self . _validate ( output ) return output fail def fail ( self , key : 'str' , ** kwargs ) Helper method that raises a ValidationError with an error message from self.error_messages . View Source def fail ( self , key : str , ** kwargs ) : \" \"\" Helper method that raises a `ValidationError` with an error message from ``self.error_messages``. .. deprecated:: 3.0.0 Use `make_error <marshmallow.fields.Field.make_error>` instead. \"\" \" warnings . warn ( '`Field.fail` is deprecated. Use `raise self.make_error(\"{}\", ...)` instead.' . format ( key ), RemovedInMarshmallow4Warning , stacklevel = 2 , ) raise self . make_error ( key = key , ** kwargs ) get_value def get_value ( self , obj , attr , accessor = None , default =< marshmallow . missing > ) Return the value for a given key from an object. Parameters: Name Type Description Default obj object The object to get the value from. None attr str The attribute/key in obj to get the value from. None accessor callable A callable used to retrieve the value of attr from the object obj . Defaults to marshmallow.utils.get_value . None View Source def get_value ( self , obj , attr , accessor = None , default = missing_ ) : \" \"\" Return the value for a given key from an object. :param object obj: The object to get the value from. :param str attr: The attribute/key in `obj` to get the value from. :param callable accessor: A callable used to retrieve the value of `attr` from the object `obj`. Defaults to `marshmallow.utils.get_value`. \"\" \" accessor_func = accessor or utils . get_value check_key = attr if self . attribute is None else self . attribute return accessor_func ( obj , check_key , default ) make_error def make_error ( self , key : 'str' , ** kwargs ) -> 'ValidationError' Helper method to make a ValidationError with an error message from self.error_messages . View Source def make_error ( self , key : str , ** kwargs ) -> ValidationError : \" \"\" Helper method to make a `ValidationError` with an error message from ``self.error_messages``. \"\" \" try : msg = self . error_messages [ key ] except KeyError as error : class_name = self . __class__ . __name__ message = ( \"ValidationError raised by `{class_name}`, but error key `{key}` does \" \"not exist in the `error_messages` dictionary.\" ). format ( class_name = class_name , key = key ) raise AssertionError ( message ) from error if isinstance ( msg , ( str , bytes )) : msg = msg . format ( ** kwargs ) return ValidationError ( msg ) serialize def serialize ( self , attr : 'str' , obj : 'typing.Any' , accessor : 'typing.Callable[[typing.Any, str, typing.Any], typing.Any] | None' = None , ** kwargs ) Pulls the value for the given key from the object, applies the field's formatting and returns the result. Parameters: Name Type Description Default attr None The attribute/key to get from the object. None obj None The object to access the attribute/key from. None accessor None Function used to access values from obj . None kwargs None Field-specific keyword arguments. None View Source def serialize ( self , attr : str , obj : typing . Any , accessor : typing . Callable [[ typing . Any , str , typing . Any ] , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Pulls the value for the given key from the object, applies the field's formatting and returns the result. :param attr: The attribute/key to get from the object. :param obj: The object to access the attribute/key from. :param accessor: Function used to access values from ``obj``. :param kwargs: Field-specific keyword arguments. \"\" \" if self . _CHECK_ATTRIBUTE : value = self . get_value ( obj , attr , accessor = accessor ) if value is missing_ : default = self . dump_default value = default () if callable ( default ) else default if value is missing_ : return value else : value = None return self . _serialize ( value , attr , obj , ** kwargs )","title":"Serializaction"},{"location":"reference/hielen3/serializaction/#module-hielen3serializaction","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 #!/usr/bin/env python # coding=utf-8 from marshmallow import Schema , fields , ValidationError , INCLUDE from numpy import datetime64 , isnat from hielen3 import conf from pathlib import Path import json from pandas import DataFrame from numpy import array , sqrt , sum , where , amin , nan , round from matplotlib.colors import ColorConverter , Normalize , LinearSegmentedColormap from abc import ABC , abstractmethod ### MARSHMALLOW FIELDS class Style ( fields . String ): \"\"\" \"\"\" pass class FTPPath ( fields . String ): \"\"\" Local FTP Filepath manager used to identify a file into the system. Mainliy usefull for action Schema declaration in hielen3.HielenSource extention \"\"\" def _deserialize ( self , value , attr , data , ** kwargs ): try : return Path ( value ) except Exception as e : raise ValueError ( e ) class LocalFile ( fields . String ): \"\"\" Local Filepath manager used to identify a file into the system. Mainliy usefull for action Schema declaration in hielen3.HielenSource extention \"\"\" pass class LoggerHeader ( fields . List ): \"\"\" Logger Header alias \"\"\" class PolyCoeff ( fields . List ): \"\"\" Polynomial Coefficients list intent: giving list a and value x result will be r=0 for i in range(0, a._len__()): r += a[i]*x**i \"\"\" def __init__ ( self , cls_or_instance = fields . Number , ** kwargs ): super () . __init__ ( cls_or_instance = cls_or_instance , ** kwargs ) def _deserialize ( self , value , attr , data , ** kwargs ): try : if value in ( 'null' , '' ): return \"\" value = json . loads ( value ) if value is not None : value = list ( map ( lambda x : x is not None and x or 0 , value )) value = \",\" . join ( map ( str , value )) return value except Exception as e : raise e raise ValueError ( e ) ''' class LoggerHeader(fields.List): \"\"\" Logger Header manager \"\"\" def __init__(self,cls_or_instance=fields.Tuple( ( fields.String(), #Param fields.Integer(), #Column fields.String(), #Raw_mu fields.String(), #Ing_mu fields.String(), #Signal_cond fields.List(fields.Number()) #Poly coeff ) ),**kwargs): super().__init__(cls_or_instance=cls_or_instance,**kwargs) def _deserialize(self,value, attr, data, **kwargs): try: return json.loads(value) except Exception as e: raise ValueError(e) ''' class ParamsDefinition ( fields . List ): \"\"\" Logger Header manager \"\"\" def __init__ ( self , cls_or_instance = fields . Tuple ( ( fields . String (), #Param fields . Integer (), #Column fields . String () #Ing_mu ) ), ** kwargs ): super () . __init__ ( cls_or_instance = cls_or_instance , ** kwargs ) def _deserialize ( self , value , attr , data , ** kwargs ): try : return json . loads ( value ) except Exception as e : raise ValueError ( e ) class ColorMap ( fields . List ): \"\"\" Colormap manager used to identify a colormap \"\"\" def __init__ ( self , cls_or_instance = fields . Tuple (( fields . String (), fields . Number ())), ** kwargs ): super () . __init__ ( cls_or_instance = cls_or_instance , ** kwargs ) def _deserialize ( self , value , attr , data , ** kwargs ): try : return ColorMap . make_colormap ( json . loads ( value )) except Exception as e : try : assert value [ 'f_cmap' ] return value except Exception as e : raise ValueError ( e ) def valorizeColor ( clmap , color ): c = ColorConverter () try : colframe = DataFrame ([ c . to_rgb ( x [ 1 ]) for x in clmap ]) except ValueError as e : colframe = DataFrame ([ x [ 1 ] for x in clmap ]) colframe = colframe / 255 colframe = colframe . apply ( c . to_rgb , axis = 1 , result_type = 'expand' ) colframe . columns = [ 'r' , 'g' , 'b' ] colframe [ 'values' ] = [ x [ 0 ] for x in clmap ] colors = colframe [[ 'r' , 'g' , 'b' ]] . values colframe = colframe . set_index ([ 'r' , 'g' , 'b' ]) color = array ( color ) try : color = array ( c . to_rgb ( color )) except ValueError as e : color = DataFrame ([ color ], columns = [ 'r' , 'g' , 'b' ]) / 255 color = color . apply ( c . to_rgb , axis = 1 , result_type = 'expand' ) . values distances = sqrt ( sum (( colors - color ) ** 2 , axis = 1 )) index_of_smallest = where ( distances == amin ( distances )) try : return float ( colframe [ 'values' ] . iloc [ index_of_smallest ] . squeeze ()) except Exception as e : return nan def parse_colormap ( incmap ): if incmap is None : return ColorMap . parse_colormap ( ColorMap . make_colormap ()) try : norm = Normalize ( ** incmap [ \"norm\" ]) norm . clip = True except Exception : norm = None cmap = LinearSegmentedColormap ( 'CustomMap' , incmap [ 'b_cmap' ]) return { \"norm\" : norm , \"cmap\" : cmap } def make_colormap ( incmap = None ): if incmap is None : incmap = [[ - 0.25 , \"#FF0000\" ],[ 0 , \"#00FF00\" ],[ 0.25 , \"#0000FF\" ]] a = DataFrame ( incmap , columns = [ \"values\" , \"colors\" ]) . sort_values ( \"values\" ) out = { \"norm\" :{ \"vmin\" : a [ \"values\" ][ 0 ], \"vmax\" : a [ \"values\" ] . iloc [ a . shape [ 0 ] - 1 ]}} n = Normalize ( ** out [ \"norm\" ]) a [ \"values\" ] = round ( a [ \"values\" ], 3 ) a [ \"idx\" ] = n ( a [ \"values\" ]) * 100 cc = a [[ \"idx\" , \"colors\" ]] . values seq = [] c = ColorConverter () for i in range ( cc . __len__ ()): if i == 0 or i == cc . __len__ (): seq . append ( c . to_rgb ( cc [ i ][ 1 ])) else : seq . append ( c . to_rgb ( cc [ i ][ 1 ])) seq . append ( cc [ i ][ 0 ] / 100 ) seq . append ( c . to_rgb ( cc [ i ][ 1 ])) seq = [( None ,) * 3 , 0.0 ] + list ( seq ) + [ 1.0 , ( None ,) * 3 ] linsegcmap = { 'red' : [], 'green' : [], 'blue' : []} for i , item in enumerate ( seq ): if isinstance ( item , float ): r1 , g1 , b1 = seq [ i - 1 ] r2 , g2 , b2 = seq [ i + 1 ] linsegcmap [ 'red' ] . append ([ item , r1 , r2 ]) linsegcmap [ 'green' ] . append ([ item , g1 , g2 ]) linsegcmap [ 'blue' ] . append ([ item , b1 , b2 ]) out [ \"f_cmap\" ] = a . values . tolist () out [ \"b_cmap\" ] = linsegcmap return out class StringTime ( fields . DateTime ): def _agoodtime ( t ): try : t = datetime64 ( t ) assert not isnat ( t ) t = str ( t ) except Exception as e : t = None return t def _deserialize ( self , value , attr , data , ** kwargs ): return str ( super () . _deserialize ( value , attr , data , ** kwargs )) def _serialize ( self , value , attr , obj , ** kwargs ): return StringTime . _agoodtime ( value ) class HSchema ( Schema ): ''' Minimal ancestor class providing mehods ''' class Meta : unknown = INCLUDE @property def __hdict__ ( self ): out = { \"fields\" :{}, \"required\" :[], \"hints\" : self . hints } for k , w in self . dump_fields . items (): out [ 'fields' ][ k ] = w . __class__ . __name__ w . __dict__ [ 'required' ] and out [ \"required\" ] . append ( k ) return out @abstractmethod def _self_hints_ (): pass @property def hints ( self ): out = self . __class__ . _self_hints_ () or {} for c in self . __class__ . __bases__ : try : out . update ( c () . hints ) except AttributeError as e : pass return out timestamp = StringTime ( required = True , allow_none = False ) class ActionSchema ( HSchema ): ''' Minimal ActionSchema object. Used to define at least a timestamp ''' def _self_hints_ (): return { \"Base\" : { 0 : [ \"timestamp\" , \"Reference time\" , False , None ] } } timestamp = StringTime ( required = True , allow_none = False ) \"\"\" class GeoInfoSchema(ActionSchema): ''' Minimal map based ActionSchema object. Used to define geo-info ''' _self_hints = { \"Geo Info\": { 0: [\"master_image\",\"The base image used as reference grid for elaboration or basemap. It can be any image format managed by rasterio pyhton library (GeoTIFF, jp eg, ...). Colometric interpretation will be RGB whit Black alpha mask. Any elaboration image based on the 'master_image' will share geometry and reference system with it.\",False], 1: [\"geo_reference_file\",\"Reference file for the geolocalization of the 'grid' and all the dependent elaboration images. It can be a standard world file (six lines text file) according to http://www.kralidis.ca/gis/worldfile.htm, as well an '.aux.xml' file according to https://desktop.arcgis.com/en/arcmap/10.3/manage-data/raster-and-images/auxiliary-files.htm (just the Coordinate system, the Transformation and the Projection informations are here managed). NOTE: When a valid 'geo_regerence_file' is provided, therein informations overwrite the ones possibly embedded into the 'master_image'\",False], 2:[\"crs\", \"the Coordinate Reference System of the master_image in the string form 'autority:code' (i.e.: 'EPSG:3857'). NOTE: If a valid 'crs' is provided, this value overwrites the ones possibly provided with the 'geo_regerence_file' and/or embeded into the 'master_image'\",False], 3:[\"extent_easting\",\"Easting map extention, according with 'crs' and 'geo_reference_file'. Ignored if 'master_image' is provided\",False], 4:[\"extent_northing\",\"Northing map extention, according with 'crs' and 'geo_reference_file'. Ignored if 'master_image' is provided\",False] } } master_image = FTPPath(required=False, allow_none=True) geo_reference_file = FTPPath(required=False,default=None, allow_none=True) crs=fields.Str(required=False,default=None,allow_none=True) extent_easting=fields.Number(required=False, default=None, allow_none=True, as_string=False) extent_northing=fields.Number(required=False, default=None, allow_none=True, as_string=False) \"\"\"","title":"Module hielen3.serializaction"},{"location":"reference/hielen3/serializaction/#variables","text":"INCLUDE conf isnat nan sqrt","title":"Variables"},{"location":"reference/hielen3/serializaction/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/serializaction/#actionschema","text":"class ActionSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ActionSchema ( HSchema ): ''' Minimal ActionSchema object. Used to define at least a timestamp ''' def _self_hints_ (): return { \"Base\" : { 0 : [ \"timestamp\" , \"Reference time\" , False , None ] } } timestamp = StringTime ( required = True , allow_none = False )","title":"ActionSchema"},{"location":"reference/hielen3/serializaction/#ancestors-in-mro","text":"hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/serializaction/#descendants","text":"hielen3.ext.feature_instrument_clinometer.feature.ConfigSchema hielen3.ext.feature_instrument_generic.feature.ConfigSchema hielen3.ext.feature_instrument_improved.feature.ConfigSchema hielen3.ext.feature_instrument_piezometer.feature.ConfigSchema hielen3.ext.feature_logger_boviar.logger.ConfigSchema hielen3.ext.feature_logger_capetti.logger.ConfigSchema hielen3.ext.feature_logger_gestecno.logger.ConfigSchema hielen3.ext.feature_logger_move.logger.ConfigSchema hielen3.ext.feature_logger_move__.logger.ConfigSchema hielen3.ext.feature_logger_move__.feature_logger_move.logger.ConfigSchema hielen3.ext.feature_logger_omnialog_temp.logger.ConfigSchema hielen3.ext.feature_logger_smartbrik4_0.logger.ConfigSchema hielen3.ext.feature_logger_winecap.logger.ConfigSchema hielen3.ext.feature_rfilogger.rfilogger.ConfigSchema hielen3.ext.feature_rfilogger.rfilogger_good.ConfigSchema hielen3.ext.feature_spotted_files_source.logger.ConfigSchema","title":"Descendants"},{"location":"reference/hielen3/serializaction/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages opts timestamp","title":"Class variables"},{"location":"reference/hielen3/serializaction/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/serializaction/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/serializaction/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/serializaction/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/serializaction/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/serializaction/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/serializaction/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/serializaction/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/serializaction/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/serializaction/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/serializaction/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/serializaction/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/serializaction/#colormap","text":"class ColorMap ( cls_or_instance =< fields . Tuple ( dump_default =< marshmallow . missing > , attribute = None , validate = None , required = False , load_only = False , dump_only = False , load_default =< marshmallow . missing > , allow_none = False , error_messages = { 'required' : 'Missing data for required field.' , 'null' : 'Field may not be null.' , 'validator_failed' : 'Invalid value.' , 'invalid' : 'Not a valid tuple.' }) > , ** kwargs ) Colormap manager used to identify a colormap View Source class ColorMap ( fields . List ): \"\"\" Colormap manager used to identify a colormap \"\"\" def __init__ ( self , cls_or_instance = fields . Tuple (( fields . String (), fields . Number ())), ** kwargs ): super () . __init__ ( cls_or_instance = cls_or_instance , ** kwargs ) def _deserialize ( self , value , attr , data , ** kwargs ): try : return ColorMap . make_colormap ( json . loads ( value )) except Exception as e : try : assert value [ 'f_cmap' ] return value except Exception as e : raise ValueError ( e ) def valorizeColor ( clmap , color ): c = ColorConverter () try : colframe = DataFrame ([ c . to_rgb ( x [ 1 ]) for x in clmap ]) except ValueError as e : colframe = DataFrame ([ x [ 1 ] for x in clmap ]) colframe = colframe / 255 colframe = colframe . apply ( c . to_rgb , axis = 1 , result_type = 'expand' ) colframe . columns = [ 'r' , 'g' , 'b' ] colframe [ 'values' ] = [ x [ 0 ] for x in clmap ] colors = colframe [[ 'r' , 'g' , 'b' ]] . values colframe = colframe . set_index ([ 'r' , 'g' , 'b' ]) color = array ( color ) try : color = array ( c . to_rgb ( color )) except ValueError as e : color = DataFrame ([ color ], columns = [ 'r' , 'g' , 'b' ]) / 255 color = color . apply ( c . to_rgb , axis = 1 , result_type = 'expand' ) . values distances = sqrt ( sum (( colors - color ) ** 2 , axis = 1 )) index_of_smallest = where ( distances == amin ( distances )) try : return float ( colframe [ 'values' ] . iloc [ index_of_smallest ] . squeeze ()) except Exception as e : return nan def parse_colormap ( incmap ): if incmap is None : return ColorMap . parse_colormap ( ColorMap . make_colormap ()) try : norm = Normalize ( ** incmap [ \"norm\" ]) norm . clip = True except Exception : norm = None cmap = LinearSegmentedColormap ( 'CustomMap' , incmap [ 'b_cmap' ]) return { \"norm\" : norm , \"cmap\" : cmap } def make_colormap ( incmap = None ): if incmap is None : incmap = [[ - 0.25 , \"#FF0000\" ],[ 0 , \"#00FF00\" ],[ 0.25 , \"#0000FF\" ]] a = DataFrame ( incmap , columns = [ \"values\" , \"colors\" ]) . sort_values ( \"values\" ) out = { \"norm\" :{ \"vmin\" : a [ \"values\" ][ 0 ], \"vmax\" : a [ \"values\" ] . iloc [ a . shape [ 0 ] - 1 ]}} n = Normalize ( ** out [ \"norm\" ]) a [ \"values\" ] = round ( a [ \"values\" ], 3 ) a [ \"idx\" ] = n ( a [ \"values\" ]) * 100 cc = a [[ \"idx\" , \"colors\" ]] . values seq = [] c = ColorConverter () for i in range ( cc . __len__ ()): if i == 0 or i == cc . __len__ (): seq . append ( c . to_rgb ( cc [ i ][ 1 ])) else : seq . append ( c . to_rgb ( cc [ i ][ 1 ])) seq . append ( cc [ i ][ 0 ] / 100 ) seq . append ( c . to_rgb ( cc [ i ][ 1 ])) seq = [( None ,) * 3 , 0.0 ] + list ( seq ) + [ 1.0 , ( None ,) * 3 ] linsegcmap = { 'red' : [], 'green' : [], 'blue' : []} for i , item in enumerate ( seq ): if isinstance ( item , float ): r1 , g1 , b1 = seq [ i - 1 ] r2 , g2 , b2 = seq [ i + 1 ] linsegcmap [ 'red' ] . append ([ item , r1 , r2 ]) linsegcmap [ 'green' ] . append ([ item , g1 , g2 ]) linsegcmap [ 'blue' ] . append ([ item , b1 , b2 ]) out [ \"f_cmap\" ] = a . values . tolist () out [ \"b_cmap\" ] = linsegcmap return out","title":"ColorMap"},{"location":"reference/hielen3/serializaction/#ancestors-in-mro_1","text":"marshmallow.fields.List marshmallow.fields.Field marshmallow.base.FieldABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/serializaction/#class-variables_1","text":"default_error_messages name parent root","title":"Class variables"},{"location":"reference/hielen3/serializaction/#instance-variables_1","text":"context The context dictionary for the parent :class: Schema . default missing","title":"Instance variables"},{"location":"reference/hielen3/serializaction/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/serializaction/#deserialize","text":"def deserialize ( self , value : 'typing.Any' , attr : 'str | None' = None , data : 'typing.Mapping[str, typing.Any] | None' = None , ** kwargs ) Deserialize value . Parameters: Name Type Description Default value None The value to deserialize. None attr None The attribute/key in data to deserialize. None data None The raw input data passed to Schema.load . None kwargs None Field-specific keyword arguments. None Raises: Type Description ValidationError If an invalid value is passed or if a required value is missing. View Source def deserialize ( self , value : typing . Any , attr : str | None = None , data : typing . Mapping [ str , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Deserialize ``value``. :param value: The value to deserialize. :param attr: The attribute/key in `data` to deserialize. :param data: The raw input data passed to `Schema.load`. :param kwargs: Field-specific keyword arguments. :raise ValidationError: If an invalid value is passed or if a required value is missing. \"\" \" # Validate required fields, deserialize, then validate # deserialized value self . _validate_missing ( value ) if value is missing_ : _miss = self . load_default return _miss () if callable ( _miss ) else _miss if self . allow_none and value is None : return None output = self . _deserialize ( value , attr , data , ** kwargs ) self . _validate ( output ) return output","title":"deserialize"},{"location":"reference/hielen3/serializaction/#fail","text":"def fail ( self , key : 'str' , ** kwargs ) Helper method that raises a ValidationError with an error message from self.error_messages . View Source def fail ( self , key : str , ** kwargs ) : \" \"\" Helper method that raises a `ValidationError` with an error message from ``self.error_messages``. .. deprecated:: 3.0.0 Use `make_error <marshmallow.fields.Field.make_error>` instead. \"\" \" warnings . warn ( '`Field.fail` is deprecated. Use `raise self.make_error(\"{}\", ...)` instead.' . format ( key ), RemovedInMarshmallow4Warning , stacklevel = 2 , ) raise self . make_error ( key = key , ** kwargs )","title":"fail"},{"location":"reference/hielen3/serializaction/#get_value","text":"def get_value ( self , obj , attr , accessor = None , default =< marshmallow . missing > ) Return the value for a given key from an object. Parameters: Name Type Description Default obj object The object to get the value from. None attr str The attribute/key in obj to get the value from. None accessor callable A callable used to retrieve the value of attr from the object obj . Defaults to marshmallow.utils.get_value . None View Source def get_value ( self , obj , attr , accessor = None , default = missing_ ) : \" \"\" Return the value for a given key from an object. :param object obj: The object to get the value from. :param str attr: The attribute/key in `obj` to get the value from. :param callable accessor: A callable used to retrieve the value of `attr` from the object `obj`. Defaults to `marshmallow.utils.get_value`. \"\" \" accessor_func = accessor or utils . get_value check_key = attr if self . attribute is None else self . attribute return accessor_func ( obj , check_key , default )","title":"get_value"},{"location":"reference/hielen3/serializaction/#make_colormap","text":"def make_colormap ( incmap = None ) View Source def make_colormap ( incmap = None ) : if incmap is None : incmap =[ [-0.25,\"#FF0000\" ] , [ 0,\"#00FF00\" ] , [ 0.25,\"#0000FF\" ] ] a = DataFrame ( incmap , columns =[ \"values\",\"colors\" ] ). sort_values ( \"values\" ) out = { \"norm\" :{ \"vmin\" : a [ \"values\" ][ 0 ] , \"vmax\" : a [ \"values\" ] . iloc [ a.shape[0 ]- 1 ]}} n = Normalize ( ** out [ \"norm\" ] ) a [ \"values\" ]= round ( a [ \"values\" ] , 3 ) a [ \"idx\" ]= n ( a [ \"values\" ] ) * 100 cc = a [ [\"idx\",\"colors\" ] ] . values seq = [] c = ColorConverter () for i in range ( cc . __len__ ()) : if i == 0 or i == cc . __len__ () : seq . append ( c . to_rgb ( cc [ i ][ 1 ] )) else : seq . append ( c . to_rgb ( cc [ i ][ 1 ] )) seq . append ( cc [ i ][ 0 ]/ 100 ) seq . append ( c . to_rgb ( cc [ i ][ 1 ] )) seq = [ (None,) * 3, 0.0 ] + list ( seq ) + [ 1.0, (None,) * 3 ] linsegcmap = { 'red' : [] , 'green' : [] , 'blue' : []} for i , item in enumerate ( seq ) : if isinstance ( item , float ) : r1 , g1 , b1 = seq [ i - 1 ] r2 , g2 , b2 = seq [ i + 1 ] linsegcmap [ 'red' ] . append ( [ item, r1, r2 ] ) linsegcmap [ 'green' ] . append ( [ item, g1, g2 ] ) linsegcmap [ 'blue' ] . append ( [ item, b1, b2 ] ) out [ \"f_cmap\" ]= a . values . tolist () out [ \"b_cmap\" ]= linsegcmap return out","title":"make_colormap"},{"location":"reference/hielen3/serializaction/#make_error","text":"def make_error ( self , key : 'str' , ** kwargs ) -> 'ValidationError' Helper method to make a ValidationError with an error message from self.error_messages . View Source def make_error ( self , key : str , ** kwargs ) -> ValidationError : \" \"\" Helper method to make a `ValidationError` with an error message from ``self.error_messages``. \"\" \" try : msg = self . error_messages [ key ] except KeyError as error : class_name = self . __class__ . __name__ message = ( \"ValidationError raised by `{class_name}`, but error key `{key}` does \" \"not exist in the `error_messages` dictionary.\" ). format ( class_name = class_name , key = key ) raise AssertionError ( message ) from error if isinstance ( msg , ( str , bytes )) : msg = msg . format ( ** kwargs ) return ValidationError ( msg )","title":"make_error"},{"location":"reference/hielen3/serializaction/#parse_colormap","text":"def parse_colormap ( incmap ) View Source def parse_colormap ( incmap ) : if incmap is None : return ColorMap . parse_colormap ( ColorMap . make_colormap ()) try : norm = Normalize ( ** incmap [ \"norm\" ] ) norm . clip = True except Exception : norm = None cmap = LinearSegmentedColormap ( 'CustomMap' , incmap [ 'b_cmap' ] ) return { \"norm\" : norm , \"cmap\" : cmap }","title":"parse_colormap"},{"location":"reference/hielen3/serializaction/#serialize","text":"def serialize ( self , attr : 'str' , obj : 'typing.Any' , accessor : 'typing.Callable[[typing.Any, str, typing.Any], typing.Any] | None' = None , ** kwargs ) Pulls the value for the given key from the object, applies the field's formatting and returns the result. Parameters: Name Type Description Default attr None The attribute/key to get from the object. None obj None The object to access the attribute/key from. None accessor None Function used to access values from obj . None kwargs None Field-specific keyword arguments. None View Source def serialize ( self , attr : str , obj : typing . Any , accessor : typing . Callable [[ typing . Any , str , typing . Any ] , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Pulls the value for the given key from the object, applies the field's formatting and returns the result. :param attr: The attribute/key to get from the object. :param obj: The object to access the attribute/key from. :param accessor: Function used to access values from ``obj``. :param kwargs: Field-specific keyword arguments. \"\" \" if self . _CHECK_ATTRIBUTE : value = self . get_value ( obj , attr , accessor = accessor ) if value is missing_ : default = self . dump_default value = default () if callable ( default ) else default if value is missing_ : return value else : value = None return self . _serialize ( value , attr , obj , ** kwargs )","title":"serialize"},{"location":"reference/hielen3/serializaction/#valorizecolor","text":"def valorizeColor ( clmap , color ) View Source def valorizeColor ( clmap , color ) : c = ColorConverter () try : colframe = DataFrame ( [ c.to_rgb(x[1 ] ) for x in clmap ] ) except ValueError as e : colframe = DataFrame ( [ x[1 ] for x in clmap ] ) colframe = colframe / 255 colframe = colframe . apply ( c . to_rgb , axis = 1 , result_type = 'expand' ) colframe . columns =[ 'r','g','b' ] colframe [ 'values' ] = [ x[0 ] for x in clmap ] colors = colframe [ ['r','g','b' ] ] . values colframe = colframe . set_index ( [ 'r','g','b' ] ) color = array ( color ) try : color = array ( c . to_rgb ( color )) except ValueError as e : color = DataFrame ( [ color ] , columns =[ 'r','g','b' ] ) / 255 color = color . apply ( c . to_rgb , axis = 1 , result_type = 'expand' ). values distances = sqrt ( sum (( colors - color ) ** 2 , axis = 1 )) index_of_smallest = where ( distances == amin ( distances )) try : return float ( colframe [ 'values' ] . iloc [ index_of_smallest ] . squeeze ()) except Exception as e : return nan","title":"valorizeColor"},{"location":"reference/hielen3/serializaction/#ftppath","text":"class FTPPath ( * , load_default : 'typing.Any' = < marshmallow . missing > , missing : 'typing.Any' = < marshmallow . missing > , dump_default : 'typing.Any' = < marshmallow . missing > , default : 'typing.Any' = < marshmallow . missing > , data_key : 'str | None' = None , attribute : 'str | None' = None , validate : 'None | (typing.Callable[[typing.Any], typing.Any] | typing.Iterable[typing.Callable[[typing.Any], typing.Any]])' = None , required : 'bool' = False , allow_none : 'bool | None' = None , load_only : 'bool' = False , dump_only : 'bool' = False , error_messages : 'dict[str, str] | None' = None , metadata : 'typing.Mapping[str, typing.Any] | None' = None , ** additional_metadata ) Local FTP Filepath manager used to identify a file into the system. Mainliy usefull for action Schema declaration in hielen3.HielenSource extention View Source class FTPPath ( fields . String ): \"\"\" Local FTP Filepath manager used to identify a file into the system. Mainliy usefull for action Schema declaration in hielen3.HielenSource extention \"\"\" def _deserialize ( self , value , attr , data , ** kwargs ): try: return Path ( value ) except Exception as e: raise ValueError ( e )","title":"FTPPath"},{"location":"reference/hielen3/serializaction/#ancestors-in-mro_2","text":"marshmallow.fields.String marshmallow.fields.Field marshmallow.base.FieldABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/serializaction/#class-variables_2","text":"default_error_messages name parent root","title":"Class variables"},{"location":"reference/hielen3/serializaction/#instance-variables_2","text":"context The context dictionary for the parent :class: Schema . default missing","title":"Instance variables"},{"location":"reference/hielen3/serializaction/#methods_2","text":"","title":"Methods"},{"location":"reference/hielen3/serializaction/#deserialize_1","text":"def deserialize ( self , value : 'typing.Any' , attr : 'str | None' = None , data : 'typing.Mapping[str, typing.Any] | None' = None , ** kwargs ) Deserialize value . Parameters: Name Type Description Default value None The value to deserialize. None attr None The attribute/key in data to deserialize. None data None The raw input data passed to Schema.load . None kwargs None Field-specific keyword arguments. None Raises: Type Description ValidationError If an invalid value is passed or if a required value is missing. View Source def deserialize ( self , value : typing . Any , attr : str | None = None , data : typing . Mapping [ str , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Deserialize ``value``. :param value: The value to deserialize. :param attr: The attribute/key in `data` to deserialize. :param data: The raw input data passed to `Schema.load`. :param kwargs: Field-specific keyword arguments. :raise ValidationError: If an invalid value is passed or if a required value is missing. \"\" \" # Validate required fields, deserialize, then validate # deserialized value self . _validate_missing ( value ) if value is missing_ : _miss = self . load_default return _miss () if callable ( _miss ) else _miss if self . allow_none and value is None : return None output = self . _deserialize ( value , attr , data , ** kwargs ) self . _validate ( output ) return output","title":"deserialize"},{"location":"reference/hielen3/serializaction/#fail_1","text":"def fail ( self , key : 'str' , ** kwargs ) Helper method that raises a ValidationError with an error message from self.error_messages . View Source def fail ( self , key : str , ** kwargs ) : \" \"\" Helper method that raises a `ValidationError` with an error message from ``self.error_messages``. .. deprecated:: 3.0.0 Use `make_error <marshmallow.fields.Field.make_error>` instead. \"\" \" warnings . warn ( '`Field.fail` is deprecated. Use `raise self.make_error(\"{}\", ...)` instead.' . format ( key ), RemovedInMarshmallow4Warning , stacklevel = 2 , ) raise self . make_error ( key = key , ** kwargs )","title":"fail"},{"location":"reference/hielen3/serializaction/#get_value_1","text":"def get_value ( self , obj , attr , accessor = None , default =< marshmallow . missing > ) Return the value for a given key from an object. Parameters: Name Type Description Default obj object The object to get the value from. None attr str The attribute/key in obj to get the value from. None accessor callable A callable used to retrieve the value of attr from the object obj . Defaults to marshmallow.utils.get_value . None View Source def get_value ( self , obj , attr , accessor = None , default = missing_ ) : \" \"\" Return the value for a given key from an object. :param object obj: The object to get the value from. :param str attr: The attribute/key in `obj` to get the value from. :param callable accessor: A callable used to retrieve the value of `attr` from the object `obj`. Defaults to `marshmallow.utils.get_value`. \"\" \" accessor_func = accessor or utils . get_value check_key = attr if self . attribute is None else self . attribute return accessor_func ( obj , check_key , default )","title":"get_value"},{"location":"reference/hielen3/serializaction/#make_error_1","text":"def make_error ( self , key : 'str' , ** kwargs ) -> 'ValidationError' Helper method to make a ValidationError with an error message from self.error_messages . View Source def make_error ( self , key : str , ** kwargs ) -> ValidationError : \" \"\" Helper method to make a `ValidationError` with an error message from ``self.error_messages``. \"\" \" try : msg = self . error_messages [ key ] except KeyError as error : class_name = self . __class__ . __name__ message = ( \"ValidationError raised by `{class_name}`, but error key `{key}` does \" \"not exist in the `error_messages` dictionary.\" ). format ( class_name = class_name , key = key ) raise AssertionError ( message ) from error if isinstance ( msg , ( str , bytes )) : msg = msg . format ( ** kwargs ) return ValidationError ( msg )","title":"make_error"},{"location":"reference/hielen3/serializaction/#serialize_1","text":"def serialize ( self , attr : 'str' , obj : 'typing.Any' , accessor : 'typing.Callable[[typing.Any, str, typing.Any], typing.Any] | None' = None , ** kwargs ) Pulls the value for the given key from the object, applies the field's formatting and returns the result. Parameters: Name Type Description Default attr None The attribute/key to get from the object. None obj None The object to access the attribute/key from. None accessor None Function used to access values from obj . None kwargs None Field-specific keyword arguments. None View Source def serialize ( self , attr : str , obj : typing . Any , accessor : typing . Callable [[ typing . Any , str , typing . Any ] , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Pulls the value for the given key from the object, applies the field's formatting and returns the result. :param attr: The attribute/key to get from the object. :param obj: The object to access the attribute/key from. :param accessor: Function used to access values from ``obj``. :param kwargs: Field-specific keyword arguments. \"\" \" if self . _CHECK_ATTRIBUTE : value = self . get_value ( obj , attr , accessor = accessor ) if value is missing_ : default = self . dump_default value = default () if callable ( default ) else default if value is missing_ : return value else : value = None return self . _serialize ( value , attr , obj , ** kwargs )","title":"serialize"},{"location":"reference/hielen3/serializaction/#hschema","text":"class HSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ancestor class providing mehods View Source class HSchema ( Schema ) : ''' Minimal ancestor class providing mehods ''' class Meta : unknown = INCLUDE @property def __hdict__ ( self ) : out = { \"fields\" :{} , \"required\" :[] , \"hints\" : self . hints } for k , w in self . dump_fields . items () : out [ 'fields' ][ k ]= w . __class__ . __name__ w . __dict__ [ 'required' ] and out [ \"required\" ] . append ( k ) return out @abstractmethod def _self_hints_ () : pass @property def hints ( self ) : out = self . __class__ . _self_hints_ () or {} for c in self . __class__ . __bases__ : try : out . update ( c (). hints ) except AttributeError as e : pass return out timestamp = StringTime ( required = True , allow_none = False )","title":"HSchema"},{"location":"reference/hielen3/serializaction/#ancestors-in-mro_3","text":"marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/serializaction/#descendants_1","text":"hielen3.serializaction.ActionSchema","title":"Descendants"},{"location":"reference/hielen3/serializaction/#class-variables_3","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages opts timestamp","title":"Class variables"},{"location":"reference/hielen3/serializaction/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/hielen3/serializaction/#from_dict_1","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/serializaction/#instance-variables_3","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/serializaction/#methods_3","text":"","title":"Methods"},{"location":"reference/hielen3/serializaction/#dump_1","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/serializaction/#dumps_1","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/serializaction/#get_attribute_1","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/serializaction/#handle_error_1","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/serializaction/#load_1","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/serializaction/#loads_1","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/serializaction/#on_bind_field_1","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/serializaction/#validate_1","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/serializaction/#localfile","text":"class LocalFile ( * , load_default : 'typing.Any' = < marshmallow . missing > , missing : 'typing.Any' = < marshmallow . missing > , dump_default : 'typing.Any' = < marshmallow . missing > , default : 'typing.Any' = < marshmallow . missing > , data_key : 'str | None' = None , attribute : 'str | None' = None , validate : 'None | (typing.Callable[[typing.Any], typing.Any] | typing.Iterable[typing.Callable[[typing.Any], typing.Any]])' = None , required : 'bool' = False , allow_none : 'bool | None' = None , load_only : 'bool' = False , dump_only : 'bool' = False , error_messages : 'dict[str, str] | None' = None , metadata : 'typing.Mapping[str, typing.Any] | None' = None , ** additional_metadata ) Local Filepath manager used to identify a file into the system. Mainliy usefull for action Schema declaration in hielen3.HielenSource extention View Source class LocalFile ( fields . String ): \"\"\" Local Filepath manager used to identify a file into the system. Mainliy usefull for action Schema declaration in hielen3.HielenSource extention \"\"\" pass","title":"LocalFile"},{"location":"reference/hielen3/serializaction/#ancestors-in-mro_4","text":"marshmallow.fields.String marshmallow.fields.Field marshmallow.base.FieldABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/serializaction/#class-variables_4","text":"default_error_messages name parent root","title":"Class variables"},{"location":"reference/hielen3/serializaction/#instance-variables_4","text":"context The context dictionary for the parent :class: Schema . default missing","title":"Instance variables"},{"location":"reference/hielen3/serializaction/#methods_4","text":"","title":"Methods"},{"location":"reference/hielen3/serializaction/#deserialize_2","text":"def deserialize ( self , value : 'typing.Any' , attr : 'str | None' = None , data : 'typing.Mapping[str, typing.Any] | None' = None , ** kwargs ) Deserialize value . Parameters: Name Type Description Default value None The value to deserialize. None attr None The attribute/key in data to deserialize. None data None The raw input data passed to Schema.load . None kwargs None Field-specific keyword arguments. None Raises: Type Description ValidationError If an invalid value is passed or if a required value is missing. View Source def deserialize ( self , value : typing . Any , attr : str | None = None , data : typing . Mapping [ str , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Deserialize ``value``. :param value: The value to deserialize. :param attr: The attribute/key in `data` to deserialize. :param data: The raw input data passed to `Schema.load`. :param kwargs: Field-specific keyword arguments. :raise ValidationError: If an invalid value is passed or if a required value is missing. \"\" \" # Validate required fields, deserialize, then validate # deserialized value self . _validate_missing ( value ) if value is missing_ : _miss = self . load_default return _miss () if callable ( _miss ) else _miss if self . allow_none and value is None : return None output = self . _deserialize ( value , attr , data , ** kwargs ) self . _validate ( output ) return output","title":"deserialize"},{"location":"reference/hielen3/serializaction/#fail_2","text":"def fail ( self , key : 'str' , ** kwargs ) Helper method that raises a ValidationError with an error message from self.error_messages . View Source def fail ( self , key : str , ** kwargs ) : \" \"\" Helper method that raises a `ValidationError` with an error message from ``self.error_messages``. .. deprecated:: 3.0.0 Use `make_error <marshmallow.fields.Field.make_error>` instead. \"\" \" warnings . warn ( '`Field.fail` is deprecated. Use `raise self.make_error(\"{}\", ...)` instead.' . format ( key ), RemovedInMarshmallow4Warning , stacklevel = 2 , ) raise self . make_error ( key = key , ** kwargs )","title":"fail"},{"location":"reference/hielen3/serializaction/#get_value_2","text":"def get_value ( self , obj , attr , accessor = None , default =< marshmallow . missing > ) Return the value for a given key from an object. Parameters: Name Type Description Default obj object The object to get the value from. None attr str The attribute/key in obj to get the value from. None accessor callable A callable used to retrieve the value of attr from the object obj . Defaults to marshmallow.utils.get_value . None View Source def get_value ( self , obj , attr , accessor = None , default = missing_ ) : \" \"\" Return the value for a given key from an object. :param object obj: The object to get the value from. :param str attr: The attribute/key in `obj` to get the value from. :param callable accessor: A callable used to retrieve the value of `attr` from the object `obj`. Defaults to `marshmallow.utils.get_value`. \"\" \" accessor_func = accessor or utils . get_value check_key = attr if self . attribute is None else self . attribute return accessor_func ( obj , check_key , default )","title":"get_value"},{"location":"reference/hielen3/serializaction/#make_error_2","text":"def make_error ( self , key : 'str' , ** kwargs ) -> 'ValidationError' Helper method to make a ValidationError with an error message from self.error_messages . View Source def make_error ( self , key : str , ** kwargs ) -> ValidationError : \" \"\" Helper method to make a `ValidationError` with an error message from ``self.error_messages``. \"\" \" try : msg = self . error_messages [ key ] except KeyError as error : class_name = self . __class__ . __name__ message = ( \"ValidationError raised by `{class_name}`, but error key `{key}` does \" \"not exist in the `error_messages` dictionary.\" ). format ( class_name = class_name , key = key ) raise AssertionError ( message ) from error if isinstance ( msg , ( str , bytes )) : msg = msg . format ( ** kwargs ) return ValidationError ( msg )","title":"make_error"},{"location":"reference/hielen3/serializaction/#serialize_2","text":"def serialize ( self , attr : 'str' , obj : 'typing.Any' , accessor : 'typing.Callable[[typing.Any, str, typing.Any], typing.Any] | None' = None , ** kwargs ) Pulls the value for the given key from the object, applies the field's formatting and returns the result. Parameters: Name Type Description Default attr None The attribute/key to get from the object. None obj None The object to access the attribute/key from. None accessor None Function used to access values from obj . None kwargs None Field-specific keyword arguments. None View Source def serialize ( self , attr : str , obj : typing . Any , accessor : typing . Callable [[ typing . Any , str , typing . Any ] , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Pulls the value for the given key from the object, applies the field's formatting and returns the result. :param attr: The attribute/key to get from the object. :param obj: The object to access the attribute/key from. :param accessor: Function used to access values from ``obj``. :param kwargs: Field-specific keyword arguments. \"\" \" if self . _CHECK_ATTRIBUTE : value = self . get_value ( obj , attr , accessor = accessor ) if value is missing_ : default = self . dump_default value = default () if callable ( default ) else default if value is missing_ : return value else : value = None return self . _serialize ( value , attr , obj , ** kwargs )","title":"serialize"},{"location":"reference/hielen3/serializaction/#loggerheader","text":"class LoggerHeader ( cls_or_instance : 'Field | type' , ** kwargs ) Logger Header alias View Source class LoggerHeader ( fields . List ): \"\"\" Logger Header alias \"\"\"","title":"LoggerHeader"},{"location":"reference/hielen3/serializaction/#ancestors-in-mro_5","text":"marshmallow.fields.List marshmallow.fields.Field marshmallow.base.FieldABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/serializaction/#class-variables_5","text":"default_error_messages name parent root","title":"Class variables"},{"location":"reference/hielen3/serializaction/#instance-variables_5","text":"context The context dictionary for the parent :class: Schema . default missing","title":"Instance variables"},{"location":"reference/hielen3/serializaction/#methods_5","text":"","title":"Methods"},{"location":"reference/hielen3/serializaction/#deserialize_3","text":"def deserialize ( self , value : 'typing.Any' , attr : 'str | None' = None , data : 'typing.Mapping[str, typing.Any] | None' = None , ** kwargs ) Deserialize value . Parameters: Name Type Description Default value None The value to deserialize. None attr None The attribute/key in data to deserialize. None data None The raw input data passed to Schema.load . None kwargs None Field-specific keyword arguments. None Raises: Type Description ValidationError If an invalid value is passed or if a required value is missing. View Source def deserialize ( self , value : typing . Any , attr : str | None = None , data : typing . Mapping [ str , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Deserialize ``value``. :param value: The value to deserialize. :param attr: The attribute/key in `data` to deserialize. :param data: The raw input data passed to `Schema.load`. :param kwargs: Field-specific keyword arguments. :raise ValidationError: If an invalid value is passed or if a required value is missing. \"\" \" # Validate required fields, deserialize, then validate # deserialized value self . _validate_missing ( value ) if value is missing_ : _miss = self . load_default return _miss () if callable ( _miss ) else _miss if self . allow_none and value is None : return None output = self . _deserialize ( value , attr , data , ** kwargs ) self . _validate ( output ) return output","title":"deserialize"},{"location":"reference/hielen3/serializaction/#fail_3","text":"def fail ( self , key : 'str' , ** kwargs ) Helper method that raises a ValidationError with an error message from self.error_messages . View Source def fail ( self , key : str , ** kwargs ) : \" \"\" Helper method that raises a `ValidationError` with an error message from ``self.error_messages``. .. deprecated:: 3.0.0 Use `make_error <marshmallow.fields.Field.make_error>` instead. \"\" \" warnings . warn ( '`Field.fail` is deprecated. Use `raise self.make_error(\"{}\", ...)` instead.' . format ( key ), RemovedInMarshmallow4Warning , stacklevel = 2 , ) raise self . make_error ( key = key , ** kwargs )","title":"fail"},{"location":"reference/hielen3/serializaction/#get_value_3","text":"def get_value ( self , obj , attr , accessor = None , default =< marshmallow . missing > ) Return the value for a given key from an object. Parameters: Name Type Description Default obj object The object to get the value from. None attr str The attribute/key in obj to get the value from. None accessor callable A callable used to retrieve the value of attr from the object obj . Defaults to marshmallow.utils.get_value . None View Source def get_value ( self , obj , attr , accessor = None , default = missing_ ) : \" \"\" Return the value for a given key from an object. :param object obj: The object to get the value from. :param str attr: The attribute/key in `obj` to get the value from. :param callable accessor: A callable used to retrieve the value of `attr` from the object `obj`. Defaults to `marshmallow.utils.get_value`. \"\" \" accessor_func = accessor or utils . get_value check_key = attr if self . attribute is None else self . attribute return accessor_func ( obj , check_key , default )","title":"get_value"},{"location":"reference/hielen3/serializaction/#make_error_3","text":"def make_error ( self , key : 'str' , ** kwargs ) -> 'ValidationError' Helper method to make a ValidationError with an error message from self.error_messages . View Source def make_error ( self , key : str , ** kwargs ) -> ValidationError : \" \"\" Helper method to make a `ValidationError` with an error message from ``self.error_messages``. \"\" \" try : msg = self . error_messages [ key ] except KeyError as error : class_name = self . __class__ . __name__ message = ( \"ValidationError raised by `{class_name}`, but error key `{key}` does \" \"not exist in the `error_messages` dictionary.\" ). format ( class_name = class_name , key = key ) raise AssertionError ( message ) from error if isinstance ( msg , ( str , bytes )) : msg = msg . format ( ** kwargs ) return ValidationError ( msg )","title":"make_error"},{"location":"reference/hielen3/serializaction/#serialize_3","text":"def serialize ( self , attr : 'str' , obj : 'typing.Any' , accessor : 'typing.Callable[[typing.Any, str, typing.Any], typing.Any] | None' = None , ** kwargs ) Pulls the value for the given key from the object, applies the field's formatting and returns the result. Parameters: Name Type Description Default attr None The attribute/key to get from the object. None obj None The object to access the attribute/key from. None accessor None Function used to access values from obj . None kwargs None Field-specific keyword arguments. None View Source def serialize ( self , attr : str , obj : typing . Any , accessor : typing . Callable [[ typing . Any , str , typing . Any ] , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Pulls the value for the given key from the object, applies the field's formatting and returns the result. :param attr: The attribute/key to get from the object. :param obj: The object to access the attribute/key from. :param accessor: Function used to access values from ``obj``. :param kwargs: Field-specific keyword arguments. \"\" \" if self . _CHECK_ATTRIBUTE : value = self . get_value ( obj , attr , accessor = accessor ) if value is missing_ : default = self . dump_default value = default () if callable ( default ) else default if value is missing_ : return value else : value = None return self . _serialize ( value , attr , obj , ** kwargs )","title":"serialize"},{"location":"reference/hielen3/serializaction/#paramsdefinition","text":"class ParamsDefinition ( cls_or_instance =< fields . Tuple ( dump_default =< marshmallow . missing > , attribute = None , validate = None , required = False , load_only = False , dump_only = False , load_default =< marshmallow . missing > , allow_none = False , error_messages = { 'required' : 'Missing data for required field.' , 'null' : 'Field may not be null.' , 'validator_failed' : 'Invalid value.' , 'invalid' : 'Not a valid tuple.' }) > , ** kwargs ) Logger Header manager View Source class ParamsDefinition ( fields . List ): \"\"\" Logger Header manager \"\"\" def __init__ ( self , cls_or_instance = fields . Tuple ( ( fields . String (), #Param fields . Integer (), #Column fields . String () #Ing_mu ) ), ** kwargs ): super () . __init__ ( cls_or_instance = cls_or_instance , ** kwargs ) def _deserialize ( self , value , attr , data , ** kwargs ): try : return json . loads ( value ) except Exception as e : raise ValueError ( e )","title":"ParamsDefinition"},{"location":"reference/hielen3/serializaction/#ancestors-in-mro_6","text":"marshmallow.fields.List marshmallow.fields.Field marshmallow.base.FieldABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/serializaction/#class-variables_6","text":"default_error_messages name parent root","title":"Class variables"},{"location":"reference/hielen3/serializaction/#instance-variables_6","text":"context The context dictionary for the parent :class: Schema . default missing","title":"Instance variables"},{"location":"reference/hielen3/serializaction/#methods_6","text":"","title":"Methods"},{"location":"reference/hielen3/serializaction/#deserialize_4","text":"def deserialize ( self , value : 'typing.Any' , attr : 'str | None' = None , data : 'typing.Mapping[str, typing.Any] | None' = None , ** kwargs ) Deserialize value . Parameters: Name Type Description Default value None The value to deserialize. None attr None The attribute/key in data to deserialize. None data None The raw input data passed to Schema.load . None kwargs None Field-specific keyword arguments. None Raises: Type Description ValidationError If an invalid value is passed or if a required value is missing. View Source def deserialize ( self , value : typing . Any , attr : str | None = None , data : typing . Mapping [ str , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Deserialize ``value``. :param value: The value to deserialize. :param attr: The attribute/key in `data` to deserialize. :param data: The raw input data passed to `Schema.load`. :param kwargs: Field-specific keyword arguments. :raise ValidationError: If an invalid value is passed or if a required value is missing. \"\" \" # Validate required fields, deserialize, then validate # deserialized value self . _validate_missing ( value ) if value is missing_ : _miss = self . load_default return _miss () if callable ( _miss ) else _miss if self . allow_none and value is None : return None output = self . _deserialize ( value , attr , data , ** kwargs ) self . _validate ( output ) return output","title":"deserialize"},{"location":"reference/hielen3/serializaction/#fail_4","text":"def fail ( self , key : 'str' , ** kwargs ) Helper method that raises a ValidationError with an error message from self.error_messages . View Source def fail ( self , key : str , ** kwargs ) : \" \"\" Helper method that raises a `ValidationError` with an error message from ``self.error_messages``. .. deprecated:: 3.0.0 Use `make_error <marshmallow.fields.Field.make_error>` instead. \"\" \" warnings . warn ( '`Field.fail` is deprecated. Use `raise self.make_error(\"{}\", ...)` instead.' . format ( key ), RemovedInMarshmallow4Warning , stacklevel = 2 , ) raise self . make_error ( key = key , ** kwargs )","title":"fail"},{"location":"reference/hielen3/serializaction/#get_value_4","text":"def get_value ( self , obj , attr , accessor = None , default =< marshmallow . missing > ) Return the value for a given key from an object. Parameters: Name Type Description Default obj object The object to get the value from. None attr str The attribute/key in obj to get the value from. None accessor callable A callable used to retrieve the value of attr from the object obj . Defaults to marshmallow.utils.get_value . None View Source def get_value ( self , obj , attr , accessor = None , default = missing_ ) : \" \"\" Return the value for a given key from an object. :param object obj: The object to get the value from. :param str attr: The attribute/key in `obj` to get the value from. :param callable accessor: A callable used to retrieve the value of `attr` from the object `obj`. Defaults to `marshmallow.utils.get_value`. \"\" \" accessor_func = accessor or utils . get_value check_key = attr if self . attribute is None else self . attribute return accessor_func ( obj , check_key , default )","title":"get_value"},{"location":"reference/hielen3/serializaction/#make_error_4","text":"def make_error ( self , key : 'str' , ** kwargs ) -> 'ValidationError' Helper method to make a ValidationError with an error message from self.error_messages . View Source def make_error ( self , key : str , ** kwargs ) -> ValidationError : \" \"\" Helper method to make a `ValidationError` with an error message from ``self.error_messages``. \"\" \" try : msg = self . error_messages [ key ] except KeyError as error : class_name = self . __class__ . __name__ message = ( \"ValidationError raised by `{class_name}`, but error key `{key}` does \" \"not exist in the `error_messages` dictionary.\" ). format ( class_name = class_name , key = key ) raise AssertionError ( message ) from error if isinstance ( msg , ( str , bytes )) : msg = msg . format ( ** kwargs ) return ValidationError ( msg )","title":"make_error"},{"location":"reference/hielen3/serializaction/#serialize_4","text":"def serialize ( self , attr : 'str' , obj : 'typing.Any' , accessor : 'typing.Callable[[typing.Any, str, typing.Any], typing.Any] | None' = None , ** kwargs ) Pulls the value for the given key from the object, applies the field's formatting and returns the result. Parameters: Name Type Description Default attr None The attribute/key to get from the object. None obj None The object to access the attribute/key from. None accessor None Function used to access values from obj . None kwargs None Field-specific keyword arguments. None View Source def serialize ( self , attr : str , obj : typing . Any , accessor : typing . Callable [[ typing . Any , str , typing . Any ] , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Pulls the value for the given key from the object, applies the field's formatting and returns the result. :param attr: The attribute/key to get from the object. :param obj: The object to access the attribute/key from. :param accessor: Function used to access values from ``obj``. :param kwargs: Field-specific keyword arguments. \"\" \" if self . _CHECK_ATTRIBUTE : value = self . get_value ( obj , attr , accessor = accessor ) if value is missing_ : default = self . dump_default value = default () if callable ( default ) else default if value is missing_ : return value else : value = None return self . _serialize ( value , attr , obj , ** kwargs )","title":"serialize"},{"location":"reference/hielen3/serializaction/#polycoeff","text":"class PolyCoeff ( cls_or_instance =< class ' marshmallow . fields . Number '>, ** kwargs ) Polynomial Coefficients list intent: giving list a and value x result will be r = 0 for i in range ( 0 , a . _len__ ()) : r += a [ i ]* x ** i View Source class PolyCoeff ( fields . List ) : \"\"\" Polynomial Coefficients list intent: giving list a and value x result will be r=0 for i in range(0, a._len__()): r += a[i]*x**i \"\"\" def __init__ ( self , cls_or_instance = fields . Number , ** kwargs ) : super (). __init__ ( cls_or_instance = cls_or_instance , ** kwargs ) def _deserialize ( self , value , attr , data , ** kwargs ) : try : if value in ( 'null' , '' ) : return \"\" value = json . loads ( value ) if value is not None : value = list ( map ( lambda x : x is not None and x or 0 , value )) value = \",\" . join ( map ( str , value )) return value except Exception as e : raise e raise ValueError ( e )","title":"PolyCoeff"},{"location":"reference/hielen3/serializaction/#ancestors-in-mro_7","text":"marshmallow.fields.List marshmallow.fields.Field marshmallow.base.FieldABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/serializaction/#class-variables_7","text":"default_error_messages name parent root","title":"Class variables"},{"location":"reference/hielen3/serializaction/#instance-variables_7","text":"context The context dictionary for the parent :class: Schema . default missing","title":"Instance variables"},{"location":"reference/hielen3/serializaction/#methods_7","text":"","title":"Methods"},{"location":"reference/hielen3/serializaction/#deserialize_5","text":"def deserialize ( self , value : 'typing.Any' , attr : 'str | None' = None , data : 'typing.Mapping[str, typing.Any] | None' = None , ** kwargs ) Deserialize value . Parameters: Name Type Description Default value None The value to deserialize. None attr None The attribute/key in data to deserialize. None data None The raw input data passed to Schema.load . None kwargs None Field-specific keyword arguments. None Raises: Type Description ValidationError If an invalid value is passed or if a required value is missing. View Source def deserialize ( self , value : typing . Any , attr : str | None = None , data : typing . Mapping [ str , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Deserialize ``value``. :param value: The value to deserialize. :param attr: The attribute/key in `data` to deserialize. :param data: The raw input data passed to `Schema.load`. :param kwargs: Field-specific keyword arguments. :raise ValidationError: If an invalid value is passed or if a required value is missing. \"\" \" # Validate required fields, deserialize, then validate # deserialized value self . _validate_missing ( value ) if value is missing_ : _miss = self . load_default return _miss () if callable ( _miss ) else _miss if self . allow_none and value is None : return None output = self . _deserialize ( value , attr , data , ** kwargs ) self . _validate ( output ) return output","title":"deserialize"},{"location":"reference/hielen3/serializaction/#fail_5","text":"def fail ( self , key : 'str' , ** kwargs ) Helper method that raises a ValidationError with an error message from self.error_messages . View Source def fail ( self , key : str , ** kwargs ) : \" \"\" Helper method that raises a `ValidationError` with an error message from ``self.error_messages``. .. deprecated:: 3.0.0 Use `make_error <marshmallow.fields.Field.make_error>` instead. \"\" \" warnings . warn ( '`Field.fail` is deprecated. Use `raise self.make_error(\"{}\", ...)` instead.' . format ( key ), RemovedInMarshmallow4Warning , stacklevel = 2 , ) raise self . make_error ( key = key , ** kwargs )","title":"fail"},{"location":"reference/hielen3/serializaction/#get_value_5","text":"def get_value ( self , obj , attr , accessor = None , default =< marshmallow . missing > ) Return the value for a given key from an object. Parameters: Name Type Description Default obj object The object to get the value from. None attr str The attribute/key in obj to get the value from. None accessor callable A callable used to retrieve the value of attr from the object obj . Defaults to marshmallow.utils.get_value . None View Source def get_value ( self , obj , attr , accessor = None , default = missing_ ) : \" \"\" Return the value for a given key from an object. :param object obj: The object to get the value from. :param str attr: The attribute/key in `obj` to get the value from. :param callable accessor: A callable used to retrieve the value of `attr` from the object `obj`. Defaults to `marshmallow.utils.get_value`. \"\" \" accessor_func = accessor or utils . get_value check_key = attr if self . attribute is None else self . attribute return accessor_func ( obj , check_key , default )","title":"get_value"},{"location":"reference/hielen3/serializaction/#make_error_5","text":"def make_error ( self , key : 'str' , ** kwargs ) -> 'ValidationError' Helper method to make a ValidationError with an error message from self.error_messages . View Source def make_error ( self , key : str , ** kwargs ) -> ValidationError : \" \"\" Helper method to make a `ValidationError` with an error message from ``self.error_messages``. \"\" \" try : msg = self . error_messages [ key ] except KeyError as error : class_name = self . __class__ . __name__ message = ( \"ValidationError raised by `{class_name}`, but error key `{key}` does \" \"not exist in the `error_messages` dictionary.\" ). format ( class_name = class_name , key = key ) raise AssertionError ( message ) from error if isinstance ( msg , ( str , bytes )) : msg = msg . format ( ** kwargs ) return ValidationError ( msg )","title":"make_error"},{"location":"reference/hielen3/serializaction/#serialize_5","text":"def serialize ( self , attr : 'str' , obj : 'typing.Any' , accessor : 'typing.Callable[[typing.Any, str, typing.Any], typing.Any] | None' = None , ** kwargs ) Pulls the value for the given key from the object, applies the field's formatting and returns the result. Parameters: Name Type Description Default attr None The attribute/key to get from the object. None obj None The object to access the attribute/key from. None accessor None Function used to access values from obj . None kwargs None Field-specific keyword arguments. None View Source def serialize ( self , attr : str , obj : typing . Any , accessor : typing . Callable [[ typing . Any , str , typing . Any ] , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Pulls the value for the given key from the object, applies the field's formatting and returns the result. :param attr: The attribute/key to get from the object. :param obj: The object to access the attribute/key from. :param accessor: Function used to access values from ``obj``. :param kwargs: Field-specific keyword arguments. \"\" \" if self . _CHECK_ATTRIBUTE : value = self . get_value ( obj , attr , accessor = accessor ) if value is missing_ : default = self . dump_default value = default () if callable ( default ) else default if value is missing_ : return value else : value = None return self . _serialize ( value , attr , obj , ** kwargs )","title":"serialize"},{"location":"reference/hielen3/serializaction/#stringtime","text":"class StringTime ( format : 'str | None' = None , ** kwargs ) A formatted datetime string. Example: '2014-12-22T03:12:58.019077+00:00'","title":"StringTime"},{"location":"reference/hielen3/serializaction/#attributes","text":"Name Type Description Default format None Either \"rfc\" (for RFC822), \"iso\" (for ISO8601), \"timestamp\" , \"timestamp_ms\" (for a POSIX timestamp) or a date format string. If None , defaults to \"iso\". \"iso\" kwargs None The same keyword arguments that :class: Field receives. .. versionchanged:: 3.0.0rc9 Does not modify timezone information on (de)serialization. .. versionchanged:: 3.19 Add timestamp as a format. None View Source class StringTime ( fields . DateTime ): def _agoodtime ( t ): try: t = datetime64 ( t ) assert not isnat ( t ) t = str ( t ) except Exception as e: t = None return t def _deserialize ( self , value , attr , data , ** kwargs ): return str ( super (). _deserialize ( value , attr , data , ** kwargs )) def _serialize ( self , value , attr , obj , ** kwargs ): return StringTime . _agoodtime ( value )","title":"Attributes"},{"location":"reference/hielen3/serializaction/#ancestors-in-mro_8","text":"marshmallow.fields.DateTime marshmallow.fields.Field marshmallow.base.FieldABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/serializaction/#class-variables_8","text":"DEFAULT_FORMAT DESERIALIZATION_FUNCS OBJ_TYPE SCHEMA_OPTS_VAR_NAME SERIALIZATION_FUNCS default_error_messages name parent root","title":"Class variables"},{"location":"reference/hielen3/serializaction/#instance-variables_8","text":"context The context dictionary for the parent :class: Schema . default missing","title":"Instance variables"},{"location":"reference/hielen3/serializaction/#methods_8","text":"","title":"Methods"},{"location":"reference/hielen3/serializaction/#deserialize_6","text":"def deserialize ( self , value : 'typing.Any' , attr : 'str | None' = None , data : 'typing.Mapping[str, typing.Any] | None' = None , ** kwargs ) Deserialize value . Parameters: Name Type Description Default value None The value to deserialize. None attr None The attribute/key in data to deserialize. None data None The raw input data passed to Schema.load . None kwargs None Field-specific keyword arguments. None Raises: Type Description ValidationError If an invalid value is passed or if a required value is missing. View Source def deserialize ( self , value : typing . Any , attr : str | None = None , data : typing . Mapping [ str , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Deserialize ``value``. :param value: The value to deserialize. :param attr: The attribute/key in `data` to deserialize. :param data: The raw input data passed to `Schema.load`. :param kwargs: Field-specific keyword arguments. :raise ValidationError: If an invalid value is passed or if a required value is missing. \"\" \" # Validate required fields, deserialize, then validate # deserialized value self . _validate_missing ( value ) if value is missing_ : _miss = self . load_default return _miss () if callable ( _miss ) else _miss if self . allow_none and value is None : return None output = self . _deserialize ( value , attr , data , ** kwargs ) self . _validate ( output ) return output","title":"deserialize"},{"location":"reference/hielen3/serializaction/#fail_6","text":"def fail ( self , key : 'str' , ** kwargs ) Helper method that raises a ValidationError with an error message from self.error_messages . View Source def fail ( self , key : str , ** kwargs ) : \" \"\" Helper method that raises a `ValidationError` with an error message from ``self.error_messages``. .. deprecated:: 3.0.0 Use `make_error <marshmallow.fields.Field.make_error>` instead. \"\" \" warnings . warn ( '`Field.fail` is deprecated. Use `raise self.make_error(\"{}\", ...)` instead.' . format ( key ), RemovedInMarshmallow4Warning , stacklevel = 2 , ) raise self . make_error ( key = key , ** kwargs )","title":"fail"},{"location":"reference/hielen3/serializaction/#get_value_6","text":"def get_value ( self , obj , attr , accessor = None , default =< marshmallow . missing > ) Return the value for a given key from an object. Parameters: Name Type Description Default obj object The object to get the value from. None attr str The attribute/key in obj to get the value from. None accessor callable A callable used to retrieve the value of attr from the object obj . Defaults to marshmallow.utils.get_value . None View Source def get_value ( self , obj , attr , accessor = None , default = missing_ ) : \" \"\" Return the value for a given key from an object. :param object obj: The object to get the value from. :param str attr: The attribute/key in `obj` to get the value from. :param callable accessor: A callable used to retrieve the value of `attr` from the object `obj`. Defaults to `marshmallow.utils.get_value`. \"\" \" accessor_func = accessor or utils . get_value check_key = attr if self . attribute is None else self . attribute return accessor_func ( obj , check_key , default )","title":"get_value"},{"location":"reference/hielen3/serializaction/#make_error_6","text":"def make_error ( self , key : 'str' , ** kwargs ) -> 'ValidationError' Helper method to make a ValidationError with an error message from self.error_messages . View Source def make_error ( self , key : str , ** kwargs ) -> ValidationError : \" \"\" Helper method to make a `ValidationError` with an error message from ``self.error_messages``. \"\" \" try : msg = self . error_messages [ key ] except KeyError as error : class_name = self . __class__ . __name__ message = ( \"ValidationError raised by `{class_name}`, but error key `{key}` does \" \"not exist in the `error_messages` dictionary.\" ). format ( class_name = class_name , key = key ) raise AssertionError ( message ) from error if isinstance ( msg , ( str , bytes )) : msg = msg . format ( ** kwargs ) return ValidationError ( msg )","title":"make_error"},{"location":"reference/hielen3/serializaction/#serialize_6","text":"def serialize ( self , attr : 'str' , obj : 'typing.Any' , accessor : 'typing.Callable[[typing.Any, str, typing.Any], typing.Any] | None' = None , ** kwargs ) Pulls the value for the given key from the object, applies the field's formatting and returns the result. Parameters: Name Type Description Default attr None The attribute/key to get from the object. None obj None The object to access the attribute/key from. None accessor None Function used to access values from obj . None kwargs None Field-specific keyword arguments. None View Source def serialize ( self , attr : str , obj : typing . Any , accessor : typing . Callable [[ typing . Any , str , typing . Any ] , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Pulls the value for the given key from the object, applies the field's formatting and returns the result. :param attr: The attribute/key to get from the object. :param obj: The object to access the attribute/key from. :param accessor: Function used to access values from ``obj``. :param kwargs: Field-specific keyword arguments. \"\" \" if self . _CHECK_ATTRIBUTE : value = self . get_value ( obj , attr , accessor = accessor ) if value is missing_ : default = self . dump_default value = default () if callable ( default ) else default if value is missing_ : return value else : value = None return self . _serialize ( value , attr , obj , ** kwargs )","title":"serialize"},{"location":"reference/hielen3/serializaction/#style","text":"class Style ( * , load_default : 'typing.Any' = < marshmallow . missing > , missing : 'typing.Any' = < marshmallow . missing > , dump_default : 'typing.Any' = < marshmallow . missing > , default : 'typing.Any' = < marshmallow . missing > , data_key : 'str | None' = None , attribute : 'str | None' = None , validate : 'None | (typing.Callable[[typing.Any], typing.Any] | typing.Iterable[typing.Callable[[typing.Any], typing.Any]])' = None , required : 'bool' = False , allow_none : 'bool | None' = None , load_only : 'bool' = False , dump_only : 'bool' = False , error_messages : 'dict[str, str] | None' = None , metadata : 'typing.Mapping[str, typing.Any] | None' = None , ** additional_metadata ) View Source class Style ( fields . String ): \"\"\" \"\"\" pass","title":"Style"},{"location":"reference/hielen3/serializaction/#ancestors-in-mro_9","text":"marshmallow.fields.String marshmallow.fields.Field marshmallow.base.FieldABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/serializaction/#class-variables_9","text":"default_error_messages name parent root","title":"Class variables"},{"location":"reference/hielen3/serializaction/#instance-variables_9","text":"context The context dictionary for the parent :class: Schema . default missing","title":"Instance variables"},{"location":"reference/hielen3/serializaction/#methods_9","text":"","title":"Methods"},{"location":"reference/hielen3/serializaction/#deserialize_7","text":"def deserialize ( self , value : 'typing.Any' , attr : 'str | None' = None , data : 'typing.Mapping[str, typing.Any] | None' = None , ** kwargs ) Deserialize value . Parameters: Name Type Description Default value None The value to deserialize. None attr None The attribute/key in data to deserialize. None data None The raw input data passed to Schema.load . None kwargs None Field-specific keyword arguments. None Raises: Type Description ValidationError If an invalid value is passed or if a required value is missing. View Source def deserialize ( self , value : typing . Any , attr : str | None = None , data : typing . Mapping [ str , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Deserialize ``value``. :param value: The value to deserialize. :param attr: The attribute/key in `data` to deserialize. :param data: The raw input data passed to `Schema.load`. :param kwargs: Field-specific keyword arguments. :raise ValidationError: If an invalid value is passed or if a required value is missing. \"\" \" # Validate required fields, deserialize, then validate # deserialized value self . _validate_missing ( value ) if value is missing_ : _miss = self . load_default return _miss () if callable ( _miss ) else _miss if self . allow_none and value is None : return None output = self . _deserialize ( value , attr , data , ** kwargs ) self . _validate ( output ) return output","title":"deserialize"},{"location":"reference/hielen3/serializaction/#fail_7","text":"def fail ( self , key : 'str' , ** kwargs ) Helper method that raises a ValidationError with an error message from self.error_messages . View Source def fail ( self , key : str , ** kwargs ) : \" \"\" Helper method that raises a `ValidationError` with an error message from ``self.error_messages``. .. deprecated:: 3.0.0 Use `make_error <marshmallow.fields.Field.make_error>` instead. \"\" \" warnings . warn ( '`Field.fail` is deprecated. Use `raise self.make_error(\"{}\", ...)` instead.' . format ( key ), RemovedInMarshmallow4Warning , stacklevel = 2 , ) raise self . make_error ( key = key , ** kwargs )","title":"fail"},{"location":"reference/hielen3/serializaction/#get_value_7","text":"def get_value ( self , obj , attr , accessor = None , default =< marshmallow . missing > ) Return the value for a given key from an object. Parameters: Name Type Description Default obj object The object to get the value from. None attr str The attribute/key in obj to get the value from. None accessor callable A callable used to retrieve the value of attr from the object obj . Defaults to marshmallow.utils.get_value . None View Source def get_value ( self , obj , attr , accessor = None , default = missing_ ) : \" \"\" Return the value for a given key from an object. :param object obj: The object to get the value from. :param str attr: The attribute/key in `obj` to get the value from. :param callable accessor: A callable used to retrieve the value of `attr` from the object `obj`. Defaults to `marshmallow.utils.get_value`. \"\" \" accessor_func = accessor or utils . get_value check_key = attr if self . attribute is None else self . attribute return accessor_func ( obj , check_key , default )","title":"get_value"},{"location":"reference/hielen3/serializaction/#make_error_7","text":"def make_error ( self , key : 'str' , ** kwargs ) -> 'ValidationError' Helper method to make a ValidationError with an error message from self.error_messages . View Source def make_error ( self , key : str , ** kwargs ) -> ValidationError : \" \"\" Helper method to make a `ValidationError` with an error message from ``self.error_messages``. \"\" \" try : msg = self . error_messages [ key ] except KeyError as error : class_name = self . __class__ . __name__ message = ( \"ValidationError raised by `{class_name}`, but error key `{key}` does \" \"not exist in the `error_messages` dictionary.\" ). format ( class_name = class_name , key = key ) raise AssertionError ( message ) from error if isinstance ( msg , ( str , bytes )) : msg = msg . format ( ** kwargs ) return ValidationError ( msg )","title":"make_error"},{"location":"reference/hielen3/serializaction/#serialize_7","text":"def serialize ( self , attr : 'str' , obj : 'typing.Any' , accessor : 'typing.Callable[[typing.Any, str, typing.Any], typing.Any] | None' = None , ** kwargs ) Pulls the value for the given key from the object, applies the field's formatting and returns the result. Parameters: Name Type Description Default attr None The attribute/key to get from the object. None obj None The object to access the attribute/key from. None accessor None Function used to access values from obj . None kwargs None Field-specific keyword arguments. None View Source def serialize ( self , attr : str , obj : typing . Any , accessor : typing . Callable [[ typing . Any , str , typing . Any ] , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Pulls the value for the given key from the object, applies the field's formatting and returns the result. :param attr: The attribute/key to get from the object. :param obj: The object to access the attribute/key from. :param accessor: Function used to access values from ``obj``. :param kwargs: Field-specific keyword arguments. \"\" \" if self . _CHECK_ATTRIBUTE : value = self . get_value ( obj , attr , accessor = accessor ) if value is missing_ : default = self . dump_default value = default () if callable ( default ) else default if value is missing_ : return value else : value = None return self . _serialize ( value , attr , obj , ** kwargs )","title":"serialize"},{"location":"reference/hielen3/series/","text":"Module hielen3.series View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 #!/usr/bin/env python # coding=utf-8 from pandas import DataFrame , Series , concat , DatetimeIndex , Index , MultiIndex from concurrent.futures import ThreadPoolExecutor from functools import wraps from numpy import nan , unique , round , inf , datetime64 , timedelta64 from importlib import import_module from hielen3 import db , conf from hielen3.utils import isot2ut , ut2isot , agoodtime , uuid as getuuid , dataframe2jsonizabledict from uuid import UUID import re import json import traceback def _threadpool ( f ): @wraps ( f ) def wrap ( * args , ** kwargs ): return ThreadPoolExecutor () . submit ( f , * args , ** kwargs ) return wrap class HSeries : def __repr__ ( self ): return self . uuid def __delayed_load__ ( self ): if self . __loaded__ : return try : ser = re . split ( \"\\s*>\\s*\" , self . uuid ) if ser . __len__ () == 2 : try : feat = db [ 'features' ][ ser [ 0 ]] except Exception as e : feats = db [ 'features' ][:] feat = feats [ feats [ 'label' ] == ser [ 0 ] ] fuuid , fname = feat [[ 'uuid' , 'label' ]] . squeeze () self . feature = fname self . uuid = db [ 'features_parameters' ][ fuuid , ser [ 1 ]][ 'series' ] . squeeze () self . parameter = ser [ 1 ] except Exception as e : raise KeyError ( f \"Series { self . uuid } not found.\" ) series_info = db [ \"series\" ][ self . uuid ] series_info = dataframe2jsonizabledict ( series_info ) if series_info [ 'datatable' ] is None or series_info [ 'datatable' ] == '' : series_info [ 'datatable' ] = 'datacache' try : db [ series_info [ 'datatable' ]] except Exception as e : series_info [ 'datatable' ] = 'datacache' self . __dict__ . update ( series_info ) self . __dict__ . pop ( 'modules' ) self . __dict__ . pop ( 'operator' ) try : operands = db [ \"series_operands\" ][ self . uuid ][ 'operand' ] . \\ reset_index () . \\ set_index ( 'label' )[ 'operand' ] . \\ to_dict () except Exception as e : operands = {} try : groupmap = db [ 'series_groups' ][ self . uuid ][ 'ordinal' ] . \\ apply ( lambda x : f \"__GROUPMAP__ { str ( x ) . zfill ( 3 ) } __\" ) . \\ reset_index () . \\ set_index ( 'ordinal' )[ 'element' ] . \\ sort_index () . \\ to_dict () self . activeuuids = list ( groupmap . values ()) self . capability = 'datadiagram' series_info [ 'group' ] = self . uuid except Exception as e : groupmap = None self . activeuuids = [ self . uuid ] series_info [ 'operands' ] = operands series_info [ 'groupmap' ] = groupmap self . generator = HSeries . __Generator__ ( ** series_info ) try : self . ingroup = db [ 'series_groups' ][{ \"element\" : self . uuid }][ 'groupseries' ] . to_list () except Exception as e : self . ingroup = None try : t = db [ 'series_thresholds' ][ self . uuid ] t = t [[ 'value' , 'color' ]] . reset_index () . drop ( 'series' , axis = 1 ) . set_index ( 'value' ) . sort_index () #t=t[['value','color']].reset_index().drop('series',axis=1).to_dict(orient='records') self . thresholds = t except Exception as e : self . thresholds = DataFrame ([], columns = [ 'ttype' , 'label' , 'columns' ], index = Index ([], name = 'value' ), dtype = 'object' ) self . __loaded__ = True def __getattr__ ( self , item ): self . __delayed_load__ () return self . __getattribute__ ( item ) def __init__ ( self , uuid , delayed = True , ** kwargs ): if uuid is None : raise ValueError self . uuid = uuid self . feature = None self . param = None self . __loaded__ = False if not delayed : self . __delayed_load__ () def clean_cache ( self , times = None ): to_clean = list ( set ([ self . uuid , * self . activeuuids ])) try : db [ self . datatable ] . pop ( key = ( to_clean , times )) except KeyError as e : pass try : db [ 'events' ] . pop ( key = ( to_clean , times )) except KeyError as e : pass try : last = str ( db [ self . datatable ][ to_clean ] . index [ - 1 ]) except Exception as e : last = None self . attribute_update ( 'last' , last ) def setup ( uuid = None , operator = None , modules = None , cache = None , datatable = None , mu = None , datatype = None , operands = None , capability = 'data' , first = None , valid_range = None , view_range = None , thresholds = None , groupmap = None , orient = 'H' ): def _managed_capabilities_ ( capability ): return capability in [ 'data' , 'stream' , 'group' , 'datadiagram' ] uuid = uuid or getuuid () try : uuid = uuid . uuid except Exception as e : pass setups = {} \"\"\" #TODO gestire le diverse tipologie di dato if datatype is not None and datatype in ['numeric']: setups['datatable']='geoframe.log' \"\"\" if datatable is None : datatable = 'datacache' try : db [ datatable ] except Exception as e : raise e pass setups [ 'datatable' ] = datatable if modules is not None and isinstance ( modules , dict ): setups [ 'modules' ] = modules if operator is not None and isinstance ( operator , str ): setups [ 'operator' ] = operator if cache is not None and isinstance ( cache , str ): setups [ 'cache' ] = cache if mu is not None and isinstance ( mu , str ): setups [ 'mu' ] = mu if capability is not None and _managed_capabilities_ ( capability ): setups [ 'capability' ] = capability # print (\"Start_time:\",first) if first is not None : setups [ 'first' ] = first if orient is not None : setups [ 'orient' ] = orient if valid_range is not None : try : setups [ 'valid_range_min' ] = valid_range [ 0 ] except Exception as e : pass try : setups [ 'valid_range_max' ] = valid_range [ 1 ] except Exception as e : pass if view_range is not None : try : setups [ 'view_range_min' ] = view_range [ 0 ] except Exception as e : pass try : setups [ 'view_range_max' ] = view_range [ 1 ] except Exception as e : pass db [ \"series\" ][ uuid ] = setups #TODO fare il check di coerenza tra operandi e operatore if operands is not None and isinstance ( operands , dict ): # print (operands) table_operands = db [ \"series_operands\" ] for k , w in operands . items (): if not isinstance ( w ,( list , tuple , set , dict )): w = [ w ] if isinstance ( w ,( list , tuple , set )): wl = min ( table_operands . values . __len__ (), w . __len__ ()) w = dict ( zip ( table_operands . values [: wl ], w [: wl ])) try : if isinstance ( w [ 'operand' ], HSeries ): w [ 'operand' ] = w [ 'operand' ] . uuid except Exception as e : print ( w , uuid ) #raise (e) table_operands [( uuid , k )] = w if groupmap is not None : try : if not isinstance ( groupmap ,( list , tuple , set )): raise Exception ( f \"not a vaild list\" ) for i in range ( 0 , groupmap . __len__ ()): v = groupmap [ i ] if not isinstance ( v , dict ): raise Exception ( f \" { v } has not a valid format\" ) el = v . pop ( 'element' ) try : el = HSeries ( el , delayed = False ) . uuid except Exception as e : raise e try : v [ 'ordinal' ] except Exception as e : v [ 'ordinal' ] = i try : v [ 'label' ] except Exception as e : v [ 'label' ] = str ( i ) db [ \"series_groups\" ][( uuid , el )] = v db [ \"series\" ][ uuid ] = { \"capability\" : 'datadiagram' } except Exception as e : raise Exception ( f \"groupmap CONF for { uuid } : { e } \" ) if thresholds is not None and isinstance ( thresholds , ( list , tuple , set )): for t in thresholds : db [ \"series_thresholds\" ][ uuid ] = t return HSeries ( uuid ) def attribute_update ( self , attribute = None , value = None ): if attribute is None : return if attribute == 'thresholds' : if not isinstance ( value ,( list , set , tuple )): value = [ value ] for t in value : db [ \"series_thresholds\" ][ self . uuid ] = t if attribute == 'reference' : pass else : db [ \"series\" ][ self . uuid ] = { attribute : value } if self . __loaded__ : self . __loaded__ = False self . __delayed_load__ () def check ( self , geometry = None , ** kwargs ): try : last_event = db [ 'status' ][{ 'series' : self . uuid }] . iloc [ 0 ] last_event_time = str ( last_event [ 'last_time' ]) except KeyError as e : last_event = None last_event_time = None times = slice ( last_event_time , None , None ) cache = 'active' # BUILDING THE REFERENCE DATAFRAME (aa) aa = self . thresholds if aa . empty : d = DataFrame ( [[ self . uuid , self . last , '#' , '#' , '#' , '#' , '#' , '#' , '#' , 0 ]], columns = [ 'series' , 'timestamp' , 'reading_value' , 'threshold_value' , 'ttype' , 'label' , 'color' , 'end' , 'count' , 'latency' ]) return d . set_index ([ 'series' , 'timestamp' ]) if aa [ 'ttype' ] . iloc [ 0 ] == 'LOWER' : aa = concat ([ aa , DataFrame ([[ None , 'LOWER' , None ]], index = Index ([ - inf ], name = 'value' ), columns = [ 'label' , 'ttype' , 'color' ])]) . sort_index () if aa [ 'ttype' ] . iloc [ - 1 ] == 'UPPER' : aa = concat ([ aa , DataFrame ([[ None , 'UPPER' , None ]], index = Index ([ inf ], name = 'value' ), columns = [ 'label' , 'ttype' , 'color' ])]) . sort_index () aa = aa . reset_index () bb = aa [ 'value' ] . copy () aa . loc [ aa [ 'ttype' ] == 'LOWER' ,[ 'value' , 'label' , 'color' ]] = aa . loc [ aa [ 'ttype' ] == 'LOWER' ,[ 'value' , 'label' , 'color' ]] . shift ( - 1 ) aa . loc [ aa [ 'ttype' ] == 'UPPER' ,[ 'value' , 'label' , 'color' ]] = aa . loc [ aa [ 'ttype' ] == 'UPPER' ,[ 'value' , 'label' , 'color' ]] . shift ( 1 ) aa [ 'limit' ] = bb aa = aa [ aa [ 'value' ] . notna ()] aa . index . name = 'idt' aa = aa . reset_index () # REFEERENCE DATAFRAME DONE # EXTRACTING THE DATA d = self . data ( times = times , cache = cache , geometry = geometry , ** kwargs ) # DATA ESTRACTION DONE try : d = d . to_frame () except Exception as e : pass v = d . columns [ 0 ] # TODO capire neither or both # TODO separare UPPER e LOWER # MATCHING FOR OVERCOMES (each i in aa, thresholds, over d, data) for i in aa . index : d . loc [ d [ v ] . between ( min ( aa . loc [ i , 'value' ], aa . loc [ i , 'limit' ]), max ( aa . loc [ i , 'value' ], aa . loc [ i , 'limit' ]), inclusive = 'neither' ), 'value' ] = aa . loc [ i , 'idt' ] aa = aa . set_index ( 'idt' ) d = d . reset_index () . set_index ( 'value' ) . sort_index () d = d . join ( aa , how = 'left' ) . set_index ( 'timestamp' ) . sort_index ()[[ v , 'value' , 'ttype' , 'label' , 'color' ]] d . columns = [ \"reading_value\" , \"threshold_value\" , \"ttype\" , \"label\" , \"color\" ] d [ 'series' ] = v d = d . reset_index () d = d . replace ( nan , \"#\" ) d [ 'end' ] = d [ 'timestamp' ] . copy () d [ 'timestamp' ] = d [ ~ ( d [ \"label\" ] == d [ \"label\" ] . shift ( 1 )) | ~ ( d [ \"ttype\" ] == d [ \"ttype\" ] . shift ( 1 )) ][ 'end' ] d [ 'timestamp' ] = d [ 'timestamp' ] . ffill () d = d . set_index ( 'timestamp' ) d [ 'count' ] = d [ 'label' ] . groupby ( 'timestamp' ) . count () d = d . reset_index () d = d [ ~ ( d [ \"label\" ] == d [ 'label' ] . shift ( - 1 )) | ~ ( d [ \"ttype\" ] == d [ 'ttype' ] . shift ( - 1 )) ] reftime = datetime64 ( 'now' ) + timedelta64 ( conf [ 'server_time_offset' ], 'h' ) d [ 'latency' ] = ( reftime - d [ 'end' ]) . astype ( 'timedelta64[s]' ) d [ 'timestamp' ] = d [ 'timestamp' ] . astype ( str ) d [ 'end' ] = d [ 'end' ] . astype ( str ) d [ 'latency' ] = d [ 'latency' ] . astype ( int ) if not d . empty and last_event is not None : d . loc [ d . index [ 0 ], 'count' ] = ( d . iloc [ 0 ][ 'count' ] - 1 + last_event [ 'count' ]) . squeeze () d . loc [ d . index [ 0 ], 'timestamp' ] = str ( last_event [ 'start_time' ]) if d . __len__ () > 1 : if last_event [ 'latency' ] is not None : d . loc [ d . index [ 0 ], 'latency' ] = last_event [ 'latency' ] def fillth ( ** kwargs ): db [ \"events\" ][{ 'series' : kwargs [ 'series' ]}] = kwargs d . apply ( lambda x : fillth ( ** x ), axis = 1 ) return d . set_index ([ 'series' , 'timestamp' ]) @_threadpool def thvalues ( self , ** kwargs ): return self . __getattr__ ( self . capability )( ** kwargs ) def datadiagram ( self , ** kwargs ): return self . data ( ** kwargs ) def data ( self , times = None , timeref = None , cache = None , group = None , geometry = None , ** kwargs ): self . __delayed_load__ () entertimes = times if self . capability not in [ 'data' , 'datadiagram' ]: raise ValueError ( f \" { self . uuid } has not 'data' capability\" ) if self . ingroup is None or group in self . ingroup : cangenerate = True else : cangenerate = False timeref = agoodtime ( timeref ) if cache is None : try : cache = self . cache assert cache in ( \"active\" , \"data\" , \"old\" ) except Exception as e : cache = \"no\" if times is None : times = slice ( None , None , None ) justnew = False try : if cache == 'new' : justnew = True timefrom = isot2ut ( self . last ) try : assert self . cache in ( \"active\" , \"data\" , \"old\" ) cache = \"active\" except Exception as e : cache = \"no\" else : tocheck = min ( isot2ut ( self . last ), isot2ut ( times . start )) timefrom = max ( isot2ut ( self . first ), tocheck ) times = slice ( ut2isot ( timefrom ), times . stop , times . step ) except Exception as e : pass firstreqstart = times . start #TODO inserire i nomi dei label out = DataFrame ([], columns = self . activeuuids , dtype = 'object' ) if cache in ( \"refresh\" ): self . clean_cache ( times ) if cache in ( \"active\" , \"data\" , \"old\" ): try : out = db [ self . datatable ][ self . activeuuids , times ] except KeyError as e : pass if not out . empty : cachestop = out . index . max () try : timefrom = max ( isot2ut ( cachestop ), isot2ut ( times . start )) times = slice ( ut2isot ( timefrom ), times . stop , times . step ) except Exception as e : pass try : try : if cache == 'old' or not cangenerate : raise Exception ( 'request for old, skip generation' ) kwargs [ 'cache' ] = cache gen = self . generator . __generate__ ( times = times , timeref = timeref , geometry = geometry , ** kwargs ) gen = gen . replace ( ',' , '.' , regex = True ) . astype ( float ) if gen . empty : raise Exception ( \"void\" ) except Exception as e : # print (\"WARN series GENERATE: \", e) # raise e ##DEBUG gen = DataFrame ([], columns = self . activeuuids , dtype = 'object' ) try : gen = gen . to_frame () except AttributeError as e : pass #gen.name=self.uuid try : gen = gen . round ( 4 ) except Exception as e : pass try : gen . columns = self . activeuuids except Exception as e : pass gen . index = DatetimeIndex ( gen . index ) out = concat ([ out , gen ]) . sort_index () out . index . name = \"timestamp\" out = out [ self . activeuuids ] if self . valid_range_min is not None : out = out . mask ( out < self . valid_range_min , nan ) if self . valid_range_max is not None : out = out . mask ( out > self . valid_range_max , nan ) out = out [ out . notna () . any ( axis = 1 )] if cache in ( \"active\" , \"data\" , \"refresh\" ) and cangenerate : for u in gen . columns : db [ self . datatable ][ u ] = out [ u ] except Exception as e : # print (\"WARN series GLOBAL: \", e) # raise e #DEBUG pass if cache in ( \"active\" , \"data\" , \"refresh\" ) and not out . empty and not justnew : lasttotry = str ( out . index [ 0 ]) times = slice ( firstreqstart , lasttotry , times . step ) kwargs [ 'cache' ] = \"none\" preout = self . data ( times = times , geometry = geometry , group = group , ** kwargs ) try : preout = preout . to_frame () except Exception as e : pass preout . index . name = \"timestamp\" try : preout . columns = self . activeuuids except Exception as e : pass if cangenerate : for u in preout . columns : db [ self . datatable ][ u ] = preout [ u ] if preout . __len__ (): out = concat ([ preout , out ]) . sort_index () out = out [ ~ out . index . duplicated ()] out . index . name = \"timestamp\" if not out . empty : self . attribute_update ( 'last' , ut2isot ( max ( isot2ut ( self . last ), isot2ut ( str ( out . index [ - 1 ]))))) try : out = out . loc [ entertimes ] except Exception as e : pass try : if out . columns . __len__ () < 2 : out = out . iloc [:, 0 ] except Exception as e : pass return out ## WARNING Omesso Map ## WARINIG Omesso Cloud def stream ( self , times = None , timeref = None , cache = None , geometry = None , ** kwargs ): if self . capability != 'stream' : raise ValueError ( f \" { self . uuid } has not 'stream' capability\" ) self . __delayed_load__ () timeref = agoodtime ( timeref ) cache = \"no\" try : try : out = self . generator . __generate__ ( ** kwargs ) gen = Series ([ out [ 'queue' ]], index = [ out [ 'timestamp' ]]) except Exception as e : # print (\"WARN series GENERATE: \",e) # raise e gen = Series ([], dtype = 'object' ) gen . name = 'queue' gen . index = DatetimeIndex ( gen . index ) out = gen [ ~ gen . index . duplicated ()] out . index . name = \"timestamp\" except Exception as e : #raise e pass try : out = out [ out . columns [ 0 ]] except Exception as e : pass return out # return out.to_frame() #TOLGO ORIENT class __Generator__ : def __load_operand__ ( value = None ): #OPERANDS RESOLUTION: try : UUID ( value ) return HSeries ( value ) except Exception as e : pass try : value = value . removeprefix ( '#' ) except Exception as e : pass \"\"\" trying to load json string, if \"value\" is it \"\"\" try : return json . loads ( value ) except Exception as e : pass return value ''' \"\"\" Trying to get values from a dict, if \"out\" is it \"\"\" try: values=out.values() except AttributeError as e: values=out \"\"\" Trying to load suboperands from a list if \"values\" is it \"\"\" try: assert not isinstance(values,str) values=[ __Generator__.__load_operand__(a,orient) for a in values ] except Exception as e: pass \"\"\" Trying zip a dict, if \"out\" is it \"\"\" try: out=dict(zip(out.keys(),values) except AttributeError as e: out = values return out ''' def __init__ ( self , modules = None , operator = None , operands = None , group = None , groupmap = None , ** kwargs ): self . modules = {} self . group = group if operator is None or operator in \"__VOID__\" : operator = \"Series([],dtype='object')\" self . operator = operator if not modules is None : for k , m in modules . items (): self . operator = self . operator . replace ( k , f \"self.modules[ { k !r} ]\" ) self . modules [ k ] = import_module ( m ) self . operands = { k : HSeries . __Generator__ . __load_operand__ ( w ) for k , w in operands . items () } if groupmap is not None : self . groupmap = { k : HSeries . __Generator__ . __load_operand__ ( w ) for k , w in groupmap . items () } else : self . groupmap = None def __generate__ ( self , ** kwargs ): operands = kwargs ''' times=kwargs['times'] try: start=re.sub('\\+.*$','',str(times.start)) except Exception as e: start=None try: stop=re.sub('\\+.*$','',str(times.stop)) except Exception as e: stop = None kwargs.update({\"times\":slice(start,stop,times.step)}) ''' operands . update ( { k : w for k , w in self . operands . items () if not isinstance ( w , HSeries )} ) operands [ 'group' ] = self . group if self . groupmap is not None : groupmap = { k : w . thvalues ( ** kwargs ) for k , w in self . groupmap . items () if isinstance ( w , HSeries ) } groupmap = { k : w . result () for k , w in groupmap . items () } #groupmap = concat(groupmap,axis=1) cols = list ( groupmap . keys ()) groupmap = concat ( groupmap ) . unstack () . T . sort_index () try : groupmap . columns = groupmap . columns . droplevel ( 0 ) except Exception as e : pass for c in cols : if c not in groupmap . columns : groupmap [ c ] = None operands [ '__GROUPMAP__' ] = groupmap runners = { k : w . thvalues ( ** kwargs ) for k , w in self . operands . items () if isinstance ( w , HSeries ) } operands . update ({ k : w . result () for k , w in runners . items ()}) #operands.update( { k:w.data(**kwargs) for k,w in self.operands.items() if isinstance(w,HSeries) } ) ## ATTENZIONE A locals: Implementation Dependant!!!! ### locals () . update ( operands ) # print (operands) #DEBUG # print (self.operator, locals() ) #DEBUG out = eval ( self . operator ) return out Variables conf db inf nan Classes HSeries class HSeries ( uuid , delayed = True , ** kwargs ) View Source class HSeries : def __repr__ ( self ) : return self . uuid def __delayed_load__ ( self ) : if self . __loaded__ : return try : ser = re . split ( \"\\s*>\\s*\" , self . uuid ) if ser . __len__ () == 2 : try : feat = db [ 'features' ][ ser[0 ] ] except Exception as e : feats = db [ 'features' ][ : ] feat = feats [ feats['label' ] == ser [ 0 ] ] fuuid , fname = feat [ ['uuid','label' ] ] . squeeze () self . feature = fname self . uuid = db [ 'features_parameters' ][ fuuid,ser[1 ] ] [ 'series' ] . squeeze () self . parameter = ser [ 1 ] except Exception as e : raise KeyError ( f \"Series {self.uuid} not found.\" ) series_info = db [ \"series\" ][ self.uuid ] series_info = dataframe2jsonizabledict ( series_info ) if series_info [ 'datatable' ] is None or series_info [ 'datatable' ] == '' : series_info [ 'datatable' ] = 'datacache' try : db [ series_info['datatable' ] ] except Exception as e : series_info [ 'datatable' ] = 'datacache' self . __dict__ . update ( series_info ) self . __dict__ . pop ( 'modules' ) self . __dict__ . pop ( 'operator' ) try : operands = db [ \"series_operands\" ][ self.uuid ][ 'operand' ] . \\ reset_index (). \\ set_index ( 'label' ) [ 'operand' ] . \\ to_dict () except Exception as e : operands = {} try : groupmap = db [ 'series_groups' ][ self.uuid ][ 'ordinal' ] . \\ apply ( lambda x : f \"__GROUPMAP__{str(x).zfill(3)}__\" ). \\ reset_index (). \\ set_index ( 'ordinal' ) [ 'element' ] . \\ sort_index (). \\ to_dict () self . activeuuids = list ( groupmap . values ()) self . capability = 'datadiagram' series_info [ 'group' ] = self . uuid except Exception as e : groupmap = None self . activeuuids =[ self.uuid ] series_info [ 'operands' ]= operands series_info [ 'groupmap' ]= groupmap self . generator = HSeries . __Generator__ ( ** series_info ) try : self . ingroup = db [ 'series_groups' ][ {\"element\":self.uuid} ][ 'groupseries' ] . to_list () except Exception as e : self . ingroup = None try : t = db [ 'series_thresholds' ][ self.uuid ] t = t [ ['value','color' ] ] . reset_index (). drop ( 'series' , axis = 1 ). set_index ( 'value' ). sort_index () #t = t [ ['value','color' ] ] . reset_index (). drop ( 'series' , axis = 1 ). to_dict ( orient = 'records' ) self . thresholds = t except Exception as e : self . thresholds = DataFrame ( [] , columns =[ 'ttype','label','columns' ] , index = Index ( [] , name = 'value' ), dtype = 'object' ) self . __loaded__ = True def __getattr__ ( self , item ) : self . __delayed_load__ () return self . __getattribute__ ( item ) def __init__ ( self , uuid , delayed = True , ** kwargs ) : if uuid is None : raise ValueError self . uuid = uuid self . feature = None self . param = None self . __loaded__ = False if not delayed : self . __delayed_load__ () def clean_cache ( self , times = None ) : to_clean = list ( set ( [ self.uuid,*self.activeuuids ] )) try : db [ self.datatable ] . pop ( key = ( to_clean , times )) except KeyError as e : pass try : db [ 'events' ] . pop ( key = ( to_clean , times )) except KeyError as e : pass try : last = str ( db [ self.datatable ][ to_clean ] . index [ -1 ] ) except Exception as e : last = None self . attribute_update ( 'last' , last ) def setup ( uuid = None , operator = None , modules = None , cache = None , datatable = None , mu = None , datatype = None , operands = None , capability = 'data' , first = None , valid_range = None , view_range = None , thresholds = None , groupmap = None , orient = 'H' ) : def _managed_capabilities_ ( capability ) : return capability in [ 'data','stream','group','datadiagram' ] uuid = uuid or getuuid () try : uuid = uuid . uuid except Exception as e : pass setups = {} \"\"\" #TODO gestire le diverse tipologie di dato if datatype is not None and datatype in ['numeric']: setups['datatable']='geoframe.log' \"\"\" if datatable is None : datatable = 'datacache' try : db [ datatable ] except Exception as e : raise e pass setups [ 'datatable' ] = datatable if modules is not None and isinstance ( modules , dict ) : setups [ 'modules' ]= modules if operator is not None and isinstance ( operator , str ) : setups [ 'operator' ]= operator if cache is not None and isinstance ( cache , str ) : setups [ 'cache' ]= cache if mu is not None and isinstance ( mu , str ) : setups [ 'mu' ] = mu if capability is not None and _managed_capabilities_ ( capability ) : setups [ 'capability' ] = capability # print ( \"Start_time:\" , first ) if first is not None : setups [ 'first' ] = first if orient is not None : setups [ 'orient' ] = orient if valid_range is not None : try : setups [ 'valid_range_min' ]= valid_range [ 0 ] except Exception as e : pass try : setups [ 'valid_range_max' ]= valid_range [ 1 ] except Exception as e : pass if view_range is not None : try : setups [ 'view_range_min' ]= view_range [ 0 ] except Exception as e : pass try : setups [ 'view_range_max' ]= view_range [ 1 ] except Exception as e : pass db [ \"series\" ][ uuid ]= setups #TODO fare il check di coerenza tra operandi e operatore if operands is not None and isinstance ( operands , dict ) : # print ( operands ) table_operands = db [ \"series_operands\" ] for k , w in operands . items () : if not isinstance ( w ,( list , tuple , set , dict )) : w =[ w ] if isinstance ( w ,( list , tuple , set )) : wl = min ( table_operands . values . __len__ (), w . __len__ ()) w = dict ( zip ( table_operands . values [ :wl ] , w [ :wl ] )) try : if isinstance ( w [ 'operand' ] , HSeries ) : w [ 'operand' ]= w [ 'operand' ] . uuid except Exception as e : print ( w , uuid ) #raise ( e ) table_operands [ (uuid,k) ]= w if groupmap is not None : try : if not isinstance ( groupmap ,( list , tuple , set )) : raise Exception ( f \"not a vaild list\" ) for i in range ( 0 , groupmap . __len__ ()) : v = groupmap [ i ] if not isinstance ( v , dict ) : raise Exception ( f \"{v} has not a valid format\" ) el = v . pop ( 'element' ) try : el = HSeries ( el , delayed = False ). uuid except Exception as e : raise e try : v [ 'ordinal' ] except Exception as e : v [ 'ordinal' ] = i try : v [ 'label' ] except Exception as e : v [ 'label' ] = str ( i ) db [ \"series_groups\" ][ (uuid,el) ]= v db [ \"series\" ][ uuid ]= { \"capability\" : 'datadiagram' } except Exception as e : raise Exception ( f \"groupmap CONF for {uuid}: {e}\" ) if thresholds is not None and isinstance ( thresholds , ( list , tuple , set )) : for t in thresholds : db [ \"series_thresholds\" ][ uuid ]= t return HSeries ( uuid ) def attribute_update ( self , attribute = None , value = None ) : if attribute is None : return if attribute == 'thresholds' : if not isinstance ( value ,( list , set , tuple )) : value =[ value ] for t in value : db [ \"series_thresholds\" ][ self.uuid ]= t if attribute == 'reference' : pass else : db [ \"series\" ][ self.uuid ]= { attribute : value } if self . __loaded__ : self . __loaded__ = False self . __delayed_load__ () def check ( self , geometry = None , ** kwargs ) : try : last_event = db [ 'status' ][ {'series':self.uuid} ] . iloc [ 0 ] last_event_time = str ( last_event [ 'last_time' ] ) except KeyError as e : last_event = None last_event_time = None times = slice ( last_event_time , None , None ) cache = 'active' # BUILDING THE REFERENCE DATAFRAME ( aa ) aa = self . thresholds if aa . empty : d = DataFrame ( [ [self.uuid,self.last,'#','#','#','#','#','#','#',0 ] ] , columns =[ 'series','timestamp','reading_value','threshold_value','ttype','label','color','end','count','latency' ] ) return d . set_index ( [ 'series','timestamp' ] ) if aa [ 'ttype' ] . iloc [ 0 ] == 'LOWER' : aa = concat ( [ aa,DataFrame([[None,'LOWER',None ] ] , index = Index ( [ -inf ] , name = 'value' ), columns =[ 'label','ttype','color' ] ) ] ). sort_index () if aa [ 'ttype' ] . iloc [ -1 ] == 'UPPER' : aa = concat ( [ aa,DataFrame([[None,'UPPER',None ] ] , index = Index ( [ inf ] , name = 'value' ), columns =[ 'label','ttype','color' ] ) ] ). sort_index () aa = aa . reset_index () bb = aa [ 'value' ] . copy () aa . loc [ aa['ttype' ]== 'LOWER' , [ 'value','label','color' ] ] = aa . loc [ aa['ttype' ]== 'LOWER' , [ 'value','label','color' ] ] . shift ( - 1 ) aa . loc [ aa['ttype' ]== 'UPPER' , [ 'value','label','color' ] ] = aa . loc [ aa['ttype' ]== 'UPPER' , [ 'value','label','color' ] ] . shift ( 1 ) aa [ 'limit' ]= bb aa = aa [ aa['value' ] . notna () ] aa . index . name = 'idt' aa = aa . reset_index () # REFEERENCE DATAFRAME DONE # EXTRACTING THE DATA d = self . data ( times = times , cache = cache , geometry = geometry , ** kwargs ) # DATA ESTRACTION DONE try : d = d . to_frame () except Exception as e : pass v = d . columns [ 0 ] # TODO capire neither or both # TODO separare UPPER e LOWER # MATCHING FOR OVERCOMES ( each i in aa , thresholds , over d , data ) for i in aa . index : d . loc [ d[v ] . between ( min ( aa . loc [ i,'value' ] , aa . loc [ i,'limit' ] ), max ( aa . loc [ i,'value' ] , aa . loc [ i,'limit' ] ), inclusive = 'neither' ), 'value' ] = aa . loc [ i,'idt' ] aa = aa . set_index ( 'idt' ) d = d . reset_index (). set_index ( 'value' ). sort_index () d = d . join ( aa , how = 'left' ). set_index ( 'timestamp' ). sort_index () [ [v,'value','ttype','label','color' ] ] d . columns =[ \"reading_value\",\"threshold_value\",\"ttype\",\"label\",\"color\" ] d [ 'series' ]= v d = d . reset_index () d = d . replace ( nan , \"#\" ) d [ 'end' ] = d [ 'timestamp' ] . copy () d [ 'timestamp' ]= d [ ~(d[\"label\" ] == d [ \"label\" ] . shift ( 1 )) | ~ ( d [ \"ttype\" ] == d [ \"ttype\" ] . shift ( 1 )) ] [ 'end' ] d [ 'timestamp' ] = d [ 'timestamp' ] . ffill () d = d . set_index ( 'timestamp' ) d [ 'count' ]= d [ 'label' ] . groupby ( 'timestamp' ). count () d = d . reset_index () d = d [ ~(d[\"label\" ] == d [ 'label' ] . shift ( - 1 )) | ~ ( d [ \"ttype\" ] == d [ 'ttype' ] . shift ( - 1 )) ] reftime = datetime64 ( 'now' ) + timedelta64 ( conf [ 'server_time_offset' ] , 'h' ) d [ 'latency' ]= ( reftime - d [ 'end' ] ). astype ( 'timedelta64[s]' ) d [ 'timestamp' ]= d [ 'timestamp' ] . astype ( str ) d [ 'end' ] = d [ 'end' ] . astype ( str ) d [ 'latency' ]= d [ 'latency' ] . astype ( int ) if not d . empty and last_event is not None : d . loc [ d.index[0 ] , 'count' ] = ( d . iloc [ 0 ][ 'count' ] - 1 + last_event [ 'count' ] ). squeeze () d . loc [ d.index[0 ] , 'timestamp' ] = str ( last_event [ 'start_time' ] ) if d . __len__ () > 1 : if last_event [ 'latency' ] is not None : d . loc [ d.index[0 ] , 'latency' ] = last_event [ 'latency' ] def fillth ( ** kwargs ) : db [ \"events\" ][ {'series':kwargs['series' ] }] = kwargs d . apply ( lambda x : fillth ( ** x ), axis = 1 ) return d . set_index ( [ 'series','timestamp' ] ) @_threadpool def thvalues ( self , ** kwargs ) : return self . __getattr__ ( self . capability )( ** kwargs ) def datadiagram ( self , ** kwargs ) : return self . data ( ** kwargs ) def data ( self , times = None , timeref = None , cache = None , group = None , geometry = None , ** kwargs ) : self . __delayed_load__ () entertimes = times if self . capability not in [ 'data','datadiagram' ] : raise ValueError ( f \"{self.uuid} has not 'data' capability\" ) if self . ingroup is None or group in self . ingroup : cangenerate = True else : cangenerate = False timeref = agoodtime ( timeref ) if cache is None : try : cache = self . cache assert cache in ( \"active\" , \"data\" , \"old\" ) except Exception as e : cache = \"no\" if times is None : times = slice ( None , None , None ) justnew = False try : if cache == 'new' : justnew = True timefrom = isot2ut ( self . last ) try : assert self . cache in ( \"active\" , \"data\" , \"old\" ) cache = \"active\" except Exception as e : cache = \"no\" else : tocheck = min ( isot2ut ( self . last ), isot2ut ( times . start )) timefrom = max ( isot2ut ( self . first ), tocheck ) times = slice ( ut2isot ( timefrom ), times . stop , times . step ) except Exception as e : pass firstreqstart = times . start #TODO inserire i nomi dei label out = DataFrame ( [] , columns = self . activeuuids , dtype = 'object' ) if cache in ( \"refresh\" ) : self . clean_cache ( times ) if cache in ( \"active\" , \"data\" , \"old\" ) : try : out = db [ self.datatable ][ self.activeuuids,times ] except KeyError as e : pass if not out . empty : cachestop = out . index . max () try : timefrom = max ( isot2ut ( cachestop ), isot2ut ( times . start )) times = slice ( ut2isot ( timefrom ), times . stop , times . step ) except Exception as e : pass try : try : if cache == 'old' or not cangenerate : raise Exception ( 'request for old, skip generation' ) kwargs [ 'cache' ] = cache gen = self . generator . __generate__ ( times = times , timeref = timeref , geometry = geometry , ** kwargs ) gen = gen . replace ( ',' , '.' , regex = True ). astype ( float ) if gen . empty : raise Exception ( \"void\" ) except Exception as e : # print ( \"WARN series GENERATE: \" , e ) # raise e ##DEBUG gen = DataFrame ( [] , columns = self . activeuuids , dtype = 'object' ) try : gen = gen . to_frame () except AttributeError as e : pass #gen . name = self . uuid try : gen = gen . round ( 4 ) except Exception as e : pass try : gen . columns = self . activeuuids except Exception as e : pass gen . index = DatetimeIndex ( gen . index ) out = concat ( [ out,gen ] ). sort_index () out . index . name = \"timestamp\" out = out [ self.activeuuids ] if self . valid_range_min is not None : out = out . mask ( out < self . valid_range_min , nan ) if self . valid_range_max is not None : out = out . mask ( out > self . valid_range_max , nan ) out = out [ out.notna().any(axis=1) ] if cache in ( \"active\" , \"data\" , \"refresh\" ) and cangenerate : for u in gen . columns : db [ self.datatable ][ u ]= out [ u ] except Exception as e : # print ( \"WARN series GLOBAL: \" , e ) # raise e #DEBUG pass if cache in ( \"active\" , \"data\" , \"refresh\" ) and not out . empty and not justnew : lasttotry = str ( out . index [ 0 ] ) times = slice ( firstreqstart , lasttotry , times . step ) kwargs [ 'cache' ] = \"none\" preout = self . data ( times = times , geometry = geometry , group = group , ** kwargs ) try : preout = preout . to_frame () except Exception as e : pass preout . index . name = \"timestamp\" try : preout . columns = self . activeuuids except Exception as e : pass if cangenerate : for u in preout . columns : db [ self.datatable ][ u ]= preout [ u ] if preout . __len__ () : out = concat ( [ preout,out ] ). sort_index () out = out [ ~out.index.duplicated() ] out . index . name = \"timestamp\" if not out . empty : self . attribute_update ( 'last' , ut2isot ( max ( isot2ut ( self . last ), isot2ut ( str ( out . index [ -1 ] ))))) try : out = out . loc [ entertimes ] except Exception as e : pass try : if out . columns . __len__ () < 2 : out = out . iloc [ :,0 ] except Exception as e : pass return out ## WARNING Omesso Map ## WARINIG Omesso Cloud def stream ( self , times = None , timeref = None , cache = None , geometry = None , ** kwargs ) : if self . capability != 'stream' : raise ValueError ( f \"{self.uuid} has not 'stream' capability\" ) self . __delayed_load__ () timeref = agoodtime ( timeref ) cache = \"no\" try : try : out = self . generator . __generate__ ( ** kwargs ) gen = Series ( [ out['queue' ] ] , index =[ out['timestamp' ] ] ) except Exception as e : # print ( \"WARN series GENERATE: \" , e ) # raise e gen = Series ( [] , dtype = 'object' ) gen . name = 'queue' gen . index = DatetimeIndex ( gen . index ) out = gen [ ~gen.index.duplicated() ] out . index . name = \"timestamp\" except Exception as e : #raise e pass try : out = out [ out.columns[0 ] ] except Exception as e : pass return out # return out . to_frame () #TOLGO ORIENT class __Generator__ : def __load_operand__ ( value = None ) : #OPERANDS RESOLUTION : try : UUID ( value ) return HSeries ( value ) except Exception as e : pass try : value = value . removeprefix ( '#' ) except Exception as e : pass \"\"\" trying to load json string, if \" value \" is it \"\"\" try : return json . loads ( value ) except Exception as e : pass return value ''' \"\"\" Trying to get values from a dict, if \"out\" is it \"\"\" try: values=out.values() except AttributeError as e: values=out \"\"\" Trying to load suboperands from a list if \"values\" is it \"\"\" try: assert not isinstance(values,str) values=[ __Generator__.__load_operand__(a,orient) for a in values ] except Exception as e: pass \"\"\" Trying zip a dict, if \"out\" is it \"\"\" try: out=dict(zip(out.keys(),values) except AttributeError as e: out = values return out ''' def __init__ ( self , modules = None , operator = None , operands = None , group = None , groupmap = None , ** kwargs ) : self . modules = {} self . group = group if operator is None or operator in \"__VOID__\" : operator = \"Series([],dtype='object')\" self . operator = operator if not modules is None : for k , m in modules . items () : self . operator = self . operator . replace ( k , f \"self.modules[{k!r}]\" ) self . modules [ k ] = import_module ( m ) self . operands = { k : HSeries . __Generator__ . __load_operand__ ( w ) for k , w in operands . items () } if groupmap is not None : self . groupmap = { k : HSeries . __Generator__ . __load_operand__ ( w ) for k , w in groupmap . items () } else : self . groupmap = None def __generate__ ( self , ** kwargs ) : operands = kwargs ''' times=kwargs[' times '] try: start=re.sub(' \\ + . * $ ','',str(times.start)) except Exception as e: start=None try: stop=re.sub(' \\ + . * $ ','',str(times.stop)) except Exception as e: stop = None kwargs.update({\"times\":slice(start,stop,times.step)}) ''' operands . update ( { k : w for k , w in self . operands . items () if not isinstance ( w , HSeries ) } ) operands [ 'group' ] = self . group if self . groupmap is not None : groupmap = { k : w . thvalues ( ** kwargs ) for k , w in self . groupmap . items () if isinstance ( w , HSeries ) } groupmap = { k : w . result () for k , w in groupmap . items () } #groupmap = concat ( groupmap , axis = 1 ) cols = list ( groupmap . keys ()) groupmap = concat ( groupmap ). unstack (). T . sort_index () try : groupmap . columns = groupmap . columns . droplevel ( 0 ) except Exception as e : pass for c in cols : if c not in groupmap . columns : groupmap [ c ] = None operands [ '__GROUPMAP__' ] = groupmap runners = { k : w . thvalues ( ** kwargs ) for k , w in self . operands . items () if isinstance ( w , HSeries ) } operands . update ( { k : w . result () for k , w in runners . items () } ) #operands . update ( { k : w . data ( ** kwargs ) for k , w in self . operands . items () if isinstance ( w , HSeries ) } ) ## ATTENZIONE A locals : Implementation Dependant !!!! ### locals (). update ( operands ) # print ( operands ) #DEBUG # print ( self . operator , locals () ) #DEBUG out = eval ( self . operator ) return out Methods attribute_update def attribute_update ( self , attribute = None , value = None ) View Source def attribute_update ( self , attribute = None , value = None ) : if attribute is None : return if attribute == 'thresholds' : if not isinstance ( value ,( list , set , tuple )) : value =[ value ] for t in value : db [ \"series_thresholds\" ][ self.uuid ]= t if attribute == 'reference' : pass else : db [ \"series\" ][ self.uuid ]= { attribute : value } if self . __loaded__ : self . __loaded__ = False self . __delayed_load__ () check def check ( self , geometry = None , ** kwargs ) View Source def check ( self , geometry = None , ** kwargs ) : try : last_event = db [ 'status' ][ {'series':self.uuid} ] . iloc [ 0 ] last_event_time = str ( last_event [ 'last_time' ] ) except KeyError as e : last_event = None last_event_time = None times = slice ( last_event_time , None , None ) cache = 'active' # BUILDING THE REFERENCE DATAFRAME ( aa ) aa = self . thresholds if aa . empty : d = DataFrame ( [ [self.uuid,self.last,'#','#','#','#','#','#','#',0 ] ] , columns =[ 'series','timestamp','reading_value','threshold_value','ttype','label','color','end','count','latency' ] ) return d . set_index ( [ 'series','timestamp' ] ) if aa [ 'ttype' ] . iloc [ 0 ] == 'LOWER' : aa = concat ( [ aa,DataFrame([[None,'LOWER',None ] ] , index = Index ( [ -inf ] , name = 'value' ), columns =[ 'label','ttype','color' ] ) ] ). sort_index () if aa [ 'ttype' ] . iloc [ -1 ] == 'UPPER' : aa = concat ( [ aa,DataFrame([[None,'UPPER',None ] ] , index = Index ( [ inf ] , name = 'value' ), columns =[ 'label','ttype','color' ] ) ] ). sort_index () aa = aa . reset_index () bb = aa [ 'value' ] . copy () aa . loc [ aa['ttype' ]== 'LOWER' , [ 'value','label','color' ] ] = aa . loc [ aa['ttype' ]== 'LOWER' , [ 'value','label','color' ] ] . shift ( - 1 ) aa . loc [ aa['ttype' ]== 'UPPER' , [ 'value','label','color' ] ] = aa . loc [ aa['ttype' ]== 'UPPER' , [ 'value','label','color' ] ] . shift ( 1 ) aa [ 'limit' ]= bb aa = aa [ aa['value' ] . notna () ] aa . index . name = 'idt' aa = aa . reset_index () # REFEERENCE DATAFRAME DONE # EXTRACTING THE DATA d = self . data ( times = times , cache = cache , geometry = geometry , ** kwargs ) # DATA ESTRACTION DONE try : d = d . to_frame () except Exception as e : pass v = d . columns [ 0 ] # TODO capire neither or both # TODO separare UPPER e LOWER # MATCHING FOR OVERCOMES ( each i in aa , thresholds , over d , data ) for i in aa . index : d . loc [ d[v ] . between ( min ( aa . loc [ i,'value' ] , aa . loc [ i,'limit' ] ), max ( aa . loc [ i,'value' ] , aa . loc [ i,'limit' ] ), inclusive = 'neither' ), 'value' ] = aa . loc [ i,'idt' ] aa = aa . set_index ( 'idt' ) d = d . reset_index (). set_index ( 'value' ). sort_index () d = d . join ( aa , how = 'left' ). set_index ( 'timestamp' ). sort_index () [ [v,'value','ttype','label','color' ] ] d . columns =[ \"reading_value\",\"threshold_value\",\"ttype\",\"label\",\"color\" ] d [ 'series' ]= v d = d . reset_index () d = d . replace ( nan , \"#\" ) d [ 'end' ] = d [ 'timestamp' ] . copy () d [ 'timestamp' ]= d [ ~(d[\"label\" ] == d [ \"label\" ] . shift ( 1 )) | ~ ( d [ \"ttype\" ] == d [ \"ttype\" ] . shift ( 1 )) ] [ 'end' ] d [ 'timestamp' ] = d [ 'timestamp' ] . ffill () d = d . set_index ( 'timestamp' ) d [ 'count' ]= d [ 'label' ] . groupby ( 'timestamp' ). count () d = d . reset_index () d = d [ ~(d[\"label\" ] == d [ 'label' ] . shift ( - 1 )) | ~ ( d [ \"ttype\" ] == d [ 'ttype' ] . shift ( - 1 )) ] reftime = datetime64 ( 'now' ) + timedelta64 ( conf [ 'server_time_offset' ] , 'h' ) d [ 'latency' ]= ( reftime - d [ 'end' ] ). astype ( 'timedelta64[s]' ) d [ 'timestamp' ]= d [ 'timestamp' ] . astype ( str ) d [ 'end' ] = d [ 'end' ] . astype ( str ) d [ 'latency' ]= d [ 'latency' ] . astype ( int ) if not d . empty and last_event is not None : d . loc [ d.index[0 ] , 'count' ] = ( d . iloc [ 0 ][ 'count' ] - 1 + last_event [ 'count' ] ). squeeze () d . loc [ d.index[0 ] , 'timestamp' ] = str ( last_event [ 'start_time' ] ) if d . __len__ () > 1 : if last_event [ 'latency' ] is not None : d . loc [ d.index[0 ] , 'latency' ] = last_event [ 'latency' ] def fillth ( ** kwargs ) : db [ \"events\" ][ {'series':kwargs['series' ] }] = kwargs d . apply ( lambda x : fillth ( ** x ), axis = 1 ) return d . set_index ( [ 'series','timestamp' ] ) clean_cache def clean_cache ( self , times = None ) View Source def clean_cache ( self , times = None ) : to_clean = list ( set ( [ self.uuid,*self.activeuuids ] )) try : db [ self.datatable ] . pop ( key = ( to_clean , times )) except KeyError as e : pass try : db [ 'events' ] . pop ( key = ( to_clean , times )) except KeyError as e : pass try : last = str ( db [ self.datatable ][ to_clean ] . index [ -1 ] ) except Exception as e : last = None self . attribute_update ( 'last' , last ) data def data ( self , times = None , timeref = None , cache = None , group = None , geometry = None , ** kwargs ) View Source def data ( self , times = None , timeref = None , cache = None , group = None , geometry = None , ** kwargs ) : self . __delayed_load__ () entertimes = times if self . capability not in [ 'data','datadiagram' ] : raise ValueError ( f \"{self.uuid} has not 'data' capability\" ) if self . ingroup is None or group in self . ingroup : cangenerate = True else : cangenerate = False timeref = agoodtime ( timeref ) if cache is None : try : cache = self . cache assert cache in ( \"active\" , \"data\" , \"old\" ) except Exception as e : cache = \"no\" if times is None : times = slice ( None , None , None ) justnew = False try : if cache == 'new' : justnew = True timefrom = isot2ut ( self . last ) try : assert self . cache in ( \"active\" , \"data\" , \"old\" ) cache = \"active\" except Exception as e : cache = \"no\" else : tocheck = min ( isot2ut ( self . last ), isot2ut ( times . start )) timefrom = max ( isot2ut ( self . first ), tocheck ) times = slice ( ut2isot ( timefrom ), times . stop , times . step ) except Exception as e : pass firstreqstart = times . start #TODO inserire i nomi dei label out = DataFrame ( [] , columns = self . activeuuids , dtype = 'object' ) if cache in ( \"refresh\" ) : self . clean_cache ( times ) if cache in ( \"active\" , \"data\" , \"old\" ) : try : out = db [ self.datatable ][ self.activeuuids,times ] except KeyError as e : pass if not out . empty : cachestop = out . index . max () try : timefrom = max ( isot2ut ( cachestop ), isot2ut ( times . start )) times = slice ( ut2isot ( timefrom ), times . stop , times . step ) except Exception as e : pass try : try : if cache == 'old' or not cangenerate : raise Exception ( 'request for old, skip generation' ) kwargs [ 'cache' ] = cache gen = self . generator . __generate__ ( times = times , timeref = timeref , geometry = geometry , ** kwargs ) gen = gen . replace ( ',' , '.' , regex = True ). astype ( float ) if gen . empty : raise Exception ( \"void\" ) except Exception as e : # print ( \"WARN series GENERATE: \" , e ) # raise e ##DEBUG gen = DataFrame ( [] , columns = self . activeuuids , dtype = 'object' ) try : gen = gen . to_frame () except AttributeError as e : pass #gen . name = self . uuid try : gen = gen . round ( 4 ) except Exception as e : pass try : gen . columns = self . activeuuids except Exception as e : pass gen . index = DatetimeIndex ( gen . index ) out = concat ( [ out,gen ] ). sort_index () out . index . name = \"timestamp\" out = out [ self.activeuuids ] if self . valid_range_min is not None : out = out . mask ( out < self . valid_range_min , nan ) if self . valid_range_max is not None : out = out . mask ( out > self . valid_range_max , nan ) out = out [ out.notna().any(axis=1) ] if cache in ( \"active\" , \"data\" , \"refresh\" ) and cangenerate : for u in gen . columns : db [ self.datatable ][ u ]= out [ u ] except Exception as e : # print ( \"WARN series GLOBAL: \" , e ) # raise e #DEBUG pass if cache in ( \"active\" , \"data\" , \"refresh\" ) and not out . empty and not justnew : lasttotry = str ( out . index [ 0 ] ) times = slice ( firstreqstart , lasttotry , times . step ) kwargs [ 'cache' ] = \"none\" preout = self . data ( times = times , geometry = geometry , group = group , ** kwargs ) try : preout = preout . to_frame () except Exception as e : pass preout . index . name = \"timestamp\" try : preout . columns = self . activeuuids except Exception as e : pass if cangenerate : for u in preout . columns : db [ self.datatable ][ u ]= preout [ u ] if preout . __len__ () : out = concat ( [ preout,out ] ). sort_index () out = out [ ~out.index.duplicated() ] out . index . name = \"timestamp\" if not out . empty : self . attribute_update ( 'last' , ut2isot ( max ( isot2ut ( self . last ), isot2ut ( str ( out . index [ -1 ] ))))) try : out = out . loc [ entertimes ] except Exception as e : pass try : if out . columns . __len__ () < 2 : out = out . iloc [ :,0 ] except Exception as e : pass return out datadiagram def datadiagram ( self , ** kwargs ) View Source def datadiagram ( self , ** kwargs ) : return self . data ( ** kwargs ) setup def setup ( uuid = None , operator = None , modules = None , cache = None , datatable = None , mu = None , datatype = None , operands = None , capability = 'data' , first = None , valid_range = None , view_range = None , thresholds = None , groupmap = None , orient = 'H' ) View Source def setup ( uuid = None , operator = None , modules = None , cache = None , datatable = None , mu = None , datatype = None , operands = None , capability = 'data' , first = None , valid_range = None , view_range = None , thresholds = None , groupmap = None , orient = 'H' ) : def _managed_capabilities_ ( capability ) : return capability in [ 'data','stream','group','datadiagram' ] uuid = uuid or getuuid () try : uuid = uuid . uuid except Exception as e : pass setups = {} \"\"\" #TODO gestire le diverse tipologie di dato if datatype is not None and datatype in ['numeric']: setups['datatable']='geoframe.log' \"\"\" if datatable is None : datatable = 'datacache' try : db [ datatable ] except Exception as e : raise e pass setups [ 'datatable' ] = datatable if modules is not None and isinstance ( modules , dict ) : setups [ 'modules' ]= modules if operator is not None and isinstance ( operator , str ) : setups [ 'operator' ]= operator if cache is not None and isinstance ( cache , str ) : setups [ 'cache' ]= cache if mu is not None and isinstance ( mu , str ) : setups [ 'mu' ] = mu if capability is not None and _managed_capabilities_ ( capability ) : setups [ 'capability' ] = capability # print ( \"Start_time:\" , first ) if first is not None : setups [ 'first' ] = first if orient is not None : setups [ 'orient' ] = orient if valid_range is not None : try : setups [ 'valid_range_min' ]= valid_range [ 0 ] except Exception as e : pass try : setups [ 'valid_range_max' ]= valid_range [ 1 ] except Exception as e : pass if view_range is not None : try : setups [ 'view_range_min' ]= view_range [ 0 ] except Exception as e : pass try : setups [ 'view_range_max' ]= view_range [ 1 ] except Exception as e : pass db [ \"series\" ][ uuid ]= setups #TODO fare il check di coerenza tra operandi e operatore if operands is not None and isinstance ( operands , dict ) : # print ( operands ) table_operands = db [ \"series_operands\" ] for k , w in operands . items () : if not isinstance ( w ,( list , tuple , set , dict )) : w =[ w ] if isinstance ( w ,( list , tuple , set )) : wl = min ( table_operands . values . __len__ (), w . __len__ ()) w = dict ( zip ( table_operands . values [ :wl ] , w [ :wl ] )) try : if isinstance ( w [ 'operand' ] , HSeries ) : w [ 'operand' ]= w [ 'operand' ] . uuid except Exception as e : print ( w , uuid ) #raise ( e ) table_operands [ (uuid,k) ]= w if groupmap is not None : try : if not isinstance ( groupmap ,( list , tuple , set )) : raise Exception ( f \"not a vaild list\" ) for i in range ( 0 , groupmap . __len__ ()) : v = groupmap [ i ] if not isinstance ( v , dict ) : raise Exception ( f \"{v} has not a valid format\" ) el = v . pop ( 'element' ) try : el = HSeries ( el , delayed = False ). uuid except Exception as e : raise e try : v [ 'ordinal' ] except Exception as e : v [ 'ordinal' ] = i try : v [ 'label' ] except Exception as e : v [ 'label' ] = str ( i ) db [ \"series_groups\" ][ (uuid,el) ]= v db [ \"series\" ][ uuid ]= { \"capability\" : 'datadiagram' } except Exception as e : raise Exception ( f \"groupmap CONF for {uuid}: {e}\" ) if thresholds is not None and isinstance ( thresholds , ( list , tuple , set )) : for t in thresholds : db [ \"series_thresholds\" ][ uuid ]= t return HSeries ( uuid ) stream def stream ( self , times = None , timeref = None , cache = None , geometry = None , ** kwargs ) View Source def stream ( self , times = None , timeref = None , cache = None , geometry = None , ** kwargs ): if self . capability != 'stream' : raise ValueError ( f \"{self.uuid} has not 'stream' capability\" ) self . __delayed_load__ () timeref = agoodtime ( timeref ) cache = \"no\" try : try : out = self . generator . __generate__ ( ** kwargs ) gen = Series ([ out [ 'queue' ]], index = [ out [ 'timestamp' ]]) except Exception as e : # print (\"WARN series GENERATE: \",e) # raise e gen = Series ([], dtype = 'object' ) gen . name = 'queue' gen . index = DatetimeIndex ( gen . index ) out = gen [ ~ gen . index . duplicated ()] out . index . name = \"timestamp\" except Exception as e : #raise e pass try : out = out [ out . columns [ 0 ]] except Exception as e : pass return out thvalues def thvalues ( self , ** kwargs ) View Source @_threadpool def thvalues ( self , ** kwargs ) : return self . __getattr__ ( self . capability )( ** kwargs )","title":"Series"},{"location":"reference/hielen3/series/#module-hielen3series","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 #!/usr/bin/env python # coding=utf-8 from pandas import DataFrame , Series , concat , DatetimeIndex , Index , MultiIndex from concurrent.futures import ThreadPoolExecutor from functools import wraps from numpy import nan , unique , round , inf , datetime64 , timedelta64 from importlib import import_module from hielen3 import db , conf from hielen3.utils import isot2ut , ut2isot , agoodtime , uuid as getuuid , dataframe2jsonizabledict from uuid import UUID import re import json import traceback def _threadpool ( f ): @wraps ( f ) def wrap ( * args , ** kwargs ): return ThreadPoolExecutor () . submit ( f , * args , ** kwargs ) return wrap class HSeries : def __repr__ ( self ): return self . uuid def __delayed_load__ ( self ): if self . __loaded__ : return try : ser = re . split ( \"\\s*>\\s*\" , self . uuid ) if ser . __len__ () == 2 : try : feat = db [ 'features' ][ ser [ 0 ]] except Exception as e : feats = db [ 'features' ][:] feat = feats [ feats [ 'label' ] == ser [ 0 ] ] fuuid , fname = feat [[ 'uuid' , 'label' ]] . squeeze () self . feature = fname self . uuid = db [ 'features_parameters' ][ fuuid , ser [ 1 ]][ 'series' ] . squeeze () self . parameter = ser [ 1 ] except Exception as e : raise KeyError ( f \"Series { self . uuid } not found.\" ) series_info = db [ \"series\" ][ self . uuid ] series_info = dataframe2jsonizabledict ( series_info ) if series_info [ 'datatable' ] is None or series_info [ 'datatable' ] == '' : series_info [ 'datatable' ] = 'datacache' try : db [ series_info [ 'datatable' ]] except Exception as e : series_info [ 'datatable' ] = 'datacache' self . __dict__ . update ( series_info ) self . __dict__ . pop ( 'modules' ) self . __dict__ . pop ( 'operator' ) try : operands = db [ \"series_operands\" ][ self . uuid ][ 'operand' ] . \\ reset_index () . \\ set_index ( 'label' )[ 'operand' ] . \\ to_dict () except Exception as e : operands = {} try : groupmap = db [ 'series_groups' ][ self . uuid ][ 'ordinal' ] . \\ apply ( lambda x : f \"__GROUPMAP__ { str ( x ) . zfill ( 3 ) } __\" ) . \\ reset_index () . \\ set_index ( 'ordinal' )[ 'element' ] . \\ sort_index () . \\ to_dict () self . activeuuids = list ( groupmap . values ()) self . capability = 'datadiagram' series_info [ 'group' ] = self . uuid except Exception as e : groupmap = None self . activeuuids = [ self . uuid ] series_info [ 'operands' ] = operands series_info [ 'groupmap' ] = groupmap self . generator = HSeries . __Generator__ ( ** series_info ) try : self . ingroup = db [ 'series_groups' ][{ \"element\" : self . uuid }][ 'groupseries' ] . to_list () except Exception as e : self . ingroup = None try : t = db [ 'series_thresholds' ][ self . uuid ] t = t [[ 'value' , 'color' ]] . reset_index () . drop ( 'series' , axis = 1 ) . set_index ( 'value' ) . sort_index () #t=t[['value','color']].reset_index().drop('series',axis=1).to_dict(orient='records') self . thresholds = t except Exception as e : self . thresholds = DataFrame ([], columns = [ 'ttype' , 'label' , 'columns' ], index = Index ([], name = 'value' ), dtype = 'object' ) self . __loaded__ = True def __getattr__ ( self , item ): self . __delayed_load__ () return self . __getattribute__ ( item ) def __init__ ( self , uuid , delayed = True , ** kwargs ): if uuid is None : raise ValueError self . uuid = uuid self . feature = None self . param = None self . __loaded__ = False if not delayed : self . __delayed_load__ () def clean_cache ( self , times = None ): to_clean = list ( set ([ self . uuid , * self . activeuuids ])) try : db [ self . datatable ] . pop ( key = ( to_clean , times )) except KeyError as e : pass try : db [ 'events' ] . pop ( key = ( to_clean , times )) except KeyError as e : pass try : last = str ( db [ self . datatable ][ to_clean ] . index [ - 1 ]) except Exception as e : last = None self . attribute_update ( 'last' , last ) def setup ( uuid = None , operator = None , modules = None , cache = None , datatable = None , mu = None , datatype = None , operands = None , capability = 'data' , first = None , valid_range = None , view_range = None , thresholds = None , groupmap = None , orient = 'H' ): def _managed_capabilities_ ( capability ): return capability in [ 'data' , 'stream' , 'group' , 'datadiagram' ] uuid = uuid or getuuid () try : uuid = uuid . uuid except Exception as e : pass setups = {} \"\"\" #TODO gestire le diverse tipologie di dato if datatype is not None and datatype in ['numeric']: setups['datatable']='geoframe.log' \"\"\" if datatable is None : datatable = 'datacache' try : db [ datatable ] except Exception as e : raise e pass setups [ 'datatable' ] = datatable if modules is not None and isinstance ( modules , dict ): setups [ 'modules' ] = modules if operator is not None and isinstance ( operator , str ): setups [ 'operator' ] = operator if cache is not None and isinstance ( cache , str ): setups [ 'cache' ] = cache if mu is not None and isinstance ( mu , str ): setups [ 'mu' ] = mu if capability is not None and _managed_capabilities_ ( capability ): setups [ 'capability' ] = capability # print (\"Start_time:\",first) if first is not None : setups [ 'first' ] = first if orient is not None : setups [ 'orient' ] = orient if valid_range is not None : try : setups [ 'valid_range_min' ] = valid_range [ 0 ] except Exception as e : pass try : setups [ 'valid_range_max' ] = valid_range [ 1 ] except Exception as e : pass if view_range is not None : try : setups [ 'view_range_min' ] = view_range [ 0 ] except Exception as e : pass try : setups [ 'view_range_max' ] = view_range [ 1 ] except Exception as e : pass db [ \"series\" ][ uuid ] = setups #TODO fare il check di coerenza tra operandi e operatore if operands is not None and isinstance ( operands , dict ): # print (operands) table_operands = db [ \"series_operands\" ] for k , w in operands . items (): if not isinstance ( w ,( list , tuple , set , dict )): w = [ w ] if isinstance ( w ,( list , tuple , set )): wl = min ( table_operands . values . __len__ (), w . __len__ ()) w = dict ( zip ( table_operands . values [: wl ], w [: wl ])) try : if isinstance ( w [ 'operand' ], HSeries ): w [ 'operand' ] = w [ 'operand' ] . uuid except Exception as e : print ( w , uuid ) #raise (e) table_operands [( uuid , k )] = w if groupmap is not None : try : if not isinstance ( groupmap ,( list , tuple , set )): raise Exception ( f \"not a vaild list\" ) for i in range ( 0 , groupmap . __len__ ()): v = groupmap [ i ] if not isinstance ( v , dict ): raise Exception ( f \" { v } has not a valid format\" ) el = v . pop ( 'element' ) try : el = HSeries ( el , delayed = False ) . uuid except Exception as e : raise e try : v [ 'ordinal' ] except Exception as e : v [ 'ordinal' ] = i try : v [ 'label' ] except Exception as e : v [ 'label' ] = str ( i ) db [ \"series_groups\" ][( uuid , el )] = v db [ \"series\" ][ uuid ] = { \"capability\" : 'datadiagram' } except Exception as e : raise Exception ( f \"groupmap CONF for { uuid } : { e } \" ) if thresholds is not None and isinstance ( thresholds , ( list , tuple , set )): for t in thresholds : db [ \"series_thresholds\" ][ uuid ] = t return HSeries ( uuid ) def attribute_update ( self , attribute = None , value = None ): if attribute is None : return if attribute == 'thresholds' : if not isinstance ( value ,( list , set , tuple )): value = [ value ] for t in value : db [ \"series_thresholds\" ][ self . uuid ] = t if attribute == 'reference' : pass else : db [ \"series\" ][ self . uuid ] = { attribute : value } if self . __loaded__ : self . __loaded__ = False self . __delayed_load__ () def check ( self , geometry = None , ** kwargs ): try : last_event = db [ 'status' ][{ 'series' : self . uuid }] . iloc [ 0 ] last_event_time = str ( last_event [ 'last_time' ]) except KeyError as e : last_event = None last_event_time = None times = slice ( last_event_time , None , None ) cache = 'active' # BUILDING THE REFERENCE DATAFRAME (aa) aa = self . thresholds if aa . empty : d = DataFrame ( [[ self . uuid , self . last , '#' , '#' , '#' , '#' , '#' , '#' , '#' , 0 ]], columns = [ 'series' , 'timestamp' , 'reading_value' , 'threshold_value' , 'ttype' , 'label' , 'color' , 'end' , 'count' , 'latency' ]) return d . set_index ([ 'series' , 'timestamp' ]) if aa [ 'ttype' ] . iloc [ 0 ] == 'LOWER' : aa = concat ([ aa , DataFrame ([[ None , 'LOWER' , None ]], index = Index ([ - inf ], name = 'value' ), columns = [ 'label' , 'ttype' , 'color' ])]) . sort_index () if aa [ 'ttype' ] . iloc [ - 1 ] == 'UPPER' : aa = concat ([ aa , DataFrame ([[ None , 'UPPER' , None ]], index = Index ([ inf ], name = 'value' ), columns = [ 'label' , 'ttype' , 'color' ])]) . sort_index () aa = aa . reset_index () bb = aa [ 'value' ] . copy () aa . loc [ aa [ 'ttype' ] == 'LOWER' ,[ 'value' , 'label' , 'color' ]] = aa . loc [ aa [ 'ttype' ] == 'LOWER' ,[ 'value' , 'label' , 'color' ]] . shift ( - 1 ) aa . loc [ aa [ 'ttype' ] == 'UPPER' ,[ 'value' , 'label' , 'color' ]] = aa . loc [ aa [ 'ttype' ] == 'UPPER' ,[ 'value' , 'label' , 'color' ]] . shift ( 1 ) aa [ 'limit' ] = bb aa = aa [ aa [ 'value' ] . notna ()] aa . index . name = 'idt' aa = aa . reset_index () # REFEERENCE DATAFRAME DONE # EXTRACTING THE DATA d = self . data ( times = times , cache = cache , geometry = geometry , ** kwargs ) # DATA ESTRACTION DONE try : d = d . to_frame () except Exception as e : pass v = d . columns [ 0 ] # TODO capire neither or both # TODO separare UPPER e LOWER # MATCHING FOR OVERCOMES (each i in aa, thresholds, over d, data) for i in aa . index : d . loc [ d [ v ] . between ( min ( aa . loc [ i , 'value' ], aa . loc [ i , 'limit' ]), max ( aa . loc [ i , 'value' ], aa . loc [ i , 'limit' ]), inclusive = 'neither' ), 'value' ] = aa . loc [ i , 'idt' ] aa = aa . set_index ( 'idt' ) d = d . reset_index () . set_index ( 'value' ) . sort_index () d = d . join ( aa , how = 'left' ) . set_index ( 'timestamp' ) . sort_index ()[[ v , 'value' , 'ttype' , 'label' , 'color' ]] d . columns = [ \"reading_value\" , \"threshold_value\" , \"ttype\" , \"label\" , \"color\" ] d [ 'series' ] = v d = d . reset_index () d = d . replace ( nan , \"#\" ) d [ 'end' ] = d [ 'timestamp' ] . copy () d [ 'timestamp' ] = d [ ~ ( d [ \"label\" ] == d [ \"label\" ] . shift ( 1 )) | ~ ( d [ \"ttype\" ] == d [ \"ttype\" ] . shift ( 1 )) ][ 'end' ] d [ 'timestamp' ] = d [ 'timestamp' ] . ffill () d = d . set_index ( 'timestamp' ) d [ 'count' ] = d [ 'label' ] . groupby ( 'timestamp' ) . count () d = d . reset_index () d = d [ ~ ( d [ \"label\" ] == d [ 'label' ] . shift ( - 1 )) | ~ ( d [ \"ttype\" ] == d [ 'ttype' ] . shift ( - 1 )) ] reftime = datetime64 ( 'now' ) + timedelta64 ( conf [ 'server_time_offset' ], 'h' ) d [ 'latency' ] = ( reftime - d [ 'end' ]) . astype ( 'timedelta64[s]' ) d [ 'timestamp' ] = d [ 'timestamp' ] . astype ( str ) d [ 'end' ] = d [ 'end' ] . astype ( str ) d [ 'latency' ] = d [ 'latency' ] . astype ( int ) if not d . empty and last_event is not None : d . loc [ d . index [ 0 ], 'count' ] = ( d . iloc [ 0 ][ 'count' ] - 1 + last_event [ 'count' ]) . squeeze () d . loc [ d . index [ 0 ], 'timestamp' ] = str ( last_event [ 'start_time' ]) if d . __len__ () > 1 : if last_event [ 'latency' ] is not None : d . loc [ d . index [ 0 ], 'latency' ] = last_event [ 'latency' ] def fillth ( ** kwargs ): db [ \"events\" ][{ 'series' : kwargs [ 'series' ]}] = kwargs d . apply ( lambda x : fillth ( ** x ), axis = 1 ) return d . set_index ([ 'series' , 'timestamp' ]) @_threadpool def thvalues ( self , ** kwargs ): return self . __getattr__ ( self . capability )( ** kwargs ) def datadiagram ( self , ** kwargs ): return self . data ( ** kwargs ) def data ( self , times = None , timeref = None , cache = None , group = None , geometry = None , ** kwargs ): self . __delayed_load__ () entertimes = times if self . capability not in [ 'data' , 'datadiagram' ]: raise ValueError ( f \" { self . uuid } has not 'data' capability\" ) if self . ingroup is None or group in self . ingroup : cangenerate = True else : cangenerate = False timeref = agoodtime ( timeref ) if cache is None : try : cache = self . cache assert cache in ( \"active\" , \"data\" , \"old\" ) except Exception as e : cache = \"no\" if times is None : times = slice ( None , None , None ) justnew = False try : if cache == 'new' : justnew = True timefrom = isot2ut ( self . last ) try : assert self . cache in ( \"active\" , \"data\" , \"old\" ) cache = \"active\" except Exception as e : cache = \"no\" else : tocheck = min ( isot2ut ( self . last ), isot2ut ( times . start )) timefrom = max ( isot2ut ( self . first ), tocheck ) times = slice ( ut2isot ( timefrom ), times . stop , times . step ) except Exception as e : pass firstreqstart = times . start #TODO inserire i nomi dei label out = DataFrame ([], columns = self . activeuuids , dtype = 'object' ) if cache in ( \"refresh\" ): self . clean_cache ( times ) if cache in ( \"active\" , \"data\" , \"old\" ): try : out = db [ self . datatable ][ self . activeuuids , times ] except KeyError as e : pass if not out . empty : cachestop = out . index . max () try : timefrom = max ( isot2ut ( cachestop ), isot2ut ( times . start )) times = slice ( ut2isot ( timefrom ), times . stop , times . step ) except Exception as e : pass try : try : if cache == 'old' or not cangenerate : raise Exception ( 'request for old, skip generation' ) kwargs [ 'cache' ] = cache gen = self . generator . __generate__ ( times = times , timeref = timeref , geometry = geometry , ** kwargs ) gen = gen . replace ( ',' , '.' , regex = True ) . astype ( float ) if gen . empty : raise Exception ( \"void\" ) except Exception as e : # print (\"WARN series GENERATE: \", e) # raise e ##DEBUG gen = DataFrame ([], columns = self . activeuuids , dtype = 'object' ) try : gen = gen . to_frame () except AttributeError as e : pass #gen.name=self.uuid try : gen = gen . round ( 4 ) except Exception as e : pass try : gen . columns = self . activeuuids except Exception as e : pass gen . index = DatetimeIndex ( gen . index ) out = concat ([ out , gen ]) . sort_index () out . index . name = \"timestamp\" out = out [ self . activeuuids ] if self . valid_range_min is not None : out = out . mask ( out < self . valid_range_min , nan ) if self . valid_range_max is not None : out = out . mask ( out > self . valid_range_max , nan ) out = out [ out . notna () . any ( axis = 1 )] if cache in ( \"active\" , \"data\" , \"refresh\" ) and cangenerate : for u in gen . columns : db [ self . datatable ][ u ] = out [ u ] except Exception as e : # print (\"WARN series GLOBAL: \", e) # raise e #DEBUG pass if cache in ( \"active\" , \"data\" , \"refresh\" ) and not out . empty and not justnew : lasttotry = str ( out . index [ 0 ]) times = slice ( firstreqstart , lasttotry , times . step ) kwargs [ 'cache' ] = \"none\" preout = self . data ( times = times , geometry = geometry , group = group , ** kwargs ) try : preout = preout . to_frame () except Exception as e : pass preout . index . name = \"timestamp\" try : preout . columns = self . activeuuids except Exception as e : pass if cangenerate : for u in preout . columns : db [ self . datatable ][ u ] = preout [ u ] if preout . __len__ (): out = concat ([ preout , out ]) . sort_index () out = out [ ~ out . index . duplicated ()] out . index . name = \"timestamp\" if not out . empty : self . attribute_update ( 'last' , ut2isot ( max ( isot2ut ( self . last ), isot2ut ( str ( out . index [ - 1 ]))))) try : out = out . loc [ entertimes ] except Exception as e : pass try : if out . columns . __len__ () < 2 : out = out . iloc [:, 0 ] except Exception as e : pass return out ## WARNING Omesso Map ## WARINIG Omesso Cloud def stream ( self , times = None , timeref = None , cache = None , geometry = None , ** kwargs ): if self . capability != 'stream' : raise ValueError ( f \" { self . uuid } has not 'stream' capability\" ) self . __delayed_load__ () timeref = agoodtime ( timeref ) cache = \"no\" try : try : out = self . generator . __generate__ ( ** kwargs ) gen = Series ([ out [ 'queue' ]], index = [ out [ 'timestamp' ]]) except Exception as e : # print (\"WARN series GENERATE: \",e) # raise e gen = Series ([], dtype = 'object' ) gen . name = 'queue' gen . index = DatetimeIndex ( gen . index ) out = gen [ ~ gen . index . duplicated ()] out . index . name = \"timestamp\" except Exception as e : #raise e pass try : out = out [ out . columns [ 0 ]] except Exception as e : pass return out # return out.to_frame() #TOLGO ORIENT class __Generator__ : def __load_operand__ ( value = None ): #OPERANDS RESOLUTION: try : UUID ( value ) return HSeries ( value ) except Exception as e : pass try : value = value . removeprefix ( '#' ) except Exception as e : pass \"\"\" trying to load json string, if \"value\" is it \"\"\" try : return json . loads ( value ) except Exception as e : pass return value ''' \"\"\" Trying to get values from a dict, if \"out\" is it \"\"\" try: values=out.values() except AttributeError as e: values=out \"\"\" Trying to load suboperands from a list if \"values\" is it \"\"\" try: assert not isinstance(values,str) values=[ __Generator__.__load_operand__(a,orient) for a in values ] except Exception as e: pass \"\"\" Trying zip a dict, if \"out\" is it \"\"\" try: out=dict(zip(out.keys(),values) except AttributeError as e: out = values return out ''' def __init__ ( self , modules = None , operator = None , operands = None , group = None , groupmap = None , ** kwargs ): self . modules = {} self . group = group if operator is None or operator in \"__VOID__\" : operator = \"Series([],dtype='object')\" self . operator = operator if not modules is None : for k , m in modules . items (): self . operator = self . operator . replace ( k , f \"self.modules[ { k !r} ]\" ) self . modules [ k ] = import_module ( m ) self . operands = { k : HSeries . __Generator__ . __load_operand__ ( w ) for k , w in operands . items () } if groupmap is not None : self . groupmap = { k : HSeries . __Generator__ . __load_operand__ ( w ) for k , w in groupmap . items () } else : self . groupmap = None def __generate__ ( self , ** kwargs ): operands = kwargs ''' times=kwargs['times'] try: start=re.sub('\\+.*$','',str(times.start)) except Exception as e: start=None try: stop=re.sub('\\+.*$','',str(times.stop)) except Exception as e: stop = None kwargs.update({\"times\":slice(start,stop,times.step)}) ''' operands . update ( { k : w for k , w in self . operands . items () if not isinstance ( w , HSeries )} ) operands [ 'group' ] = self . group if self . groupmap is not None : groupmap = { k : w . thvalues ( ** kwargs ) for k , w in self . groupmap . items () if isinstance ( w , HSeries ) } groupmap = { k : w . result () for k , w in groupmap . items () } #groupmap = concat(groupmap,axis=1) cols = list ( groupmap . keys ()) groupmap = concat ( groupmap ) . unstack () . T . sort_index () try : groupmap . columns = groupmap . columns . droplevel ( 0 ) except Exception as e : pass for c in cols : if c not in groupmap . columns : groupmap [ c ] = None operands [ '__GROUPMAP__' ] = groupmap runners = { k : w . thvalues ( ** kwargs ) for k , w in self . operands . items () if isinstance ( w , HSeries ) } operands . update ({ k : w . result () for k , w in runners . items ()}) #operands.update( { k:w.data(**kwargs) for k,w in self.operands.items() if isinstance(w,HSeries) } ) ## ATTENZIONE A locals: Implementation Dependant!!!! ### locals () . update ( operands ) # print (operands) #DEBUG # print (self.operator, locals() ) #DEBUG out = eval ( self . operator ) return out","title":"Module hielen3.series"},{"location":"reference/hielen3/series/#variables","text":"conf db inf nan","title":"Variables"},{"location":"reference/hielen3/series/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/series/#hseries","text":"class HSeries ( uuid , delayed = True , ** kwargs ) View Source class HSeries : def __repr__ ( self ) : return self . uuid def __delayed_load__ ( self ) : if self . __loaded__ : return try : ser = re . split ( \"\\s*>\\s*\" , self . uuid ) if ser . __len__ () == 2 : try : feat = db [ 'features' ][ ser[0 ] ] except Exception as e : feats = db [ 'features' ][ : ] feat = feats [ feats['label' ] == ser [ 0 ] ] fuuid , fname = feat [ ['uuid','label' ] ] . squeeze () self . feature = fname self . uuid = db [ 'features_parameters' ][ fuuid,ser[1 ] ] [ 'series' ] . squeeze () self . parameter = ser [ 1 ] except Exception as e : raise KeyError ( f \"Series {self.uuid} not found.\" ) series_info = db [ \"series\" ][ self.uuid ] series_info = dataframe2jsonizabledict ( series_info ) if series_info [ 'datatable' ] is None or series_info [ 'datatable' ] == '' : series_info [ 'datatable' ] = 'datacache' try : db [ series_info['datatable' ] ] except Exception as e : series_info [ 'datatable' ] = 'datacache' self . __dict__ . update ( series_info ) self . __dict__ . pop ( 'modules' ) self . __dict__ . pop ( 'operator' ) try : operands = db [ \"series_operands\" ][ self.uuid ][ 'operand' ] . \\ reset_index (). \\ set_index ( 'label' ) [ 'operand' ] . \\ to_dict () except Exception as e : operands = {} try : groupmap = db [ 'series_groups' ][ self.uuid ][ 'ordinal' ] . \\ apply ( lambda x : f \"__GROUPMAP__{str(x).zfill(3)}__\" ). \\ reset_index (). \\ set_index ( 'ordinal' ) [ 'element' ] . \\ sort_index (). \\ to_dict () self . activeuuids = list ( groupmap . values ()) self . capability = 'datadiagram' series_info [ 'group' ] = self . uuid except Exception as e : groupmap = None self . activeuuids =[ self.uuid ] series_info [ 'operands' ]= operands series_info [ 'groupmap' ]= groupmap self . generator = HSeries . __Generator__ ( ** series_info ) try : self . ingroup = db [ 'series_groups' ][ {\"element\":self.uuid} ][ 'groupseries' ] . to_list () except Exception as e : self . ingroup = None try : t = db [ 'series_thresholds' ][ self.uuid ] t = t [ ['value','color' ] ] . reset_index (). drop ( 'series' , axis = 1 ). set_index ( 'value' ). sort_index () #t = t [ ['value','color' ] ] . reset_index (). drop ( 'series' , axis = 1 ). to_dict ( orient = 'records' ) self . thresholds = t except Exception as e : self . thresholds = DataFrame ( [] , columns =[ 'ttype','label','columns' ] , index = Index ( [] , name = 'value' ), dtype = 'object' ) self . __loaded__ = True def __getattr__ ( self , item ) : self . __delayed_load__ () return self . __getattribute__ ( item ) def __init__ ( self , uuid , delayed = True , ** kwargs ) : if uuid is None : raise ValueError self . uuid = uuid self . feature = None self . param = None self . __loaded__ = False if not delayed : self . __delayed_load__ () def clean_cache ( self , times = None ) : to_clean = list ( set ( [ self.uuid,*self.activeuuids ] )) try : db [ self.datatable ] . pop ( key = ( to_clean , times )) except KeyError as e : pass try : db [ 'events' ] . pop ( key = ( to_clean , times )) except KeyError as e : pass try : last = str ( db [ self.datatable ][ to_clean ] . index [ -1 ] ) except Exception as e : last = None self . attribute_update ( 'last' , last ) def setup ( uuid = None , operator = None , modules = None , cache = None , datatable = None , mu = None , datatype = None , operands = None , capability = 'data' , first = None , valid_range = None , view_range = None , thresholds = None , groupmap = None , orient = 'H' ) : def _managed_capabilities_ ( capability ) : return capability in [ 'data','stream','group','datadiagram' ] uuid = uuid or getuuid () try : uuid = uuid . uuid except Exception as e : pass setups = {} \"\"\" #TODO gestire le diverse tipologie di dato if datatype is not None and datatype in ['numeric']: setups['datatable']='geoframe.log' \"\"\" if datatable is None : datatable = 'datacache' try : db [ datatable ] except Exception as e : raise e pass setups [ 'datatable' ] = datatable if modules is not None and isinstance ( modules , dict ) : setups [ 'modules' ]= modules if operator is not None and isinstance ( operator , str ) : setups [ 'operator' ]= operator if cache is not None and isinstance ( cache , str ) : setups [ 'cache' ]= cache if mu is not None and isinstance ( mu , str ) : setups [ 'mu' ] = mu if capability is not None and _managed_capabilities_ ( capability ) : setups [ 'capability' ] = capability # print ( \"Start_time:\" , first ) if first is not None : setups [ 'first' ] = first if orient is not None : setups [ 'orient' ] = orient if valid_range is not None : try : setups [ 'valid_range_min' ]= valid_range [ 0 ] except Exception as e : pass try : setups [ 'valid_range_max' ]= valid_range [ 1 ] except Exception as e : pass if view_range is not None : try : setups [ 'view_range_min' ]= view_range [ 0 ] except Exception as e : pass try : setups [ 'view_range_max' ]= view_range [ 1 ] except Exception as e : pass db [ \"series\" ][ uuid ]= setups #TODO fare il check di coerenza tra operandi e operatore if operands is not None and isinstance ( operands , dict ) : # print ( operands ) table_operands = db [ \"series_operands\" ] for k , w in operands . items () : if not isinstance ( w ,( list , tuple , set , dict )) : w =[ w ] if isinstance ( w ,( list , tuple , set )) : wl = min ( table_operands . values . __len__ (), w . __len__ ()) w = dict ( zip ( table_operands . values [ :wl ] , w [ :wl ] )) try : if isinstance ( w [ 'operand' ] , HSeries ) : w [ 'operand' ]= w [ 'operand' ] . uuid except Exception as e : print ( w , uuid ) #raise ( e ) table_operands [ (uuid,k) ]= w if groupmap is not None : try : if not isinstance ( groupmap ,( list , tuple , set )) : raise Exception ( f \"not a vaild list\" ) for i in range ( 0 , groupmap . __len__ ()) : v = groupmap [ i ] if not isinstance ( v , dict ) : raise Exception ( f \"{v} has not a valid format\" ) el = v . pop ( 'element' ) try : el = HSeries ( el , delayed = False ). uuid except Exception as e : raise e try : v [ 'ordinal' ] except Exception as e : v [ 'ordinal' ] = i try : v [ 'label' ] except Exception as e : v [ 'label' ] = str ( i ) db [ \"series_groups\" ][ (uuid,el) ]= v db [ \"series\" ][ uuid ]= { \"capability\" : 'datadiagram' } except Exception as e : raise Exception ( f \"groupmap CONF for {uuid}: {e}\" ) if thresholds is not None and isinstance ( thresholds , ( list , tuple , set )) : for t in thresholds : db [ \"series_thresholds\" ][ uuid ]= t return HSeries ( uuid ) def attribute_update ( self , attribute = None , value = None ) : if attribute is None : return if attribute == 'thresholds' : if not isinstance ( value ,( list , set , tuple )) : value =[ value ] for t in value : db [ \"series_thresholds\" ][ self.uuid ]= t if attribute == 'reference' : pass else : db [ \"series\" ][ self.uuid ]= { attribute : value } if self . __loaded__ : self . __loaded__ = False self . __delayed_load__ () def check ( self , geometry = None , ** kwargs ) : try : last_event = db [ 'status' ][ {'series':self.uuid} ] . iloc [ 0 ] last_event_time = str ( last_event [ 'last_time' ] ) except KeyError as e : last_event = None last_event_time = None times = slice ( last_event_time , None , None ) cache = 'active' # BUILDING THE REFERENCE DATAFRAME ( aa ) aa = self . thresholds if aa . empty : d = DataFrame ( [ [self.uuid,self.last,'#','#','#','#','#','#','#',0 ] ] , columns =[ 'series','timestamp','reading_value','threshold_value','ttype','label','color','end','count','latency' ] ) return d . set_index ( [ 'series','timestamp' ] ) if aa [ 'ttype' ] . iloc [ 0 ] == 'LOWER' : aa = concat ( [ aa,DataFrame([[None,'LOWER',None ] ] , index = Index ( [ -inf ] , name = 'value' ), columns =[ 'label','ttype','color' ] ) ] ). sort_index () if aa [ 'ttype' ] . iloc [ -1 ] == 'UPPER' : aa = concat ( [ aa,DataFrame([[None,'UPPER',None ] ] , index = Index ( [ inf ] , name = 'value' ), columns =[ 'label','ttype','color' ] ) ] ). sort_index () aa = aa . reset_index () bb = aa [ 'value' ] . copy () aa . loc [ aa['ttype' ]== 'LOWER' , [ 'value','label','color' ] ] = aa . loc [ aa['ttype' ]== 'LOWER' , [ 'value','label','color' ] ] . shift ( - 1 ) aa . loc [ aa['ttype' ]== 'UPPER' , [ 'value','label','color' ] ] = aa . loc [ aa['ttype' ]== 'UPPER' , [ 'value','label','color' ] ] . shift ( 1 ) aa [ 'limit' ]= bb aa = aa [ aa['value' ] . notna () ] aa . index . name = 'idt' aa = aa . reset_index () # REFEERENCE DATAFRAME DONE # EXTRACTING THE DATA d = self . data ( times = times , cache = cache , geometry = geometry , ** kwargs ) # DATA ESTRACTION DONE try : d = d . to_frame () except Exception as e : pass v = d . columns [ 0 ] # TODO capire neither or both # TODO separare UPPER e LOWER # MATCHING FOR OVERCOMES ( each i in aa , thresholds , over d , data ) for i in aa . index : d . loc [ d[v ] . between ( min ( aa . loc [ i,'value' ] , aa . loc [ i,'limit' ] ), max ( aa . loc [ i,'value' ] , aa . loc [ i,'limit' ] ), inclusive = 'neither' ), 'value' ] = aa . loc [ i,'idt' ] aa = aa . set_index ( 'idt' ) d = d . reset_index (). set_index ( 'value' ). sort_index () d = d . join ( aa , how = 'left' ). set_index ( 'timestamp' ). sort_index () [ [v,'value','ttype','label','color' ] ] d . columns =[ \"reading_value\",\"threshold_value\",\"ttype\",\"label\",\"color\" ] d [ 'series' ]= v d = d . reset_index () d = d . replace ( nan , \"#\" ) d [ 'end' ] = d [ 'timestamp' ] . copy () d [ 'timestamp' ]= d [ ~(d[\"label\" ] == d [ \"label\" ] . shift ( 1 )) | ~ ( d [ \"ttype\" ] == d [ \"ttype\" ] . shift ( 1 )) ] [ 'end' ] d [ 'timestamp' ] = d [ 'timestamp' ] . ffill () d = d . set_index ( 'timestamp' ) d [ 'count' ]= d [ 'label' ] . groupby ( 'timestamp' ). count () d = d . reset_index () d = d [ ~(d[\"label\" ] == d [ 'label' ] . shift ( - 1 )) | ~ ( d [ \"ttype\" ] == d [ 'ttype' ] . shift ( - 1 )) ] reftime = datetime64 ( 'now' ) + timedelta64 ( conf [ 'server_time_offset' ] , 'h' ) d [ 'latency' ]= ( reftime - d [ 'end' ] ). astype ( 'timedelta64[s]' ) d [ 'timestamp' ]= d [ 'timestamp' ] . astype ( str ) d [ 'end' ] = d [ 'end' ] . astype ( str ) d [ 'latency' ]= d [ 'latency' ] . astype ( int ) if not d . empty and last_event is not None : d . loc [ d.index[0 ] , 'count' ] = ( d . iloc [ 0 ][ 'count' ] - 1 + last_event [ 'count' ] ). squeeze () d . loc [ d.index[0 ] , 'timestamp' ] = str ( last_event [ 'start_time' ] ) if d . __len__ () > 1 : if last_event [ 'latency' ] is not None : d . loc [ d.index[0 ] , 'latency' ] = last_event [ 'latency' ] def fillth ( ** kwargs ) : db [ \"events\" ][ {'series':kwargs['series' ] }] = kwargs d . apply ( lambda x : fillth ( ** x ), axis = 1 ) return d . set_index ( [ 'series','timestamp' ] ) @_threadpool def thvalues ( self , ** kwargs ) : return self . __getattr__ ( self . capability )( ** kwargs ) def datadiagram ( self , ** kwargs ) : return self . data ( ** kwargs ) def data ( self , times = None , timeref = None , cache = None , group = None , geometry = None , ** kwargs ) : self . __delayed_load__ () entertimes = times if self . capability not in [ 'data','datadiagram' ] : raise ValueError ( f \"{self.uuid} has not 'data' capability\" ) if self . ingroup is None or group in self . ingroup : cangenerate = True else : cangenerate = False timeref = agoodtime ( timeref ) if cache is None : try : cache = self . cache assert cache in ( \"active\" , \"data\" , \"old\" ) except Exception as e : cache = \"no\" if times is None : times = slice ( None , None , None ) justnew = False try : if cache == 'new' : justnew = True timefrom = isot2ut ( self . last ) try : assert self . cache in ( \"active\" , \"data\" , \"old\" ) cache = \"active\" except Exception as e : cache = \"no\" else : tocheck = min ( isot2ut ( self . last ), isot2ut ( times . start )) timefrom = max ( isot2ut ( self . first ), tocheck ) times = slice ( ut2isot ( timefrom ), times . stop , times . step ) except Exception as e : pass firstreqstart = times . start #TODO inserire i nomi dei label out = DataFrame ( [] , columns = self . activeuuids , dtype = 'object' ) if cache in ( \"refresh\" ) : self . clean_cache ( times ) if cache in ( \"active\" , \"data\" , \"old\" ) : try : out = db [ self.datatable ][ self.activeuuids,times ] except KeyError as e : pass if not out . empty : cachestop = out . index . max () try : timefrom = max ( isot2ut ( cachestop ), isot2ut ( times . start )) times = slice ( ut2isot ( timefrom ), times . stop , times . step ) except Exception as e : pass try : try : if cache == 'old' or not cangenerate : raise Exception ( 'request for old, skip generation' ) kwargs [ 'cache' ] = cache gen = self . generator . __generate__ ( times = times , timeref = timeref , geometry = geometry , ** kwargs ) gen = gen . replace ( ',' , '.' , regex = True ). astype ( float ) if gen . empty : raise Exception ( \"void\" ) except Exception as e : # print ( \"WARN series GENERATE: \" , e ) # raise e ##DEBUG gen = DataFrame ( [] , columns = self . activeuuids , dtype = 'object' ) try : gen = gen . to_frame () except AttributeError as e : pass #gen . name = self . uuid try : gen = gen . round ( 4 ) except Exception as e : pass try : gen . columns = self . activeuuids except Exception as e : pass gen . index = DatetimeIndex ( gen . index ) out = concat ( [ out,gen ] ). sort_index () out . index . name = \"timestamp\" out = out [ self.activeuuids ] if self . valid_range_min is not None : out = out . mask ( out < self . valid_range_min , nan ) if self . valid_range_max is not None : out = out . mask ( out > self . valid_range_max , nan ) out = out [ out.notna().any(axis=1) ] if cache in ( \"active\" , \"data\" , \"refresh\" ) and cangenerate : for u in gen . columns : db [ self.datatable ][ u ]= out [ u ] except Exception as e : # print ( \"WARN series GLOBAL: \" , e ) # raise e #DEBUG pass if cache in ( \"active\" , \"data\" , \"refresh\" ) and not out . empty and not justnew : lasttotry = str ( out . index [ 0 ] ) times = slice ( firstreqstart , lasttotry , times . step ) kwargs [ 'cache' ] = \"none\" preout = self . data ( times = times , geometry = geometry , group = group , ** kwargs ) try : preout = preout . to_frame () except Exception as e : pass preout . index . name = \"timestamp\" try : preout . columns = self . activeuuids except Exception as e : pass if cangenerate : for u in preout . columns : db [ self.datatable ][ u ]= preout [ u ] if preout . __len__ () : out = concat ( [ preout,out ] ). sort_index () out = out [ ~out.index.duplicated() ] out . index . name = \"timestamp\" if not out . empty : self . attribute_update ( 'last' , ut2isot ( max ( isot2ut ( self . last ), isot2ut ( str ( out . index [ -1 ] ))))) try : out = out . loc [ entertimes ] except Exception as e : pass try : if out . columns . __len__ () < 2 : out = out . iloc [ :,0 ] except Exception as e : pass return out ## WARNING Omesso Map ## WARINIG Omesso Cloud def stream ( self , times = None , timeref = None , cache = None , geometry = None , ** kwargs ) : if self . capability != 'stream' : raise ValueError ( f \"{self.uuid} has not 'stream' capability\" ) self . __delayed_load__ () timeref = agoodtime ( timeref ) cache = \"no\" try : try : out = self . generator . __generate__ ( ** kwargs ) gen = Series ( [ out['queue' ] ] , index =[ out['timestamp' ] ] ) except Exception as e : # print ( \"WARN series GENERATE: \" , e ) # raise e gen = Series ( [] , dtype = 'object' ) gen . name = 'queue' gen . index = DatetimeIndex ( gen . index ) out = gen [ ~gen.index.duplicated() ] out . index . name = \"timestamp\" except Exception as e : #raise e pass try : out = out [ out.columns[0 ] ] except Exception as e : pass return out # return out . to_frame () #TOLGO ORIENT class __Generator__ : def __load_operand__ ( value = None ) : #OPERANDS RESOLUTION : try : UUID ( value ) return HSeries ( value ) except Exception as e : pass try : value = value . removeprefix ( '#' ) except Exception as e : pass \"\"\" trying to load json string, if \" value \" is it \"\"\" try : return json . loads ( value ) except Exception as e : pass return value ''' \"\"\" Trying to get values from a dict, if \"out\" is it \"\"\" try: values=out.values() except AttributeError as e: values=out \"\"\" Trying to load suboperands from a list if \"values\" is it \"\"\" try: assert not isinstance(values,str) values=[ __Generator__.__load_operand__(a,orient) for a in values ] except Exception as e: pass \"\"\" Trying zip a dict, if \"out\" is it \"\"\" try: out=dict(zip(out.keys(),values) except AttributeError as e: out = values return out ''' def __init__ ( self , modules = None , operator = None , operands = None , group = None , groupmap = None , ** kwargs ) : self . modules = {} self . group = group if operator is None or operator in \"__VOID__\" : operator = \"Series([],dtype='object')\" self . operator = operator if not modules is None : for k , m in modules . items () : self . operator = self . operator . replace ( k , f \"self.modules[{k!r}]\" ) self . modules [ k ] = import_module ( m ) self . operands = { k : HSeries . __Generator__ . __load_operand__ ( w ) for k , w in operands . items () } if groupmap is not None : self . groupmap = { k : HSeries . __Generator__ . __load_operand__ ( w ) for k , w in groupmap . items () } else : self . groupmap = None def __generate__ ( self , ** kwargs ) : operands = kwargs ''' times=kwargs[' times '] try: start=re.sub(' \\ + . * $ ','',str(times.start)) except Exception as e: start=None try: stop=re.sub(' \\ + . * $ ','',str(times.stop)) except Exception as e: stop = None kwargs.update({\"times\":slice(start,stop,times.step)}) ''' operands . update ( { k : w for k , w in self . operands . items () if not isinstance ( w , HSeries ) } ) operands [ 'group' ] = self . group if self . groupmap is not None : groupmap = { k : w . thvalues ( ** kwargs ) for k , w in self . groupmap . items () if isinstance ( w , HSeries ) } groupmap = { k : w . result () for k , w in groupmap . items () } #groupmap = concat ( groupmap , axis = 1 ) cols = list ( groupmap . keys ()) groupmap = concat ( groupmap ). unstack (). T . sort_index () try : groupmap . columns = groupmap . columns . droplevel ( 0 ) except Exception as e : pass for c in cols : if c not in groupmap . columns : groupmap [ c ] = None operands [ '__GROUPMAP__' ] = groupmap runners = { k : w . thvalues ( ** kwargs ) for k , w in self . operands . items () if isinstance ( w , HSeries ) } operands . update ( { k : w . result () for k , w in runners . items () } ) #operands . update ( { k : w . data ( ** kwargs ) for k , w in self . operands . items () if isinstance ( w , HSeries ) } ) ## ATTENZIONE A locals : Implementation Dependant !!!! ### locals (). update ( operands ) # print ( operands ) #DEBUG # print ( self . operator , locals () ) #DEBUG out = eval ( self . operator ) return out","title":"HSeries"},{"location":"reference/hielen3/series/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/series/#attribute_update","text":"def attribute_update ( self , attribute = None , value = None ) View Source def attribute_update ( self , attribute = None , value = None ) : if attribute is None : return if attribute == 'thresholds' : if not isinstance ( value ,( list , set , tuple )) : value =[ value ] for t in value : db [ \"series_thresholds\" ][ self.uuid ]= t if attribute == 'reference' : pass else : db [ \"series\" ][ self.uuid ]= { attribute : value } if self . __loaded__ : self . __loaded__ = False self . __delayed_load__ ()","title":"attribute_update"},{"location":"reference/hielen3/series/#check","text":"def check ( self , geometry = None , ** kwargs ) View Source def check ( self , geometry = None , ** kwargs ) : try : last_event = db [ 'status' ][ {'series':self.uuid} ] . iloc [ 0 ] last_event_time = str ( last_event [ 'last_time' ] ) except KeyError as e : last_event = None last_event_time = None times = slice ( last_event_time , None , None ) cache = 'active' # BUILDING THE REFERENCE DATAFRAME ( aa ) aa = self . thresholds if aa . empty : d = DataFrame ( [ [self.uuid,self.last,'#','#','#','#','#','#','#',0 ] ] , columns =[ 'series','timestamp','reading_value','threshold_value','ttype','label','color','end','count','latency' ] ) return d . set_index ( [ 'series','timestamp' ] ) if aa [ 'ttype' ] . iloc [ 0 ] == 'LOWER' : aa = concat ( [ aa,DataFrame([[None,'LOWER',None ] ] , index = Index ( [ -inf ] , name = 'value' ), columns =[ 'label','ttype','color' ] ) ] ). sort_index () if aa [ 'ttype' ] . iloc [ -1 ] == 'UPPER' : aa = concat ( [ aa,DataFrame([[None,'UPPER',None ] ] , index = Index ( [ inf ] , name = 'value' ), columns =[ 'label','ttype','color' ] ) ] ). sort_index () aa = aa . reset_index () bb = aa [ 'value' ] . copy () aa . loc [ aa['ttype' ]== 'LOWER' , [ 'value','label','color' ] ] = aa . loc [ aa['ttype' ]== 'LOWER' , [ 'value','label','color' ] ] . shift ( - 1 ) aa . loc [ aa['ttype' ]== 'UPPER' , [ 'value','label','color' ] ] = aa . loc [ aa['ttype' ]== 'UPPER' , [ 'value','label','color' ] ] . shift ( 1 ) aa [ 'limit' ]= bb aa = aa [ aa['value' ] . notna () ] aa . index . name = 'idt' aa = aa . reset_index () # REFEERENCE DATAFRAME DONE # EXTRACTING THE DATA d = self . data ( times = times , cache = cache , geometry = geometry , ** kwargs ) # DATA ESTRACTION DONE try : d = d . to_frame () except Exception as e : pass v = d . columns [ 0 ] # TODO capire neither or both # TODO separare UPPER e LOWER # MATCHING FOR OVERCOMES ( each i in aa , thresholds , over d , data ) for i in aa . index : d . loc [ d[v ] . between ( min ( aa . loc [ i,'value' ] , aa . loc [ i,'limit' ] ), max ( aa . loc [ i,'value' ] , aa . loc [ i,'limit' ] ), inclusive = 'neither' ), 'value' ] = aa . loc [ i,'idt' ] aa = aa . set_index ( 'idt' ) d = d . reset_index (). set_index ( 'value' ). sort_index () d = d . join ( aa , how = 'left' ). set_index ( 'timestamp' ). sort_index () [ [v,'value','ttype','label','color' ] ] d . columns =[ \"reading_value\",\"threshold_value\",\"ttype\",\"label\",\"color\" ] d [ 'series' ]= v d = d . reset_index () d = d . replace ( nan , \"#\" ) d [ 'end' ] = d [ 'timestamp' ] . copy () d [ 'timestamp' ]= d [ ~(d[\"label\" ] == d [ \"label\" ] . shift ( 1 )) | ~ ( d [ \"ttype\" ] == d [ \"ttype\" ] . shift ( 1 )) ] [ 'end' ] d [ 'timestamp' ] = d [ 'timestamp' ] . ffill () d = d . set_index ( 'timestamp' ) d [ 'count' ]= d [ 'label' ] . groupby ( 'timestamp' ). count () d = d . reset_index () d = d [ ~(d[\"label\" ] == d [ 'label' ] . shift ( - 1 )) | ~ ( d [ \"ttype\" ] == d [ 'ttype' ] . shift ( - 1 )) ] reftime = datetime64 ( 'now' ) + timedelta64 ( conf [ 'server_time_offset' ] , 'h' ) d [ 'latency' ]= ( reftime - d [ 'end' ] ). astype ( 'timedelta64[s]' ) d [ 'timestamp' ]= d [ 'timestamp' ] . astype ( str ) d [ 'end' ] = d [ 'end' ] . astype ( str ) d [ 'latency' ]= d [ 'latency' ] . astype ( int ) if not d . empty and last_event is not None : d . loc [ d.index[0 ] , 'count' ] = ( d . iloc [ 0 ][ 'count' ] - 1 + last_event [ 'count' ] ). squeeze () d . loc [ d.index[0 ] , 'timestamp' ] = str ( last_event [ 'start_time' ] ) if d . __len__ () > 1 : if last_event [ 'latency' ] is not None : d . loc [ d.index[0 ] , 'latency' ] = last_event [ 'latency' ] def fillth ( ** kwargs ) : db [ \"events\" ][ {'series':kwargs['series' ] }] = kwargs d . apply ( lambda x : fillth ( ** x ), axis = 1 ) return d . set_index ( [ 'series','timestamp' ] )","title":"check"},{"location":"reference/hielen3/series/#clean_cache","text":"def clean_cache ( self , times = None ) View Source def clean_cache ( self , times = None ) : to_clean = list ( set ( [ self.uuid,*self.activeuuids ] )) try : db [ self.datatable ] . pop ( key = ( to_clean , times )) except KeyError as e : pass try : db [ 'events' ] . pop ( key = ( to_clean , times )) except KeyError as e : pass try : last = str ( db [ self.datatable ][ to_clean ] . index [ -1 ] ) except Exception as e : last = None self . attribute_update ( 'last' , last )","title":"clean_cache"},{"location":"reference/hielen3/series/#data","text":"def data ( self , times = None , timeref = None , cache = None , group = None , geometry = None , ** kwargs ) View Source def data ( self , times = None , timeref = None , cache = None , group = None , geometry = None , ** kwargs ) : self . __delayed_load__ () entertimes = times if self . capability not in [ 'data','datadiagram' ] : raise ValueError ( f \"{self.uuid} has not 'data' capability\" ) if self . ingroup is None or group in self . ingroup : cangenerate = True else : cangenerate = False timeref = agoodtime ( timeref ) if cache is None : try : cache = self . cache assert cache in ( \"active\" , \"data\" , \"old\" ) except Exception as e : cache = \"no\" if times is None : times = slice ( None , None , None ) justnew = False try : if cache == 'new' : justnew = True timefrom = isot2ut ( self . last ) try : assert self . cache in ( \"active\" , \"data\" , \"old\" ) cache = \"active\" except Exception as e : cache = \"no\" else : tocheck = min ( isot2ut ( self . last ), isot2ut ( times . start )) timefrom = max ( isot2ut ( self . first ), tocheck ) times = slice ( ut2isot ( timefrom ), times . stop , times . step ) except Exception as e : pass firstreqstart = times . start #TODO inserire i nomi dei label out = DataFrame ( [] , columns = self . activeuuids , dtype = 'object' ) if cache in ( \"refresh\" ) : self . clean_cache ( times ) if cache in ( \"active\" , \"data\" , \"old\" ) : try : out = db [ self.datatable ][ self.activeuuids,times ] except KeyError as e : pass if not out . empty : cachestop = out . index . max () try : timefrom = max ( isot2ut ( cachestop ), isot2ut ( times . start )) times = slice ( ut2isot ( timefrom ), times . stop , times . step ) except Exception as e : pass try : try : if cache == 'old' or not cangenerate : raise Exception ( 'request for old, skip generation' ) kwargs [ 'cache' ] = cache gen = self . generator . __generate__ ( times = times , timeref = timeref , geometry = geometry , ** kwargs ) gen = gen . replace ( ',' , '.' , regex = True ). astype ( float ) if gen . empty : raise Exception ( \"void\" ) except Exception as e : # print ( \"WARN series GENERATE: \" , e ) # raise e ##DEBUG gen = DataFrame ( [] , columns = self . activeuuids , dtype = 'object' ) try : gen = gen . to_frame () except AttributeError as e : pass #gen . name = self . uuid try : gen = gen . round ( 4 ) except Exception as e : pass try : gen . columns = self . activeuuids except Exception as e : pass gen . index = DatetimeIndex ( gen . index ) out = concat ( [ out,gen ] ). sort_index () out . index . name = \"timestamp\" out = out [ self.activeuuids ] if self . valid_range_min is not None : out = out . mask ( out < self . valid_range_min , nan ) if self . valid_range_max is not None : out = out . mask ( out > self . valid_range_max , nan ) out = out [ out.notna().any(axis=1) ] if cache in ( \"active\" , \"data\" , \"refresh\" ) and cangenerate : for u in gen . columns : db [ self.datatable ][ u ]= out [ u ] except Exception as e : # print ( \"WARN series GLOBAL: \" , e ) # raise e #DEBUG pass if cache in ( \"active\" , \"data\" , \"refresh\" ) and not out . empty and not justnew : lasttotry = str ( out . index [ 0 ] ) times = slice ( firstreqstart , lasttotry , times . step ) kwargs [ 'cache' ] = \"none\" preout = self . data ( times = times , geometry = geometry , group = group , ** kwargs ) try : preout = preout . to_frame () except Exception as e : pass preout . index . name = \"timestamp\" try : preout . columns = self . activeuuids except Exception as e : pass if cangenerate : for u in preout . columns : db [ self.datatable ][ u ]= preout [ u ] if preout . __len__ () : out = concat ( [ preout,out ] ). sort_index () out = out [ ~out.index.duplicated() ] out . index . name = \"timestamp\" if not out . empty : self . attribute_update ( 'last' , ut2isot ( max ( isot2ut ( self . last ), isot2ut ( str ( out . index [ -1 ] ))))) try : out = out . loc [ entertimes ] except Exception as e : pass try : if out . columns . __len__ () < 2 : out = out . iloc [ :,0 ] except Exception as e : pass return out","title":"data"},{"location":"reference/hielen3/series/#datadiagram","text":"def datadiagram ( self , ** kwargs ) View Source def datadiagram ( self , ** kwargs ) : return self . data ( ** kwargs )","title":"datadiagram"},{"location":"reference/hielen3/series/#setup","text":"def setup ( uuid = None , operator = None , modules = None , cache = None , datatable = None , mu = None , datatype = None , operands = None , capability = 'data' , first = None , valid_range = None , view_range = None , thresholds = None , groupmap = None , orient = 'H' ) View Source def setup ( uuid = None , operator = None , modules = None , cache = None , datatable = None , mu = None , datatype = None , operands = None , capability = 'data' , first = None , valid_range = None , view_range = None , thresholds = None , groupmap = None , orient = 'H' ) : def _managed_capabilities_ ( capability ) : return capability in [ 'data','stream','group','datadiagram' ] uuid = uuid or getuuid () try : uuid = uuid . uuid except Exception as e : pass setups = {} \"\"\" #TODO gestire le diverse tipologie di dato if datatype is not None and datatype in ['numeric']: setups['datatable']='geoframe.log' \"\"\" if datatable is None : datatable = 'datacache' try : db [ datatable ] except Exception as e : raise e pass setups [ 'datatable' ] = datatable if modules is not None and isinstance ( modules , dict ) : setups [ 'modules' ]= modules if operator is not None and isinstance ( operator , str ) : setups [ 'operator' ]= operator if cache is not None and isinstance ( cache , str ) : setups [ 'cache' ]= cache if mu is not None and isinstance ( mu , str ) : setups [ 'mu' ] = mu if capability is not None and _managed_capabilities_ ( capability ) : setups [ 'capability' ] = capability # print ( \"Start_time:\" , first ) if first is not None : setups [ 'first' ] = first if orient is not None : setups [ 'orient' ] = orient if valid_range is not None : try : setups [ 'valid_range_min' ]= valid_range [ 0 ] except Exception as e : pass try : setups [ 'valid_range_max' ]= valid_range [ 1 ] except Exception as e : pass if view_range is not None : try : setups [ 'view_range_min' ]= view_range [ 0 ] except Exception as e : pass try : setups [ 'view_range_max' ]= view_range [ 1 ] except Exception as e : pass db [ \"series\" ][ uuid ]= setups #TODO fare il check di coerenza tra operandi e operatore if operands is not None and isinstance ( operands , dict ) : # print ( operands ) table_operands = db [ \"series_operands\" ] for k , w in operands . items () : if not isinstance ( w ,( list , tuple , set , dict )) : w =[ w ] if isinstance ( w ,( list , tuple , set )) : wl = min ( table_operands . values . __len__ (), w . __len__ ()) w = dict ( zip ( table_operands . values [ :wl ] , w [ :wl ] )) try : if isinstance ( w [ 'operand' ] , HSeries ) : w [ 'operand' ]= w [ 'operand' ] . uuid except Exception as e : print ( w , uuid ) #raise ( e ) table_operands [ (uuid,k) ]= w if groupmap is not None : try : if not isinstance ( groupmap ,( list , tuple , set )) : raise Exception ( f \"not a vaild list\" ) for i in range ( 0 , groupmap . __len__ ()) : v = groupmap [ i ] if not isinstance ( v , dict ) : raise Exception ( f \"{v} has not a valid format\" ) el = v . pop ( 'element' ) try : el = HSeries ( el , delayed = False ). uuid except Exception as e : raise e try : v [ 'ordinal' ] except Exception as e : v [ 'ordinal' ] = i try : v [ 'label' ] except Exception as e : v [ 'label' ] = str ( i ) db [ \"series_groups\" ][ (uuid,el) ]= v db [ \"series\" ][ uuid ]= { \"capability\" : 'datadiagram' } except Exception as e : raise Exception ( f \"groupmap CONF for {uuid}: {e}\" ) if thresholds is not None and isinstance ( thresholds , ( list , tuple , set )) : for t in thresholds : db [ \"series_thresholds\" ][ uuid ]= t return HSeries ( uuid )","title":"setup"},{"location":"reference/hielen3/series/#stream","text":"def stream ( self , times = None , timeref = None , cache = None , geometry = None , ** kwargs ) View Source def stream ( self , times = None , timeref = None , cache = None , geometry = None , ** kwargs ): if self . capability != 'stream' : raise ValueError ( f \"{self.uuid} has not 'stream' capability\" ) self . __delayed_load__ () timeref = agoodtime ( timeref ) cache = \"no\" try : try : out = self . generator . __generate__ ( ** kwargs ) gen = Series ([ out [ 'queue' ]], index = [ out [ 'timestamp' ]]) except Exception as e : # print (\"WARN series GENERATE: \",e) # raise e gen = Series ([], dtype = 'object' ) gen . name = 'queue' gen . index = DatetimeIndex ( gen . index ) out = gen [ ~ gen . index . duplicated ()] out . index . name = \"timestamp\" except Exception as e : #raise e pass try : out = out [ out . columns [ 0 ]] except Exception as e : pass return out","title":"stream"},{"location":"reference/hielen3/series/#thvalues","text":"def thvalues ( self , ** kwargs ) View Source @_threadpool def thvalues ( self , ** kwargs ) : return self . __getattr__ ( self . capability )( ** kwargs )","title":"thvalues"},{"location":"reference/hielen3/series_good/","text":"Module hielen3.series_good View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 #!/usr/bin/env python # coding=utf-8 from pandas import DataFrame , Series , concat , DatetimeIndex , Index , MultiIndex from concurrent.futures import ThreadPoolExecutor from functools import wraps from numpy import nan , unique , round , inf , datetime64 , timedelta64 from importlib import import_module from hielen3 import db , conf from hielen3.utils import isot2ut , ut2isot , agoodtime , uuid as getuuid , dataframe2jsonizabledict from uuid import UUID import re import json import traceback def _threadpool ( f ): @wraps ( f ) def wrap ( * args , ** kwargs ): return ThreadPoolExecutor () . submit ( f , * args , ** kwargs ) return wrap class HSeries : def __repr__ ( self ): return self . uuid def __delayed_load__ ( self ): if self . __loaded__ : return try : ser = re . split ( \"\\s*>\\s*\" , self . uuid ) if ser . __len__ () == 2 : try : feat = db [ 'features' ][ ser [ 0 ]] except Exception as e : feats = db [ 'features' ][:] feat = feats [ feats [ 'label' ] == ser [ 0 ] ] fuuid , fname = feat [[ 'uuid' , 'label' ]] . squeeze () self . feature = fname self . uuid = db [ 'features_parameters' ][ fuuid , ser [ 1 ]][ 'series' ] . squeeze () self . parameter = ser [ 1 ] except Exception as e : raise KeyError ( f \"Series { self . uuid } not found.\" ) series_info = db [ \"series\" ][ self . uuid ] series_info = dataframe2jsonizabledict ( series_info ) self . __dict__ . update ( series_info ) self . __dict__ . pop ( 'modules' ) self . __dict__ . pop ( 'operator' ) try : operands = db [ \"series_operands\" ][ self . uuid ][ 'operand' ] . \\ reset_index () . \\ set_index ( 'label' )[ 'operand' ] . \\ to_dict () except Exception as e : operands = {} try : groupmap = db [ 'series_groups' ][ self . uuid ][ 'ordinal' ] . \\ apply ( lambda x : f \"__GROUPMAP__ { str ( x ) . zfill ( 3 ) } __\" ) . \\ reset_index () . \\ set_index ( 'ordinal' )[ 'element' ] . \\ sort_index () . \\ to_dict () self . activeuuids = list ( groupmap . values ()) self . capability = 'datadiagram' series_info [ 'group' ] = self . uuid except Exception as e : groupmap = None self . activeuuids = [ self . uuid ] series_info [ 'operands' ] = operands series_info [ 'groupmap' ] = groupmap self . generator = HSeries . __Generator__ ( ** series_info ) try : self . ingroup = db [ 'series_groups' ][{ \"element\" : self . uuid }][ 'groupseries' ] . to_list () except Exception as e : self . ingroup = None try : t = db [ 'series_thresholds' ][ self . uuid ] t = t [[ 'value' , 'color' ]] . reset_index () . drop ( 'series' , axis = 1 ) . set_index ( 'value' ) . sort_index () #t=t[['value','color']].reset_index().drop('series',axis=1).to_dict(orient='records') self . thresholds = t except Exception as e : self . thresholds = DataFrame ([], columns = [ 'ttype' , 'label' , 'columns' ], index = Index ([], name = 'value' ), dtype = 'object' ) self . __loaded__ = True def __getattr__ ( self , item ): self . __delayed_load__ () return self . __getattribute__ ( item ) def __init__ ( self , uuid , delayed = True , ** kwargs ): if uuid is None : raise ValueError self . uuid = uuid self . feature = None self . param = None self . __loaded__ = False if not delayed : self . __delayed_load__ () def clean_cache ( self , times = None ): to_clean = list ( set ([ self . uuid , * self . activeuuids ])) try : db [ 'datacache' ] . pop ( key = ( to_clean , times )) except KeyError as e : pass try : db [ 'events' ] . pop ( key = ( to_clean , times )) except KeyError as e : pass try : last = str ( db [ 'datacache' ][ to_clean ] . index [ - 1 ]) except Exception as e : last = None self . attribute_update ( 'last' , last ) def setup ( uuid = None , operator = None , modules = None , cache = None , mu = None , datatype = None , operands = None , capability = 'data' , first = None , valid_range = None , view_range = None , thresholds = None , groupmap = None , orient = 'H' ): def _managed_capabilities_ ( capability ): return capability in [ 'data' , 'stream' , 'group' , 'datadiagram' ] uuid = uuid or getuuid () try : uuid = uuid . uuid except Exception as e : pass setups = {} #TODO gestire le diverse tipologie di dato if datatype is not None and datatype in [ 'numeric' ]: setups [ 'datatable' ] = 'geoframe.log' if modules is not None and isinstance ( modules , dict ): setups [ 'modules' ] = modules if operator is not None and isinstance ( operator , str ): setups [ 'operator' ] = operator if cache is not None and isinstance ( cache , str ): setups [ 'cache' ] = cache if mu is not None and isinstance ( mu , str ): setups [ 'mu' ] = mu if capability is not None and _managed_capabilities_ ( capability ): setups [ 'capability' ] = capability # print (\"Start_time:\",first) if first is not None : setups [ 'first' ] = first if orient is not None : setups [ 'orient' ] = orient if valid_range is not None : try : setups [ 'valid_range_min' ] = valid_range [ 0 ] except Exception as e : pass try : setups [ 'valid_range_max' ] = valid_range [ 1 ] except Exception as e : pass if view_range is not None : try : setups [ 'view_range_min' ] = view_range [ 0 ] except Exception as e : pass try : setups [ 'view_range_max' ] = view_range [ 1 ] except Exception as e : pass db [ \"series\" ][ uuid ] = setups #TODO fare il check di coerenza tra operandi e operatore if operands is not None and isinstance ( operands , dict ): # print (operands) table_operands = db [ \"series_operands\" ] for k , w in operands . items (): if not isinstance ( w ,( list , tuple , set , dict )): w = [ w ] if isinstance ( w ,( list , tuple , set )): wl = min ( table_operands . values . __len__ (), w . __len__ ()) w = dict ( zip ( table_operands . values [: wl ], w [: wl ])) try : if isinstance ( w [ 'operand' ], HSeries ): w [ 'operand' ] = w [ 'operand' ] . uuid except Exception as e : print ( w , uuid ) #raise (e) table_operands [( uuid , k )] = w if groupmap is not None : try : if not isinstance ( groupmap ,( list , tuple , set )): raise Exception ( f \"not a vaild list\" ) for i in range ( 0 , groupmap . __len__ ()): v = groupmap [ i ] if not isinstance ( v , dict ): raise Exception ( f \" { v } has not a valid format\" ) el = v . pop ( 'element' ) try : el = HSeries ( el , delayed = False ) . uuid except Exception as e : raise e try : v [ 'ordinal' ] except Exception as e : v [ 'ordinal' ] = i try : v [ 'label' ] except Exception as e : v [ 'label' ] = str ( i ) db [ \"series_groups\" ][( uuid , el )] = v db [ \"series\" ][ uuid ] = { \"capability\" : 'datadiagram' } except Exception as e : raise Exception ( f \"groupmap CONF for { uuid } : { e } \" ) if thresholds is not None and isinstance ( thresholds , ( list , tuple , set )): for t in thresholds : db [ \"series_thresholds\" ][ uuid ] = t return HSeries ( uuid ) def attribute_update ( self , attribute = None , value = None ): if attribute is None : return if attribute == 'thresholds' : if not isinstance ( value ,( list , set , tuple )): value = [ value ] for t in value : db [ \"series_thresholds\" ][ self . uuid ] = t if attribute == 'reference' : pass else : db [ \"series\" ][ self . uuid ] = { attribute : value } if self . __loaded__ : self . __loaded__ = False self . __delayed_load__ () def check ( self , geometry = None , ** kwargs ): try : last_event = db [ 'status' ][{ 'series' : self . uuid }] . iloc [ 0 ] last_event_time = str ( last_event [ 'last_time' ]) except KeyError as e : last_event = None last_event_time = None times = slice ( last_event_time , None , None ) cache = 'active' # BUILDING THE REFERENCE DATAFRAME (aa) aa = self . thresholds if aa . empty : d = DataFrame ( [[ self . uuid , self . last , '#' , '#' , '#' , '#' , '#' , '#' , '#' , 0 ]], columns = [ 'series' , 'timestamp' , 'reading_value' , 'threshold_value' , 'ttype' , 'label' , 'color' , 'end' , 'count' , 'latency' ]) return d . set_index ([ 'series' , 'timestamp' ]) if aa [ 'ttype' ] . iloc [ 0 ] == 'LOWER' : aa = concat ([ aa , DataFrame ([[ None , 'LOWER' , None ]], index = Index ([ - inf ], name = 'value' ), columns = [ 'label' , 'ttype' , 'color' ])]) . sort_index () if aa [ 'ttype' ] . iloc [ - 1 ] == 'UPPER' : aa = concat ([ aa , DataFrame ([[ None , 'UPPER' , None ]], index = Index ([ inf ], name = 'value' ), columns = [ 'label' , 'ttype' , 'color' ])]) . sort_index () aa = aa . reset_index () bb = aa [ 'value' ] . copy () aa . loc [ aa [ 'ttype' ] == 'LOWER' ,[ 'value' , 'label' , 'color' ]] = aa . loc [ aa [ 'ttype' ] == 'LOWER' ,[ 'value' , 'label' , 'color' ]] . shift ( - 1 ) aa . loc [ aa [ 'ttype' ] == 'UPPER' ,[ 'value' , 'label' , 'color' ]] = aa . loc [ aa [ 'ttype' ] == 'UPPER' ,[ 'value' , 'label' , 'color' ]] . shift ( 1 ) aa [ 'limit' ] = bb aa = aa [ aa [ 'value' ] . notna ()] aa . index . name = 'idt' aa = aa . reset_index () # REFEERENCE DATAFRAME DONE # EXTRACTING THE DATA d = self . data ( times = times , cache = cache , geometry = geometry , ** kwargs ) # DATA ESTRACTION DONE try : d = d . to_frame () except Exception as e : pass v = d . columns [ 0 ] # TODO capire neither or both # TODO separare UPPER e LOWER # MATCHING FOR OVERCOMES (each i in aa, thresholds, over d, data) for i in aa . index : d . loc [ d [ v ] . between ( min ( aa . loc [ i , 'value' ], aa . loc [ i , 'limit' ]), max ( aa . loc [ i , 'value' ], aa . loc [ i , 'limit' ]), inclusive = 'neither' ), 'value' ] = aa . loc [ i , 'idt' ] aa = aa . set_index ( 'idt' ) d = d . reset_index () . set_index ( 'value' ) . sort_index () d = d . join ( aa , how = 'left' ) . set_index ( 'timestamp' ) . sort_index ()[[ v , 'value' , 'ttype' , 'label' , 'color' ]] d . columns = [ \"reading_value\" , \"threshold_value\" , \"ttype\" , \"label\" , \"color\" ] d [ 'series' ] = v d = d . reset_index () d = d . replace ( nan , \"#\" ) d [ 'end' ] = d [ 'timestamp' ] . copy () d [ 'timestamp' ] = d [ ~ ( d [ \"label\" ] == d [ \"label\" ] . shift ( 1 )) | ~ ( d [ \"ttype\" ] == d [ \"ttype\" ] . shift ( 1 )) ][ 'end' ] d [ 'timestamp' ] = d [ 'timestamp' ] . ffill () d = d . set_index ( 'timestamp' ) d [ 'count' ] = d [ 'label' ] . groupby ( 'timestamp' ) . count () d = d . reset_index () d = d [ ~ ( d [ \"label\" ] == d [ 'label' ] . shift ( - 1 )) | ~ ( d [ \"ttype\" ] == d [ 'ttype' ] . shift ( - 1 )) ] reftime = datetime64 ( 'now' ) + timedelta64 ( conf [ 'server_time_offset' ], 'h' ) d [ 'latency' ] = ( reftime - d [ 'end' ]) . astype ( 'timedelta64[s]' ) d [ 'timestamp' ] = d [ 'timestamp' ] . astype ( str ) d [ 'end' ] = d [ 'end' ] . astype ( str ) d [ 'latency' ] = d [ 'latency' ] . astype ( int ) if not d . empty and last_event is not None : d . loc [ d . index [ 0 ], 'count' ] = ( d . iloc [ 0 ][ 'count' ] - 1 + last_event [ 'count' ]) . squeeze () d . loc [ d . index [ 0 ], 'timestamp' ] = str ( last_event [ 'start_time' ]) if d . __len__ () > 1 : if last_event [ 'latency' ] is not None : d . loc [ d . index [ 0 ], 'latency' ] = last_event [ 'latency' ] def fillth ( ** kwargs ): db [ \"events\" ][{ 'series' : kwargs [ 'series' ]}] = kwargs d . apply ( lambda x : fillth ( ** x ), axis = 1 ) return d . set_index ([ 'series' , 'timestamp' ]) @_threadpool def thvalues ( self , ** kwargs ): return self . __getattr__ ( self . capability )( ** kwargs ) def datadiagram ( self , ** kwargs ): return self . data ( ** kwargs ) def data ( self , times = None , timeref = None , cache = None , group = None , geometry = None , ** kwargs ): self . __delayed_load__ () entertimes = times if self . capability not in [ 'data' , 'datadiagram' ]: raise ValueError ( f \" { self . uuid } has not 'data' capability\" ) if self . ingroup is None or group in self . ingroup : cangenerate = True else : cangenerate = False timeref = agoodtime ( timeref ) if cache is None : try : cache = self . cache assert cache in ( \"active\" , \"data\" , \"old\" ) except Exception as e : cache = \"no\" if times is None : times = slice ( None , None , None ) justnew = False try : if cache == 'new' : justnew = True timefrom = isot2ut ( self . last ) try : assert self . cache in ( \"active\" , \"data\" , \"old\" ) cache = \"active\" except Exception as e : cache = \"no\" else : tocheck = min ( isot2ut ( self . last ), isot2ut ( times . start )) timefrom = max ( isot2ut ( self . first ), tocheck ) times = slice ( ut2isot ( timefrom ), times . stop , times . step ) except Exception as e : pass firstreqstart = times . start #TODO inserire i nomi dei label out = DataFrame ([], columns = self . activeuuids , dtype = 'object' ) if cache in ( \"refresh\" ): self . clean_cache ( times ) if cache in ( \"active\" , \"data\" , \"old\" ): try : out = db [ \"datacache\" ][ self . activeuuids , times ] except KeyError as e : pass if not out . empty : cachestop = out . index . max () try : timefrom = max ( isot2ut ( cachestop ), isot2ut ( times . start )) times = slice ( ut2isot ( timefrom ), times . stop , times . step ) except Exception as e : pass try : try : if cache == 'old' or not cangenerate : raise Exception ( 'request for old, skip generation' ) kwargs [ 'cache' ] = cache gen = self . generator . __generate__ ( times = times , timeref = timeref , geometry = geometry , ** kwargs ) gen = gen . replace ( ',' , '.' , regex = True ) . astype ( float ) if gen . empty : raise Exception ( \"void\" ) except Exception as e : # print (\"WARN series GENERATE: \", e) # raise e ##DEBUG gen = DataFrame ([], columns = self . activeuuids , dtype = 'object' ) try : gen = gen . to_frame () except AttributeError as e : pass #gen.name=self.uuid try : gen = gen . round ( 4 ) except Exception as e : pass try : gen . columns = self . activeuuids except Exception as e : pass gen . index = DatetimeIndex ( gen . index ) out = concat ([ out , gen ]) . sort_index () out . index . name = \"timestamp\" out = out [ self . activeuuids ] if self . valid_range_min is not None : out = out . mask ( out < self . valid_range_min , nan ) if self . valid_range_max is not None : out = out . mask ( out > self . valid_range_max , nan ) out = out [ out . notna () . any ( axis = 1 )] if cache in ( \"active\" , \"data\" , \"refresh\" ) and cangenerate : for u in gen . columns : db [ \"datacache\" ][ u ] = out [ u ] except Exception as e : # print (\"WARN series GLOBAL: \", e) # raise e #DEBUG pass if cache in ( \"active\" , \"data\" , \"refresh\" ) and not out . empty and not justnew : lasttotry = str ( out . index [ 0 ]) times = slice ( firstreqstart , lasttotry , times . step ) kwargs [ 'cache' ] = \"none\" preout = self . data ( times = times , geometry = geometry , group = group , ** kwargs ) try : preout = preout . to_frame () except Exception as e : pass preout . index . name = \"timestamp\" try : preout . columns = self . activeuuids except Exception as e : pass if cangenerate : for u in preout . columns : db [ \"datacache\" ][ u ] = preout [ u ] if preout . __len__ (): out = concat ([ preout , out ]) . sort_index () out = out [ ~ out . index . duplicated ()] out . index . name = \"timestamp\" if not out . empty : self . attribute_update ( 'last' , ut2isot ( max ( isot2ut ( self . last ), isot2ut ( str ( out . index [ - 1 ]))))) try : out = out . loc [ entertimes ] except Exception as e : pass try : if out . columns . __len__ () < 2 : out = out . iloc [:, 0 ] except Exception as e : pass return out ## WARNING Omesso Map ## WARINIG Omesso Cloud def stream ( self , times = None , timeref = None , cache = None , geometry = None , ** kwargs ): if self . capability != 'stream' : raise ValueError ( f \" { self . uuid } has not 'stream' capability\" ) self . __delayed_load__ () timeref = agoodtime ( timeref ) cache = \"no\" try : try : out = self . generator . __generate__ ( ** kwargs ) gen = Series ([ out [ 'queue' ]], index = [ out [ 'timestamp' ]]) except Exception as e : # print (\"WARN series GENERATE: \",e) # raise e gen = Series ([], dtype = 'object' ) gen . name = 'queue' gen . index = DatetimeIndex ( gen . index ) out = gen [ ~ gen . index . duplicated ()] out . index . name = \"timestamp\" except Exception as e : #raise e pass try : out = out [ out . columns [ 0 ]] except Exception as e : pass return out # return out.to_frame() #TOLGO ORIENT class __Generator__ : def __load_operand__ ( value = None ): #OPERANDS RESOLUTION: try : UUID ( value ) return HSeries ( value ) except Exception as e : pass try : value = value . removeprefix ( '#' ) except Exception as e : pass \"\"\" trying to load json string, if \"value\" is it \"\"\" try : return json . loads ( value ) except Exception as e : pass return value ''' \"\"\" Trying to get values from a dict, if \"out\" is it \"\"\" try: values=out.values() except AttributeError as e: values=out \"\"\" Trying to load suboperands from a list if \"values\" is it \"\"\" try: assert not isinstance(values,str) values=[ __Generator__.__load_operand__(a,orient) for a in values ] except Exception as e: pass \"\"\" Trying zip a dict, if \"out\" is it \"\"\" try: out=dict(zip(out.keys(),values) except AttributeError as e: out = values return out ''' def __init__ ( self , modules = None , operator = None , operands = None , group = None , groupmap = None , ** kwargs ): self . modules = {} self . group = group if operator is None or operator in \"__VOID__\" : operator = \"Series([],dtype='object')\" self . operator = operator if not modules is None : for k , m in modules . items (): self . operator = self . operator . replace ( k , f \"self.modules[ { k !r} ]\" ) self . modules [ k ] = import_module ( m ) self . operands = { k : HSeries . __Generator__ . __load_operand__ ( w ) for k , w in operands . items () } if groupmap is not None : self . groupmap = { k : HSeries . __Generator__ . __load_operand__ ( w ) for k , w in groupmap . items () } else : self . groupmap = None def __generate__ ( self , ** kwargs ): operands = kwargs ''' times=kwargs['times'] try: start=re.sub('\\+.*$','',str(times.start)) except Exception as e: start=None try: stop=re.sub('\\+.*$','',str(times.stop)) except Exception as e: stop = None kwargs.update({\"times\":slice(start,stop,times.step)}) ''' operands . update ( { k : w for k , w in self . operands . items () if not isinstance ( w , HSeries )} ) operands [ 'group' ] = self . group if self . groupmap is not None : groupmap = { k : w . thvalues ( ** kwargs ) for k , w in self . groupmap . items () if isinstance ( w , HSeries ) } groupmap = { k : w . result () for k , w in groupmap . items () } #groupmap = concat(groupmap,axis=1) cols = list ( groupmap . keys ()) groupmap = concat ( groupmap ) . unstack () . T . sort_index () try : groupmap . columns = groupmap . columns . droplevel ( 0 ) except Exception as e : pass for c in cols : if c not in groupmap . columns : groupmap [ c ] = None operands [ '__GROUPMAP__' ] = groupmap runners = { k : w . thvalues ( ** kwargs ) for k , w in self . operands . items () if isinstance ( w , HSeries ) } operands . update ({ k : w . result () for k , w in runners . items ()}) #operands.update( { k:w.data(**kwargs) for k,w in self.operands.items() if isinstance(w,HSeries) } ) ## ATTENZIONE A locals: Implementation Dependant!!!! ### locals () . update ( operands ) # print (operands) #DEBUG # print (self.operator, locals() ) #DEBUG out = eval ( self . operator ) return out Variables conf db inf nan Classes HSeries class HSeries ( uuid , delayed = True , ** kwargs ) View Source class HSeries : def __repr__ ( self ) : return self . uuid def __delayed_load__ ( self ) : if self . __loaded__ : return try : ser = re . split ( \"\\s*>\\s*\" , self . uuid ) if ser . __len__ () == 2 : try : feat = db [ 'features' ][ ser[0 ] ] except Exception as e : feats = db [ 'features' ][ : ] feat = feats [ feats['label' ] == ser [ 0 ] ] fuuid , fname = feat [ ['uuid','label' ] ] . squeeze () self . feature = fname self . uuid = db [ 'features_parameters' ][ fuuid,ser[1 ] ] [ 'series' ] . squeeze () self . parameter = ser [ 1 ] except Exception as e : raise KeyError ( f \"Series {self.uuid} not found.\" ) series_info = db [ \"series\" ][ self.uuid ] series_info = dataframe2jsonizabledict ( series_info ) self . __dict__ . update ( series_info ) self . __dict__ . pop ( 'modules' ) self . __dict__ . pop ( 'operator' ) try : operands = db [ \"series_operands\" ][ self.uuid ][ 'operand' ] . \\ reset_index (). \\ set_index ( 'label' ) [ 'operand' ] . \\ to_dict () except Exception as e : operands = {} try : groupmap = db [ 'series_groups' ][ self.uuid ][ 'ordinal' ] . \\ apply ( lambda x : f \"__GROUPMAP__{str(x).zfill(3)}__\" ). \\ reset_index (). \\ set_index ( 'ordinal' ) [ 'element' ] . \\ sort_index (). \\ to_dict () self . activeuuids = list ( groupmap . values ()) self . capability = 'datadiagram' series_info [ 'group' ] = self . uuid except Exception as e : groupmap = None self . activeuuids =[ self.uuid ] series_info [ 'operands' ]= operands series_info [ 'groupmap' ]= groupmap self . generator = HSeries . __Generator__ ( ** series_info ) try : self . ingroup = db [ 'series_groups' ][ {\"element\":self.uuid} ][ 'groupseries' ] . to_list () except Exception as e : self . ingroup = None try : t = db [ 'series_thresholds' ][ self.uuid ] t = t [ ['value','color' ] ] . reset_index (). drop ( 'series' , axis = 1 ). set_index ( 'value' ). sort_index () #t = t [ ['value','color' ] ] . reset_index (). drop ( 'series' , axis = 1 ). to_dict ( orient = 'records' ) self . thresholds = t except Exception as e : self . thresholds = DataFrame ( [] , columns =[ 'ttype','label','columns' ] , index = Index ( [] , name = 'value' ), dtype = 'object' ) self . __loaded__ = True def __getattr__ ( self , item ) : self . __delayed_load__ () return self . __getattribute__ ( item ) def __init__ ( self , uuid , delayed = True , ** kwargs ) : if uuid is None : raise ValueError self . uuid = uuid self . feature = None self . param = None self . __loaded__ = False if not delayed : self . __delayed_load__ () def clean_cache ( self , times = None ) : to_clean = list ( set ( [ self.uuid,*self.activeuuids ] )) try : db [ 'datacache' ] . pop ( key = ( to_clean , times )) except KeyError as e : pass try : db [ 'events' ] . pop ( key = ( to_clean , times )) except KeyError as e : pass try : last = str ( db [ 'datacache' ][ to_clean ] . index [ -1 ] ) except Exception as e : last = None self . attribute_update ( 'last' , last ) def setup ( uuid = None , operator = None , modules = None , cache = None , mu = None , datatype = None , operands = None , capability = 'data' , first = None , valid_range = None , view_range = None , thresholds = None , groupmap = None , orient = 'H' ) : def _managed_capabilities_ ( capability ) : return capability in [ 'data','stream','group','datadiagram' ] uuid = uuid or getuuid () try : uuid = uuid . uuid except Exception as e : pass setups = {} #TODO gestire le diverse tipologie di dato if datatype is not None and datatype in [ 'numeric' ] : setups [ 'datatable' ]= 'geoframe.log' if modules is not None and isinstance ( modules , dict ) : setups [ 'modules' ]= modules if operator is not None and isinstance ( operator , str ) : setups [ 'operator' ]= operator if cache is not None and isinstance ( cache , str ) : setups [ 'cache' ]= cache if mu is not None and isinstance ( mu , str ) : setups [ 'mu' ] = mu if capability is not None and _managed_capabilities_ ( capability ) : setups [ 'capability' ] = capability # print ( \"Start_time:\" , first ) if first is not None : setups [ 'first' ] = first if orient is not None : setups [ 'orient' ] = orient if valid_range is not None : try : setups [ 'valid_range_min' ]= valid_range [ 0 ] except Exception as e : pass try : setups [ 'valid_range_max' ]= valid_range [ 1 ] except Exception as e : pass if view_range is not None : try : setups [ 'view_range_min' ]= view_range [ 0 ] except Exception as e : pass try : setups [ 'view_range_max' ]= view_range [ 1 ] except Exception as e : pass db [ \"series\" ][ uuid ]= setups #TODO fare il check di coerenza tra operandi e operatore if operands is not None and isinstance ( operands , dict ) : # print ( operands ) table_operands = db [ \"series_operands\" ] for k , w in operands . items () : if not isinstance ( w ,( list , tuple , set , dict )) : w =[ w ] if isinstance ( w ,( list , tuple , set )) : wl = min ( table_operands . values . __len__ (), w . __len__ ()) w = dict ( zip ( table_operands . values [ :wl ] , w [ :wl ] )) try : if isinstance ( w [ 'operand' ] , HSeries ) : w [ 'operand' ]= w [ 'operand' ] . uuid except Exception as e : print ( w , uuid ) #raise ( e ) table_operands [ (uuid,k) ]= w if groupmap is not None : try : if not isinstance ( groupmap ,( list , tuple , set )) : raise Exception ( f \"not a vaild list\" ) for i in range ( 0 , groupmap . __len__ ()) : v = groupmap [ i ] if not isinstance ( v , dict ) : raise Exception ( f \"{v} has not a valid format\" ) el = v . pop ( 'element' ) try : el = HSeries ( el , delayed = False ). uuid except Exception as e : raise e try : v [ 'ordinal' ] except Exception as e : v [ 'ordinal' ] = i try : v [ 'label' ] except Exception as e : v [ 'label' ] = str ( i ) db [ \"series_groups\" ][ (uuid,el) ]= v db [ \"series\" ][ uuid ]= { \"capability\" : 'datadiagram' } except Exception as e : raise Exception ( f \"groupmap CONF for {uuid}: {e}\" ) if thresholds is not None and isinstance ( thresholds , ( list , tuple , set )) : for t in thresholds : db [ \"series_thresholds\" ][ uuid ]= t return HSeries ( uuid ) def attribute_update ( self , attribute = None , value = None ) : if attribute is None : return if attribute == 'thresholds' : if not isinstance ( value ,( list , set , tuple )) : value =[ value ] for t in value : db [ \"series_thresholds\" ][ self.uuid ]= t if attribute == 'reference' : pass else : db [ \"series\" ][ self.uuid ]= { attribute : value } if self . __loaded__ : self . __loaded__ = False self . __delayed_load__ () def check ( self , geometry = None , ** kwargs ) : try : last_event = db [ 'status' ][ {'series':self.uuid} ] . iloc [ 0 ] last_event_time = str ( last_event [ 'last_time' ] ) except KeyError as e : last_event = None last_event_time = None times = slice ( last_event_time , None , None ) cache = 'active' # BUILDING THE REFERENCE DATAFRAME ( aa ) aa = self . thresholds if aa . empty : d = DataFrame ( [ [self.uuid,self.last,'#','#','#','#','#','#','#',0 ] ] , columns =[ 'series','timestamp','reading_value','threshold_value','ttype','label','color','end','count','latency' ] ) return d . set_index ( [ 'series','timestamp' ] ) if aa [ 'ttype' ] . iloc [ 0 ] == 'LOWER' : aa = concat ( [ aa,DataFrame([[None,'LOWER',None ] ] , index = Index ( [ -inf ] , name = 'value' ), columns =[ 'label','ttype','color' ] ) ] ). sort_index () if aa [ 'ttype' ] . iloc [ -1 ] == 'UPPER' : aa = concat ( [ aa,DataFrame([[None,'UPPER',None ] ] , index = Index ( [ inf ] , name = 'value' ), columns =[ 'label','ttype','color' ] ) ] ). sort_index () aa = aa . reset_index () bb = aa [ 'value' ] . copy () aa . loc [ aa['ttype' ]== 'LOWER' , [ 'value','label','color' ] ] = aa . loc [ aa['ttype' ]== 'LOWER' , [ 'value','label','color' ] ] . shift ( - 1 ) aa . loc [ aa['ttype' ]== 'UPPER' , [ 'value','label','color' ] ] = aa . loc [ aa['ttype' ]== 'UPPER' , [ 'value','label','color' ] ] . shift ( 1 ) aa [ 'limit' ]= bb aa = aa [ aa['value' ] . notna () ] aa . index . name = 'idt' aa = aa . reset_index () # REFEERENCE DATAFRAME DONE # EXTRACTING THE DATA d = self . data ( times = times , cache = cache , geometry = geometry , ** kwargs ) # DATA ESTRACTION DONE try : d = d . to_frame () except Exception as e : pass v = d . columns [ 0 ] # TODO capire neither or both # TODO separare UPPER e LOWER # MATCHING FOR OVERCOMES ( each i in aa , thresholds , over d , data ) for i in aa . index : d . loc [ d[v ] . between ( min ( aa . loc [ i,'value' ] , aa . loc [ i,'limit' ] ), max ( aa . loc [ i,'value' ] , aa . loc [ i,'limit' ] ), inclusive = 'neither' ), 'value' ] = aa . loc [ i,'idt' ] aa = aa . set_index ( 'idt' ) d = d . reset_index (). set_index ( 'value' ). sort_index () d = d . join ( aa , how = 'left' ). set_index ( 'timestamp' ). sort_index () [ [v,'value','ttype','label','color' ] ] d . columns =[ \"reading_value\",\"threshold_value\",\"ttype\",\"label\",\"color\" ] d [ 'series' ]= v d = d . reset_index () d = d . replace ( nan , \"#\" ) d [ 'end' ] = d [ 'timestamp' ] . copy () d [ 'timestamp' ]= d [ ~(d[\"label\" ] == d [ \"label\" ] . shift ( 1 )) | ~ ( d [ \"ttype\" ] == d [ \"ttype\" ] . shift ( 1 )) ] [ 'end' ] d [ 'timestamp' ] = d [ 'timestamp' ] . ffill () d = d . set_index ( 'timestamp' ) d [ 'count' ]= d [ 'label' ] . groupby ( 'timestamp' ). count () d = d . reset_index () d = d [ ~(d[\"label\" ] == d [ 'label' ] . shift ( - 1 )) | ~ ( d [ \"ttype\" ] == d [ 'ttype' ] . shift ( - 1 )) ] reftime = datetime64 ( 'now' ) + timedelta64 ( conf [ 'server_time_offset' ] , 'h' ) d [ 'latency' ]= ( reftime - d [ 'end' ] ). astype ( 'timedelta64[s]' ) d [ 'timestamp' ]= d [ 'timestamp' ] . astype ( str ) d [ 'end' ] = d [ 'end' ] . astype ( str ) d [ 'latency' ]= d [ 'latency' ] . astype ( int ) if not d . empty and last_event is not None : d . loc [ d.index[0 ] , 'count' ] = ( d . iloc [ 0 ][ 'count' ] - 1 + last_event [ 'count' ] ). squeeze () d . loc [ d.index[0 ] , 'timestamp' ] = str ( last_event [ 'start_time' ] ) if d . __len__ () > 1 : if last_event [ 'latency' ] is not None : d . loc [ d.index[0 ] , 'latency' ] = last_event [ 'latency' ] def fillth ( ** kwargs ) : db [ \"events\" ][ {'series':kwargs['series' ] }] = kwargs d . apply ( lambda x : fillth ( ** x ), axis = 1 ) return d . set_index ( [ 'series','timestamp' ] ) @_threadpool def thvalues ( self , ** kwargs ) : return self . __getattr__ ( self . capability )( ** kwargs ) def datadiagram ( self , ** kwargs ) : return self . data ( ** kwargs ) def data ( self , times = None , timeref = None , cache = None , group = None , geometry = None , ** kwargs ) : self . __delayed_load__ () entertimes = times if self . capability not in [ 'data','datadiagram' ] : raise ValueError ( f \"{self.uuid} has not 'data' capability\" ) if self . ingroup is None or group in self . ingroup : cangenerate = True else : cangenerate = False timeref = agoodtime ( timeref ) if cache is None : try : cache = self . cache assert cache in ( \"active\" , \"data\" , \"old\" ) except Exception as e : cache = \"no\" if times is None : times = slice ( None , None , None ) justnew = False try : if cache == 'new' : justnew = True timefrom = isot2ut ( self . last ) try : assert self . cache in ( \"active\" , \"data\" , \"old\" ) cache = \"active\" except Exception as e : cache = \"no\" else : tocheck = min ( isot2ut ( self . last ), isot2ut ( times . start )) timefrom = max ( isot2ut ( self . first ), tocheck ) times = slice ( ut2isot ( timefrom ), times . stop , times . step ) except Exception as e : pass firstreqstart = times . start #TODO inserire i nomi dei label out = DataFrame ( [] , columns = self . activeuuids , dtype = 'object' ) if cache in ( \"refresh\" ) : self . clean_cache ( times ) if cache in ( \"active\" , \"data\" , \"old\" ) : try : out = db [ \"datacache\" ][ self.activeuuids,times ] except KeyError as e : pass if not out . empty : cachestop = out . index . max () try : timefrom = max ( isot2ut ( cachestop ), isot2ut ( times . start )) times = slice ( ut2isot ( timefrom ), times . stop , times . step ) except Exception as e : pass try : try : if cache == 'old' or not cangenerate : raise Exception ( 'request for old, skip generation' ) kwargs [ 'cache' ] = cache gen = self . generator . __generate__ ( times = times , timeref = timeref , geometry = geometry , ** kwargs ) gen = gen . replace ( ',' , '.' , regex = True ). astype ( float ) if gen . empty : raise Exception ( \"void\" ) except Exception as e : # print ( \"WARN series GENERATE: \" , e ) # raise e ##DEBUG gen = DataFrame ( [] , columns = self . activeuuids , dtype = 'object' ) try : gen = gen . to_frame () except AttributeError as e : pass #gen . name = self . uuid try : gen = gen . round ( 4 ) except Exception as e : pass try : gen . columns = self . activeuuids except Exception as e : pass gen . index = DatetimeIndex ( gen . index ) out = concat ( [ out,gen ] ). sort_index () out . index . name = \"timestamp\" out = out [ self.activeuuids ] if self . valid_range_min is not None : out = out . mask ( out < self . valid_range_min , nan ) if self . valid_range_max is not None : out = out . mask ( out > self . valid_range_max , nan ) out = out [ out.notna().any(axis=1) ] if cache in ( \"active\" , \"data\" , \"refresh\" ) and cangenerate : for u in gen . columns : db [ \"datacache\" ][ u ]= out [ u ] except Exception as e : # print ( \"WARN series GLOBAL: \" , e ) # raise e #DEBUG pass if cache in ( \"active\" , \"data\" , \"refresh\" ) and not out . empty and not justnew : lasttotry = str ( out . index [ 0 ] ) times = slice ( firstreqstart , lasttotry , times . step ) kwargs [ 'cache' ] = \"none\" preout = self . data ( times = times , geometry = geometry , group = group , ** kwargs ) try : preout = preout . to_frame () except Exception as e : pass preout . index . name = \"timestamp\" try : preout . columns = self . activeuuids except Exception as e : pass if cangenerate : for u in preout . columns : db [ \"datacache\" ][ u ]= preout [ u ] if preout . __len__ () : out = concat ( [ preout,out ] ). sort_index () out = out [ ~out.index.duplicated() ] out . index . name = \"timestamp\" if not out . empty : self . attribute_update ( 'last' , ut2isot ( max ( isot2ut ( self . last ), isot2ut ( str ( out . index [ -1 ] ))))) try : out = out . loc [ entertimes ] except Exception as e : pass try : if out . columns . __len__ () < 2 : out = out . iloc [ :,0 ] except Exception as e : pass return out ## WARNING Omesso Map ## WARINIG Omesso Cloud def stream ( self , times = None , timeref = None , cache = None , geometry = None , ** kwargs ) : if self . capability != 'stream' : raise ValueError ( f \"{self.uuid} has not 'stream' capability\" ) self . __delayed_load__ () timeref = agoodtime ( timeref ) cache = \"no\" try : try : out = self . generator . __generate__ ( ** kwargs ) gen = Series ( [ out['queue' ] ] , index =[ out['timestamp' ] ] ) except Exception as e : # print ( \"WARN series GENERATE: \" , e ) # raise e gen = Series ( [] , dtype = 'object' ) gen . name = 'queue' gen . index = DatetimeIndex ( gen . index ) out = gen [ ~gen.index.duplicated() ] out . index . name = \"timestamp\" except Exception as e : #raise e pass try : out = out [ out.columns[0 ] ] except Exception as e : pass return out # return out . to_frame () #TOLGO ORIENT class __Generator__ : def __load_operand__ ( value = None ) : #OPERANDS RESOLUTION : try : UUID ( value ) return HSeries ( value ) except Exception as e : pass try : value = value . removeprefix ( '#' ) except Exception as e : pass \"\"\" trying to load json string, if \" value \" is it \"\"\" try : return json . loads ( value ) except Exception as e : pass return value ''' \"\"\" Trying to get values from a dict, if \"out\" is it \"\"\" try: values=out.values() except AttributeError as e: values=out \"\"\" Trying to load suboperands from a list if \"values\" is it \"\"\" try: assert not isinstance(values,str) values=[ __Generator__.__load_operand__(a,orient) for a in values ] except Exception as e: pass \"\"\" Trying zip a dict, if \"out\" is it \"\"\" try: out=dict(zip(out.keys(),values) except AttributeError as e: out = values return out ''' def __init__ ( self , modules = None , operator = None , operands = None , group = None , groupmap = None , ** kwargs ) : self . modules = {} self . group = group if operator is None or operator in \"__VOID__\" : operator = \"Series([],dtype='object')\" self . operator = operator if not modules is None : for k , m in modules . items () : self . operator = self . operator . replace ( k , f \"self.modules[{k!r}]\" ) self . modules [ k ] = import_module ( m ) self . operands = { k : HSeries . __Generator__ . __load_operand__ ( w ) for k , w in operands . items () } if groupmap is not None : self . groupmap = { k : HSeries . __Generator__ . __load_operand__ ( w ) for k , w in groupmap . items () } else : self . groupmap = None def __generate__ ( self , ** kwargs ) : operands = kwargs ''' times=kwargs[' times '] try: start=re.sub(' \\ + . * $ ','',str(times.start)) except Exception as e: start=None try: stop=re.sub(' \\ + . * $ ','',str(times.stop)) except Exception as e: stop = None kwargs.update({\"times\":slice(start,stop,times.step)}) ''' operands . update ( { k : w for k , w in self . operands . items () if not isinstance ( w , HSeries ) } ) operands [ 'group' ] = self . group if self . groupmap is not None : groupmap = { k : w . thvalues ( ** kwargs ) for k , w in self . groupmap . items () if isinstance ( w , HSeries ) } groupmap = { k : w . result () for k , w in groupmap . items () } #groupmap = concat ( groupmap , axis = 1 ) cols = list ( groupmap . keys ()) groupmap = concat ( groupmap ). unstack (). T . sort_index () try : groupmap . columns = groupmap . columns . droplevel ( 0 ) except Exception as e : pass for c in cols : if c not in groupmap . columns : groupmap [ c ] = None operands [ '__GROUPMAP__' ] = groupmap runners = { k : w . thvalues ( ** kwargs ) for k , w in self . operands . items () if isinstance ( w , HSeries ) } operands . update ( { k : w . result () for k , w in runners . items () } ) #operands . update ( { k : w . data ( ** kwargs ) for k , w in self . operands . items () if isinstance ( w , HSeries ) } ) ## ATTENZIONE A locals : Implementation Dependant !!!! ### locals (). update ( operands ) # print ( operands ) #DEBUG # print ( self . operator , locals () ) #DEBUG out = eval ( self . operator ) return out Methods attribute_update def attribute_update ( self , attribute = None , value = None ) View Source def attribute_update ( self , attribute = None , value = None ) : if attribute is None : return if attribute == 'thresholds' : if not isinstance ( value ,( list , set , tuple )) : value =[ value ] for t in value : db [ \"series_thresholds\" ][ self.uuid ]= t if attribute == 'reference' : pass else : db [ \"series\" ][ self.uuid ]= { attribute : value } if self . __loaded__ : self . __loaded__ = False self . __delayed_load__ () check def check ( self , geometry = None , ** kwargs ) View Source def check ( self , geometry = None , ** kwargs ) : try : last_event = db [ 'status' ][ {'series':self.uuid} ] . iloc [ 0 ] last_event_time = str ( last_event [ 'last_time' ] ) except KeyError as e : last_event = None last_event_time = None times = slice ( last_event_time , None , None ) cache = 'active' # BUILDING THE REFERENCE DATAFRAME ( aa ) aa = self . thresholds if aa . empty : d = DataFrame ( [ [self.uuid,self.last,'#','#','#','#','#','#','#',0 ] ] , columns =[ 'series','timestamp','reading_value','threshold_value','ttype','label','color','end','count','latency' ] ) return d . set_index ( [ 'series','timestamp' ] ) if aa [ 'ttype' ] . iloc [ 0 ] == 'LOWER' : aa = concat ( [ aa,DataFrame([[None,'LOWER',None ] ] , index = Index ( [ -inf ] , name = 'value' ), columns =[ 'label','ttype','color' ] ) ] ). sort_index () if aa [ 'ttype' ] . iloc [ -1 ] == 'UPPER' : aa = concat ( [ aa,DataFrame([[None,'UPPER',None ] ] , index = Index ( [ inf ] , name = 'value' ), columns =[ 'label','ttype','color' ] ) ] ). sort_index () aa = aa . reset_index () bb = aa [ 'value' ] . copy () aa . loc [ aa['ttype' ]== 'LOWER' , [ 'value','label','color' ] ] = aa . loc [ aa['ttype' ]== 'LOWER' , [ 'value','label','color' ] ] . shift ( - 1 ) aa . loc [ aa['ttype' ]== 'UPPER' , [ 'value','label','color' ] ] = aa . loc [ aa['ttype' ]== 'UPPER' , [ 'value','label','color' ] ] . shift ( 1 ) aa [ 'limit' ]= bb aa = aa [ aa['value' ] . notna () ] aa . index . name = 'idt' aa = aa . reset_index () # REFEERENCE DATAFRAME DONE # EXTRACTING THE DATA d = self . data ( times = times , cache = cache , geometry = geometry , ** kwargs ) # DATA ESTRACTION DONE try : d = d . to_frame () except Exception as e : pass v = d . columns [ 0 ] # TODO capire neither or both # TODO separare UPPER e LOWER # MATCHING FOR OVERCOMES ( each i in aa , thresholds , over d , data ) for i in aa . index : d . loc [ d[v ] . between ( min ( aa . loc [ i,'value' ] , aa . loc [ i,'limit' ] ), max ( aa . loc [ i,'value' ] , aa . loc [ i,'limit' ] ), inclusive = 'neither' ), 'value' ] = aa . loc [ i,'idt' ] aa = aa . set_index ( 'idt' ) d = d . reset_index (). set_index ( 'value' ). sort_index () d = d . join ( aa , how = 'left' ). set_index ( 'timestamp' ). sort_index () [ [v,'value','ttype','label','color' ] ] d . columns =[ \"reading_value\",\"threshold_value\",\"ttype\",\"label\",\"color\" ] d [ 'series' ]= v d = d . reset_index () d = d . replace ( nan , \"#\" ) d [ 'end' ] = d [ 'timestamp' ] . copy () d [ 'timestamp' ]= d [ ~(d[\"label\" ] == d [ \"label\" ] . shift ( 1 )) | ~ ( d [ \"ttype\" ] == d [ \"ttype\" ] . shift ( 1 )) ] [ 'end' ] d [ 'timestamp' ] = d [ 'timestamp' ] . ffill () d = d . set_index ( 'timestamp' ) d [ 'count' ]= d [ 'label' ] . groupby ( 'timestamp' ). count () d = d . reset_index () d = d [ ~(d[\"label\" ] == d [ 'label' ] . shift ( - 1 )) | ~ ( d [ \"ttype\" ] == d [ 'ttype' ] . shift ( - 1 )) ] reftime = datetime64 ( 'now' ) + timedelta64 ( conf [ 'server_time_offset' ] , 'h' ) d [ 'latency' ]= ( reftime - d [ 'end' ] ). astype ( 'timedelta64[s]' ) d [ 'timestamp' ]= d [ 'timestamp' ] . astype ( str ) d [ 'end' ] = d [ 'end' ] . astype ( str ) d [ 'latency' ]= d [ 'latency' ] . astype ( int ) if not d . empty and last_event is not None : d . loc [ d.index[0 ] , 'count' ] = ( d . iloc [ 0 ][ 'count' ] - 1 + last_event [ 'count' ] ). squeeze () d . loc [ d.index[0 ] , 'timestamp' ] = str ( last_event [ 'start_time' ] ) if d . __len__ () > 1 : if last_event [ 'latency' ] is not None : d . loc [ d.index[0 ] , 'latency' ] = last_event [ 'latency' ] def fillth ( ** kwargs ) : db [ \"events\" ][ {'series':kwargs['series' ] }] = kwargs d . apply ( lambda x : fillth ( ** x ), axis = 1 ) return d . set_index ( [ 'series','timestamp' ] ) clean_cache def clean_cache ( self , times = None ) View Source def clean_cache ( self , times = None ) : to_clean = list ( set ( [ self.uuid,*self.activeuuids ] )) try : db [ 'datacache' ] . pop ( key = ( to_clean , times )) except KeyError as e : pass try : db [ 'events' ] . pop ( key = ( to_clean , times )) except KeyError as e : pass try : last = str ( db [ 'datacache' ][ to_clean ] . index [ -1 ] ) except Exception as e : last = None self . attribute_update ( 'last' , last ) data def data ( self , times = None , timeref = None , cache = None , group = None , geometry = None , ** kwargs ) View Source def data ( self , times = None , timeref = None , cache = None , group = None , geometry = None , ** kwargs ) : self . __delayed_load__ () entertimes = times if self . capability not in [ 'data','datadiagram' ] : raise ValueError ( f \"{self.uuid} has not 'data' capability\" ) if self . ingroup is None or group in self . ingroup : cangenerate = True else : cangenerate = False timeref = agoodtime ( timeref ) if cache is None : try : cache = self . cache assert cache in ( \"active\" , \"data\" , \"old\" ) except Exception as e : cache = \"no\" if times is None : times = slice ( None , None , None ) justnew = False try : if cache == 'new' : justnew = True timefrom = isot2ut ( self . last ) try : assert self . cache in ( \"active\" , \"data\" , \"old\" ) cache = \"active\" except Exception as e : cache = \"no\" else : tocheck = min ( isot2ut ( self . last ), isot2ut ( times . start )) timefrom = max ( isot2ut ( self . first ), tocheck ) times = slice ( ut2isot ( timefrom ), times . stop , times . step ) except Exception as e : pass firstreqstart = times . start #TODO inserire i nomi dei label out = DataFrame ( [] , columns = self . activeuuids , dtype = 'object' ) if cache in ( \"refresh\" ) : self . clean_cache ( times ) if cache in ( \"active\" , \"data\" , \"old\" ) : try : out = db [ \"datacache\" ][ self.activeuuids,times ] except KeyError as e : pass if not out . empty : cachestop = out . index . max () try : timefrom = max ( isot2ut ( cachestop ), isot2ut ( times . start )) times = slice ( ut2isot ( timefrom ), times . stop , times . step ) except Exception as e : pass try : try : if cache == 'old' or not cangenerate : raise Exception ( 'request for old, skip generation' ) kwargs [ 'cache' ] = cache gen = self . generator . __generate__ ( times = times , timeref = timeref , geometry = geometry , ** kwargs ) gen = gen . replace ( ',' , '.' , regex = True ). astype ( float ) if gen . empty : raise Exception ( \"void\" ) except Exception as e : # print ( \"WARN series GENERATE: \" , e ) # raise e ##DEBUG gen = DataFrame ( [] , columns = self . activeuuids , dtype = 'object' ) try : gen = gen . to_frame () except AttributeError as e : pass #gen . name = self . uuid try : gen = gen . round ( 4 ) except Exception as e : pass try : gen . columns = self . activeuuids except Exception as e : pass gen . index = DatetimeIndex ( gen . index ) out = concat ( [ out,gen ] ). sort_index () out . index . name = \"timestamp\" out = out [ self.activeuuids ] if self . valid_range_min is not None : out = out . mask ( out < self . valid_range_min , nan ) if self . valid_range_max is not None : out = out . mask ( out > self . valid_range_max , nan ) out = out [ out.notna().any(axis=1) ] if cache in ( \"active\" , \"data\" , \"refresh\" ) and cangenerate : for u in gen . columns : db [ \"datacache\" ][ u ]= out [ u ] except Exception as e : # print ( \"WARN series GLOBAL: \" , e ) # raise e #DEBUG pass if cache in ( \"active\" , \"data\" , \"refresh\" ) and not out . empty and not justnew : lasttotry = str ( out . index [ 0 ] ) times = slice ( firstreqstart , lasttotry , times . step ) kwargs [ 'cache' ] = \"none\" preout = self . data ( times = times , geometry = geometry , group = group , ** kwargs ) try : preout = preout . to_frame () except Exception as e : pass preout . index . name = \"timestamp\" try : preout . columns = self . activeuuids except Exception as e : pass if cangenerate : for u in preout . columns : db [ \"datacache\" ][ u ]= preout [ u ] if preout . __len__ () : out = concat ( [ preout,out ] ). sort_index () out = out [ ~out.index.duplicated() ] out . index . name = \"timestamp\" if not out . empty : self . attribute_update ( 'last' , ut2isot ( max ( isot2ut ( self . last ), isot2ut ( str ( out . index [ -1 ] ))))) try : out = out . loc [ entertimes ] except Exception as e : pass try : if out . columns . __len__ () < 2 : out = out . iloc [ :,0 ] except Exception as e : pass return out datadiagram def datadiagram ( self , ** kwargs ) View Source def datadiagram ( self , ** kwargs ) : return self . data ( ** kwargs ) setup def setup ( uuid = None , operator = None , modules = None , cache = None , mu = None , datatype = None , operands = None , capability = 'data' , first = None , valid_range = None , view_range = None , thresholds = None , groupmap = None , orient = 'H' ) View Source def setup ( uuid = None , operator = None , modules = None , cache = None , mu = None , datatype = None , operands = None , capability = 'data' , first = None , valid_range = None , view_range = None , thresholds = None , groupmap = None , orient = 'H' ) : def _managed_capabilities_ ( capability ) : return capability in [ 'data','stream','group','datadiagram' ] uuid = uuid or getuuid () try : uuid = uuid . uuid except Exception as e : pass setups = {} #TODO gestire le diverse tipologie di dato if datatype is not None and datatype in [ 'numeric' ] : setups [ 'datatable' ]= 'geoframe.log' if modules is not None and isinstance ( modules , dict ) : setups [ 'modules' ]= modules if operator is not None and isinstance ( operator , str ) : setups [ 'operator' ]= operator if cache is not None and isinstance ( cache , str ) : setups [ 'cache' ]= cache if mu is not None and isinstance ( mu , str ) : setups [ 'mu' ] = mu if capability is not None and _managed_capabilities_ ( capability ) : setups [ 'capability' ] = capability # print ( \"Start_time:\" , first ) if first is not None : setups [ 'first' ] = first if orient is not None : setups [ 'orient' ] = orient if valid_range is not None : try : setups [ 'valid_range_min' ]= valid_range [ 0 ] except Exception as e : pass try : setups [ 'valid_range_max' ]= valid_range [ 1 ] except Exception as e : pass if view_range is not None : try : setups [ 'view_range_min' ]= view_range [ 0 ] except Exception as e : pass try : setups [ 'view_range_max' ]= view_range [ 1 ] except Exception as e : pass db [ \"series\" ][ uuid ]= setups #TODO fare il check di coerenza tra operandi e operatore if operands is not None and isinstance ( operands , dict ) : # print ( operands ) table_operands = db [ \"series_operands\" ] for k , w in operands . items () : if not isinstance ( w ,( list , tuple , set , dict )) : w =[ w ] if isinstance ( w ,( list , tuple , set )) : wl = min ( table_operands . values . __len__ (), w . __len__ ()) w = dict ( zip ( table_operands . values [ :wl ] , w [ :wl ] )) try : if isinstance ( w [ 'operand' ] , HSeries ) : w [ 'operand' ]= w [ 'operand' ] . uuid except Exception as e : print ( w , uuid ) #raise ( e ) table_operands [ (uuid,k) ]= w if groupmap is not None : try : if not isinstance ( groupmap ,( list , tuple , set )) : raise Exception ( f \"not a vaild list\" ) for i in range ( 0 , groupmap . __len__ ()) : v = groupmap [ i ] if not isinstance ( v , dict ) : raise Exception ( f \"{v} has not a valid format\" ) el = v . pop ( 'element' ) try : el = HSeries ( el , delayed = False ). uuid except Exception as e : raise e try : v [ 'ordinal' ] except Exception as e : v [ 'ordinal' ] = i try : v [ 'label' ] except Exception as e : v [ 'label' ] = str ( i ) db [ \"series_groups\" ][ (uuid,el) ]= v db [ \"series\" ][ uuid ]= { \"capability\" : 'datadiagram' } except Exception as e : raise Exception ( f \"groupmap CONF for {uuid}: {e}\" ) if thresholds is not None and isinstance ( thresholds , ( list , tuple , set )) : for t in thresholds : db [ \"series_thresholds\" ][ uuid ]= t return HSeries ( uuid ) stream def stream ( self , times = None , timeref = None , cache = None , geometry = None , ** kwargs ) View Source def stream ( self , times = None , timeref = None , cache = None , geometry = None , ** kwargs ): if self . capability != 'stream' : raise ValueError ( f \"{self.uuid} has not 'stream' capability\" ) self . __delayed_load__ () timeref = agoodtime ( timeref ) cache = \"no\" try : try : out = self . generator . __generate__ ( ** kwargs ) gen = Series ([ out [ 'queue' ]], index = [ out [ 'timestamp' ]]) except Exception as e : # print (\"WARN series GENERATE: \",e) # raise e gen = Series ([], dtype = 'object' ) gen . name = 'queue' gen . index = DatetimeIndex ( gen . index ) out = gen [ ~ gen . index . duplicated ()] out . index . name = \"timestamp\" except Exception as e : #raise e pass try : out = out [ out . columns [ 0 ]] except Exception as e : pass return out thvalues def thvalues ( self , ** kwargs ) View Source @_threadpool def thvalues ( self , ** kwargs ) : return self . __getattr__ ( self . capability )( ** kwargs )","title":"Series Good"},{"location":"reference/hielen3/series_good/#module-hielen3series_good","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 #!/usr/bin/env python # coding=utf-8 from pandas import DataFrame , Series , concat , DatetimeIndex , Index , MultiIndex from concurrent.futures import ThreadPoolExecutor from functools import wraps from numpy import nan , unique , round , inf , datetime64 , timedelta64 from importlib import import_module from hielen3 import db , conf from hielen3.utils import isot2ut , ut2isot , agoodtime , uuid as getuuid , dataframe2jsonizabledict from uuid import UUID import re import json import traceback def _threadpool ( f ): @wraps ( f ) def wrap ( * args , ** kwargs ): return ThreadPoolExecutor () . submit ( f , * args , ** kwargs ) return wrap class HSeries : def __repr__ ( self ): return self . uuid def __delayed_load__ ( self ): if self . __loaded__ : return try : ser = re . split ( \"\\s*>\\s*\" , self . uuid ) if ser . __len__ () == 2 : try : feat = db [ 'features' ][ ser [ 0 ]] except Exception as e : feats = db [ 'features' ][:] feat = feats [ feats [ 'label' ] == ser [ 0 ] ] fuuid , fname = feat [[ 'uuid' , 'label' ]] . squeeze () self . feature = fname self . uuid = db [ 'features_parameters' ][ fuuid , ser [ 1 ]][ 'series' ] . squeeze () self . parameter = ser [ 1 ] except Exception as e : raise KeyError ( f \"Series { self . uuid } not found.\" ) series_info = db [ \"series\" ][ self . uuid ] series_info = dataframe2jsonizabledict ( series_info ) self . __dict__ . update ( series_info ) self . __dict__ . pop ( 'modules' ) self . __dict__ . pop ( 'operator' ) try : operands = db [ \"series_operands\" ][ self . uuid ][ 'operand' ] . \\ reset_index () . \\ set_index ( 'label' )[ 'operand' ] . \\ to_dict () except Exception as e : operands = {} try : groupmap = db [ 'series_groups' ][ self . uuid ][ 'ordinal' ] . \\ apply ( lambda x : f \"__GROUPMAP__ { str ( x ) . zfill ( 3 ) } __\" ) . \\ reset_index () . \\ set_index ( 'ordinal' )[ 'element' ] . \\ sort_index () . \\ to_dict () self . activeuuids = list ( groupmap . values ()) self . capability = 'datadiagram' series_info [ 'group' ] = self . uuid except Exception as e : groupmap = None self . activeuuids = [ self . uuid ] series_info [ 'operands' ] = operands series_info [ 'groupmap' ] = groupmap self . generator = HSeries . __Generator__ ( ** series_info ) try : self . ingroup = db [ 'series_groups' ][{ \"element\" : self . uuid }][ 'groupseries' ] . to_list () except Exception as e : self . ingroup = None try : t = db [ 'series_thresholds' ][ self . uuid ] t = t [[ 'value' , 'color' ]] . reset_index () . drop ( 'series' , axis = 1 ) . set_index ( 'value' ) . sort_index () #t=t[['value','color']].reset_index().drop('series',axis=1).to_dict(orient='records') self . thresholds = t except Exception as e : self . thresholds = DataFrame ([], columns = [ 'ttype' , 'label' , 'columns' ], index = Index ([], name = 'value' ), dtype = 'object' ) self . __loaded__ = True def __getattr__ ( self , item ): self . __delayed_load__ () return self . __getattribute__ ( item ) def __init__ ( self , uuid , delayed = True , ** kwargs ): if uuid is None : raise ValueError self . uuid = uuid self . feature = None self . param = None self . __loaded__ = False if not delayed : self . __delayed_load__ () def clean_cache ( self , times = None ): to_clean = list ( set ([ self . uuid , * self . activeuuids ])) try : db [ 'datacache' ] . pop ( key = ( to_clean , times )) except KeyError as e : pass try : db [ 'events' ] . pop ( key = ( to_clean , times )) except KeyError as e : pass try : last = str ( db [ 'datacache' ][ to_clean ] . index [ - 1 ]) except Exception as e : last = None self . attribute_update ( 'last' , last ) def setup ( uuid = None , operator = None , modules = None , cache = None , mu = None , datatype = None , operands = None , capability = 'data' , first = None , valid_range = None , view_range = None , thresholds = None , groupmap = None , orient = 'H' ): def _managed_capabilities_ ( capability ): return capability in [ 'data' , 'stream' , 'group' , 'datadiagram' ] uuid = uuid or getuuid () try : uuid = uuid . uuid except Exception as e : pass setups = {} #TODO gestire le diverse tipologie di dato if datatype is not None and datatype in [ 'numeric' ]: setups [ 'datatable' ] = 'geoframe.log' if modules is not None and isinstance ( modules , dict ): setups [ 'modules' ] = modules if operator is not None and isinstance ( operator , str ): setups [ 'operator' ] = operator if cache is not None and isinstance ( cache , str ): setups [ 'cache' ] = cache if mu is not None and isinstance ( mu , str ): setups [ 'mu' ] = mu if capability is not None and _managed_capabilities_ ( capability ): setups [ 'capability' ] = capability # print (\"Start_time:\",first) if first is not None : setups [ 'first' ] = first if orient is not None : setups [ 'orient' ] = orient if valid_range is not None : try : setups [ 'valid_range_min' ] = valid_range [ 0 ] except Exception as e : pass try : setups [ 'valid_range_max' ] = valid_range [ 1 ] except Exception as e : pass if view_range is not None : try : setups [ 'view_range_min' ] = view_range [ 0 ] except Exception as e : pass try : setups [ 'view_range_max' ] = view_range [ 1 ] except Exception as e : pass db [ \"series\" ][ uuid ] = setups #TODO fare il check di coerenza tra operandi e operatore if operands is not None and isinstance ( operands , dict ): # print (operands) table_operands = db [ \"series_operands\" ] for k , w in operands . items (): if not isinstance ( w ,( list , tuple , set , dict )): w = [ w ] if isinstance ( w ,( list , tuple , set )): wl = min ( table_operands . values . __len__ (), w . __len__ ()) w = dict ( zip ( table_operands . values [: wl ], w [: wl ])) try : if isinstance ( w [ 'operand' ], HSeries ): w [ 'operand' ] = w [ 'operand' ] . uuid except Exception as e : print ( w , uuid ) #raise (e) table_operands [( uuid , k )] = w if groupmap is not None : try : if not isinstance ( groupmap ,( list , tuple , set )): raise Exception ( f \"not a vaild list\" ) for i in range ( 0 , groupmap . __len__ ()): v = groupmap [ i ] if not isinstance ( v , dict ): raise Exception ( f \" { v } has not a valid format\" ) el = v . pop ( 'element' ) try : el = HSeries ( el , delayed = False ) . uuid except Exception as e : raise e try : v [ 'ordinal' ] except Exception as e : v [ 'ordinal' ] = i try : v [ 'label' ] except Exception as e : v [ 'label' ] = str ( i ) db [ \"series_groups\" ][( uuid , el )] = v db [ \"series\" ][ uuid ] = { \"capability\" : 'datadiagram' } except Exception as e : raise Exception ( f \"groupmap CONF for { uuid } : { e } \" ) if thresholds is not None and isinstance ( thresholds , ( list , tuple , set )): for t in thresholds : db [ \"series_thresholds\" ][ uuid ] = t return HSeries ( uuid ) def attribute_update ( self , attribute = None , value = None ): if attribute is None : return if attribute == 'thresholds' : if not isinstance ( value ,( list , set , tuple )): value = [ value ] for t in value : db [ \"series_thresholds\" ][ self . uuid ] = t if attribute == 'reference' : pass else : db [ \"series\" ][ self . uuid ] = { attribute : value } if self . __loaded__ : self . __loaded__ = False self . __delayed_load__ () def check ( self , geometry = None , ** kwargs ): try : last_event = db [ 'status' ][{ 'series' : self . uuid }] . iloc [ 0 ] last_event_time = str ( last_event [ 'last_time' ]) except KeyError as e : last_event = None last_event_time = None times = slice ( last_event_time , None , None ) cache = 'active' # BUILDING THE REFERENCE DATAFRAME (aa) aa = self . thresholds if aa . empty : d = DataFrame ( [[ self . uuid , self . last , '#' , '#' , '#' , '#' , '#' , '#' , '#' , 0 ]], columns = [ 'series' , 'timestamp' , 'reading_value' , 'threshold_value' , 'ttype' , 'label' , 'color' , 'end' , 'count' , 'latency' ]) return d . set_index ([ 'series' , 'timestamp' ]) if aa [ 'ttype' ] . iloc [ 0 ] == 'LOWER' : aa = concat ([ aa , DataFrame ([[ None , 'LOWER' , None ]], index = Index ([ - inf ], name = 'value' ), columns = [ 'label' , 'ttype' , 'color' ])]) . sort_index () if aa [ 'ttype' ] . iloc [ - 1 ] == 'UPPER' : aa = concat ([ aa , DataFrame ([[ None , 'UPPER' , None ]], index = Index ([ inf ], name = 'value' ), columns = [ 'label' , 'ttype' , 'color' ])]) . sort_index () aa = aa . reset_index () bb = aa [ 'value' ] . copy () aa . loc [ aa [ 'ttype' ] == 'LOWER' ,[ 'value' , 'label' , 'color' ]] = aa . loc [ aa [ 'ttype' ] == 'LOWER' ,[ 'value' , 'label' , 'color' ]] . shift ( - 1 ) aa . loc [ aa [ 'ttype' ] == 'UPPER' ,[ 'value' , 'label' , 'color' ]] = aa . loc [ aa [ 'ttype' ] == 'UPPER' ,[ 'value' , 'label' , 'color' ]] . shift ( 1 ) aa [ 'limit' ] = bb aa = aa [ aa [ 'value' ] . notna ()] aa . index . name = 'idt' aa = aa . reset_index () # REFEERENCE DATAFRAME DONE # EXTRACTING THE DATA d = self . data ( times = times , cache = cache , geometry = geometry , ** kwargs ) # DATA ESTRACTION DONE try : d = d . to_frame () except Exception as e : pass v = d . columns [ 0 ] # TODO capire neither or both # TODO separare UPPER e LOWER # MATCHING FOR OVERCOMES (each i in aa, thresholds, over d, data) for i in aa . index : d . loc [ d [ v ] . between ( min ( aa . loc [ i , 'value' ], aa . loc [ i , 'limit' ]), max ( aa . loc [ i , 'value' ], aa . loc [ i , 'limit' ]), inclusive = 'neither' ), 'value' ] = aa . loc [ i , 'idt' ] aa = aa . set_index ( 'idt' ) d = d . reset_index () . set_index ( 'value' ) . sort_index () d = d . join ( aa , how = 'left' ) . set_index ( 'timestamp' ) . sort_index ()[[ v , 'value' , 'ttype' , 'label' , 'color' ]] d . columns = [ \"reading_value\" , \"threshold_value\" , \"ttype\" , \"label\" , \"color\" ] d [ 'series' ] = v d = d . reset_index () d = d . replace ( nan , \"#\" ) d [ 'end' ] = d [ 'timestamp' ] . copy () d [ 'timestamp' ] = d [ ~ ( d [ \"label\" ] == d [ \"label\" ] . shift ( 1 )) | ~ ( d [ \"ttype\" ] == d [ \"ttype\" ] . shift ( 1 )) ][ 'end' ] d [ 'timestamp' ] = d [ 'timestamp' ] . ffill () d = d . set_index ( 'timestamp' ) d [ 'count' ] = d [ 'label' ] . groupby ( 'timestamp' ) . count () d = d . reset_index () d = d [ ~ ( d [ \"label\" ] == d [ 'label' ] . shift ( - 1 )) | ~ ( d [ \"ttype\" ] == d [ 'ttype' ] . shift ( - 1 )) ] reftime = datetime64 ( 'now' ) + timedelta64 ( conf [ 'server_time_offset' ], 'h' ) d [ 'latency' ] = ( reftime - d [ 'end' ]) . astype ( 'timedelta64[s]' ) d [ 'timestamp' ] = d [ 'timestamp' ] . astype ( str ) d [ 'end' ] = d [ 'end' ] . astype ( str ) d [ 'latency' ] = d [ 'latency' ] . astype ( int ) if not d . empty and last_event is not None : d . loc [ d . index [ 0 ], 'count' ] = ( d . iloc [ 0 ][ 'count' ] - 1 + last_event [ 'count' ]) . squeeze () d . loc [ d . index [ 0 ], 'timestamp' ] = str ( last_event [ 'start_time' ]) if d . __len__ () > 1 : if last_event [ 'latency' ] is not None : d . loc [ d . index [ 0 ], 'latency' ] = last_event [ 'latency' ] def fillth ( ** kwargs ): db [ \"events\" ][{ 'series' : kwargs [ 'series' ]}] = kwargs d . apply ( lambda x : fillth ( ** x ), axis = 1 ) return d . set_index ([ 'series' , 'timestamp' ]) @_threadpool def thvalues ( self , ** kwargs ): return self . __getattr__ ( self . capability )( ** kwargs ) def datadiagram ( self , ** kwargs ): return self . data ( ** kwargs ) def data ( self , times = None , timeref = None , cache = None , group = None , geometry = None , ** kwargs ): self . __delayed_load__ () entertimes = times if self . capability not in [ 'data' , 'datadiagram' ]: raise ValueError ( f \" { self . uuid } has not 'data' capability\" ) if self . ingroup is None or group in self . ingroup : cangenerate = True else : cangenerate = False timeref = agoodtime ( timeref ) if cache is None : try : cache = self . cache assert cache in ( \"active\" , \"data\" , \"old\" ) except Exception as e : cache = \"no\" if times is None : times = slice ( None , None , None ) justnew = False try : if cache == 'new' : justnew = True timefrom = isot2ut ( self . last ) try : assert self . cache in ( \"active\" , \"data\" , \"old\" ) cache = \"active\" except Exception as e : cache = \"no\" else : tocheck = min ( isot2ut ( self . last ), isot2ut ( times . start )) timefrom = max ( isot2ut ( self . first ), tocheck ) times = slice ( ut2isot ( timefrom ), times . stop , times . step ) except Exception as e : pass firstreqstart = times . start #TODO inserire i nomi dei label out = DataFrame ([], columns = self . activeuuids , dtype = 'object' ) if cache in ( \"refresh\" ): self . clean_cache ( times ) if cache in ( \"active\" , \"data\" , \"old\" ): try : out = db [ \"datacache\" ][ self . activeuuids , times ] except KeyError as e : pass if not out . empty : cachestop = out . index . max () try : timefrom = max ( isot2ut ( cachestop ), isot2ut ( times . start )) times = slice ( ut2isot ( timefrom ), times . stop , times . step ) except Exception as e : pass try : try : if cache == 'old' or not cangenerate : raise Exception ( 'request for old, skip generation' ) kwargs [ 'cache' ] = cache gen = self . generator . __generate__ ( times = times , timeref = timeref , geometry = geometry , ** kwargs ) gen = gen . replace ( ',' , '.' , regex = True ) . astype ( float ) if gen . empty : raise Exception ( \"void\" ) except Exception as e : # print (\"WARN series GENERATE: \", e) # raise e ##DEBUG gen = DataFrame ([], columns = self . activeuuids , dtype = 'object' ) try : gen = gen . to_frame () except AttributeError as e : pass #gen.name=self.uuid try : gen = gen . round ( 4 ) except Exception as e : pass try : gen . columns = self . activeuuids except Exception as e : pass gen . index = DatetimeIndex ( gen . index ) out = concat ([ out , gen ]) . sort_index () out . index . name = \"timestamp\" out = out [ self . activeuuids ] if self . valid_range_min is not None : out = out . mask ( out < self . valid_range_min , nan ) if self . valid_range_max is not None : out = out . mask ( out > self . valid_range_max , nan ) out = out [ out . notna () . any ( axis = 1 )] if cache in ( \"active\" , \"data\" , \"refresh\" ) and cangenerate : for u in gen . columns : db [ \"datacache\" ][ u ] = out [ u ] except Exception as e : # print (\"WARN series GLOBAL: \", e) # raise e #DEBUG pass if cache in ( \"active\" , \"data\" , \"refresh\" ) and not out . empty and not justnew : lasttotry = str ( out . index [ 0 ]) times = slice ( firstreqstart , lasttotry , times . step ) kwargs [ 'cache' ] = \"none\" preout = self . data ( times = times , geometry = geometry , group = group , ** kwargs ) try : preout = preout . to_frame () except Exception as e : pass preout . index . name = \"timestamp\" try : preout . columns = self . activeuuids except Exception as e : pass if cangenerate : for u in preout . columns : db [ \"datacache\" ][ u ] = preout [ u ] if preout . __len__ (): out = concat ([ preout , out ]) . sort_index () out = out [ ~ out . index . duplicated ()] out . index . name = \"timestamp\" if not out . empty : self . attribute_update ( 'last' , ut2isot ( max ( isot2ut ( self . last ), isot2ut ( str ( out . index [ - 1 ]))))) try : out = out . loc [ entertimes ] except Exception as e : pass try : if out . columns . __len__ () < 2 : out = out . iloc [:, 0 ] except Exception as e : pass return out ## WARNING Omesso Map ## WARINIG Omesso Cloud def stream ( self , times = None , timeref = None , cache = None , geometry = None , ** kwargs ): if self . capability != 'stream' : raise ValueError ( f \" { self . uuid } has not 'stream' capability\" ) self . __delayed_load__ () timeref = agoodtime ( timeref ) cache = \"no\" try : try : out = self . generator . __generate__ ( ** kwargs ) gen = Series ([ out [ 'queue' ]], index = [ out [ 'timestamp' ]]) except Exception as e : # print (\"WARN series GENERATE: \",e) # raise e gen = Series ([], dtype = 'object' ) gen . name = 'queue' gen . index = DatetimeIndex ( gen . index ) out = gen [ ~ gen . index . duplicated ()] out . index . name = \"timestamp\" except Exception as e : #raise e pass try : out = out [ out . columns [ 0 ]] except Exception as e : pass return out # return out.to_frame() #TOLGO ORIENT class __Generator__ : def __load_operand__ ( value = None ): #OPERANDS RESOLUTION: try : UUID ( value ) return HSeries ( value ) except Exception as e : pass try : value = value . removeprefix ( '#' ) except Exception as e : pass \"\"\" trying to load json string, if \"value\" is it \"\"\" try : return json . loads ( value ) except Exception as e : pass return value ''' \"\"\" Trying to get values from a dict, if \"out\" is it \"\"\" try: values=out.values() except AttributeError as e: values=out \"\"\" Trying to load suboperands from a list if \"values\" is it \"\"\" try: assert not isinstance(values,str) values=[ __Generator__.__load_operand__(a,orient) for a in values ] except Exception as e: pass \"\"\" Trying zip a dict, if \"out\" is it \"\"\" try: out=dict(zip(out.keys(),values) except AttributeError as e: out = values return out ''' def __init__ ( self , modules = None , operator = None , operands = None , group = None , groupmap = None , ** kwargs ): self . modules = {} self . group = group if operator is None or operator in \"__VOID__\" : operator = \"Series([],dtype='object')\" self . operator = operator if not modules is None : for k , m in modules . items (): self . operator = self . operator . replace ( k , f \"self.modules[ { k !r} ]\" ) self . modules [ k ] = import_module ( m ) self . operands = { k : HSeries . __Generator__ . __load_operand__ ( w ) for k , w in operands . items () } if groupmap is not None : self . groupmap = { k : HSeries . __Generator__ . __load_operand__ ( w ) for k , w in groupmap . items () } else : self . groupmap = None def __generate__ ( self , ** kwargs ): operands = kwargs ''' times=kwargs['times'] try: start=re.sub('\\+.*$','',str(times.start)) except Exception as e: start=None try: stop=re.sub('\\+.*$','',str(times.stop)) except Exception as e: stop = None kwargs.update({\"times\":slice(start,stop,times.step)}) ''' operands . update ( { k : w for k , w in self . operands . items () if not isinstance ( w , HSeries )} ) operands [ 'group' ] = self . group if self . groupmap is not None : groupmap = { k : w . thvalues ( ** kwargs ) for k , w in self . groupmap . items () if isinstance ( w , HSeries ) } groupmap = { k : w . result () for k , w in groupmap . items () } #groupmap = concat(groupmap,axis=1) cols = list ( groupmap . keys ()) groupmap = concat ( groupmap ) . unstack () . T . sort_index () try : groupmap . columns = groupmap . columns . droplevel ( 0 ) except Exception as e : pass for c in cols : if c not in groupmap . columns : groupmap [ c ] = None operands [ '__GROUPMAP__' ] = groupmap runners = { k : w . thvalues ( ** kwargs ) for k , w in self . operands . items () if isinstance ( w , HSeries ) } operands . update ({ k : w . result () for k , w in runners . items ()}) #operands.update( { k:w.data(**kwargs) for k,w in self.operands.items() if isinstance(w,HSeries) } ) ## ATTENZIONE A locals: Implementation Dependant!!!! ### locals () . update ( operands ) # print (operands) #DEBUG # print (self.operator, locals() ) #DEBUG out = eval ( self . operator ) return out","title":"Module hielen3.series_good"},{"location":"reference/hielen3/series_good/#variables","text":"conf db inf nan","title":"Variables"},{"location":"reference/hielen3/series_good/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/series_good/#hseries","text":"class HSeries ( uuid , delayed = True , ** kwargs ) View Source class HSeries : def __repr__ ( self ) : return self . uuid def __delayed_load__ ( self ) : if self . __loaded__ : return try : ser = re . split ( \"\\s*>\\s*\" , self . uuid ) if ser . __len__ () == 2 : try : feat = db [ 'features' ][ ser[0 ] ] except Exception as e : feats = db [ 'features' ][ : ] feat = feats [ feats['label' ] == ser [ 0 ] ] fuuid , fname = feat [ ['uuid','label' ] ] . squeeze () self . feature = fname self . uuid = db [ 'features_parameters' ][ fuuid,ser[1 ] ] [ 'series' ] . squeeze () self . parameter = ser [ 1 ] except Exception as e : raise KeyError ( f \"Series {self.uuid} not found.\" ) series_info = db [ \"series\" ][ self.uuid ] series_info = dataframe2jsonizabledict ( series_info ) self . __dict__ . update ( series_info ) self . __dict__ . pop ( 'modules' ) self . __dict__ . pop ( 'operator' ) try : operands = db [ \"series_operands\" ][ self.uuid ][ 'operand' ] . \\ reset_index (). \\ set_index ( 'label' ) [ 'operand' ] . \\ to_dict () except Exception as e : operands = {} try : groupmap = db [ 'series_groups' ][ self.uuid ][ 'ordinal' ] . \\ apply ( lambda x : f \"__GROUPMAP__{str(x).zfill(3)}__\" ). \\ reset_index (). \\ set_index ( 'ordinal' ) [ 'element' ] . \\ sort_index (). \\ to_dict () self . activeuuids = list ( groupmap . values ()) self . capability = 'datadiagram' series_info [ 'group' ] = self . uuid except Exception as e : groupmap = None self . activeuuids =[ self.uuid ] series_info [ 'operands' ]= operands series_info [ 'groupmap' ]= groupmap self . generator = HSeries . __Generator__ ( ** series_info ) try : self . ingroup = db [ 'series_groups' ][ {\"element\":self.uuid} ][ 'groupseries' ] . to_list () except Exception as e : self . ingroup = None try : t = db [ 'series_thresholds' ][ self.uuid ] t = t [ ['value','color' ] ] . reset_index (). drop ( 'series' , axis = 1 ). set_index ( 'value' ). sort_index () #t = t [ ['value','color' ] ] . reset_index (). drop ( 'series' , axis = 1 ). to_dict ( orient = 'records' ) self . thresholds = t except Exception as e : self . thresholds = DataFrame ( [] , columns =[ 'ttype','label','columns' ] , index = Index ( [] , name = 'value' ), dtype = 'object' ) self . __loaded__ = True def __getattr__ ( self , item ) : self . __delayed_load__ () return self . __getattribute__ ( item ) def __init__ ( self , uuid , delayed = True , ** kwargs ) : if uuid is None : raise ValueError self . uuid = uuid self . feature = None self . param = None self . __loaded__ = False if not delayed : self . __delayed_load__ () def clean_cache ( self , times = None ) : to_clean = list ( set ( [ self.uuid,*self.activeuuids ] )) try : db [ 'datacache' ] . pop ( key = ( to_clean , times )) except KeyError as e : pass try : db [ 'events' ] . pop ( key = ( to_clean , times )) except KeyError as e : pass try : last = str ( db [ 'datacache' ][ to_clean ] . index [ -1 ] ) except Exception as e : last = None self . attribute_update ( 'last' , last ) def setup ( uuid = None , operator = None , modules = None , cache = None , mu = None , datatype = None , operands = None , capability = 'data' , first = None , valid_range = None , view_range = None , thresholds = None , groupmap = None , orient = 'H' ) : def _managed_capabilities_ ( capability ) : return capability in [ 'data','stream','group','datadiagram' ] uuid = uuid or getuuid () try : uuid = uuid . uuid except Exception as e : pass setups = {} #TODO gestire le diverse tipologie di dato if datatype is not None and datatype in [ 'numeric' ] : setups [ 'datatable' ]= 'geoframe.log' if modules is not None and isinstance ( modules , dict ) : setups [ 'modules' ]= modules if operator is not None and isinstance ( operator , str ) : setups [ 'operator' ]= operator if cache is not None and isinstance ( cache , str ) : setups [ 'cache' ]= cache if mu is not None and isinstance ( mu , str ) : setups [ 'mu' ] = mu if capability is not None and _managed_capabilities_ ( capability ) : setups [ 'capability' ] = capability # print ( \"Start_time:\" , first ) if first is not None : setups [ 'first' ] = first if orient is not None : setups [ 'orient' ] = orient if valid_range is not None : try : setups [ 'valid_range_min' ]= valid_range [ 0 ] except Exception as e : pass try : setups [ 'valid_range_max' ]= valid_range [ 1 ] except Exception as e : pass if view_range is not None : try : setups [ 'view_range_min' ]= view_range [ 0 ] except Exception as e : pass try : setups [ 'view_range_max' ]= view_range [ 1 ] except Exception as e : pass db [ \"series\" ][ uuid ]= setups #TODO fare il check di coerenza tra operandi e operatore if operands is not None and isinstance ( operands , dict ) : # print ( operands ) table_operands = db [ \"series_operands\" ] for k , w in operands . items () : if not isinstance ( w ,( list , tuple , set , dict )) : w =[ w ] if isinstance ( w ,( list , tuple , set )) : wl = min ( table_operands . values . __len__ (), w . __len__ ()) w = dict ( zip ( table_operands . values [ :wl ] , w [ :wl ] )) try : if isinstance ( w [ 'operand' ] , HSeries ) : w [ 'operand' ]= w [ 'operand' ] . uuid except Exception as e : print ( w , uuid ) #raise ( e ) table_operands [ (uuid,k) ]= w if groupmap is not None : try : if not isinstance ( groupmap ,( list , tuple , set )) : raise Exception ( f \"not a vaild list\" ) for i in range ( 0 , groupmap . __len__ ()) : v = groupmap [ i ] if not isinstance ( v , dict ) : raise Exception ( f \"{v} has not a valid format\" ) el = v . pop ( 'element' ) try : el = HSeries ( el , delayed = False ). uuid except Exception as e : raise e try : v [ 'ordinal' ] except Exception as e : v [ 'ordinal' ] = i try : v [ 'label' ] except Exception as e : v [ 'label' ] = str ( i ) db [ \"series_groups\" ][ (uuid,el) ]= v db [ \"series\" ][ uuid ]= { \"capability\" : 'datadiagram' } except Exception as e : raise Exception ( f \"groupmap CONF for {uuid}: {e}\" ) if thresholds is not None and isinstance ( thresholds , ( list , tuple , set )) : for t in thresholds : db [ \"series_thresholds\" ][ uuid ]= t return HSeries ( uuid ) def attribute_update ( self , attribute = None , value = None ) : if attribute is None : return if attribute == 'thresholds' : if not isinstance ( value ,( list , set , tuple )) : value =[ value ] for t in value : db [ \"series_thresholds\" ][ self.uuid ]= t if attribute == 'reference' : pass else : db [ \"series\" ][ self.uuid ]= { attribute : value } if self . __loaded__ : self . __loaded__ = False self . __delayed_load__ () def check ( self , geometry = None , ** kwargs ) : try : last_event = db [ 'status' ][ {'series':self.uuid} ] . iloc [ 0 ] last_event_time = str ( last_event [ 'last_time' ] ) except KeyError as e : last_event = None last_event_time = None times = slice ( last_event_time , None , None ) cache = 'active' # BUILDING THE REFERENCE DATAFRAME ( aa ) aa = self . thresholds if aa . empty : d = DataFrame ( [ [self.uuid,self.last,'#','#','#','#','#','#','#',0 ] ] , columns =[ 'series','timestamp','reading_value','threshold_value','ttype','label','color','end','count','latency' ] ) return d . set_index ( [ 'series','timestamp' ] ) if aa [ 'ttype' ] . iloc [ 0 ] == 'LOWER' : aa = concat ( [ aa,DataFrame([[None,'LOWER',None ] ] , index = Index ( [ -inf ] , name = 'value' ), columns =[ 'label','ttype','color' ] ) ] ). sort_index () if aa [ 'ttype' ] . iloc [ -1 ] == 'UPPER' : aa = concat ( [ aa,DataFrame([[None,'UPPER',None ] ] , index = Index ( [ inf ] , name = 'value' ), columns =[ 'label','ttype','color' ] ) ] ). sort_index () aa = aa . reset_index () bb = aa [ 'value' ] . copy () aa . loc [ aa['ttype' ]== 'LOWER' , [ 'value','label','color' ] ] = aa . loc [ aa['ttype' ]== 'LOWER' , [ 'value','label','color' ] ] . shift ( - 1 ) aa . loc [ aa['ttype' ]== 'UPPER' , [ 'value','label','color' ] ] = aa . loc [ aa['ttype' ]== 'UPPER' , [ 'value','label','color' ] ] . shift ( 1 ) aa [ 'limit' ]= bb aa = aa [ aa['value' ] . notna () ] aa . index . name = 'idt' aa = aa . reset_index () # REFEERENCE DATAFRAME DONE # EXTRACTING THE DATA d = self . data ( times = times , cache = cache , geometry = geometry , ** kwargs ) # DATA ESTRACTION DONE try : d = d . to_frame () except Exception as e : pass v = d . columns [ 0 ] # TODO capire neither or both # TODO separare UPPER e LOWER # MATCHING FOR OVERCOMES ( each i in aa , thresholds , over d , data ) for i in aa . index : d . loc [ d[v ] . between ( min ( aa . loc [ i,'value' ] , aa . loc [ i,'limit' ] ), max ( aa . loc [ i,'value' ] , aa . loc [ i,'limit' ] ), inclusive = 'neither' ), 'value' ] = aa . loc [ i,'idt' ] aa = aa . set_index ( 'idt' ) d = d . reset_index (). set_index ( 'value' ). sort_index () d = d . join ( aa , how = 'left' ). set_index ( 'timestamp' ). sort_index () [ [v,'value','ttype','label','color' ] ] d . columns =[ \"reading_value\",\"threshold_value\",\"ttype\",\"label\",\"color\" ] d [ 'series' ]= v d = d . reset_index () d = d . replace ( nan , \"#\" ) d [ 'end' ] = d [ 'timestamp' ] . copy () d [ 'timestamp' ]= d [ ~(d[\"label\" ] == d [ \"label\" ] . shift ( 1 )) | ~ ( d [ \"ttype\" ] == d [ \"ttype\" ] . shift ( 1 )) ] [ 'end' ] d [ 'timestamp' ] = d [ 'timestamp' ] . ffill () d = d . set_index ( 'timestamp' ) d [ 'count' ]= d [ 'label' ] . groupby ( 'timestamp' ). count () d = d . reset_index () d = d [ ~(d[\"label\" ] == d [ 'label' ] . shift ( - 1 )) | ~ ( d [ \"ttype\" ] == d [ 'ttype' ] . shift ( - 1 )) ] reftime = datetime64 ( 'now' ) + timedelta64 ( conf [ 'server_time_offset' ] , 'h' ) d [ 'latency' ]= ( reftime - d [ 'end' ] ). astype ( 'timedelta64[s]' ) d [ 'timestamp' ]= d [ 'timestamp' ] . astype ( str ) d [ 'end' ] = d [ 'end' ] . astype ( str ) d [ 'latency' ]= d [ 'latency' ] . astype ( int ) if not d . empty and last_event is not None : d . loc [ d.index[0 ] , 'count' ] = ( d . iloc [ 0 ][ 'count' ] - 1 + last_event [ 'count' ] ). squeeze () d . loc [ d.index[0 ] , 'timestamp' ] = str ( last_event [ 'start_time' ] ) if d . __len__ () > 1 : if last_event [ 'latency' ] is not None : d . loc [ d.index[0 ] , 'latency' ] = last_event [ 'latency' ] def fillth ( ** kwargs ) : db [ \"events\" ][ {'series':kwargs['series' ] }] = kwargs d . apply ( lambda x : fillth ( ** x ), axis = 1 ) return d . set_index ( [ 'series','timestamp' ] ) @_threadpool def thvalues ( self , ** kwargs ) : return self . __getattr__ ( self . capability )( ** kwargs ) def datadiagram ( self , ** kwargs ) : return self . data ( ** kwargs ) def data ( self , times = None , timeref = None , cache = None , group = None , geometry = None , ** kwargs ) : self . __delayed_load__ () entertimes = times if self . capability not in [ 'data','datadiagram' ] : raise ValueError ( f \"{self.uuid} has not 'data' capability\" ) if self . ingroup is None or group in self . ingroup : cangenerate = True else : cangenerate = False timeref = agoodtime ( timeref ) if cache is None : try : cache = self . cache assert cache in ( \"active\" , \"data\" , \"old\" ) except Exception as e : cache = \"no\" if times is None : times = slice ( None , None , None ) justnew = False try : if cache == 'new' : justnew = True timefrom = isot2ut ( self . last ) try : assert self . cache in ( \"active\" , \"data\" , \"old\" ) cache = \"active\" except Exception as e : cache = \"no\" else : tocheck = min ( isot2ut ( self . last ), isot2ut ( times . start )) timefrom = max ( isot2ut ( self . first ), tocheck ) times = slice ( ut2isot ( timefrom ), times . stop , times . step ) except Exception as e : pass firstreqstart = times . start #TODO inserire i nomi dei label out = DataFrame ( [] , columns = self . activeuuids , dtype = 'object' ) if cache in ( \"refresh\" ) : self . clean_cache ( times ) if cache in ( \"active\" , \"data\" , \"old\" ) : try : out = db [ \"datacache\" ][ self.activeuuids,times ] except KeyError as e : pass if not out . empty : cachestop = out . index . max () try : timefrom = max ( isot2ut ( cachestop ), isot2ut ( times . start )) times = slice ( ut2isot ( timefrom ), times . stop , times . step ) except Exception as e : pass try : try : if cache == 'old' or not cangenerate : raise Exception ( 'request for old, skip generation' ) kwargs [ 'cache' ] = cache gen = self . generator . __generate__ ( times = times , timeref = timeref , geometry = geometry , ** kwargs ) gen = gen . replace ( ',' , '.' , regex = True ). astype ( float ) if gen . empty : raise Exception ( \"void\" ) except Exception as e : # print ( \"WARN series GENERATE: \" , e ) # raise e ##DEBUG gen = DataFrame ( [] , columns = self . activeuuids , dtype = 'object' ) try : gen = gen . to_frame () except AttributeError as e : pass #gen . name = self . uuid try : gen = gen . round ( 4 ) except Exception as e : pass try : gen . columns = self . activeuuids except Exception as e : pass gen . index = DatetimeIndex ( gen . index ) out = concat ( [ out,gen ] ). sort_index () out . index . name = \"timestamp\" out = out [ self.activeuuids ] if self . valid_range_min is not None : out = out . mask ( out < self . valid_range_min , nan ) if self . valid_range_max is not None : out = out . mask ( out > self . valid_range_max , nan ) out = out [ out.notna().any(axis=1) ] if cache in ( \"active\" , \"data\" , \"refresh\" ) and cangenerate : for u in gen . columns : db [ \"datacache\" ][ u ]= out [ u ] except Exception as e : # print ( \"WARN series GLOBAL: \" , e ) # raise e #DEBUG pass if cache in ( \"active\" , \"data\" , \"refresh\" ) and not out . empty and not justnew : lasttotry = str ( out . index [ 0 ] ) times = slice ( firstreqstart , lasttotry , times . step ) kwargs [ 'cache' ] = \"none\" preout = self . data ( times = times , geometry = geometry , group = group , ** kwargs ) try : preout = preout . to_frame () except Exception as e : pass preout . index . name = \"timestamp\" try : preout . columns = self . activeuuids except Exception as e : pass if cangenerate : for u in preout . columns : db [ \"datacache\" ][ u ]= preout [ u ] if preout . __len__ () : out = concat ( [ preout,out ] ). sort_index () out = out [ ~out.index.duplicated() ] out . index . name = \"timestamp\" if not out . empty : self . attribute_update ( 'last' , ut2isot ( max ( isot2ut ( self . last ), isot2ut ( str ( out . index [ -1 ] ))))) try : out = out . loc [ entertimes ] except Exception as e : pass try : if out . columns . __len__ () < 2 : out = out . iloc [ :,0 ] except Exception as e : pass return out ## WARNING Omesso Map ## WARINIG Omesso Cloud def stream ( self , times = None , timeref = None , cache = None , geometry = None , ** kwargs ) : if self . capability != 'stream' : raise ValueError ( f \"{self.uuid} has not 'stream' capability\" ) self . __delayed_load__ () timeref = agoodtime ( timeref ) cache = \"no\" try : try : out = self . generator . __generate__ ( ** kwargs ) gen = Series ( [ out['queue' ] ] , index =[ out['timestamp' ] ] ) except Exception as e : # print ( \"WARN series GENERATE: \" , e ) # raise e gen = Series ( [] , dtype = 'object' ) gen . name = 'queue' gen . index = DatetimeIndex ( gen . index ) out = gen [ ~gen.index.duplicated() ] out . index . name = \"timestamp\" except Exception as e : #raise e pass try : out = out [ out.columns[0 ] ] except Exception as e : pass return out # return out . to_frame () #TOLGO ORIENT class __Generator__ : def __load_operand__ ( value = None ) : #OPERANDS RESOLUTION : try : UUID ( value ) return HSeries ( value ) except Exception as e : pass try : value = value . removeprefix ( '#' ) except Exception as e : pass \"\"\" trying to load json string, if \" value \" is it \"\"\" try : return json . loads ( value ) except Exception as e : pass return value ''' \"\"\" Trying to get values from a dict, if \"out\" is it \"\"\" try: values=out.values() except AttributeError as e: values=out \"\"\" Trying to load suboperands from a list if \"values\" is it \"\"\" try: assert not isinstance(values,str) values=[ __Generator__.__load_operand__(a,orient) for a in values ] except Exception as e: pass \"\"\" Trying zip a dict, if \"out\" is it \"\"\" try: out=dict(zip(out.keys(),values) except AttributeError as e: out = values return out ''' def __init__ ( self , modules = None , operator = None , operands = None , group = None , groupmap = None , ** kwargs ) : self . modules = {} self . group = group if operator is None or operator in \"__VOID__\" : operator = \"Series([],dtype='object')\" self . operator = operator if not modules is None : for k , m in modules . items () : self . operator = self . operator . replace ( k , f \"self.modules[{k!r}]\" ) self . modules [ k ] = import_module ( m ) self . operands = { k : HSeries . __Generator__ . __load_operand__ ( w ) for k , w in operands . items () } if groupmap is not None : self . groupmap = { k : HSeries . __Generator__ . __load_operand__ ( w ) for k , w in groupmap . items () } else : self . groupmap = None def __generate__ ( self , ** kwargs ) : operands = kwargs ''' times=kwargs[' times '] try: start=re.sub(' \\ + . * $ ','',str(times.start)) except Exception as e: start=None try: stop=re.sub(' \\ + . * $ ','',str(times.stop)) except Exception as e: stop = None kwargs.update({\"times\":slice(start,stop,times.step)}) ''' operands . update ( { k : w for k , w in self . operands . items () if not isinstance ( w , HSeries ) } ) operands [ 'group' ] = self . group if self . groupmap is not None : groupmap = { k : w . thvalues ( ** kwargs ) for k , w in self . groupmap . items () if isinstance ( w , HSeries ) } groupmap = { k : w . result () for k , w in groupmap . items () } #groupmap = concat ( groupmap , axis = 1 ) cols = list ( groupmap . keys ()) groupmap = concat ( groupmap ). unstack (). T . sort_index () try : groupmap . columns = groupmap . columns . droplevel ( 0 ) except Exception as e : pass for c in cols : if c not in groupmap . columns : groupmap [ c ] = None operands [ '__GROUPMAP__' ] = groupmap runners = { k : w . thvalues ( ** kwargs ) for k , w in self . operands . items () if isinstance ( w , HSeries ) } operands . update ( { k : w . result () for k , w in runners . items () } ) #operands . update ( { k : w . data ( ** kwargs ) for k , w in self . operands . items () if isinstance ( w , HSeries ) } ) ## ATTENZIONE A locals : Implementation Dependant !!!! ### locals (). update ( operands ) # print ( operands ) #DEBUG # print ( self . operator , locals () ) #DEBUG out = eval ( self . operator ) return out","title":"HSeries"},{"location":"reference/hielen3/series_good/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/series_good/#attribute_update","text":"def attribute_update ( self , attribute = None , value = None ) View Source def attribute_update ( self , attribute = None , value = None ) : if attribute is None : return if attribute == 'thresholds' : if not isinstance ( value ,( list , set , tuple )) : value =[ value ] for t in value : db [ \"series_thresholds\" ][ self.uuid ]= t if attribute == 'reference' : pass else : db [ \"series\" ][ self.uuid ]= { attribute : value } if self . __loaded__ : self . __loaded__ = False self . __delayed_load__ ()","title":"attribute_update"},{"location":"reference/hielen3/series_good/#check","text":"def check ( self , geometry = None , ** kwargs ) View Source def check ( self , geometry = None , ** kwargs ) : try : last_event = db [ 'status' ][ {'series':self.uuid} ] . iloc [ 0 ] last_event_time = str ( last_event [ 'last_time' ] ) except KeyError as e : last_event = None last_event_time = None times = slice ( last_event_time , None , None ) cache = 'active' # BUILDING THE REFERENCE DATAFRAME ( aa ) aa = self . thresholds if aa . empty : d = DataFrame ( [ [self.uuid,self.last,'#','#','#','#','#','#','#',0 ] ] , columns =[ 'series','timestamp','reading_value','threshold_value','ttype','label','color','end','count','latency' ] ) return d . set_index ( [ 'series','timestamp' ] ) if aa [ 'ttype' ] . iloc [ 0 ] == 'LOWER' : aa = concat ( [ aa,DataFrame([[None,'LOWER',None ] ] , index = Index ( [ -inf ] , name = 'value' ), columns =[ 'label','ttype','color' ] ) ] ). sort_index () if aa [ 'ttype' ] . iloc [ -1 ] == 'UPPER' : aa = concat ( [ aa,DataFrame([[None,'UPPER',None ] ] , index = Index ( [ inf ] , name = 'value' ), columns =[ 'label','ttype','color' ] ) ] ). sort_index () aa = aa . reset_index () bb = aa [ 'value' ] . copy () aa . loc [ aa['ttype' ]== 'LOWER' , [ 'value','label','color' ] ] = aa . loc [ aa['ttype' ]== 'LOWER' , [ 'value','label','color' ] ] . shift ( - 1 ) aa . loc [ aa['ttype' ]== 'UPPER' , [ 'value','label','color' ] ] = aa . loc [ aa['ttype' ]== 'UPPER' , [ 'value','label','color' ] ] . shift ( 1 ) aa [ 'limit' ]= bb aa = aa [ aa['value' ] . notna () ] aa . index . name = 'idt' aa = aa . reset_index () # REFEERENCE DATAFRAME DONE # EXTRACTING THE DATA d = self . data ( times = times , cache = cache , geometry = geometry , ** kwargs ) # DATA ESTRACTION DONE try : d = d . to_frame () except Exception as e : pass v = d . columns [ 0 ] # TODO capire neither or both # TODO separare UPPER e LOWER # MATCHING FOR OVERCOMES ( each i in aa , thresholds , over d , data ) for i in aa . index : d . loc [ d[v ] . between ( min ( aa . loc [ i,'value' ] , aa . loc [ i,'limit' ] ), max ( aa . loc [ i,'value' ] , aa . loc [ i,'limit' ] ), inclusive = 'neither' ), 'value' ] = aa . loc [ i,'idt' ] aa = aa . set_index ( 'idt' ) d = d . reset_index (). set_index ( 'value' ). sort_index () d = d . join ( aa , how = 'left' ). set_index ( 'timestamp' ). sort_index () [ [v,'value','ttype','label','color' ] ] d . columns =[ \"reading_value\",\"threshold_value\",\"ttype\",\"label\",\"color\" ] d [ 'series' ]= v d = d . reset_index () d = d . replace ( nan , \"#\" ) d [ 'end' ] = d [ 'timestamp' ] . copy () d [ 'timestamp' ]= d [ ~(d[\"label\" ] == d [ \"label\" ] . shift ( 1 )) | ~ ( d [ \"ttype\" ] == d [ \"ttype\" ] . shift ( 1 )) ] [ 'end' ] d [ 'timestamp' ] = d [ 'timestamp' ] . ffill () d = d . set_index ( 'timestamp' ) d [ 'count' ]= d [ 'label' ] . groupby ( 'timestamp' ). count () d = d . reset_index () d = d [ ~(d[\"label\" ] == d [ 'label' ] . shift ( - 1 )) | ~ ( d [ \"ttype\" ] == d [ 'ttype' ] . shift ( - 1 )) ] reftime = datetime64 ( 'now' ) + timedelta64 ( conf [ 'server_time_offset' ] , 'h' ) d [ 'latency' ]= ( reftime - d [ 'end' ] ). astype ( 'timedelta64[s]' ) d [ 'timestamp' ]= d [ 'timestamp' ] . astype ( str ) d [ 'end' ] = d [ 'end' ] . astype ( str ) d [ 'latency' ]= d [ 'latency' ] . astype ( int ) if not d . empty and last_event is not None : d . loc [ d.index[0 ] , 'count' ] = ( d . iloc [ 0 ][ 'count' ] - 1 + last_event [ 'count' ] ). squeeze () d . loc [ d.index[0 ] , 'timestamp' ] = str ( last_event [ 'start_time' ] ) if d . __len__ () > 1 : if last_event [ 'latency' ] is not None : d . loc [ d.index[0 ] , 'latency' ] = last_event [ 'latency' ] def fillth ( ** kwargs ) : db [ \"events\" ][ {'series':kwargs['series' ] }] = kwargs d . apply ( lambda x : fillth ( ** x ), axis = 1 ) return d . set_index ( [ 'series','timestamp' ] )","title":"check"},{"location":"reference/hielen3/series_good/#clean_cache","text":"def clean_cache ( self , times = None ) View Source def clean_cache ( self , times = None ) : to_clean = list ( set ( [ self.uuid,*self.activeuuids ] )) try : db [ 'datacache' ] . pop ( key = ( to_clean , times )) except KeyError as e : pass try : db [ 'events' ] . pop ( key = ( to_clean , times )) except KeyError as e : pass try : last = str ( db [ 'datacache' ][ to_clean ] . index [ -1 ] ) except Exception as e : last = None self . attribute_update ( 'last' , last )","title":"clean_cache"},{"location":"reference/hielen3/series_good/#data","text":"def data ( self , times = None , timeref = None , cache = None , group = None , geometry = None , ** kwargs ) View Source def data ( self , times = None , timeref = None , cache = None , group = None , geometry = None , ** kwargs ) : self . __delayed_load__ () entertimes = times if self . capability not in [ 'data','datadiagram' ] : raise ValueError ( f \"{self.uuid} has not 'data' capability\" ) if self . ingroup is None or group in self . ingroup : cangenerate = True else : cangenerate = False timeref = agoodtime ( timeref ) if cache is None : try : cache = self . cache assert cache in ( \"active\" , \"data\" , \"old\" ) except Exception as e : cache = \"no\" if times is None : times = slice ( None , None , None ) justnew = False try : if cache == 'new' : justnew = True timefrom = isot2ut ( self . last ) try : assert self . cache in ( \"active\" , \"data\" , \"old\" ) cache = \"active\" except Exception as e : cache = \"no\" else : tocheck = min ( isot2ut ( self . last ), isot2ut ( times . start )) timefrom = max ( isot2ut ( self . first ), tocheck ) times = slice ( ut2isot ( timefrom ), times . stop , times . step ) except Exception as e : pass firstreqstart = times . start #TODO inserire i nomi dei label out = DataFrame ( [] , columns = self . activeuuids , dtype = 'object' ) if cache in ( \"refresh\" ) : self . clean_cache ( times ) if cache in ( \"active\" , \"data\" , \"old\" ) : try : out = db [ \"datacache\" ][ self.activeuuids,times ] except KeyError as e : pass if not out . empty : cachestop = out . index . max () try : timefrom = max ( isot2ut ( cachestop ), isot2ut ( times . start )) times = slice ( ut2isot ( timefrom ), times . stop , times . step ) except Exception as e : pass try : try : if cache == 'old' or not cangenerate : raise Exception ( 'request for old, skip generation' ) kwargs [ 'cache' ] = cache gen = self . generator . __generate__ ( times = times , timeref = timeref , geometry = geometry , ** kwargs ) gen = gen . replace ( ',' , '.' , regex = True ). astype ( float ) if gen . empty : raise Exception ( \"void\" ) except Exception as e : # print ( \"WARN series GENERATE: \" , e ) # raise e ##DEBUG gen = DataFrame ( [] , columns = self . activeuuids , dtype = 'object' ) try : gen = gen . to_frame () except AttributeError as e : pass #gen . name = self . uuid try : gen = gen . round ( 4 ) except Exception as e : pass try : gen . columns = self . activeuuids except Exception as e : pass gen . index = DatetimeIndex ( gen . index ) out = concat ( [ out,gen ] ). sort_index () out . index . name = \"timestamp\" out = out [ self.activeuuids ] if self . valid_range_min is not None : out = out . mask ( out < self . valid_range_min , nan ) if self . valid_range_max is not None : out = out . mask ( out > self . valid_range_max , nan ) out = out [ out.notna().any(axis=1) ] if cache in ( \"active\" , \"data\" , \"refresh\" ) and cangenerate : for u in gen . columns : db [ \"datacache\" ][ u ]= out [ u ] except Exception as e : # print ( \"WARN series GLOBAL: \" , e ) # raise e #DEBUG pass if cache in ( \"active\" , \"data\" , \"refresh\" ) and not out . empty and not justnew : lasttotry = str ( out . index [ 0 ] ) times = slice ( firstreqstart , lasttotry , times . step ) kwargs [ 'cache' ] = \"none\" preout = self . data ( times = times , geometry = geometry , group = group , ** kwargs ) try : preout = preout . to_frame () except Exception as e : pass preout . index . name = \"timestamp\" try : preout . columns = self . activeuuids except Exception as e : pass if cangenerate : for u in preout . columns : db [ \"datacache\" ][ u ]= preout [ u ] if preout . __len__ () : out = concat ( [ preout,out ] ). sort_index () out = out [ ~out.index.duplicated() ] out . index . name = \"timestamp\" if not out . empty : self . attribute_update ( 'last' , ut2isot ( max ( isot2ut ( self . last ), isot2ut ( str ( out . index [ -1 ] ))))) try : out = out . loc [ entertimes ] except Exception as e : pass try : if out . columns . __len__ () < 2 : out = out . iloc [ :,0 ] except Exception as e : pass return out","title":"data"},{"location":"reference/hielen3/series_good/#datadiagram","text":"def datadiagram ( self , ** kwargs ) View Source def datadiagram ( self , ** kwargs ) : return self . data ( ** kwargs )","title":"datadiagram"},{"location":"reference/hielen3/series_good/#setup","text":"def setup ( uuid = None , operator = None , modules = None , cache = None , mu = None , datatype = None , operands = None , capability = 'data' , first = None , valid_range = None , view_range = None , thresholds = None , groupmap = None , orient = 'H' ) View Source def setup ( uuid = None , operator = None , modules = None , cache = None , mu = None , datatype = None , operands = None , capability = 'data' , first = None , valid_range = None , view_range = None , thresholds = None , groupmap = None , orient = 'H' ) : def _managed_capabilities_ ( capability ) : return capability in [ 'data','stream','group','datadiagram' ] uuid = uuid or getuuid () try : uuid = uuid . uuid except Exception as e : pass setups = {} #TODO gestire le diverse tipologie di dato if datatype is not None and datatype in [ 'numeric' ] : setups [ 'datatable' ]= 'geoframe.log' if modules is not None and isinstance ( modules , dict ) : setups [ 'modules' ]= modules if operator is not None and isinstance ( operator , str ) : setups [ 'operator' ]= operator if cache is not None and isinstance ( cache , str ) : setups [ 'cache' ]= cache if mu is not None and isinstance ( mu , str ) : setups [ 'mu' ] = mu if capability is not None and _managed_capabilities_ ( capability ) : setups [ 'capability' ] = capability # print ( \"Start_time:\" , first ) if first is not None : setups [ 'first' ] = first if orient is not None : setups [ 'orient' ] = orient if valid_range is not None : try : setups [ 'valid_range_min' ]= valid_range [ 0 ] except Exception as e : pass try : setups [ 'valid_range_max' ]= valid_range [ 1 ] except Exception as e : pass if view_range is not None : try : setups [ 'view_range_min' ]= view_range [ 0 ] except Exception as e : pass try : setups [ 'view_range_max' ]= view_range [ 1 ] except Exception as e : pass db [ \"series\" ][ uuid ]= setups #TODO fare il check di coerenza tra operandi e operatore if operands is not None and isinstance ( operands , dict ) : # print ( operands ) table_operands = db [ \"series_operands\" ] for k , w in operands . items () : if not isinstance ( w ,( list , tuple , set , dict )) : w =[ w ] if isinstance ( w ,( list , tuple , set )) : wl = min ( table_operands . values . __len__ (), w . __len__ ()) w = dict ( zip ( table_operands . values [ :wl ] , w [ :wl ] )) try : if isinstance ( w [ 'operand' ] , HSeries ) : w [ 'operand' ]= w [ 'operand' ] . uuid except Exception as e : print ( w , uuid ) #raise ( e ) table_operands [ (uuid,k) ]= w if groupmap is not None : try : if not isinstance ( groupmap ,( list , tuple , set )) : raise Exception ( f \"not a vaild list\" ) for i in range ( 0 , groupmap . __len__ ()) : v = groupmap [ i ] if not isinstance ( v , dict ) : raise Exception ( f \"{v} has not a valid format\" ) el = v . pop ( 'element' ) try : el = HSeries ( el , delayed = False ). uuid except Exception as e : raise e try : v [ 'ordinal' ] except Exception as e : v [ 'ordinal' ] = i try : v [ 'label' ] except Exception as e : v [ 'label' ] = str ( i ) db [ \"series_groups\" ][ (uuid,el) ]= v db [ \"series\" ][ uuid ]= { \"capability\" : 'datadiagram' } except Exception as e : raise Exception ( f \"groupmap CONF for {uuid}: {e}\" ) if thresholds is not None and isinstance ( thresholds , ( list , tuple , set )) : for t in thresholds : db [ \"series_thresholds\" ][ uuid ]= t return HSeries ( uuid )","title":"setup"},{"location":"reference/hielen3/series_good/#stream","text":"def stream ( self , times = None , timeref = None , cache = None , geometry = None , ** kwargs ) View Source def stream ( self , times = None , timeref = None , cache = None , geometry = None , ** kwargs ): if self . capability != 'stream' : raise ValueError ( f \"{self.uuid} has not 'stream' capability\" ) self . __delayed_load__ () timeref = agoodtime ( timeref ) cache = \"no\" try : try : out = self . generator . __generate__ ( ** kwargs ) gen = Series ([ out [ 'queue' ]], index = [ out [ 'timestamp' ]]) except Exception as e : # print (\"WARN series GENERATE: \",e) # raise e gen = Series ([], dtype = 'object' ) gen . name = 'queue' gen . index = DatetimeIndex ( gen . index ) out = gen [ ~ gen . index . duplicated ()] out . index . name = \"timestamp\" except Exception as e : #raise e pass try : out = out [ out . columns [ 0 ]] except Exception as e : pass return out","title":"stream"},{"location":"reference/hielen3/series_good/#thvalues","text":"def thvalues ( self , ** kwargs ) View Source @_threadpool def thvalues ( self , ** kwargs ) : return self . __getattr__ ( self . capability )( ** kwargs )","title":"thvalues"},{"location":"reference/hielen3/sourcestorage/","text":"Module hielen3.sourcestorage View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #!/usr/bin/env python # coding=utf-8 from pathlib import Path , os from shutil import rmtree import traceback class SourceStorage (): def __repr__ ( self ): return self . __str__ () def __str__ ( self ): return str ( self . cache ) def __init__ ( self , syspath , subpath = '' ): self . cache = Path ( syspath ) / subpath def __truediv__ ( self , other ): other = str ( other ) . replace ( f \" { self . cache }{ os . sep } \" , \"\" ) return self . cache / other def glob ( self , * args , ** kwargs ): return self . cache . glob ( * args , ** kwargs ) def mkdir ( self , path = None ): if path is None : path = '' outpath = self / path os . makedirs ( outpath , exist_ok = True ) return outpath def rmdir ( self , path = None ): if path is None : path = '' outpath = self . cache / path rmtree ( outpath ) Classes SourceStorage class SourceStorage ( syspath , subpath = '' ) View Source class SourceStorage (): def __repr__ ( self ): return self . __str__ () def __str__ ( self ): return str ( self . cache ) def __init__ ( self , syspath , subpath = '' ): self . cache = Path ( syspath ) / subpath def __truediv__ ( self , other ): other = str ( other ). replace ( f \"{self.cache}{os.sep}\" , \"\" ) return self . cache / other def glob ( self ,* args ,** kwargs ): return self . cache . glob (* args ,** kwargs ) def mkdir ( self , path = None ): if path is None: path = '' outpath = self / path os . makedirs ( outpath , exist_ok = True ) return outpath def rmdir ( self , path = None ): if path is None: path = '' outpath = self . cache / path rmtree ( outpath ) Methods glob def glob ( self , * args , ** kwargs ) View Source def glob ( self , * args , ** kwargs ) : return self . cache . glob ( * args , ** kwargs ) mkdir def mkdir ( self , path = None ) View Source def mkdir ( self , path = None ) : if path is None : path = '' outpath = self / path os . makedirs ( outpath , exist_ok = True ) return outpath rmdir def rmdir ( self , path = None ) View Source def rmdir ( self , path = None ) : if path is None : path = '' outpath = self . cache / path rmtree ( outpath )","title":"Sourcestorage"},{"location":"reference/hielen3/sourcestorage/#module-hielen3sourcestorage","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #!/usr/bin/env python # coding=utf-8 from pathlib import Path , os from shutil import rmtree import traceback class SourceStorage (): def __repr__ ( self ): return self . __str__ () def __str__ ( self ): return str ( self . cache ) def __init__ ( self , syspath , subpath = '' ): self . cache = Path ( syspath ) / subpath def __truediv__ ( self , other ): other = str ( other ) . replace ( f \" { self . cache }{ os . sep } \" , \"\" ) return self . cache / other def glob ( self , * args , ** kwargs ): return self . cache . glob ( * args , ** kwargs ) def mkdir ( self , path = None ): if path is None : path = '' outpath = self / path os . makedirs ( outpath , exist_ok = True ) return outpath def rmdir ( self , path = None ): if path is None : path = '' outpath = self . cache / path rmtree ( outpath )","title":"Module hielen3.sourcestorage"},{"location":"reference/hielen3/sourcestorage/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/sourcestorage/#sourcestorage","text":"class SourceStorage ( syspath , subpath = '' ) View Source class SourceStorage (): def __repr__ ( self ): return self . __str__ () def __str__ ( self ): return str ( self . cache ) def __init__ ( self , syspath , subpath = '' ): self . cache = Path ( syspath ) / subpath def __truediv__ ( self , other ): other = str ( other ). replace ( f \"{self.cache}{os.sep}\" , \"\" ) return self . cache / other def glob ( self ,* args ,** kwargs ): return self . cache . glob (* args ,** kwargs ) def mkdir ( self , path = None ): if path is None: path = '' outpath = self / path os . makedirs ( outpath , exist_ok = True ) return outpath def rmdir ( self , path = None ): if path is None: path = '' outpath = self . cache / path rmtree ( outpath )","title":"SourceStorage"},{"location":"reference/hielen3/sourcestorage/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/sourcestorage/#glob","text":"def glob ( self , * args , ** kwargs ) View Source def glob ( self , * args , ** kwargs ) : return self . cache . glob ( * args , ** kwargs )","title":"glob"},{"location":"reference/hielen3/sourcestorage/#mkdir","text":"def mkdir ( self , path = None ) View Source def mkdir ( self , path = None ) : if path is None : path = '' outpath = self / path os . makedirs ( outpath , exist_ok = True ) return outpath","title":"mkdir"},{"location":"reference/hielen3/sourcestorage/#rmdir","text":"def rmdir ( self , path = None ) View Source def rmdir ( self , path = None ) : if path is None : path = '' outpath = self . cache / path rmtree ( outpath )","title":"rmdir"},{"location":"reference/hielen3/utils/","text":"Module hielen3.utils View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 #!/usr/bin/env python # coding=utf-8 from datetime import datetime from re import split , sub , findall from time import mktime import json from importlib import import_module from falcon import HTTPNotAcceptable , HTTP_OK , Response , Request from hashlib import md5 from marshmallow import Schema , fields from numpy import datetime64 , isnat from collections.abc import Iterable from uuid import uuid4 from pandas import DataFrame def uuid (): return str ( uuid4 ()) def dataframe2jsonizabledict ( df : DataFrame , orient = 'records' , squeeze = True ): try : out = df . assign ( ** df . select_dtypes ([ 'datetime64' ]) . astype ( str )) . to_dict ( orient = orient ) if squeeze and out . __len__ () == 0 : out = [] if squeeze and out . __len__ () == 1 : out = out [ 0 ] except Exception as e : raise e out = [] return out def hug_output_format_conten_type ( handlers = [], error = \"The requested format does not match any of those allowed\" , ctpar = \"content_type\" , ): \"\"\"Returns a different handler depending on the input param ctpar If none match and no default is given falcon.HTTPNotAcceptable(error) is raised \"\"\" try : default = handlers [ 0 ] except Exception : default = None handlers = { h . content_type : h for h in handlers } def requested_output_type ( request = None ): try : par = request . _params [ ctpar ] handler = None for k , h in handlers . items (): if par . split ( \";\" )[ 0 ] == k . split ( \";\" )[ 0 ]: handler = h break except Exception : if default is not None : handler = default if handler is None : raise HTTPNotAcceptable ( error ) return handler def output_type ( data , request , response ): handler = requested_output_type ( request ) response . content_type = handler . content_type return handler ( data , request = request , response = response ) output_type . __doc__ = \"Supports any of the following formats: {0} \" . format ( \", \" . join ( function . __doc__ for function in handlers . values ()) ) output_type . content_type = \", \" . join ( handlers . keys ()) output_type . requested = requested_output_type return output_type def newinstanceof ( klass , * args , ** kwargs ): klass_ar = klass . split ( \".\" ) module = \".\" . join ( klass_ar [: - 1 ]) klass = klass_ar [ - 1 ] return getattr ( import_module ( module ), klass )( * args , ** kwargs ) def ut2isot ( u = None ): u = u or 1 return str ( datetime . fromtimestamp ( u )) def isot2ut ( t = None ): t = t or \"1970-01-01T01:00:01.00000Z\" try : dt = datetime ( * map ( int , split ( \"[^\\d]\" , sub ( \"[^\\d]$\" , \"\" , str ( t ))))) out = int ( mktime ( dt . timetuple ())) except Exception as e : print ( e , t ) return out def agoodtime ( t ): try : t = datetime64 ( t ) assert not isnat ( t ) t = str ( t ) except Exception : t = None return t def loadjsonfile ( filename ): with open ( filename ) as jf : return json . load ( jf ) def savejsonfile ( filename , struct ): with open ( filename , \"w\" ) as jf : json . dump ( struct , jf ) def eprint ( * args , fname = \"error\" , ** kwargs ): with open ( fname , \"a\" ) as f : print ( * args , file = f , ** kwargs ) def hasher ( * args , ** kwargs ): h = [ * args ] h . extend ( list ( kwargs . values ())) h = '' . join ([ str ( a ) for a in h ]) return md5 ( f ' { h } ' . encode () ) . hexdigest () def hashfile ( filename ): BLOCKSIZE = 65536 hasher = md5 () with open ( filename , \"rb\" ) as afile : buf = afile . read ( BLOCKSIZE ) while len ( buf ) > 0 : hasher . update ( buf ) buf = afile . read ( BLOCKSIZE ) return hasher . hexdigest () ### MARSHMALLOW class Selection ( fields . String ): \"\"\" Provides python object which pertims selection on narry. It axcept a three filed \\ string separated by \",\". \",\" presence is managed as: \"start,stop,step\" ie.: \"start,stop\" - extracts from start to stop \"start,\" - extracts from start to max \"start\" - extract exactly start \"\"\" def _deserialize ( self , value , attr , data , ** kwargs ): try : if isinstance ( value , list ): value = \";\" . join ( value ) if value is None or value == \"\" : #return [None,None,None] return slice ( None , None , None ) value = [ v or None for v in value . split ( ';' ) ] if value . __len__ () == 1 : return slice ( value [ 0 ], value [ 0 ]) if value . __len__ () > 2 : value [ 2 ] = int ( value [ 2 ]) return slice ( * value [ 0 : 3 ]) #return value[0:3] except Exception as e : raise ValueError ( e ) class JsonValidable : \"\"\" JSON Validator class. It is initailzed with a marshmallow.Schema instance. When __call__ function is invoked, \\ uses marshmallow facilities to validate the json and raise errors. Once initalized, changes __doc__ in order to descibe the json accepted. \"\"\" def __field_doc__ ( self , field ): required = field . required and \"!\" or \"\" allow_none = not field . allow_none and \"!\" or \"\" try : types = \"|\" . join ( self . TYPE_MAPPING [ field . __class__ ]) except KeyError : if field . __class__ is fields . List : f , required , allow_none = self . __field_doc__ ( field . inner ) types = f \"[ { f } ]\" elif field . __class__ is fields . Dict : kf , required , allow_none = self . __field_doc__ ( field . key_field ) vf , required , allow_none = self . __field_doc__ ( field . value_field ) types = f \" {{ { kf } , { vf } }} \" else : types = \"\" return ( types , required , allow_none ) def __schema_doc__ ( self ): flds = [] for n , f in self . schema . fields . items (): types , required , allow_none = self . __field_doc__ ( f ) # TODO formattare required e allow_none # flds.append( f\"**{n}**{required}{allow_none}: {types}\") flds . append ( f \"** { n } **: { types } \" ) fields = \", \" . join ( flds ) fields = f \" {{ { fields } }} \" if self . schema . many : fields = f \"[ { fields } ]\" return f \"JSON Schema { fields } \" def __init__ ( self , schema ): self . schema = schema self . TYPE_MAPPING = {} for k , w in self . schema . TYPE_MAPPING . items (): try : self . TYPE_MAPPING [ w ] . append ( findall ( r \"'(.*)'\" , str ( k ))[ 0 ]) except KeyError : self . TYPE_MAPPING [ w ] = [ findall ( r \"'(.*)'\" , str ( k ))[ 0 ]] self . __doc__ = str ( self . __schema_doc__ ()) def __call__ ( self , value ): if type ( value ) is list : # If Falcon is set to comma-separate entries, this segment joins them again. fixed_value = \",\" . join ( value ) else : fixed_value = value return self . schema . loads ( fixed_value ) class ResponseFormatter (): def parse_status ( status ): try : if int ( status . rsplit ( \" \" )[ 0 ]) < 400 : return \"ok\" else : return \"error\" except ValueError : return \"error\" def __init__ ( self , status = HTTP_OK , message = \"\" , data = \"\" ): self . status = status self . message = message self . data = data def format ( self , response : Response , request : Request = None ): body = dict ( meta = dict ( response = ResponseFormatter . parse_status ( self . status ), message = isinstance ( self . message , Iterable ) and self . message . __len__ () == 1 and self . message [ 0 ] or self . message , data_type = request and f \" { request . method } { request . path } \" or \"\" , ), data = self . data ) response . status = self . status response . body = json . dumps ( body ) return response Variables HTTP_OK isnat Functions agoodtime def agoodtime ( t ) View Source def agoodtime ( t ) : try : t = datetime64 ( t ) assert not isnat ( t ) t = str ( t ) except Exception : t = None return t dataframe2jsonizabledict def dataframe2jsonizabledict ( df : pandas . core . frame . DataFrame , orient = 'records' , squeeze = True ) View Source def dataframe2jsonizabledict ( df: DataFrame , orient = ' records ', squeeze = True ) : try: out = df . assign ( ** df . select_dtypes ([' datetime64 ']). astype ( str )). to_dict ( orient = orient ) if squeeze and out . __len__ () == 0 : out = [] if squeeze and out . __len__ () == 1 : out = out [ 0 ] except Exception as e: raise e out = [] return out eprint def eprint ( * args , fname = 'error' , ** kwargs ) View Source def eprint(*args, fname=\"error\", **kwargs): with open(fname, \"a\") as f: print(*args, file=f, **kwargs) hasher def hasher ( * args , ** kwargs ) View Source def hasher ( * args , ** kwargs ) : h = [ * args ] h . extend ( list ( kwargs . values ())) h = '' . join ( [ str ( a ) for a in h ] ) return md5 ( f '{h}' . encode () ) . hexdigest () hashfile def hashfile ( filename ) View Source def hashfile ( filename ) : BLOCKSIZE = 65536 hasher = md5 () with open ( filename , \"rb\" ) as afile : buf = afile . read ( BLOCKSIZE ) while len ( buf ) > 0 : hasher . update ( buf ) buf = afile . read ( BLOCKSIZE ) return hasher . hexdigest () hug_output_format_conten_type def hug_output_format_conten_type ( handlers = [], error = 'The requested format does not match any of those allowed' , ctpar = 'content_type' ) Returns a different handler depending on the input param ctpar If none match and no default is given falcon.HTTPNotAcceptable(error) is raised View Source def hug_output_format_conten_type ( handlers = [] , error = \"The requested format does not match any of those allowed\" , ctpar = \"content_type\" , ) : \"\"\"Returns a different handler depending on the input param ctpar If none match and no default is given falcon.HTTPNotAcceptable(error) is raised \"\"\" try : default = handlers [ 0 ] except Exception : default = None handlers = { h . content_type : h for h in handlers } def requested_output_type ( request = None ) : try : par = request . _params [ ctpar ] handler = None for k , h in handlers . items () : if par . split ( \";\" ) [ 0 ] == k . split ( \";\" ) [ 0 ] : handler = h break except Exception : if default is not None : handler = default if handler is None : raise HTTPNotAcceptable ( error ) return handler def output_type ( data , request , response ) : handler = requested_output_type ( request ) response . content_type = handler . content_type return handler ( data , request = request , response = response ) output_type . __doc__ = \"Supports any of the following formats: {0}\" . format ( \", \" . join ( function . __doc__ for function in handlers . values ()) ) output_type . content_type = \", \" . join ( handlers . keys ()) output_type . requested = requested_output_type return output_type isot2ut def isot2ut ( t = None ) View Source def isot2ut ( t = None ) : t = t or \"1970-01-01T01:00:01.00000Z\" try : dt = datetime ( * map ( int , split ( \"[^\\d]\" , sub ( \"[^\\d]$\" , \"\" , str ( t ))))) out = int ( mktime ( dt . timetuple ())) except Exception as e : print ( e , t ) return out loadjsonfile def loadjsonfile ( filename ) View Source def loadjsonfile ( filename ): with open ( filename ) as jf : return json . load ( jf ) newinstanceof def newinstanceof ( klass , * args , ** kwargs ) View Source def newinstanceof ( klass , * args , **kwargs ) : klass_ar = klass . split ( \".\" ) module = \".\" . join ( klass_ar [ :- 1 ]) klass = klass_ar [ - 1 ] return getattr ( import_module ( module ), klass )( * args , **kwargs ) savejsonfile def savejsonfile ( filename , struct ) View Source def savejsonfile(filename, struct): with open(filename, \"w\") as jf: json.dump(struct, jf) ut2isot def ut2isot ( u = None ) View Source def ut2isot ( u = None ) : u = u or 1 return str ( datetime . fromtimestamp ( u )) uuid def uuid ( ) View Source def uuid () : return str ( uuid4 ()) Classes JsonValidable class JsonValidable ( schema ) JSON Validator class. It is initailzed with a marshmallow.Schema instance. When call function is invoked, uses marshmallow facilities to validate the json and raise errors. Once initalized, changes doc in order to descibe the json accepted. View Source class JsonValidable : \"\"\" JSON Validator class. It is initailzed with a marshmallow.Schema instance. When __call__ function is invoked, \\ uses marshmallow facilities to validate the json and raise errors. Once initalized, changes __doc__ in order to descibe the json accepted. \"\"\" def __field_doc__ ( self , field ) : required = field . required and \"!\" or \"\" allow_none = not field . allow_none and \"!\" or \"\" try : types = \"|\" . join ( self . TYPE_MAPPING [ field.__class__ ] ) except KeyError : if field . __class__ is fields . List : f , required , allow_none = self . __field_doc__ ( field . inner ) types = f \"[{f}]\" elif field . __class__ is fields . Dict : kf , required , allow_none = self . __field_doc__ ( field . key_field ) vf , required , allow_none = self . __field_doc__ ( field . value_field ) types = f \"{{{kf},{vf}}}\" else : types = \"\" return ( types , required , allow_none ) def __schema_doc__ ( self ) : flds = [] for n , f in self . schema . fields . items () : types , required , allow_none = self . __field_doc__ ( f ) # TODO formattare required e allow_none # flds . append ( f \"**{n}**{required}{allow_none}: {types}\" ) flds . append ( f \"**{n}**: {types}\" ) fields = \", \" . join ( flds ) fields = f \"{{{fields}}}\" if self . schema . many : fields = f \"[{fields}]\" return f \"JSON Schema {fields}\" def __init__ ( self , schema ) : self . schema = schema self . TYPE_MAPPING = {} for k , w in self . schema . TYPE_MAPPING . items () : try : self . TYPE_MAPPING [ w ] . append ( findall ( r \"'(.*)'\" , str ( k )) [ 0 ] ) except KeyError : self . TYPE_MAPPING [ w ] = [ findall(r\"'(.*)'\", str(k))[0 ] ] self . __doc__ = str ( self . __schema_doc__ ()) def __call__ ( self , value ) : if type ( value ) is list : # If Falcon is set to comma - separate entries , this segment joins them again . fixed_value = \",\" . join ( value ) else : fixed_value = value return self . schema . loads ( fixed_value ) ResponseFormatter class ResponseFormatter ( status = '200 OK' , message = '' , data = '' ) View Source class ResponseFormatter (): def parse_status ( status ): try: if int ( status . rsplit ( \" \" )[ 0 ]) < 400 : return \"ok\" else: return \"error\" except ValueError: return \"error\" def __init__ ( self , status = HTTP_OK , message = \"\" , data = \"\" ): self . status = status self . message = message self . data = data def format ( self , response:Response , request:Request = None ): body = dict ( meta = dict ( response = ResponseFormatter . parse_status ( self . status ), message = isinstance ( self . message , Iterable ) and self . message . __len__ () == 1 and self . message [ 0 ] or self . message , data_type = request and f \"{request.method} {request.path}\" or \"\" , ), data = self . data ) response . status = self . status response . body = json . dumps ( body ) return response Methods format def format ( self , response : falcon . response . Response , request : falcon . request . Request = None ) View Source def format ( self , response : Response , request : Request = None ) : body = dict ( meta = dict ( response = ResponseFormatter . parse_status ( self . status ) , message = isinstance ( self . message , Iterable ) and self . message . __len__ () == 1 and self . message [ 0 ] or self . message , data_type = request and f \"{request.method} {request.path}\" or \"\" , ) , data = self . data ) response . status = self . status response . body = json . dumps ( body ) return response parse_status def parse_status ( status ) View Source def parse_status ( status ) : try : if int ( status . rsplit ( \" \" ) [ 0 ] ) < 400 : return \"ok\" else : return \"error\" except ValueError : return \"error\" Selection class Selection ( * , load_default : 'typing.Any' = < marshmallow . missing > , missing : 'typing.Any' = < marshmallow . missing > , dump_default : 'typing.Any' = < marshmallow . missing > , default : 'typing.Any' = < marshmallow . missing > , data_key : 'str | None' = None , attribute : 'str | None' = None , validate : 'None | (typing.Callable[[typing.Any], typing.Any] | typing.Iterable[typing.Callable[[typing.Any], typing.Any]])' = None , required : 'bool' = False , allow_none : 'bool | None' = None , load_only : 'bool' = False , dump_only : 'bool' = False , error_messages : 'dict[str, str] | None' = None , metadata : 'typing.Mapping[str, typing.Any] | None' = None , ** additional_metadata ) Provides python object which pertims selection on narry. It axcept a three filed string separated by \",\". \",\" presence is managed as: \"start,stop,step\" ie.: \"start,stop\" - extracts from start to stop \"start,\" - extracts from start to max \"start\" - extract exactly start View Source class Selection ( fields . String ): \"\"\" Provides python object which pertims selection on narry. It axcept a three filed \\ string separated by \" , \". \" , \" presence is managed as: \" start , stop , step \" ie.: \" start , stop \" - extracts from start to stop \" start , \" - extracts from start to max \" start \" - extract exactly start \"\"\" def _deserialize ( self , value , attr , data , ** kwargs ): try : if isinstance ( value , list ): value = \";\" . join ( value ) if value is None or value == \"\" : # return [ None , None , None ] return slice ( None , None , None ) value = [ v or None for v in value.split ( ';' ) ] if value . __len__ () == 1 : return slice ( value [ 0 ] , value [ 0 ] ) if value . __len__ () > 2 : value [ 2 ] = int ( value [ 2 ] ) return slice (* value [ 0 : 3 ] ) # return value [ 0 : 3 ] except Exception as e : raise ValueError ( e ) Ancestors (in MRO) marshmallow.fields.String marshmallow.fields.Field marshmallow.base.FieldABC Class variables default_error_messages name parent root Instance variables context The context dictionary for the parent :class: Schema . default missing Methods deserialize def deserialize ( self , value : 'typing.Any' , attr : 'str | None' = None , data : 'typing.Mapping[str, typing.Any] | None' = None , ** kwargs ) Deserialize value . Parameters: Name Type Description Default value None The value to deserialize. None attr None The attribute/key in data to deserialize. None data None The raw input data passed to Schema.load . None kwargs None Field-specific keyword arguments. None Raises: Type Description ValidationError If an invalid value is passed or if a required value is missing. View Source def deserialize ( self , value : typing . Any , attr : str | None = None , data : typing . Mapping [ str , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Deserialize ``value``. :param value: The value to deserialize. :param attr: The attribute/key in `data` to deserialize. :param data: The raw input data passed to `Schema.load`. :param kwargs: Field-specific keyword arguments. :raise ValidationError: If an invalid value is passed or if a required value is missing. \"\" \" # Validate required fields, deserialize, then validate # deserialized value self . _validate_missing ( value ) if value is missing_ : _miss = self . load_default return _miss () if callable ( _miss ) else _miss if self . allow_none and value is None : return None output = self . _deserialize ( value , attr , data , ** kwargs ) self . _validate ( output ) return output fail def fail ( self , key : 'str' , ** kwargs ) Helper method that raises a ValidationError with an error message from self.error_messages . View Source def fail ( self , key : str , ** kwargs ) : \" \"\" Helper method that raises a `ValidationError` with an error message from ``self.error_messages``. .. deprecated:: 3.0.0 Use `make_error <marshmallow.fields.Field.make_error>` instead. \"\" \" warnings . warn ( '`Field.fail` is deprecated. Use `raise self.make_error(\"{}\", ...)` instead.' . format ( key ), RemovedInMarshmallow4Warning , stacklevel = 2 , ) raise self . make_error ( key = key , ** kwargs ) get_value def get_value ( self , obj , attr , accessor = None , default =< marshmallow . missing > ) Return the value for a given key from an object. Parameters: Name Type Description Default obj object The object to get the value from. None attr str The attribute/key in obj to get the value from. None accessor callable A callable used to retrieve the value of attr from the object obj . Defaults to marshmallow.utils.get_value . None View Source def get_value ( self , obj , attr , accessor = None , default = missing_ ) : \" \"\" Return the value for a given key from an object. :param object obj: The object to get the value from. :param str attr: The attribute/key in `obj` to get the value from. :param callable accessor: A callable used to retrieve the value of `attr` from the object `obj`. Defaults to `marshmallow.utils.get_value`. \"\" \" accessor_func = accessor or utils . get_value check_key = attr if self . attribute is None else self . attribute return accessor_func ( obj , check_key , default ) make_error def make_error ( self , key : 'str' , ** kwargs ) -> 'ValidationError' Helper method to make a ValidationError with an error message from self.error_messages . View Source def make_error ( self , key : str , ** kwargs ) -> ValidationError : \" \"\" Helper method to make a `ValidationError` with an error message from ``self.error_messages``. \"\" \" try : msg = self . error_messages [ key ] except KeyError as error : class_name = self . __class__ . __name__ message = ( \"ValidationError raised by `{class_name}`, but error key `{key}` does \" \"not exist in the `error_messages` dictionary.\" ). format ( class_name = class_name , key = key ) raise AssertionError ( message ) from error if isinstance ( msg , ( str , bytes )) : msg = msg . format ( ** kwargs ) return ValidationError ( msg ) serialize def serialize ( self , attr : 'str' , obj : 'typing.Any' , accessor : 'typing.Callable[[typing.Any, str, typing.Any], typing.Any] | None' = None , ** kwargs ) Pulls the value for the given key from the object, applies the field's formatting and returns the result. Parameters: Name Type Description Default attr None The attribute/key to get from the object. None obj None The object to access the attribute/key from. None accessor None Function used to access values from obj . None kwargs None Field-specific keyword arguments. None View Source def serialize ( self , attr : str , obj : typing . Any , accessor : typing . Callable [[ typing . Any , str , typing . Any ] , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Pulls the value for the given key from the object, applies the field's formatting and returns the result. :param attr: The attribute/key to get from the object. :param obj: The object to access the attribute/key from. :param accessor: Function used to access values from ``obj``. :param kwargs: Field-specific keyword arguments. \"\" \" if self . _CHECK_ATTRIBUTE : value = self . get_value ( obj , attr , accessor = accessor ) if value is missing_ : default = self . dump_default value = default () if callable ( default ) else default if value is missing_ : return value else : value = None return self . _serialize ( value , attr , obj , ** kwargs )","title":"Utils"},{"location":"reference/hielen3/utils/#module-hielen3utils","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 #!/usr/bin/env python # coding=utf-8 from datetime import datetime from re import split , sub , findall from time import mktime import json from importlib import import_module from falcon import HTTPNotAcceptable , HTTP_OK , Response , Request from hashlib import md5 from marshmallow import Schema , fields from numpy import datetime64 , isnat from collections.abc import Iterable from uuid import uuid4 from pandas import DataFrame def uuid (): return str ( uuid4 ()) def dataframe2jsonizabledict ( df : DataFrame , orient = 'records' , squeeze = True ): try : out = df . assign ( ** df . select_dtypes ([ 'datetime64' ]) . astype ( str )) . to_dict ( orient = orient ) if squeeze and out . __len__ () == 0 : out = [] if squeeze and out . __len__ () == 1 : out = out [ 0 ] except Exception as e : raise e out = [] return out def hug_output_format_conten_type ( handlers = [], error = \"The requested format does not match any of those allowed\" , ctpar = \"content_type\" , ): \"\"\"Returns a different handler depending on the input param ctpar If none match and no default is given falcon.HTTPNotAcceptable(error) is raised \"\"\" try : default = handlers [ 0 ] except Exception : default = None handlers = { h . content_type : h for h in handlers } def requested_output_type ( request = None ): try : par = request . _params [ ctpar ] handler = None for k , h in handlers . items (): if par . split ( \";\" )[ 0 ] == k . split ( \";\" )[ 0 ]: handler = h break except Exception : if default is not None : handler = default if handler is None : raise HTTPNotAcceptable ( error ) return handler def output_type ( data , request , response ): handler = requested_output_type ( request ) response . content_type = handler . content_type return handler ( data , request = request , response = response ) output_type . __doc__ = \"Supports any of the following formats: {0} \" . format ( \", \" . join ( function . __doc__ for function in handlers . values ()) ) output_type . content_type = \", \" . join ( handlers . keys ()) output_type . requested = requested_output_type return output_type def newinstanceof ( klass , * args , ** kwargs ): klass_ar = klass . split ( \".\" ) module = \".\" . join ( klass_ar [: - 1 ]) klass = klass_ar [ - 1 ] return getattr ( import_module ( module ), klass )( * args , ** kwargs ) def ut2isot ( u = None ): u = u or 1 return str ( datetime . fromtimestamp ( u )) def isot2ut ( t = None ): t = t or \"1970-01-01T01:00:01.00000Z\" try : dt = datetime ( * map ( int , split ( \"[^\\d]\" , sub ( \"[^\\d]$\" , \"\" , str ( t ))))) out = int ( mktime ( dt . timetuple ())) except Exception as e : print ( e , t ) return out def agoodtime ( t ): try : t = datetime64 ( t ) assert not isnat ( t ) t = str ( t ) except Exception : t = None return t def loadjsonfile ( filename ): with open ( filename ) as jf : return json . load ( jf ) def savejsonfile ( filename , struct ): with open ( filename , \"w\" ) as jf : json . dump ( struct , jf ) def eprint ( * args , fname = \"error\" , ** kwargs ): with open ( fname , \"a\" ) as f : print ( * args , file = f , ** kwargs ) def hasher ( * args , ** kwargs ): h = [ * args ] h . extend ( list ( kwargs . values ())) h = '' . join ([ str ( a ) for a in h ]) return md5 ( f ' { h } ' . encode () ) . hexdigest () def hashfile ( filename ): BLOCKSIZE = 65536 hasher = md5 () with open ( filename , \"rb\" ) as afile : buf = afile . read ( BLOCKSIZE ) while len ( buf ) > 0 : hasher . update ( buf ) buf = afile . read ( BLOCKSIZE ) return hasher . hexdigest () ### MARSHMALLOW class Selection ( fields . String ): \"\"\" Provides python object which pertims selection on narry. It axcept a three filed \\ string separated by \",\". \",\" presence is managed as: \"start,stop,step\" ie.: \"start,stop\" - extracts from start to stop \"start,\" - extracts from start to max \"start\" - extract exactly start \"\"\" def _deserialize ( self , value , attr , data , ** kwargs ): try : if isinstance ( value , list ): value = \";\" . join ( value ) if value is None or value == \"\" : #return [None,None,None] return slice ( None , None , None ) value = [ v or None for v in value . split ( ';' ) ] if value . __len__ () == 1 : return slice ( value [ 0 ], value [ 0 ]) if value . __len__ () > 2 : value [ 2 ] = int ( value [ 2 ]) return slice ( * value [ 0 : 3 ]) #return value[0:3] except Exception as e : raise ValueError ( e ) class JsonValidable : \"\"\" JSON Validator class. It is initailzed with a marshmallow.Schema instance. When __call__ function is invoked, \\ uses marshmallow facilities to validate the json and raise errors. Once initalized, changes __doc__ in order to descibe the json accepted. \"\"\" def __field_doc__ ( self , field ): required = field . required and \"!\" or \"\" allow_none = not field . allow_none and \"!\" or \"\" try : types = \"|\" . join ( self . TYPE_MAPPING [ field . __class__ ]) except KeyError : if field . __class__ is fields . List : f , required , allow_none = self . __field_doc__ ( field . inner ) types = f \"[ { f } ]\" elif field . __class__ is fields . Dict : kf , required , allow_none = self . __field_doc__ ( field . key_field ) vf , required , allow_none = self . __field_doc__ ( field . value_field ) types = f \" {{ { kf } , { vf } }} \" else : types = \"\" return ( types , required , allow_none ) def __schema_doc__ ( self ): flds = [] for n , f in self . schema . fields . items (): types , required , allow_none = self . __field_doc__ ( f ) # TODO formattare required e allow_none # flds.append( f\"**{n}**{required}{allow_none}: {types}\") flds . append ( f \"** { n } **: { types } \" ) fields = \", \" . join ( flds ) fields = f \" {{ { fields } }} \" if self . schema . many : fields = f \"[ { fields } ]\" return f \"JSON Schema { fields } \" def __init__ ( self , schema ): self . schema = schema self . TYPE_MAPPING = {} for k , w in self . schema . TYPE_MAPPING . items (): try : self . TYPE_MAPPING [ w ] . append ( findall ( r \"'(.*)'\" , str ( k ))[ 0 ]) except KeyError : self . TYPE_MAPPING [ w ] = [ findall ( r \"'(.*)'\" , str ( k ))[ 0 ]] self . __doc__ = str ( self . __schema_doc__ ()) def __call__ ( self , value ): if type ( value ) is list : # If Falcon is set to comma-separate entries, this segment joins them again. fixed_value = \",\" . join ( value ) else : fixed_value = value return self . schema . loads ( fixed_value ) class ResponseFormatter (): def parse_status ( status ): try : if int ( status . rsplit ( \" \" )[ 0 ]) < 400 : return \"ok\" else : return \"error\" except ValueError : return \"error\" def __init__ ( self , status = HTTP_OK , message = \"\" , data = \"\" ): self . status = status self . message = message self . data = data def format ( self , response : Response , request : Request = None ): body = dict ( meta = dict ( response = ResponseFormatter . parse_status ( self . status ), message = isinstance ( self . message , Iterable ) and self . message . __len__ () == 1 and self . message [ 0 ] or self . message , data_type = request and f \" { request . method } { request . path } \" or \"\" , ), data = self . data ) response . status = self . status response . body = json . dumps ( body ) return response","title":"Module hielen3.utils"},{"location":"reference/hielen3/utils/#variables","text":"HTTP_OK isnat","title":"Variables"},{"location":"reference/hielen3/utils/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/utils/#agoodtime","text":"def agoodtime ( t ) View Source def agoodtime ( t ) : try : t = datetime64 ( t ) assert not isnat ( t ) t = str ( t ) except Exception : t = None return t","title":"agoodtime"},{"location":"reference/hielen3/utils/#dataframe2jsonizabledict","text":"def dataframe2jsonizabledict ( df : pandas . core . frame . DataFrame , orient = 'records' , squeeze = True ) View Source def dataframe2jsonizabledict ( df: DataFrame , orient = ' records ', squeeze = True ) : try: out = df . assign ( ** df . select_dtypes ([' datetime64 ']). astype ( str )). to_dict ( orient = orient ) if squeeze and out . __len__ () == 0 : out = [] if squeeze and out . __len__ () == 1 : out = out [ 0 ] except Exception as e: raise e out = [] return out","title":"dataframe2jsonizabledict"},{"location":"reference/hielen3/utils/#eprint","text":"def eprint ( * args , fname = 'error' , ** kwargs ) View Source def eprint(*args, fname=\"error\", **kwargs): with open(fname, \"a\") as f: print(*args, file=f, **kwargs)","title":"eprint"},{"location":"reference/hielen3/utils/#hasher","text":"def hasher ( * args , ** kwargs ) View Source def hasher ( * args , ** kwargs ) : h = [ * args ] h . extend ( list ( kwargs . values ())) h = '' . join ( [ str ( a ) for a in h ] ) return md5 ( f '{h}' . encode () ) . hexdigest ()","title":"hasher"},{"location":"reference/hielen3/utils/#hashfile","text":"def hashfile ( filename ) View Source def hashfile ( filename ) : BLOCKSIZE = 65536 hasher = md5 () with open ( filename , \"rb\" ) as afile : buf = afile . read ( BLOCKSIZE ) while len ( buf ) > 0 : hasher . update ( buf ) buf = afile . read ( BLOCKSIZE ) return hasher . hexdigest ()","title":"hashfile"},{"location":"reference/hielen3/utils/#hug_output_format_conten_type","text":"def hug_output_format_conten_type ( handlers = [], error = 'The requested format does not match any of those allowed' , ctpar = 'content_type' ) Returns a different handler depending on the input param ctpar If none match and no default is given falcon.HTTPNotAcceptable(error) is raised View Source def hug_output_format_conten_type ( handlers = [] , error = \"The requested format does not match any of those allowed\" , ctpar = \"content_type\" , ) : \"\"\"Returns a different handler depending on the input param ctpar If none match and no default is given falcon.HTTPNotAcceptable(error) is raised \"\"\" try : default = handlers [ 0 ] except Exception : default = None handlers = { h . content_type : h for h in handlers } def requested_output_type ( request = None ) : try : par = request . _params [ ctpar ] handler = None for k , h in handlers . items () : if par . split ( \";\" ) [ 0 ] == k . split ( \";\" ) [ 0 ] : handler = h break except Exception : if default is not None : handler = default if handler is None : raise HTTPNotAcceptable ( error ) return handler def output_type ( data , request , response ) : handler = requested_output_type ( request ) response . content_type = handler . content_type return handler ( data , request = request , response = response ) output_type . __doc__ = \"Supports any of the following formats: {0}\" . format ( \", \" . join ( function . __doc__ for function in handlers . values ()) ) output_type . content_type = \", \" . join ( handlers . keys ()) output_type . requested = requested_output_type return output_type","title":"hug_output_format_conten_type"},{"location":"reference/hielen3/utils/#isot2ut","text":"def isot2ut ( t = None ) View Source def isot2ut ( t = None ) : t = t or \"1970-01-01T01:00:01.00000Z\" try : dt = datetime ( * map ( int , split ( \"[^\\d]\" , sub ( \"[^\\d]$\" , \"\" , str ( t ))))) out = int ( mktime ( dt . timetuple ())) except Exception as e : print ( e , t ) return out","title":"isot2ut"},{"location":"reference/hielen3/utils/#loadjsonfile","text":"def loadjsonfile ( filename ) View Source def loadjsonfile ( filename ): with open ( filename ) as jf : return json . load ( jf )","title":"loadjsonfile"},{"location":"reference/hielen3/utils/#newinstanceof","text":"def newinstanceof ( klass , * args , ** kwargs ) View Source def newinstanceof ( klass , * args , **kwargs ) : klass_ar = klass . split ( \".\" ) module = \".\" . join ( klass_ar [ :- 1 ]) klass = klass_ar [ - 1 ] return getattr ( import_module ( module ), klass )( * args , **kwargs )","title":"newinstanceof"},{"location":"reference/hielen3/utils/#savejsonfile","text":"def savejsonfile ( filename , struct ) View Source def savejsonfile(filename, struct): with open(filename, \"w\") as jf: json.dump(struct, jf)","title":"savejsonfile"},{"location":"reference/hielen3/utils/#ut2isot","text":"def ut2isot ( u = None ) View Source def ut2isot ( u = None ) : u = u or 1 return str ( datetime . fromtimestamp ( u ))","title":"ut2isot"},{"location":"reference/hielen3/utils/#uuid","text":"def uuid ( ) View Source def uuid () : return str ( uuid4 ())","title":"uuid"},{"location":"reference/hielen3/utils/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/utils/#jsonvalidable","text":"class JsonValidable ( schema ) JSON Validator class. It is initailzed with a marshmallow.Schema instance. When call function is invoked, uses marshmallow facilities to validate the json and raise errors. Once initalized, changes doc in order to descibe the json accepted. View Source class JsonValidable : \"\"\" JSON Validator class. It is initailzed with a marshmallow.Schema instance. When __call__ function is invoked, \\ uses marshmallow facilities to validate the json and raise errors. Once initalized, changes __doc__ in order to descibe the json accepted. \"\"\" def __field_doc__ ( self , field ) : required = field . required and \"!\" or \"\" allow_none = not field . allow_none and \"!\" or \"\" try : types = \"|\" . join ( self . TYPE_MAPPING [ field.__class__ ] ) except KeyError : if field . __class__ is fields . List : f , required , allow_none = self . __field_doc__ ( field . inner ) types = f \"[{f}]\" elif field . __class__ is fields . Dict : kf , required , allow_none = self . __field_doc__ ( field . key_field ) vf , required , allow_none = self . __field_doc__ ( field . value_field ) types = f \"{{{kf},{vf}}}\" else : types = \"\" return ( types , required , allow_none ) def __schema_doc__ ( self ) : flds = [] for n , f in self . schema . fields . items () : types , required , allow_none = self . __field_doc__ ( f ) # TODO formattare required e allow_none # flds . append ( f \"**{n}**{required}{allow_none}: {types}\" ) flds . append ( f \"**{n}**: {types}\" ) fields = \", \" . join ( flds ) fields = f \"{{{fields}}}\" if self . schema . many : fields = f \"[{fields}]\" return f \"JSON Schema {fields}\" def __init__ ( self , schema ) : self . schema = schema self . TYPE_MAPPING = {} for k , w in self . schema . TYPE_MAPPING . items () : try : self . TYPE_MAPPING [ w ] . append ( findall ( r \"'(.*)'\" , str ( k )) [ 0 ] ) except KeyError : self . TYPE_MAPPING [ w ] = [ findall(r\"'(.*)'\", str(k))[0 ] ] self . __doc__ = str ( self . __schema_doc__ ()) def __call__ ( self , value ) : if type ( value ) is list : # If Falcon is set to comma - separate entries , this segment joins them again . fixed_value = \",\" . join ( value ) else : fixed_value = value return self . schema . loads ( fixed_value )","title":"JsonValidable"},{"location":"reference/hielen3/utils/#responseformatter","text":"class ResponseFormatter ( status = '200 OK' , message = '' , data = '' ) View Source class ResponseFormatter (): def parse_status ( status ): try: if int ( status . rsplit ( \" \" )[ 0 ]) < 400 : return \"ok\" else: return \"error\" except ValueError: return \"error\" def __init__ ( self , status = HTTP_OK , message = \"\" , data = \"\" ): self . status = status self . message = message self . data = data def format ( self , response:Response , request:Request = None ): body = dict ( meta = dict ( response = ResponseFormatter . parse_status ( self . status ), message = isinstance ( self . message , Iterable ) and self . message . __len__ () == 1 and self . message [ 0 ] or self . message , data_type = request and f \"{request.method} {request.path}\" or \"\" , ), data = self . data ) response . status = self . status response . body = json . dumps ( body ) return response","title":"ResponseFormatter"},{"location":"reference/hielen3/utils/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/utils/#format","text":"def format ( self , response : falcon . response . Response , request : falcon . request . Request = None ) View Source def format ( self , response : Response , request : Request = None ) : body = dict ( meta = dict ( response = ResponseFormatter . parse_status ( self . status ) , message = isinstance ( self . message , Iterable ) and self . message . __len__ () == 1 and self . message [ 0 ] or self . message , data_type = request and f \"{request.method} {request.path}\" or \"\" , ) , data = self . data ) response . status = self . status response . body = json . dumps ( body ) return response","title":"format"},{"location":"reference/hielen3/utils/#parse_status","text":"def parse_status ( status ) View Source def parse_status ( status ) : try : if int ( status . rsplit ( \" \" ) [ 0 ] ) < 400 : return \"ok\" else : return \"error\" except ValueError : return \"error\"","title":"parse_status"},{"location":"reference/hielen3/utils/#selection","text":"class Selection ( * , load_default : 'typing.Any' = < marshmallow . missing > , missing : 'typing.Any' = < marshmallow . missing > , dump_default : 'typing.Any' = < marshmallow . missing > , default : 'typing.Any' = < marshmallow . missing > , data_key : 'str | None' = None , attribute : 'str | None' = None , validate : 'None | (typing.Callable[[typing.Any], typing.Any] | typing.Iterable[typing.Callable[[typing.Any], typing.Any]])' = None , required : 'bool' = False , allow_none : 'bool | None' = None , load_only : 'bool' = False , dump_only : 'bool' = False , error_messages : 'dict[str, str] | None' = None , metadata : 'typing.Mapping[str, typing.Any] | None' = None , ** additional_metadata ) Provides python object which pertims selection on narry. It axcept a three filed string separated by \",\". \",\" presence is managed as: \"start,stop,step\" ie.: \"start,stop\" - extracts from start to stop \"start,\" - extracts from start to max \"start\" - extract exactly start View Source class Selection ( fields . String ): \"\"\" Provides python object which pertims selection on narry. It axcept a three filed \\ string separated by \" , \". \" , \" presence is managed as: \" start , stop , step \" ie.: \" start , stop \" - extracts from start to stop \" start , \" - extracts from start to max \" start \" - extract exactly start \"\"\" def _deserialize ( self , value , attr , data , ** kwargs ): try : if isinstance ( value , list ): value = \";\" . join ( value ) if value is None or value == \"\" : # return [ None , None , None ] return slice ( None , None , None ) value = [ v or None for v in value.split ( ';' ) ] if value . __len__ () == 1 : return slice ( value [ 0 ] , value [ 0 ] ) if value . __len__ () > 2 : value [ 2 ] = int ( value [ 2 ] ) return slice (* value [ 0 : 3 ] ) # return value [ 0 : 3 ] except Exception as e : raise ValueError ( e )","title":"Selection"},{"location":"reference/hielen3/utils/#ancestors-in-mro","text":"marshmallow.fields.String marshmallow.fields.Field marshmallow.base.FieldABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/utils/#class-variables","text":"default_error_messages name parent root","title":"Class variables"},{"location":"reference/hielen3/utils/#instance-variables","text":"context The context dictionary for the parent :class: Schema . default missing","title":"Instance variables"},{"location":"reference/hielen3/utils/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/utils/#deserialize","text":"def deserialize ( self , value : 'typing.Any' , attr : 'str | None' = None , data : 'typing.Mapping[str, typing.Any] | None' = None , ** kwargs ) Deserialize value . Parameters: Name Type Description Default value None The value to deserialize. None attr None The attribute/key in data to deserialize. None data None The raw input data passed to Schema.load . None kwargs None Field-specific keyword arguments. None Raises: Type Description ValidationError If an invalid value is passed or if a required value is missing. View Source def deserialize ( self , value : typing . Any , attr : str | None = None , data : typing . Mapping [ str , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Deserialize ``value``. :param value: The value to deserialize. :param attr: The attribute/key in `data` to deserialize. :param data: The raw input data passed to `Schema.load`. :param kwargs: Field-specific keyword arguments. :raise ValidationError: If an invalid value is passed or if a required value is missing. \"\" \" # Validate required fields, deserialize, then validate # deserialized value self . _validate_missing ( value ) if value is missing_ : _miss = self . load_default return _miss () if callable ( _miss ) else _miss if self . allow_none and value is None : return None output = self . _deserialize ( value , attr , data , ** kwargs ) self . _validate ( output ) return output","title":"deserialize"},{"location":"reference/hielen3/utils/#fail","text":"def fail ( self , key : 'str' , ** kwargs ) Helper method that raises a ValidationError with an error message from self.error_messages . View Source def fail ( self , key : str , ** kwargs ) : \" \"\" Helper method that raises a `ValidationError` with an error message from ``self.error_messages``. .. deprecated:: 3.0.0 Use `make_error <marshmallow.fields.Field.make_error>` instead. \"\" \" warnings . warn ( '`Field.fail` is deprecated. Use `raise self.make_error(\"{}\", ...)` instead.' . format ( key ), RemovedInMarshmallow4Warning , stacklevel = 2 , ) raise self . make_error ( key = key , ** kwargs )","title":"fail"},{"location":"reference/hielen3/utils/#get_value","text":"def get_value ( self , obj , attr , accessor = None , default =< marshmallow . missing > ) Return the value for a given key from an object. Parameters: Name Type Description Default obj object The object to get the value from. None attr str The attribute/key in obj to get the value from. None accessor callable A callable used to retrieve the value of attr from the object obj . Defaults to marshmallow.utils.get_value . None View Source def get_value ( self , obj , attr , accessor = None , default = missing_ ) : \" \"\" Return the value for a given key from an object. :param object obj: The object to get the value from. :param str attr: The attribute/key in `obj` to get the value from. :param callable accessor: A callable used to retrieve the value of `attr` from the object `obj`. Defaults to `marshmallow.utils.get_value`. \"\" \" accessor_func = accessor or utils . get_value check_key = attr if self . attribute is None else self . attribute return accessor_func ( obj , check_key , default )","title":"get_value"},{"location":"reference/hielen3/utils/#make_error","text":"def make_error ( self , key : 'str' , ** kwargs ) -> 'ValidationError' Helper method to make a ValidationError with an error message from self.error_messages . View Source def make_error ( self , key : str , ** kwargs ) -> ValidationError : \" \"\" Helper method to make a `ValidationError` with an error message from ``self.error_messages``. \"\" \" try : msg = self . error_messages [ key ] except KeyError as error : class_name = self . __class__ . __name__ message = ( \"ValidationError raised by `{class_name}`, but error key `{key}` does \" \"not exist in the `error_messages` dictionary.\" ). format ( class_name = class_name , key = key ) raise AssertionError ( message ) from error if isinstance ( msg , ( str , bytes )) : msg = msg . format ( ** kwargs ) return ValidationError ( msg )","title":"make_error"},{"location":"reference/hielen3/utils/#serialize","text":"def serialize ( self , attr : 'str' , obj : 'typing.Any' , accessor : 'typing.Callable[[typing.Any, str, typing.Any], typing.Any] | None' = None , ** kwargs ) Pulls the value for the given key from the object, applies the field's formatting and returns the result. Parameters: Name Type Description Default attr None The attribute/key to get from the object. None obj None The object to access the attribute/key from. None accessor None Function used to access values from obj . None kwargs None Field-specific keyword arguments. None View Source def serialize ( self , attr : str , obj : typing . Any , accessor : typing . Callable [[ typing . Any , str , typing . Any ] , typing . Any ] | None = None , ** kwargs , ) : \" \"\" Pulls the value for the given key from the object, applies the field's formatting and returns the result. :param attr: The attribute/key to get from the object. :param obj: The object to access the attribute/key from. :param accessor: Function used to access values from ``obj``. :param kwargs: Field-specific keyword arguments. \"\" \" if self . _CHECK_ATTRIBUTE : value = self . get_value ( obj , attr , accessor = accessor ) if value is missing_ : default = self . dump_default value = default () if callable ( default ) else default if value is missing_ : return value else : value = None return self . _serialize ( value , attr , obj , ** kwargs )","title":"serialize"},{"location":"reference/hielen3/api/","text":"Module hielen3.api Sub-modules hielen3.api.actions hielen3.api.actionschemata hielen3.api.awskine hielen3.api.features hielen3.api.glob hielen3.api.hls hielen3.api.italferdatarate hielen3.api.prototypes hielen3.api.query hielen3.api.query2 hielen3.api.queue hielen3.api.status","title":"Index"},{"location":"reference/hielen3/api/#module-hielen3api","text":"","title":"Module hielen3.api"},{"location":"reference/hielen3/api/#sub-modules","text":"hielen3.api.actions hielen3.api.actionschemata hielen3.api.awskine hielen3.api.features hielen3.api.glob hielen3.api.hls hielen3.api.italferdatarate hielen3.api.prototypes hielen3.api.query hielen3.api.query2 hielen3.api.queue hielen3.api.status","title":"Sub-modules"},{"location":"reference/hielen3/api/actions/","text":"Module hielen3.api.actions View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 #!/usr/bin/env python # coding=utf-8 import hug import tempfile import falcon import os import time import json from hielen3 import db , conf from hielen3.feature import HFeature from hielen3.utils import ResponseFormatter from streaming_form_data import StreamingFormDataParser from streaming_form_data.targets import FileTarget , ValueTarget from urllib.parse import unquote from importlib import import_module from pathlib import Path , PosixPath import traceback ''' @hug.get(\"/{feature}\") def features_actions_values(feature, actions=None, timestamp=None, request=None, response=None): \"\"\" **Recupero dello stato corrente delle azioni effettuate su una feature** L'intento di questa api \u00e8 quello di fornire i valori richiesti secondo lo schema dell'azione ___nota 1___: `actions` accetta valori multipli separati da virgola ___nota 2___: A seconda dell'action richiesta, alcuni parametri potrebbero essere utilizzati in fase \\ di input ma non registrati. Il che vuol dire che per quei parametri il valore di ritorno sar\u00e0 null viene restituito una struttura di questo tipo: [ { \"feature\"*:..., \"action_name*\":..., \"timestamp\": ..., \"value\":{...} }, { \"feature\"*:..., \"action_name*\":..., \"timestamp\": ..., \"value\":{...} }, ... ] ___nota 3___ :(*) I campi \"feature\" e \"action\" potrebbero non essere restituiti nella struttura \\ nel caso in cui essi risultino non ambigui. \"timestamp\" e \"value\" vengono sempre restituiti Possibili risposte: - _404 Not Found_: Nel non venga trovata la feature richiesta o essa abbia un problema di \\ configurazione \"\"\" out = ResponseFormatter() # Trying to manage income feature request and its prototype configuration try: featobj = sourceman.sourceFactory(feature) out.data = featobj.getActionValues(actions,timestamp) if not isinstance(out.data,list): out.data=[out.data] except Exception as e: traceback.print_exc() out.status = falcon.HTTP_NOT_FOUND out.message = f\"feature '{feature}' does not exists or it is misconfigured: {e}\" out.format(request=request, response=response) return out.format(request=request, response=response) return @hug.get(\"/{feature}/{action}\") def feature_action_values(feature, action, timestamp=None, request=None, response=None): \"\"\" **Recupero dello stato corrente per una specifica azione di una specifica feature**\"\"\" return features_actions_values(feature, action, timestamp, request=request, response=response) @hug.delete(\"/{feature}/{action}\") def feature_action_delete(feature,action,timestamp,request=None,response=None): \"\"\" **Eliminazione di una determinata azione di una specifica feature**\"\"\" out = ResponseFormatter() # Trying to manage income feature request and its prototype configuration try: featobj = sourceman.sourceFactory(feature) out.data = featobj.deleteActionValues(action,timestamp) except Exception as e: traceback.print_exc() out.status = falcon.HTTP_NOT_FOUND out.message = f\"feature '{feature}' does not exists or it is misconfigured: {e}\" out.format(request=request, response=response) return out.format(request=request, response=response) return ''' @hug . post ( \"/ {feature} / {action} \" , parse_body = False ) @hug . default_input_format ( content_type = \"multipart/form-data\" ) def make_action ( feature , action , request = None , response = None ): \"\"\" **Esecuzione delle azioni** Richiede l'esecuzione di una specifica azione su una feature, fornendo tutte le informazioni \\ necessarie attraverso una form dinamica dedicata. - Oltre ai due parametri `feature` e `form`, `timestamp`, indicati nella url, accetta un \\ _multipart/form-data_ basato sulla specifica form, selezionata tramite i due parametri espliciti. - Tutto il content \u00e8 scaricato attarverso i chunk dello stream ('100 continue') per evitare il \\ timeout dei workers in caso di contenuti di grandi dimensioni. Possibili risposte: - _200 OK_: Nel caso in cui l'azione vada a buon fine. L'azione richiesta viene presa in carico ma \\ potrebbe avere un tempo di esecuzione arbitrario. L'azione quindi viene splittata su un altro processo. - _404 Not Found_: Nel caso la feature non esista o non sia definita per essa l'azione richiesta. - _500 Internal Server Error_: Nel caso pessimo che il modulo dichiarato non esista. - _501 Not Implemented'_: Nel caso la tipologia non fornisse ancora l'iplementazione di uno o tutti \\ i moduli di gestione E' stato implementato il meccanismo minimo di gestione che prevede il salvataggio delle info \\ fornite che possono essere fornite tali e quali in uscita (vedi metodo GET dell'api). Questo \\ meccanismo permette di svluppare i moduli a partire da un template con risposta di default. \"\"\" out = ResponseFormatter () # Trying to manage income feature request and its prototype configuration try : print ( \"A\" , feature ) featobj = HFeature . retrive ( feature ) print ( \"B\" , feature ) except KeyError as e : print ( \"C\" , feature ) traceback . print_exc () out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature ' { feature } ' does not exists or it is misconfigured: { e } \" out . format ( request = request , response = response ) return try : schema = featobj . schemata [ action ] except KeyError as e : raise e traceback . print_exc () out . status = falcon . HTTP_NOT_IMPLEMENTED out . message = f \"Prototype ' { featobj . ftype } ' actions not implemented.\" out . format ( request = request , response = response ) return except ModuleNotFoundError as e : traceback . print_exc () out . status = falcon . HTTP_INTERNAL_SERVER_ERROR out . message = f \"Prototype ' { featobj . ftype } ' module not found.\" out . format ( request = request , response = response ) return parser = StreamingFormDataParser ( headers = request . headers ) values = {} toremove = [] # TODO Differenziazione delle tipologie di input for k , w in schema [ \"fields\" ] . items (): if w == \"LocalFile\" : timenow = time . perf_counter () filepath = Path ( tempfile . gettempdir (), f \" { feature } . { k } . { timenow } .part\" ) target = FileTarget ( filepath ) parser . register ( k , target ) values [ k ] = filepath toremove . append ( filepath ) else : target = ValueTarget () parser . register ( k , target ) values [ k ] = target def removetempfiles ( toremove ): for v in toremove : try : os . unlink ( v ) except FileNotFoundError as e : pass while True : chunk = request . stream . read ( 8192 ) if not chunk : break parser . data_received ( chunk ) kwargs = {} for k , w in values . items (): model = schema [ \"fields\" ][ k ] if model == \"LocalFile\" : #v = os.path.exists(w) and str(w) or None v = str ( w ) elif model == \"FTPPath\" : v = unquote ( w . value . decode ( \"utf8\" )) or None if v is not None : v = Path ( v ) else : v = unquote ( w . value . decode ( \"utf8\" )) or None kwargs [ k ] = v m = [ m for m in schema [ \"required\" ] if kwargs [ m ] is None ] if m . __len__ (): out . status = falcon . HTTP_BAD_REQUEST out . message = f \"Required parameters { m } not supplied\" out . format ( request = request , response = response ) removetempfiles ( toremove ) return # CHECKS request checks ALL RIGHT. Continuing with code loading # Trying to initialize feature action manager module try : result = featobj . execute ( action , ** kwargs ) except AttributeError as e : raise e traceback . print_exc () out . status = falcon . HTTP_NOT_IMPLEMENTED out . message = f \"Action ' { action } ' not implemented.\" out . format ( request = request , response = response ) removetempfiles ( toremove ) return except Exception as e : traceback . print_exc () out . status = falcon . HTTP_BAD_REQUEST out . message = f \"Action values error: { e } .\" out . format ( request = request , response = response ) removetempfiles ( toremove ) return out . format ( request = request , response = response ) removetempfiles ( toremove ) return @hug . put ( \"/ {feature} / {action} \" , parse_body = False ) @hug . default_input_format ( content_type = \"multipart/form-data\" ) def update_action ( feature , action , request = None , response = None ): \"\"\" **Esecuzione delle azioni** Richiede l'esecuzione di una specifica azione su una feature, fornendo tutte le informazioni \\ necessarie attraverso una form dinamica dedicata. - Oltre ai due parametri `feature` e `form`, `timestamp`, indicati nella url, accetta un \\ _multipart/form-data_ basato sulla specifica form, selezionata tramite i due parametri espliciti. - Tutto il content \u00e8 scaricato attarverso i chunk dello stream ('100 continue') per evitare il \\ timeout dei workers in caso di contenuti di grandi dimensioni. Possibili risposte: - _200 OK_: Nel caso in cui l'azione vada a buon fine. L'azione richiesta viene presa in carico ma \\ potrebbe avere un tempo di esecuzione arbitrario. L'azione quindi viene splittata su un altro processo. - _404 Not Found_: Nel caso la feature non esista o non sia definita per essa l'azione richiesta. - _500 Internal Server Error_: Nel caso pessimo che il modulo dichiarato non esista. - _501 Not Implemented'_: Nel caso la tipologia non fornisse ancora l'iplementazione di uno o tutti \\ i moduli di gestione E' stato implementato il meccanismo minimo di gestione che prevede il salvataggio delle info \\ fornite che possono essere fornite tali e quali in uscita (vedi metodo GET dell'api). Questo \\ meccanismo permette di svluppare i moduli a partire da un template con risposta di default. \"\"\" out = ResponseFormatter () # Trying to manage income feature request and its prototype configuration try : featobj = sourceman . sourceFactory ( feature ) except KeyError as e : traceback . print_exc () out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature ' { feature } ' does not exists or it is misconfigured: { e } \" out . format ( request = request , response = response ) return try : schema = featobj . getActionSchema ( action ) except KeyError as e : traceback . print_exc () out . status = falcon . HTTP_NOT_IMPLEMENTED out . message = f \"Prototype ' { featobj . type } ' actions not implemented.\" out . format ( request = request , response = response ) return except ModuleNotFoundError as e : traceback . print_exc () out . status = falcon . HTTP_INTERNAL_SERVER_ERROR out . message = f \"Prototype ' { featobj . type } ' module not found.\" out . format ( request = request , response = response ) return parser = StreamingFormDataParser ( headers = request . headers ) values = {} toremove = [] # TODO Differenziazione delle tipologie di input for k , w in schema [ \"fields\" ] . items (): if w == \"LocalFile\" : timenow = time . perf_counter () filepath = Path ( tempfile . gettempdir (), f \" { feature } . { k } . { timenow } .part\" ) target = FileTarget ( filepath ) parser . register ( k , target ) values [ k ] = filepath toremove . append ( filepath ) else : target = ValueTarget () parser . register ( k , target ) values [ k ] = target def removetempfiles ( toremove ): for v in toremove : try : os . unlink ( v ) except FileNotFoundError as e : pass while True : chunk = request . stream . read ( 8192 ) if not chunk : break parser . data_received ( chunk ) kwargs = {} for k , w in values . items (): model = schema [ \"fields\" ][ k ] if model == \"LocalFile\" : #v = os.path.exists(w) and str(w) or None v = str ( w ) elif model == \"FTPPath\" : v = unquote ( w . value . decode ( \"utf8\" )) or None if v is not None : v = str ( Path ( conf [ 'ftproot' ], v )) else : v = unquote ( w . value . decode ( \"utf8\" )) or None kwargs [ k ] = v # CHECKS request checks ALL RIGHT. Continuing with code loading # Trying to initialize feature action manager module try : result = featobj . updateAction ( action , ** kwargs ) except AttributeError as e : traceback . print_exc () out . status = falcon . HTTP_NOT_IMPLEMENTED out . message = f \"Action ' { action } ' not implemented.\" out . format ( request = request , response = response ) removetempfiles ( toremove ) return except Exception as e : traceback . print_exc () out . status = falcon . HTTP_BAD_REQUEST out . message = f \"Action values error: { e } .\" out . format ( request = request , response = response ) removetempfiles ( toremove ) return try : db [ \"actions\" ][ feature , action , result [ 'timestamp' ]] = None except Exception : pass try : db [ \"actions\" ][ feature , action , result [ 'timestamp' ]] = { \"value\" : result } out . format ( request = request , response = response ) except KeyError as e : traceback . print_exc () out . status = falcon . HTTP_INTERNAL_SERVER_ERROR out . message = str ( e ) out . format ( request = request , response = response ) except ValueError as e : traceback . print_exc () out . status = falcon . HTTP_BAD_REQUEST out . message = str ( e ) out . format ( request = request , response = response ) removetempfiles ( toremove ) return Variables conf db Functions make_action def make_action ( feature , action , request = None , response = None ) Esecuzione delle azioni Richiede l'esecuzione di una specifica azione su una feature, fornendo tutte le informazioni necessarie attraverso una form dinamica dedicata. Oltre ai due parametri feature e form , timestamp , indicati nella url, accetta un multipart/form-data basato sulla specifica form, selezionata tramite i due parametri espliciti. Tutto il content \u00e8 scaricato attarverso i chunk dello stream ('100 continue') per evitare il timeout dei workers in caso di contenuti di grandi dimensioni. Possibili risposte: 200 OK : Nel caso in cui l'azione vada a buon fine. L'azione richiesta viene presa in carico ma potrebbe avere un tempo di esecuzione arbitrario. L'azione quindi viene splittata su un altro processo. 404 Not Found : Nel caso la feature non esista o non sia definita per essa l'azione richiesta. 500 Internal Server Error : Nel caso pessimo che il modulo dichiarato non esista. 501 Not Implemented' : Nel caso la tipologia non fornisse ancora l'iplementazione di uno o tutti i moduli di gestione E' stato implementato il meccanismo minimo di gestione che prevede il salvataggio delle info fornite che possono essere fornite tali e quali in uscita (vedi metodo GET dell'api). Questo meccanismo permette di svluppare i moduli a partire da un template con risposta di default. View Source @hug . post ( \"/{feature}/{action}\" , parse_body = False ) @hug . default_input_format ( content_type = \"multipart/form-data\" ) def make_action ( feature , action , request = None , response = None ) : \"\"\" **Esecuzione delle azioni** Richiede l'esecuzione di una specifica azione su una feature, fornendo tutte le informazioni \\ necessarie attraverso una form dinamica dedicata. - Oltre ai due parametri `feature` e `form`, `timestamp`, indicati nella url, accetta un \\ _multipart/form-data_ basato sulla specifica form, selezionata tramite i due parametri espliciti. - Tutto il content \u00e8 scaricato attarverso i chunk dello stream ('100 continue') per evitare il \\ timeout dei workers in caso di contenuti di grandi dimensioni. Possibili risposte: - _200 OK_: Nel caso in cui l'azione vada a buon fine. L'azione richiesta viene presa in carico ma \\ potrebbe avere un tempo di esecuzione arbitrario. L'azione quindi viene splittata su un altro processo. - _404 Not Found_: Nel caso la feature non esista o non sia definita per essa l'azione richiesta. - _500 Internal Server Error_: Nel caso pessimo che il modulo dichiarato non esista. - _501 Not Implemented'_: Nel caso la tipologia non fornisse ancora l'iplementazione di uno o tutti \\ i moduli di gestione E' stato implementato il meccanismo minimo di gestione che prevede il salvataggio delle info \\ fornite che possono essere fornite tali e quali in uscita (vedi metodo GET dell'api). Questo \\ meccanismo permette di svluppare i moduli a partire da un template con risposta di default. \"\"\" out = ResponseFormatter () # Trying to manage income feature request and its prototype configuration try : print ( \"A\" , feature ) featobj = HFeature . retrive ( feature ) print ( \"B\" , feature ) except KeyError as e : print ( \"C\" , feature ) traceback . print_exc () out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature '{feature}' does not exists or it is misconfigured: {e}\" out . format ( request = request , response = response ) return try : schema = featobj . schemata [ action ] except KeyError as e : raise e traceback . print_exc () out . status = falcon . HTTP_NOT_IMPLEMENTED out . message = f \"Prototype '{featobj.ftype}' actions not implemented.\" out . format ( request = request , response = response ) return except ModuleNotFoundError as e : traceback . print_exc () out . status = falcon . HTTP_INTERNAL_SERVER_ERROR out . message = f \"Prototype '{featobj.ftype}' module not found.\" out . format ( request = request , response = response ) return parser = StreamingFormDataParser ( headers = request . headers ) values = {} toremove = [] # TODO Differenziazione delle tipologie di input for k , w in schema [ \"fields\" ] . items () : if w == \"LocalFile\" : timenow = time . perf_counter () filepath = Path ( tempfile . gettempdir (), f \"{feature}.{k}.{timenow}.part\" ) target = FileTarget ( filepath ) parser . register ( k , target ) values [ k ] = filepath toremove . append ( filepath ) else : target = ValueTarget () parser . register ( k , target ) values [ k ] = target def removetempfiles ( toremove ) : for v in toremove : try : os . unlink ( v ) except FileNotFoundError as e : pass while True : chunk = request . stream . read ( 8192 ) if not chunk : break parser . data_received ( chunk ) kwargs = {} for k , w in values . items () : model = schema [ \"fields\" ][ k ] if model == \"LocalFile\" : #v = os . path . exists ( w ) and str ( w ) or None v = str ( w ) elif model == \"FTPPath\" : v = unquote ( w . value . decode ( \"utf8\" )) or None if v is not None : v = Path ( v ) else : v = unquote ( w . value . decode ( \"utf8\" )) or None kwargs [ k ] = v m = [ m for m in schema[\"required\" ] if kwargs [ m ] is None ] if m . __len__ () : out . status = falcon . HTTP_BAD_REQUEST out . message = f \"Required parameters {m} not supplied\" out . format ( request = request , response = response ) removetempfiles ( toremove ) return # CHECKS request checks ALL RIGHT . Continuing with code loading # Trying to initialize feature action manager module try : result = featobj . execute ( action , ** kwargs ) except AttributeError as e : raise e traceback . print_exc () out . status = falcon . HTTP_NOT_IMPLEMENTED out . message = f \"Action '{action}' not implemented.\" out . format ( request = request , response = response ) removetempfiles ( toremove ) return except Exception as e : traceback . print_exc () out . status = falcon . HTTP_BAD_REQUEST out . message = f \"Action values error: {e}.\" out . format ( request = request , response = response ) removetempfiles ( toremove ) return out . format ( request = request , response = response ) removetempfiles ( toremove ) return update_action def update_action ( feature , action , request = None , response = None ) Esecuzione delle azioni Richiede l'esecuzione di una specifica azione su una feature, fornendo tutte le informazioni necessarie attraverso una form dinamica dedicata. Oltre ai due parametri feature e form , timestamp , indicati nella url, accetta un multipart/form-data basato sulla specifica form, selezionata tramite i due parametri espliciti. Tutto il content \u00e8 scaricato attarverso i chunk dello stream ('100 continue') per evitare il timeout dei workers in caso di contenuti di grandi dimensioni. Possibili risposte: 200 OK : Nel caso in cui l'azione vada a buon fine. L'azione richiesta viene presa in carico ma potrebbe avere un tempo di esecuzione arbitrario. L'azione quindi viene splittata su un altro processo. 404 Not Found : Nel caso la feature non esista o non sia definita per essa l'azione richiesta. 500 Internal Server Error : Nel caso pessimo che il modulo dichiarato non esista. 501 Not Implemented' : Nel caso la tipologia non fornisse ancora l'iplementazione di uno o tutti i moduli di gestione E' stato implementato il meccanismo minimo di gestione che prevede il salvataggio delle info fornite che possono essere fornite tali e quali in uscita (vedi metodo GET dell'api). Questo meccanismo permette di svluppare i moduli a partire da un template con risposta di default. View Source @ hug . put ( \"/{feature}/{action}\" , parse_body = False ) @ hug . default_input_format ( content_type = \"multipart/form-data\" ) def update_action ( feature , action , request = None , response = None ): \"\"\" **Esecuzione delle azioni** Richiede l'esecuzione di una specifica azione su una feature, fornendo tutte le informazioni \\ necessarie attraverso una form dinamica dedicata. - Oltre ai due parametri `feature` e `form`, `timestamp`, indicati nella url, accetta un \\ _multipart/form-data_ basato sulla specifica form, selezionata tramite i due parametri espliciti. - Tutto il content \u00e8 scaricato attarverso i chunk dello stream ('100 continue') per evitare il \\ timeout dei workers in caso di contenuti di grandi dimensioni. Possibili risposte: - _200 OK_: Nel caso in cui l'azione vada a buon fine. L'azione richiesta viene presa in carico ma \\ potrebbe avere un tempo di esecuzione arbitrario. L'azione quindi viene splittata su un altro processo. - _404 Not Found_: Nel caso la feature non esista o non sia definita per essa l'azione richiesta. - _500 Internal Server Error_: Nel caso pessimo che il modulo dichiarato non esista. - _501 Not Implemented'_: Nel caso la tipologia non fornisse ancora l'iplementazione di uno o tutti \\ i moduli di gestione E' stato implementato il meccanismo minimo di gestione che prevede il salvataggio delle info \\ fornite che possono essere fornite tali e quali in uscita (vedi metodo GET dell'api). Questo \\ meccanismo permette di svluppare i moduli a partire da un template con risposta di default. \"\"\" out = ResponseFormatter () # Trying to manage income feature request and its prototype configuration try : featobj = sourceman . sourceFactory ( feature ) except KeyError as e : traceback . print_exc () out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature '{feature}' does not exists or it is misconfigured: {e}\" out . format ( request = request , response = response ) return try : schema = featobj . getActionSchema ( action ) except KeyError as e : traceback . print_exc () out . status = falcon . HTTP_NOT_IMPLEMENTED out . message = f \"Prototype '{featobj.type}' actions not implemented.\" out . format ( request = request , response = response ) return except ModuleNotFoundError as e : traceback . print_exc () out . status = falcon . HTTP_INTERNAL_SERVER_ERROR out . message = f \"Prototype '{featobj.type}' module not found.\" out . format ( request = request , response = response ) return parser = StreamingFormDataParser ( headers = request . headers ) values = {} toremove = [] # TODO Differenziazione delle tipologie di input for k , w in schema [ \"fields\" ] . items (): if w == \"LocalFile\" : timenow = time . perf_counter () filepath = Path ( tempfile . gettempdir (), f \"{feature}.{k}.{timenow}.part\" ) target = FileTarget ( filepath ) parser . register ( k , target ) values [ k ] = filepath toremove . append ( filepath ) else : target = ValueTarget () parser . register ( k , target ) values [ k ] = target def removetempfiles ( toremove ): for v in toremove : try : os . unlink ( v ) except FileNotFoundError as e : pass while True : chunk = request . stream . read ( 8192 ) if not chunk : break parser . data_received ( chunk ) kwargs = {} for k , w in values . items (): model = schema [ \"fields\" ][ k ] if model == \"LocalFile\" : #v = os.path.exists(w) and str(w) or None v = str ( w ) elif model == \"FTPPath\" : v = unquote ( w . value . decode ( \"utf8\" )) or None if v is not None : v = str ( Path ( conf [ 'ftproot' ], v )) else : v = unquote ( w . value . decode ( \"utf8\" )) or None kwargs [ k ] = v # CHECKS request checks ALL RIGHT. Continuing with code loading # Trying to initialize feature action manager module try : result = featobj . updateAction ( action , ** kwargs ) except AttributeError as e : traceback . print_exc () out . status = falcon . HTTP_NOT_IMPLEMENTED out . message = f \"Action '{action}' not implemented.\" out . format ( request = request , response = response ) removetempfiles ( toremove ) return except Exception as e : traceback . print_exc () out . status = falcon . HTTP_BAD_REQUEST out . message = f \"Action values error: {e}.\" out . format ( request = request , response = response ) removetempfiles ( toremove ) return try : db [ \"actions\" ][ feature , action , result [ 'timestamp' ]] = None except Exception : pass try : db [ \"actions\" ][ feature , action , result [ 'timestamp' ]] = { \"value\" : result } out . format ( request = request , response = response ) except KeyError as e : traceback . print_exc () out . status = falcon . HTTP_INTERNAL_SERVER_ERROR out . message = str ( e ) out . format ( request = request , response = response ) except ValueError as e : traceback . print_exc () out . status = falcon . HTTP_BAD_REQUEST out . message = str ( e ) out . format ( request = request , response = response ) removetempfiles ( toremove ) return","title":"Actions"},{"location":"reference/hielen3/api/actions/#module-hielen3apiactions","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 #!/usr/bin/env python # coding=utf-8 import hug import tempfile import falcon import os import time import json from hielen3 import db , conf from hielen3.feature import HFeature from hielen3.utils import ResponseFormatter from streaming_form_data import StreamingFormDataParser from streaming_form_data.targets import FileTarget , ValueTarget from urllib.parse import unquote from importlib import import_module from pathlib import Path , PosixPath import traceback ''' @hug.get(\"/{feature}\") def features_actions_values(feature, actions=None, timestamp=None, request=None, response=None): \"\"\" **Recupero dello stato corrente delle azioni effettuate su una feature** L'intento di questa api \u00e8 quello di fornire i valori richiesti secondo lo schema dell'azione ___nota 1___: `actions` accetta valori multipli separati da virgola ___nota 2___: A seconda dell'action richiesta, alcuni parametri potrebbero essere utilizzati in fase \\ di input ma non registrati. Il che vuol dire che per quei parametri il valore di ritorno sar\u00e0 null viene restituito una struttura di questo tipo: [ { \"feature\"*:..., \"action_name*\":..., \"timestamp\": ..., \"value\":{...} }, { \"feature\"*:..., \"action_name*\":..., \"timestamp\": ..., \"value\":{...} }, ... ] ___nota 3___ :(*) I campi \"feature\" e \"action\" potrebbero non essere restituiti nella struttura \\ nel caso in cui essi risultino non ambigui. \"timestamp\" e \"value\" vengono sempre restituiti Possibili risposte: - _404 Not Found_: Nel non venga trovata la feature richiesta o essa abbia un problema di \\ configurazione \"\"\" out = ResponseFormatter() # Trying to manage income feature request and its prototype configuration try: featobj = sourceman.sourceFactory(feature) out.data = featobj.getActionValues(actions,timestamp) if not isinstance(out.data,list): out.data=[out.data] except Exception as e: traceback.print_exc() out.status = falcon.HTTP_NOT_FOUND out.message = f\"feature '{feature}' does not exists or it is misconfigured: {e}\" out.format(request=request, response=response) return out.format(request=request, response=response) return @hug.get(\"/{feature}/{action}\") def feature_action_values(feature, action, timestamp=None, request=None, response=None): \"\"\" **Recupero dello stato corrente per una specifica azione di una specifica feature**\"\"\" return features_actions_values(feature, action, timestamp, request=request, response=response) @hug.delete(\"/{feature}/{action}\") def feature_action_delete(feature,action,timestamp,request=None,response=None): \"\"\" **Eliminazione di una determinata azione di una specifica feature**\"\"\" out = ResponseFormatter() # Trying to manage income feature request and its prototype configuration try: featobj = sourceman.sourceFactory(feature) out.data = featobj.deleteActionValues(action,timestamp) except Exception as e: traceback.print_exc() out.status = falcon.HTTP_NOT_FOUND out.message = f\"feature '{feature}' does not exists or it is misconfigured: {e}\" out.format(request=request, response=response) return out.format(request=request, response=response) return ''' @hug . post ( \"/ {feature} / {action} \" , parse_body = False ) @hug . default_input_format ( content_type = \"multipart/form-data\" ) def make_action ( feature , action , request = None , response = None ): \"\"\" **Esecuzione delle azioni** Richiede l'esecuzione di una specifica azione su una feature, fornendo tutte le informazioni \\ necessarie attraverso una form dinamica dedicata. - Oltre ai due parametri `feature` e `form`, `timestamp`, indicati nella url, accetta un \\ _multipart/form-data_ basato sulla specifica form, selezionata tramite i due parametri espliciti. - Tutto il content \u00e8 scaricato attarverso i chunk dello stream ('100 continue') per evitare il \\ timeout dei workers in caso di contenuti di grandi dimensioni. Possibili risposte: - _200 OK_: Nel caso in cui l'azione vada a buon fine. L'azione richiesta viene presa in carico ma \\ potrebbe avere un tempo di esecuzione arbitrario. L'azione quindi viene splittata su un altro processo. - _404 Not Found_: Nel caso la feature non esista o non sia definita per essa l'azione richiesta. - _500 Internal Server Error_: Nel caso pessimo che il modulo dichiarato non esista. - _501 Not Implemented'_: Nel caso la tipologia non fornisse ancora l'iplementazione di uno o tutti \\ i moduli di gestione E' stato implementato il meccanismo minimo di gestione che prevede il salvataggio delle info \\ fornite che possono essere fornite tali e quali in uscita (vedi metodo GET dell'api). Questo \\ meccanismo permette di svluppare i moduli a partire da un template con risposta di default. \"\"\" out = ResponseFormatter () # Trying to manage income feature request and its prototype configuration try : print ( \"A\" , feature ) featobj = HFeature . retrive ( feature ) print ( \"B\" , feature ) except KeyError as e : print ( \"C\" , feature ) traceback . print_exc () out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature ' { feature } ' does not exists or it is misconfigured: { e } \" out . format ( request = request , response = response ) return try : schema = featobj . schemata [ action ] except KeyError as e : raise e traceback . print_exc () out . status = falcon . HTTP_NOT_IMPLEMENTED out . message = f \"Prototype ' { featobj . ftype } ' actions not implemented.\" out . format ( request = request , response = response ) return except ModuleNotFoundError as e : traceback . print_exc () out . status = falcon . HTTP_INTERNAL_SERVER_ERROR out . message = f \"Prototype ' { featobj . ftype } ' module not found.\" out . format ( request = request , response = response ) return parser = StreamingFormDataParser ( headers = request . headers ) values = {} toremove = [] # TODO Differenziazione delle tipologie di input for k , w in schema [ \"fields\" ] . items (): if w == \"LocalFile\" : timenow = time . perf_counter () filepath = Path ( tempfile . gettempdir (), f \" { feature } . { k } . { timenow } .part\" ) target = FileTarget ( filepath ) parser . register ( k , target ) values [ k ] = filepath toremove . append ( filepath ) else : target = ValueTarget () parser . register ( k , target ) values [ k ] = target def removetempfiles ( toremove ): for v in toremove : try : os . unlink ( v ) except FileNotFoundError as e : pass while True : chunk = request . stream . read ( 8192 ) if not chunk : break parser . data_received ( chunk ) kwargs = {} for k , w in values . items (): model = schema [ \"fields\" ][ k ] if model == \"LocalFile\" : #v = os.path.exists(w) and str(w) or None v = str ( w ) elif model == \"FTPPath\" : v = unquote ( w . value . decode ( \"utf8\" )) or None if v is not None : v = Path ( v ) else : v = unquote ( w . value . decode ( \"utf8\" )) or None kwargs [ k ] = v m = [ m for m in schema [ \"required\" ] if kwargs [ m ] is None ] if m . __len__ (): out . status = falcon . HTTP_BAD_REQUEST out . message = f \"Required parameters { m } not supplied\" out . format ( request = request , response = response ) removetempfiles ( toremove ) return # CHECKS request checks ALL RIGHT. Continuing with code loading # Trying to initialize feature action manager module try : result = featobj . execute ( action , ** kwargs ) except AttributeError as e : raise e traceback . print_exc () out . status = falcon . HTTP_NOT_IMPLEMENTED out . message = f \"Action ' { action } ' not implemented.\" out . format ( request = request , response = response ) removetempfiles ( toremove ) return except Exception as e : traceback . print_exc () out . status = falcon . HTTP_BAD_REQUEST out . message = f \"Action values error: { e } .\" out . format ( request = request , response = response ) removetempfiles ( toremove ) return out . format ( request = request , response = response ) removetempfiles ( toremove ) return @hug . put ( \"/ {feature} / {action} \" , parse_body = False ) @hug . default_input_format ( content_type = \"multipart/form-data\" ) def update_action ( feature , action , request = None , response = None ): \"\"\" **Esecuzione delle azioni** Richiede l'esecuzione di una specifica azione su una feature, fornendo tutte le informazioni \\ necessarie attraverso una form dinamica dedicata. - Oltre ai due parametri `feature` e `form`, `timestamp`, indicati nella url, accetta un \\ _multipart/form-data_ basato sulla specifica form, selezionata tramite i due parametri espliciti. - Tutto il content \u00e8 scaricato attarverso i chunk dello stream ('100 continue') per evitare il \\ timeout dei workers in caso di contenuti di grandi dimensioni. Possibili risposte: - _200 OK_: Nel caso in cui l'azione vada a buon fine. L'azione richiesta viene presa in carico ma \\ potrebbe avere un tempo di esecuzione arbitrario. L'azione quindi viene splittata su un altro processo. - _404 Not Found_: Nel caso la feature non esista o non sia definita per essa l'azione richiesta. - _500 Internal Server Error_: Nel caso pessimo che il modulo dichiarato non esista. - _501 Not Implemented'_: Nel caso la tipologia non fornisse ancora l'iplementazione di uno o tutti \\ i moduli di gestione E' stato implementato il meccanismo minimo di gestione che prevede il salvataggio delle info \\ fornite che possono essere fornite tali e quali in uscita (vedi metodo GET dell'api). Questo \\ meccanismo permette di svluppare i moduli a partire da un template con risposta di default. \"\"\" out = ResponseFormatter () # Trying to manage income feature request and its prototype configuration try : featobj = sourceman . sourceFactory ( feature ) except KeyError as e : traceback . print_exc () out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature ' { feature } ' does not exists or it is misconfigured: { e } \" out . format ( request = request , response = response ) return try : schema = featobj . getActionSchema ( action ) except KeyError as e : traceback . print_exc () out . status = falcon . HTTP_NOT_IMPLEMENTED out . message = f \"Prototype ' { featobj . type } ' actions not implemented.\" out . format ( request = request , response = response ) return except ModuleNotFoundError as e : traceback . print_exc () out . status = falcon . HTTP_INTERNAL_SERVER_ERROR out . message = f \"Prototype ' { featobj . type } ' module not found.\" out . format ( request = request , response = response ) return parser = StreamingFormDataParser ( headers = request . headers ) values = {} toremove = [] # TODO Differenziazione delle tipologie di input for k , w in schema [ \"fields\" ] . items (): if w == \"LocalFile\" : timenow = time . perf_counter () filepath = Path ( tempfile . gettempdir (), f \" { feature } . { k } . { timenow } .part\" ) target = FileTarget ( filepath ) parser . register ( k , target ) values [ k ] = filepath toremove . append ( filepath ) else : target = ValueTarget () parser . register ( k , target ) values [ k ] = target def removetempfiles ( toremove ): for v in toremove : try : os . unlink ( v ) except FileNotFoundError as e : pass while True : chunk = request . stream . read ( 8192 ) if not chunk : break parser . data_received ( chunk ) kwargs = {} for k , w in values . items (): model = schema [ \"fields\" ][ k ] if model == \"LocalFile\" : #v = os.path.exists(w) and str(w) or None v = str ( w ) elif model == \"FTPPath\" : v = unquote ( w . value . decode ( \"utf8\" )) or None if v is not None : v = str ( Path ( conf [ 'ftproot' ], v )) else : v = unquote ( w . value . decode ( \"utf8\" )) or None kwargs [ k ] = v # CHECKS request checks ALL RIGHT. Continuing with code loading # Trying to initialize feature action manager module try : result = featobj . updateAction ( action , ** kwargs ) except AttributeError as e : traceback . print_exc () out . status = falcon . HTTP_NOT_IMPLEMENTED out . message = f \"Action ' { action } ' not implemented.\" out . format ( request = request , response = response ) removetempfiles ( toremove ) return except Exception as e : traceback . print_exc () out . status = falcon . HTTP_BAD_REQUEST out . message = f \"Action values error: { e } .\" out . format ( request = request , response = response ) removetempfiles ( toremove ) return try : db [ \"actions\" ][ feature , action , result [ 'timestamp' ]] = None except Exception : pass try : db [ \"actions\" ][ feature , action , result [ 'timestamp' ]] = { \"value\" : result } out . format ( request = request , response = response ) except KeyError as e : traceback . print_exc () out . status = falcon . HTTP_INTERNAL_SERVER_ERROR out . message = str ( e ) out . format ( request = request , response = response ) except ValueError as e : traceback . print_exc () out . status = falcon . HTTP_BAD_REQUEST out . message = str ( e ) out . format ( request = request , response = response ) removetempfiles ( toremove ) return","title":"Module hielen3.api.actions"},{"location":"reference/hielen3/api/actions/#variables","text":"conf db","title":"Variables"},{"location":"reference/hielen3/api/actions/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/api/actions/#make_action","text":"def make_action ( feature , action , request = None , response = None ) Esecuzione delle azioni Richiede l'esecuzione di una specifica azione su una feature, fornendo tutte le informazioni necessarie attraverso una form dinamica dedicata. Oltre ai due parametri feature e form , timestamp , indicati nella url, accetta un multipart/form-data basato sulla specifica form, selezionata tramite i due parametri espliciti. Tutto il content \u00e8 scaricato attarverso i chunk dello stream ('100 continue') per evitare il timeout dei workers in caso di contenuti di grandi dimensioni. Possibili risposte: 200 OK : Nel caso in cui l'azione vada a buon fine. L'azione richiesta viene presa in carico ma potrebbe avere un tempo di esecuzione arbitrario. L'azione quindi viene splittata su un altro processo. 404 Not Found : Nel caso la feature non esista o non sia definita per essa l'azione richiesta. 500 Internal Server Error : Nel caso pessimo che il modulo dichiarato non esista. 501 Not Implemented' : Nel caso la tipologia non fornisse ancora l'iplementazione di uno o tutti i moduli di gestione E' stato implementato il meccanismo minimo di gestione che prevede il salvataggio delle info fornite che possono essere fornite tali e quali in uscita (vedi metodo GET dell'api). Questo meccanismo permette di svluppare i moduli a partire da un template con risposta di default. View Source @hug . post ( \"/{feature}/{action}\" , parse_body = False ) @hug . default_input_format ( content_type = \"multipart/form-data\" ) def make_action ( feature , action , request = None , response = None ) : \"\"\" **Esecuzione delle azioni** Richiede l'esecuzione di una specifica azione su una feature, fornendo tutte le informazioni \\ necessarie attraverso una form dinamica dedicata. - Oltre ai due parametri `feature` e `form`, `timestamp`, indicati nella url, accetta un \\ _multipart/form-data_ basato sulla specifica form, selezionata tramite i due parametri espliciti. - Tutto il content \u00e8 scaricato attarverso i chunk dello stream ('100 continue') per evitare il \\ timeout dei workers in caso di contenuti di grandi dimensioni. Possibili risposte: - _200 OK_: Nel caso in cui l'azione vada a buon fine. L'azione richiesta viene presa in carico ma \\ potrebbe avere un tempo di esecuzione arbitrario. L'azione quindi viene splittata su un altro processo. - _404 Not Found_: Nel caso la feature non esista o non sia definita per essa l'azione richiesta. - _500 Internal Server Error_: Nel caso pessimo che il modulo dichiarato non esista. - _501 Not Implemented'_: Nel caso la tipologia non fornisse ancora l'iplementazione di uno o tutti \\ i moduli di gestione E' stato implementato il meccanismo minimo di gestione che prevede il salvataggio delle info \\ fornite che possono essere fornite tali e quali in uscita (vedi metodo GET dell'api). Questo \\ meccanismo permette di svluppare i moduli a partire da un template con risposta di default. \"\"\" out = ResponseFormatter () # Trying to manage income feature request and its prototype configuration try : print ( \"A\" , feature ) featobj = HFeature . retrive ( feature ) print ( \"B\" , feature ) except KeyError as e : print ( \"C\" , feature ) traceback . print_exc () out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature '{feature}' does not exists or it is misconfigured: {e}\" out . format ( request = request , response = response ) return try : schema = featobj . schemata [ action ] except KeyError as e : raise e traceback . print_exc () out . status = falcon . HTTP_NOT_IMPLEMENTED out . message = f \"Prototype '{featobj.ftype}' actions not implemented.\" out . format ( request = request , response = response ) return except ModuleNotFoundError as e : traceback . print_exc () out . status = falcon . HTTP_INTERNAL_SERVER_ERROR out . message = f \"Prototype '{featobj.ftype}' module not found.\" out . format ( request = request , response = response ) return parser = StreamingFormDataParser ( headers = request . headers ) values = {} toremove = [] # TODO Differenziazione delle tipologie di input for k , w in schema [ \"fields\" ] . items () : if w == \"LocalFile\" : timenow = time . perf_counter () filepath = Path ( tempfile . gettempdir (), f \"{feature}.{k}.{timenow}.part\" ) target = FileTarget ( filepath ) parser . register ( k , target ) values [ k ] = filepath toremove . append ( filepath ) else : target = ValueTarget () parser . register ( k , target ) values [ k ] = target def removetempfiles ( toremove ) : for v in toremove : try : os . unlink ( v ) except FileNotFoundError as e : pass while True : chunk = request . stream . read ( 8192 ) if not chunk : break parser . data_received ( chunk ) kwargs = {} for k , w in values . items () : model = schema [ \"fields\" ][ k ] if model == \"LocalFile\" : #v = os . path . exists ( w ) and str ( w ) or None v = str ( w ) elif model == \"FTPPath\" : v = unquote ( w . value . decode ( \"utf8\" )) or None if v is not None : v = Path ( v ) else : v = unquote ( w . value . decode ( \"utf8\" )) or None kwargs [ k ] = v m = [ m for m in schema[\"required\" ] if kwargs [ m ] is None ] if m . __len__ () : out . status = falcon . HTTP_BAD_REQUEST out . message = f \"Required parameters {m} not supplied\" out . format ( request = request , response = response ) removetempfiles ( toremove ) return # CHECKS request checks ALL RIGHT . Continuing with code loading # Trying to initialize feature action manager module try : result = featobj . execute ( action , ** kwargs ) except AttributeError as e : raise e traceback . print_exc () out . status = falcon . HTTP_NOT_IMPLEMENTED out . message = f \"Action '{action}' not implemented.\" out . format ( request = request , response = response ) removetempfiles ( toremove ) return except Exception as e : traceback . print_exc () out . status = falcon . HTTP_BAD_REQUEST out . message = f \"Action values error: {e}.\" out . format ( request = request , response = response ) removetempfiles ( toremove ) return out . format ( request = request , response = response ) removetempfiles ( toremove ) return","title":"make_action"},{"location":"reference/hielen3/api/actions/#update_action","text":"def update_action ( feature , action , request = None , response = None ) Esecuzione delle azioni Richiede l'esecuzione di una specifica azione su una feature, fornendo tutte le informazioni necessarie attraverso una form dinamica dedicata. Oltre ai due parametri feature e form , timestamp , indicati nella url, accetta un multipart/form-data basato sulla specifica form, selezionata tramite i due parametri espliciti. Tutto il content \u00e8 scaricato attarverso i chunk dello stream ('100 continue') per evitare il timeout dei workers in caso di contenuti di grandi dimensioni. Possibili risposte: 200 OK : Nel caso in cui l'azione vada a buon fine. L'azione richiesta viene presa in carico ma potrebbe avere un tempo di esecuzione arbitrario. L'azione quindi viene splittata su un altro processo. 404 Not Found : Nel caso la feature non esista o non sia definita per essa l'azione richiesta. 500 Internal Server Error : Nel caso pessimo che il modulo dichiarato non esista. 501 Not Implemented' : Nel caso la tipologia non fornisse ancora l'iplementazione di uno o tutti i moduli di gestione E' stato implementato il meccanismo minimo di gestione che prevede il salvataggio delle info fornite che possono essere fornite tali e quali in uscita (vedi metodo GET dell'api). Questo meccanismo permette di svluppare i moduli a partire da un template con risposta di default. View Source @ hug . put ( \"/{feature}/{action}\" , parse_body = False ) @ hug . default_input_format ( content_type = \"multipart/form-data\" ) def update_action ( feature , action , request = None , response = None ): \"\"\" **Esecuzione delle azioni** Richiede l'esecuzione di una specifica azione su una feature, fornendo tutte le informazioni \\ necessarie attraverso una form dinamica dedicata. - Oltre ai due parametri `feature` e `form`, `timestamp`, indicati nella url, accetta un \\ _multipart/form-data_ basato sulla specifica form, selezionata tramite i due parametri espliciti. - Tutto il content \u00e8 scaricato attarverso i chunk dello stream ('100 continue') per evitare il \\ timeout dei workers in caso di contenuti di grandi dimensioni. Possibili risposte: - _200 OK_: Nel caso in cui l'azione vada a buon fine. L'azione richiesta viene presa in carico ma \\ potrebbe avere un tempo di esecuzione arbitrario. L'azione quindi viene splittata su un altro processo. - _404 Not Found_: Nel caso la feature non esista o non sia definita per essa l'azione richiesta. - _500 Internal Server Error_: Nel caso pessimo che il modulo dichiarato non esista. - _501 Not Implemented'_: Nel caso la tipologia non fornisse ancora l'iplementazione di uno o tutti \\ i moduli di gestione E' stato implementato il meccanismo minimo di gestione che prevede il salvataggio delle info \\ fornite che possono essere fornite tali e quali in uscita (vedi metodo GET dell'api). Questo \\ meccanismo permette di svluppare i moduli a partire da un template con risposta di default. \"\"\" out = ResponseFormatter () # Trying to manage income feature request and its prototype configuration try : featobj = sourceman . sourceFactory ( feature ) except KeyError as e : traceback . print_exc () out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature '{feature}' does not exists or it is misconfigured: {e}\" out . format ( request = request , response = response ) return try : schema = featobj . getActionSchema ( action ) except KeyError as e : traceback . print_exc () out . status = falcon . HTTP_NOT_IMPLEMENTED out . message = f \"Prototype '{featobj.type}' actions not implemented.\" out . format ( request = request , response = response ) return except ModuleNotFoundError as e : traceback . print_exc () out . status = falcon . HTTP_INTERNAL_SERVER_ERROR out . message = f \"Prototype '{featobj.type}' module not found.\" out . format ( request = request , response = response ) return parser = StreamingFormDataParser ( headers = request . headers ) values = {} toremove = [] # TODO Differenziazione delle tipologie di input for k , w in schema [ \"fields\" ] . items (): if w == \"LocalFile\" : timenow = time . perf_counter () filepath = Path ( tempfile . gettempdir (), f \"{feature}.{k}.{timenow}.part\" ) target = FileTarget ( filepath ) parser . register ( k , target ) values [ k ] = filepath toremove . append ( filepath ) else : target = ValueTarget () parser . register ( k , target ) values [ k ] = target def removetempfiles ( toremove ): for v in toremove : try : os . unlink ( v ) except FileNotFoundError as e : pass while True : chunk = request . stream . read ( 8192 ) if not chunk : break parser . data_received ( chunk ) kwargs = {} for k , w in values . items (): model = schema [ \"fields\" ][ k ] if model == \"LocalFile\" : #v = os.path.exists(w) and str(w) or None v = str ( w ) elif model == \"FTPPath\" : v = unquote ( w . value . decode ( \"utf8\" )) or None if v is not None : v = str ( Path ( conf [ 'ftproot' ], v )) else : v = unquote ( w . value . decode ( \"utf8\" )) or None kwargs [ k ] = v # CHECKS request checks ALL RIGHT. Continuing with code loading # Trying to initialize feature action manager module try : result = featobj . updateAction ( action , ** kwargs ) except AttributeError as e : traceback . print_exc () out . status = falcon . HTTP_NOT_IMPLEMENTED out . message = f \"Action '{action}' not implemented.\" out . format ( request = request , response = response ) removetempfiles ( toremove ) return except Exception as e : traceback . print_exc () out . status = falcon . HTTP_BAD_REQUEST out . message = f \"Action values error: {e}.\" out . format ( request = request , response = response ) removetempfiles ( toremove ) return try : db [ \"actions\" ][ feature , action , result [ 'timestamp' ]] = None except Exception : pass try : db [ \"actions\" ][ feature , action , result [ 'timestamp' ]] = { \"value\" : result } out . format ( request = request , response = response ) except KeyError as e : traceback . print_exc () out . status = falcon . HTTP_INTERNAL_SERVER_ERROR out . message = str ( e ) out . format ( request = request , response = response ) except ValueError as e : traceback . print_exc () out . status = falcon . HTTP_BAD_REQUEST out . message = str ( e ) out . format ( request = request , response = response ) removetempfiles ( toremove ) return","title":"update_action"},{"location":"reference/hielen3/api/actionschemata/","text":"Module hielen3.api.actionschemata View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 #!/usr/bin/env python # coding=utf-8 import hug import falcon from hielen3 import db from hielen3.feature import HFeature from hielen3.utils import ResponseFormatter @hug . get ( \"/\" ) def get_actions_schemata ( prototypes = None , actions = None , request = None , response = None ): \"\"\" **Recupero dello schema dei parametri per inizializare le forms delle azioni** ritorna una struttura json di questo tipo: { \"NomePrototipo1\": { \"action1\": { \"args\": { \"arg1.1\": \"type_arg1.1\", \"arg1.2\": \"type_arg1.2\", ... }, \"mandatory\": [ args keys sublist ] }, \"action2\": { \"args\": { \"arg2.1\": \"type_arg2.1\", \"arg2.2\": \"type_arg2.2\", ... }, }, ... }, \"NomePrototipo3\": { ... }, ... }, \"\"\" out = ResponseFormatter () try : out . data = HFeature . actions_schemata ( prototypes , actions ) except KeyError as e : out . data = {} #out.status = out.status = falcon.HTTP_NOT_FOUND out . message = e . args response = out . format ( response = response , request = request ) @hug . get ( \"/ {prototype} \" ) def get_action_schemata ( prototype , actions = None , request = None , response = None ): \"\"\" **Alias per il recupero di tutte le informazioni di uno specifico prototipo** \"\"\" return get_actions_schemata ( prototype , actions , request , response ) @hug . get ( \"/ {prototype} / {action} \" ) def get_action_schema ( prototype , action , request = None , response = None ): \"\"\" **Alias per il recupero di tutte le informazioni delle form di uno specifico prototipo** \"\"\" return get_actions_schemata ( prototype , action , request , response ) Variables db Functions get_action_schema def get_action_schema ( prototype , action , request = None , response = None ) Alias per il recupero di tutte le informazioni delle form di uno specifico prototipo View Source @hug . get ( \"/{prototype}/{action}\" ) def get_action_schema ( prototype , action , request = None , response = None ) : \"\"\" **Alias per il recupero di tutte le informazioni delle form di uno specifico prototipo** \"\"\" return get_actions_schemata ( prototype , action , request , response ) get_action_schemata def get_action_schemata ( prototype , actions = None , request = None , response = None ) Alias per il recupero di tutte le informazioni di uno specifico prototipo View Source @hug . get ( \"/{prototype}\" ) def get_action_schemata ( prototype , actions = None , request = None , response = None ) : \"\"\" **Alias per il recupero di tutte le informazioni di uno specifico prototipo** \"\"\" return get_actions_schemata ( prototype , actions , request , response ) get_actions_schemata def get_actions_schemata ( prototypes = None , actions = None , request = None , response = None ) Recupero dello schema dei parametri per inizializare le forms delle azioni ritorna una struttura json di questo tipo: { \"NomePrototipo1\": { \"action1\": { \"args\": { \"arg1.1\": \"type_arg1.1\", \"arg1.2\": \"type_arg1.2\", ... }, \"mandatory\": [ args keys sublist ] }, \"action2\": { \"args\": { \"arg2.1\": \"type_arg2.1\", \"arg2.2\": \"type_arg2.2\", ... }, }, ... }, \"NomePrototipo3\": { ... }, ... }, View Source @hug . get ( \"/\" ) def get_actions_schemata ( prototypes = None , actions = None , request = None , response = None ) : \"\"\" **Recupero dello schema dei parametri per inizializare le forms delle azioni** ritorna una struttura json di questo tipo: { \" NomePrototipo1 \": { \" action1 \": { \" args \": { \" arg1 .1 \": \" type_arg1 .1 \", \" arg1 .2 \": \" type_arg1 .2 \", ... }, \" mandatory \": [ args keys sublist ] }, \" action2 \": { \" args \": { \" arg2 .1 \": \" type_arg2 .1 \", \" arg2 .2 \": \" type_arg2 .2 \", ... }, }, ... }, \" NomePrototipo3 \": { ... }, ... }, \"\"\" out = ResponseFormatter () try : out . data = HFeature . actions_schemata ( prototypes , actions ) except KeyError as e : out . data = {} #out . status = out . status = falcon . HTTP_NOT_FOUND out . message = e . args response = out . format ( response = response , request = request )","title":"Actionschemata"},{"location":"reference/hielen3/api/actionschemata/#module-hielen3apiactionschemata","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 #!/usr/bin/env python # coding=utf-8 import hug import falcon from hielen3 import db from hielen3.feature import HFeature from hielen3.utils import ResponseFormatter @hug . get ( \"/\" ) def get_actions_schemata ( prototypes = None , actions = None , request = None , response = None ): \"\"\" **Recupero dello schema dei parametri per inizializare le forms delle azioni** ritorna una struttura json di questo tipo: { \"NomePrototipo1\": { \"action1\": { \"args\": { \"arg1.1\": \"type_arg1.1\", \"arg1.2\": \"type_arg1.2\", ... }, \"mandatory\": [ args keys sublist ] }, \"action2\": { \"args\": { \"arg2.1\": \"type_arg2.1\", \"arg2.2\": \"type_arg2.2\", ... }, }, ... }, \"NomePrototipo3\": { ... }, ... }, \"\"\" out = ResponseFormatter () try : out . data = HFeature . actions_schemata ( prototypes , actions ) except KeyError as e : out . data = {} #out.status = out.status = falcon.HTTP_NOT_FOUND out . message = e . args response = out . format ( response = response , request = request ) @hug . get ( \"/ {prototype} \" ) def get_action_schemata ( prototype , actions = None , request = None , response = None ): \"\"\" **Alias per il recupero di tutte le informazioni di uno specifico prototipo** \"\"\" return get_actions_schemata ( prototype , actions , request , response ) @hug . get ( \"/ {prototype} / {action} \" ) def get_action_schema ( prototype , action , request = None , response = None ): \"\"\" **Alias per il recupero di tutte le informazioni delle form di uno specifico prototipo** \"\"\" return get_actions_schemata ( prototype , action , request , response )","title":"Module hielen3.api.actionschemata"},{"location":"reference/hielen3/api/actionschemata/#variables","text":"db","title":"Variables"},{"location":"reference/hielen3/api/actionschemata/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/api/actionschemata/#get_action_schema","text":"def get_action_schema ( prototype , action , request = None , response = None ) Alias per il recupero di tutte le informazioni delle form di uno specifico prototipo View Source @hug . get ( \"/{prototype}/{action}\" ) def get_action_schema ( prototype , action , request = None , response = None ) : \"\"\" **Alias per il recupero di tutte le informazioni delle form di uno specifico prototipo** \"\"\" return get_actions_schemata ( prototype , action , request , response )","title":"get_action_schema"},{"location":"reference/hielen3/api/actionschemata/#get_action_schemata","text":"def get_action_schemata ( prototype , actions = None , request = None , response = None ) Alias per il recupero di tutte le informazioni di uno specifico prototipo View Source @hug . get ( \"/{prototype}\" ) def get_action_schemata ( prototype , actions = None , request = None , response = None ) : \"\"\" **Alias per il recupero di tutte le informazioni di uno specifico prototipo** \"\"\" return get_actions_schemata ( prototype , actions , request , response )","title":"get_action_schemata"},{"location":"reference/hielen3/api/actionschemata/#get_actions_schemata","text":"def get_actions_schemata ( prototypes = None , actions = None , request = None , response = None ) Recupero dello schema dei parametri per inizializare le forms delle azioni ritorna una struttura json di questo tipo: { \"NomePrototipo1\": { \"action1\": { \"args\": { \"arg1.1\": \"type_arg1.1\", \"arg1.2\": \"type_arg1.2\", ... }, \"mandatory\": [ args keys sublist ] }, \"action2\": { \"args\": { \"arg2.1\": \"type_arg2.1\", \"arg2.2\": \"type_arg2.2\", ... }, }, ... }, \"NomePrototipo3\": { ... }, ... }, View Source @hug . get ( \"/\" ) def get_actions_schemata ( prototypes = None , actions = None , request = None , response = None ) : \"\"\" **Recupero dello schema dei parametri per inizializare le forms delle azioni** ritorna una struttura json di questo tipo: { \" NomePrototipo1 \": { \" action1 \": { \" args \": { \" arg1 .1 \": \" type_arg1 .1 \", \" arg1 .2 \": \" type_arg1 .2 \", ... }, \" mandatory \": [ args keys sublist ] }, \" action2 \": { \" args \": { \" arg2 .1 \": \" type_arg2 .1 \", \" arg2 .2 \": \" type_arg2 .2 \", ... }, }, ... }, \" NomePrototipo3 \": { ... }, ... }, \"\"\" out = ResponseFormatter () try : out . data = HFeature . actions_schemata ( prototypes , actions ) except KeyError as e : out . data = {} #out . status = out . status = falcon . HTTP_NOT_FOUND out . message = e . args response = out . format ( response = response , request = request )","title":"get_actions_schemata"},{"location":"reference/hielen3/api/awskine/","text":"Module hielen3.api.awskine View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #!/usr/bin/env python # coding=utf-8 import hug import falcon import json from hielen3 import db from hielen3.utils import JsonValidable , hasher , ResponseFormatter , uuid , dataframe2jsonizabledict from hielen3.feature import HFeature from hielen3.geje import GeoJSONSchema from pandas import Series from marshmallow import Schema , fields import traceback @hug . get ( \"/\" ) def features_info ( uids = None , request = None , response = None ): \"\"\" \"\"\" out = ResponseFormatter () try : feafra = db [ 'awskine' ][ uids ] print ( \"AAAAAAAAAAAAAAAAA \\n \" , feafra ) feafra = dataframe2jsonizabledict ( feafra , orient = 'index' , squeeze = False ) print ( \"BBBBBBBBBBBBBBBBB \\n \" , feafra ) out . data = { \"resources\" : feafra } except KeyError as e : out . data = { \"resources\" :[] } #out.status = falcon.HTTP_NOT_FOUND out . message = e . args response = out . format ( response = response , request = request ) return @hug . get ( \"/ {uid} \" ) def feature_info ( uid , request = None , response = None ): \"\"\" \"\"\" return features_info ( uid , request , response ) Variables db Functions feature_info def feature_info ( uid , request = None , response = None ) View Source @hug . get ( \"/{uid}\" ) def feature_info ( uid , request = None , response = None ) : \"\"\" \"\"\" return features_info ( uid , request , response ) features_info def features_info ( uids = None , request = None , response = None ) View Source @hug . get ( \"/\" ) def features_info ( uids = None , request = None , response = None ) : \"\"\" \"\"\" out = ResponseFormatter () try : feafra = db [ 'awskine' ][ uids ] print ( \"AAAAAAAAAAAAAAAAA\\n\" , feafra ) feafra = dataframe2jsonizabledict ( feafra , orient = 'index' , squeeze = False ) print ( \"BBBBBBBBBBBBBBBBB\\n\" , feafra ) out . data = { \"resources\" : feafra } except KeyError as e : out . data = { \"resources\" :[] } #out . status = falcon . HTTP_NOT_FOUND out . message = e . args response = out . format ( response = response , request = request ) return","title":"Awskine"},{"location":"reference/hielen3/api/awskine/#module-hielen3apiawskine","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #!/usr/bin/env python # coding=utf-8 import hug import falcon import json from hielen3 import db from hielen3.utils import JsonValidable , hasher , ResponseFormatter , uuid , dataframe2jsonizabledict from hielen3.feature import HFeature from hielen3.geje import GeoJSONSchema from pandas import Series from marshmallow import Schema , fields import traceback @hug . get ( \"/\" ) def features_info ( uids = None , request = None , response = None ): \"\"\" \"\"\" out = ResponseFormatter () try : feafra = db [ 'awskine' ][ uids ] print ( \"AAAAAAAAAAAAAAAAA \\n \" , feafra ) feafra = dataframe2jsonizabledict ( feafra , orient = 'index' , squeeze = False ) print ( \"BBBBBBBBBBBBBBBBB \\n \" , feafra ) out . data = { \"resources\" : feafra } except KeyError as e : out . data = { \"resources\" :[] } #out.status = falcon.HTTP_NOT_FOUND out . message = e . args response = out . format ( response = response , request = request ) return @hug . get ( \"/ {uid} \" ) def feature_info ( uid , request = None , response = None ): \"\"\" \"\"\" return features_info ( uid , request , response )","title":"Module hielen3.api.awskine"},{"location":"reference/hielen3/api/awskine/#variables","text":"db","title":"Variables"},{"location":"reference/hielen3/api/awskine/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/api/awskine/#feature_info","text":"def feature_info ( uid , request = None , response = None ) View Source @hug . get ( \"/{uid}\" ) def feature_info ( uid , request = None , response = None ) : \"\"\" \"\"\" return features_info ( uid , request , response )","title":"feature_info"},{"location":"reference/hielen3/api/awskine/#features_info","text":"def features_info ( uids = None , request = None , response = None ) View Source @hug . get ( \"/\" ) def features_info ( uids = None , request = None , response = None ) : \"\"\" \"\"\" out = ResponseFormatter () try : feafra = db [ 'awskine' ][ uids ] print ( \"AAAAAAAAAAAAAAAAA\\n\" , feafra ) feafra = dataframe2jsonizabledict ( feafra , orient = 'index' , squeeze = False ) print ( \"BBBBBBBBBBBBBBBBB\\n\" , feafra ) out . data = { \"resources\" : feafra } except KeyError as e : out . data = { \"resources\" :[] } #out . status = falcon . HTTP_NOT_FOUND out . message = e . args response = out . format ( response = response , request = request ) return","title":"features_info"},{"location":"reference/hielen3/api/features/","text":"Module hielen3.api.features View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 #!/usr/bin/env python # coding=utf-8 import hug import falcon import json from hielen3 import db from hielen3.utils import JsonValidable , hasher , ResponseFormatter , uuid , dataframe2jsonizabledict from hielen3.feature import HFeature from hielen3.geje import GeoJSONSchema from pandas import Series from marshmallow import Schema , fields import traceback class FeaturePropertiesSchema ( Schema ): context = fields . Str ( default = None ) label = fields . Str ( default = None ) description = fields . Str ( default = None ) location = fields . Str ( default = None ) style = fields . Str ( default = None ) status = fields . Str ( default = None ) timestamp = fields . Str ( default = None ) def mkpmaponthefly ( geometry ): try : lon = geometry [ 'coordinates' ][ 0 ] lat = geometry [ 'coordinates' ][ 1 ] span = 0.005 maptempl = { \"extent\" : { \"minlon\" : min ( lon - span , lon + span ), \"minlat\" : min ( lat - span , lat + span ), \"maxlon\" : max ( lon - span , lon + span ), \"maxlat\" : max ( lat - span , lat + span ) }, \"center\" : { \"lon\" : lon , \"lat\" : lat }, \"zoom\" : { \"default\" : 14 }, \"basemapurl\" : None , \"geographic\" : True , \"features\" : None } except Exception as e : return None return maptempl @hug . post ( \"/\" ) def create_feature ( prototype , properties : JsonValidable ( FeaturePropertiesSchema ()) = {}, geometry : JsonValidable ( GeoJSONSchema ()) = None , request = None , response = None , ): \"\"\" DESCRIZIONE: **Creazione delle Features.** Ogni feature viene creata sulla il suo il suo prototipo `prototype` ed in fase di creazione \\ viene creato il campo `uid`. Questi due campi sono immutabli. Vedi [PUT feature](#put-featuresuid) PARAMETRI: - **prototype**: Definisce il tipo della feature e accetta uno dei valori recuperabili \\ attraverso l'API [GET prototype](../prototypes/#get) - **properties**: Json dei campi anagrafici della feature, utilizzati dal sistema. Nessuno di \\ essi \u00e8 obbligatorio. Lo schema \u00e8 il seguente: { \"context\": \"Stringa: gruppo in cui inserire la feature\", \"label\": \"Stringa: etichetta mnemonica della feature\", \"description\": \"Stringa: descrizione della feature\", \"location\": \"Stringa: descrizione mnemonica della posizioni\", \"style\": \"Stringa: informazioni per le direttive csv\", \"status\": \"Stringa: informaizoni di stato\", \"timestamp\": \"Stringa: data di creazione della feature nel formato YYYY-MM-DD HH:MM:SS\" } - **geometry** : Accetta un [GeoJson](https://geojson.org/) OUTPUT: Se la feature viene creata correttamente la sua struttura viene restituita all'interno del campo \\ `data` del json di risposta standard RESPONSE CODES: - _409 Conflict_: Nel caso in cui il uid fornito esista gi\u00e0. - _404 Not Found_: Nel caso in cui il prototipo richiesto non esista. - _201 Created_: Nel caso in cui la feature venga creata correttamente. \"\"\" out = ResponseFormatter ( status = falcon . HTTP_CREATED ) try : f = HFeature . create ( ftype = prototype , geometry = geometry , ** properties ) . uuid #TODO da delegare al plugin specifico se serve \"\"\" feature[\"classification\"]=feature_info.pop(\"classification\") feature[\"inmap\"]=feature_info.pop(\"inmap\") feature_info.update({\"data\":None, \"map\":None, \"cloud\":None}) \"\"\" out . data = dataframe2jsonizabledict ( db [ 'features' ][ f ]) #json.loads(db['features'][f].to_json(orient='records'))[0] out . data [ \"uid\" ] = out . data . pop ( 'uuid' ) f = None except KeyError as e : out . message = f \"prototype ' { prototype } ' not found.\" out . status = falcon . HTTP_NOT_FOUND except ValueError as e : out . message = e . args out . status = falcon . HTTP_CONFLICT response = out . format ( response = response , request = request ) return @hug . get ( \"/\" ) def features_info ( uids = None , cntxt = None , info = [ \"geometry\" , \"capabilities\" ], request = None , response = None ): \"\"\" DESCRIZIONE: **Recupero delle informazioni delle features.** PARAMETRI: - **uids**: Lista \"comma separated\" degli id delle features da recuperare. Nel caso in cui non \\ venisse fornito alcun valore, verrebbe fornita in output l'intera lista delle features presenti \\ nel sistema. - **cntxt**: Lista \"comma separated\" dei gruppi di features da recuperare. Se presente agisce da \\ filtro rispetto al risultato elaborato in base al parametro _\"uids\"_ \\ - **info**: Lista \"comma separated\" delle informazioni relative ad ogni feature da includere nella \\ risposta. In generale dei sottoalberi Json. Le classi di informazione disponibili sono: - _capabilities_: tipi di interrogazioni eseguibili sulla feature: elenco comprendente una, nessuna \\ o pi\u00f9 voci tra queste: _data_, _map_, _cloud_. Vedi [GET query](../query/#get) - _parameters_: parametri (timeseries) associati alla feature, interrogabili tramite \\ [GET query](../query/#get) - _timeline_: eventuale timeline globale dei parametri della feature ESEMPIO: GET features?cntxt=619d00137303c&info=parameters,capabilities OUTPUT: All'interno del campo `data` del json di risposta standard viene restituito un oggetto \\ \"chiave, valore\" json che \u00e9 interpretabile come GeoJson estraendo la lista dei values. L'oggetto contiene tutte le features che rientrano nei criteri di ricerca. Quindi un struttura \\ di questo tipo: \"features\": { \"1285beb4\": { \"type\": \"Feature\", \"properties\": { \"uid\": \"1285beb4\", \"classification\": \"Source\", \"context\": \"619d00137303c\", \"description\": null, \"label\": \"CAM1\", \"location\": null, \"status\": \"0\", \"style\": \"9cecce36\", \"timestamp\": \"2021-11-10 00:00:00\", \"type\": \"PhotoMonitoring\", \"inmap\": null }, \"parameters\": [ { \"series\": \"06578ff5509871eef7e62f8d2bc175de\", \"param\": \"Displacement\", \"unit\": \"mm\", }, { \"series\": \"2388b145eed5036e78afff43114cf7f7\", \"param\": \"Correlation_Coefficient\", \"unit\": \"number\", }, ], \"timeline\": [ \"2021-11-04T15:11:45\" ], \"capabilities\": [ \"map\" ] }, } RESPONSE CODES: - _200 OK_: Nel caso vengano trovate features corrispondenti ai criteri di ricerca - _404 Not Found_: Nel caso in cui nessuna feature risponda ai criteri di ricerca \"\"\" out = ResponseFormatter () if cntxt is not None and not isinstance ( cntxt , list ): if cntxt == \"\" : cntxt = None else : cntxt = [ cntxt ] if info is None : info = [] if not isinstance ( info , list ): info = [ info ] info . extend ([ \"type\" , \"properties\" , \"capabilities\" ]) info = Series ( list ( set ( info ))) good_info = info [ info . isin ( db [ 'features_info' ] . columns )] bad_info = info [ ~ info . isin ( db [ 'features_info' ] . columns )] # TODO: GESTIONE DEI SUBITEMS \"\"\" if 'map' in info: info.append('subitemsfrommap') \"\"\" try : feafra = db [ 'features_info' ][ uids , cntxt ][ good_info ] feafra [ bad_info ] = None feafra = feafra . where ( feafra . notnull (), None ) #feafra=feafra[feafra['intent'] != 'HIDDEN'] #feafra=json.loads(feafra.droplevel(\"context\").to_json(orient='index')) feafra = dataframe2jsonizabledict ( feafra . droplevel ( \"context\" ), orient = 'index' , squeeze = False ) out . data = { \"features\" : feafra } feafra = None except KeyError as e : out . data = { \"features\" :[] } #out.status = falcon.HTTP_NOT_FOUND out . message = e . args response = out . format ( response = response , request = request ) return @hug . get ( \"/ {uid} \" ) def feature_info ( uid , cntxt = None , info = [ \"geometry\" , \"capabilities\" ], request = None , response = None ): \"\"\" DESCRIZIONE: **Alias di recupero informazioni della specifica feature** PARAMETRI: - **info**: Lista \"comma separated\" delle informazioni relative ad ogni feature da includere nella \\ risposta. In generale dei sottoalberi Json. Le classi di informazione disponibili sono: - _capabilities_: tipi di interrogazioni eseguibili sulla feature: elenco comprendente una, nessuna \\ o pi\u00f9 voci tra queste: _data_, _map_, _cloud_. Vedi [GET query](../query/#get) - _parameters_: parametri (timeseries) associati alla feature, interrogabili tramite \\ [GET query](../query/#get) - _timeline_: eventuale timeline globale dei parametri della feature ESEMPIO: GET features/1285beb4&info=parameters,capabilities OUTPUT: Vedi [GET features](#get) RESPONSE CODES: - _200 OK_: Nel caso vengano trovate features corrispondenti ai criteri di ricerca - _404 Not Found_: Nel caso in cui nessuna feature risponda ai criteri di ricerca \"\"\" return features_info ( uid , cntxt , info , request , response ) @hug . put ( \"/ {uid} \" ) def update_feature ( uid , properties : JsonValidable ( FeaturePropertiesSchema ()) = {}, geometry : JsonValidable ( GeoJSONSchema ()) = {}, request = None , response = None , ): \"\"\" **Modifica delle properties di una feature** Possibili risposte: - _404 Not Found_: Nel caso in cui il prototipo richiesto non esista. - _200 Ok_: Nel caso in cui la feature venga modificata correttamente. \"\"\" out = ResponseFormatter () if uid is None : out . status = falcon . HTTP_BAD_REQUEST out . message = \"None value not allowed\" try : f = HFeature . update ( uuid = uid , geometry = geometry , ** properties ) . uuid #out.data=json.loads(db['features'][f].to_json(orient='records'))[0] out . data = dataframe2jsonizabledict ( db [ 'features' ][ f ]) out . data [ \"uid\" ] = out . data . pop ( 'uuid' ) f = None except KeyError as e : out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature ' { uid } ' not foud.\" response = out . format ( response = response , request = request ) return @hug . delete ( \"/ {uid} \" ) def del_feature ( uid , request = None , response = None ): \"\"\" **Cancellazione delle Features** Se la feature viene cancellata correttamente ne restituisce la struttura Possibili risposte: - _404 Not Found_: Nel caso in cui il prototipo richiesto non esista. - _200 Accepted_: Nel caso in cui la feature venga eliminata correttamente. \"\"\" #TODO Ottimizzare passando direttamente al db out = ResponseFormatter () if uid is None : out . status = falcon . HTTP_BAD_REQUEST out . message = \"None value not allowed\" try : #out.data=json.loads(db['features'][uid].to_json(orient='records'))[0] out . data = dataframe2jsonizabledict ( db [ 'features' ][ uid ]) out . data [ \"uid\" ] = out . data . pop ( 'uuid' ) HFeature . drop ( uuid = uid ) except KeyError as e : #traceback.print_exc() out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature ' { uid } ' not foud.\" response = out . format ( response = response , request = request ) return Variables db Functions create_feature def create_feature ( prototype , properties : < hielen3 . utils . JsonValidable object at 0x7f74b1fefcd0 > = {}, geometry : < hielen3 . utils . JsonValidable object at 0x7f74b1fefa60 > = None , request = None , response = None ) DESCRIZIONE: Creazione delle Features. Ogni feature viene creata sulla il suo il suo prototipo prototype ed in fase di creazione viene creato il campo uid . Questi due campi sono immutabli. Vedi PUT feature PARAMETRI: prototype : Definisce il tipo della feature e accetta uno dei valori recuperabili attraverso l'API GET prototype properties : Json dei campi anagrafici della feature, utilizzati dal sistema. Nessuno di essi \u00e8 obbligatorio. Lo schema \u00e8 il seguente: { \"context\": \"Stringa: gruppo in cui inserire la feature\", \"label\": \"Stringa: etichetta mnemonica della feature\", \"description\": \"Stringa: descrizione della feature\", \"location\": \"Stringa: descrizione mnemonica della posizioni\", \"style\": \"Stringa: informazioni per le direttive csv\", \"status\": \"Stringa: informaizoni di stato\", \"timestamp\": \"Stringa: data di creazione della feature nel formato YYYY-MM-DD HH:MM:SS\" } geometry : Accetta un GeoJson OUTPUT: Se la feature viene creata correttamente la sua struttura viene restituita all'interno del campo data del json di risposta standard RESPONSE CODES: 409 Conflict : Nel caso in cui il uid fornito esista gi\u00e0. 404 Not Found : Nel caso in cui il prototipo richiesto non esista. 201 Created : Nel caso in cui la feature venga creata correttamente. View Source @ hug . post ( \"/\" ) def create_feature ( prototype , properties : JsonValidable ( FeaturePropertiesSchema ()) = {}, geometry : JsonValidable ( GeoJSONSchema ()) = None , request = None , response = None , ) : \"\"\" DESCRIZIONE : ** Creazione delle Features . ** Ogni feature viene creata sulla il suo il suo prototipo ` prototype ` ed in fase di creazione \\ viene creato il campo ` uid ` . Questi due campi sono immutabli . Vedi [ PUT feature ]( # put - featuresuid ) PARAMETRI : - ** prototype **: Definisce il tipo della feature e accetta uno dei valori recuperabili \\ attraverso l ' API [ GET prototype ](.. / prototypes / # get ) - ** properties **: Json dei campi anagrafici della feature , utilizzati dal sistema . Nessuno di \\ essi \u00e8 obbligatorio . Lo schema \u00e8 il seguente : { \"context\" : \"Stringa: gruppo in cui inserire la feature\" , \"label\" : \"Stringa: etichetta mnemonica della feature\" , \"description\" : \"Stringa: descrizione della feature\" , \"location\" : \"Stringa: descrizione mnemonica della posizioni\" , \"style\" : \"Stringa: informazioni per le direttive csv\" , \"status\" : \"Stringa: informaizoni di stato\" , \"timestamp\" : \"Stringa: data di creazione della feature nel formato YYYY-MM-DD HH:MM:SS\" } - ** geometry ** : Accetta un [ GeoJson ]( https : //geojson.org/) OUTPUT : Se la feature viene creata correttamente la sua struttura viene restituita all ' interno del campo \\ ` data ` del json di risposta standard RESPONSE CODES : - _409 Conflict_ : Nel caso in cui il uid fornito esista gi\u00e0 . - _404 Not Found_ : Nel caso in cui il prototipo richiesto non esista . - _201 Created_ : Nel caso in cui la feature venga creata correttamente . \"\"\" out = ResponseFormatter ( status = falcon . HTTP_CREATED ) try : f = HFeature . create ( ftype = prototype , geometry = geometry , ** properties ). uuid #TODO da delegare al plugin specifico se serve \"\"\" feature [ \"classification\" ] = feature_info . pop ( \"classification\" ) feature [ \"inmap\" ] = feature_info . pop ( \"inmap\" ) feature_info . update ({ \"data\" : None , \"map\" : None , \"cloud\" : None }) \"\"\" out . data = dataframe2jsonizabledict ( db [ ' features ' ][ f ]) #json.loads(db['features'][f].to_json(orient='records'))[0] out . data [ \"uid\" ] = out . data . pop ( ' uuid ' ) f = None except KeyError as e : out . message = f \"prototype '{prototype}' not found.\" out . status = falcon . HTTP_NOT_FOUND except ValueError as e : out . message = e . args out . status = falcon . HTTP_CONFLICT response = out . format ( response = response , request = request ) return del_feature def del_feature ( uid , request = None , response = None ) Cancellazione delle Features Se la feature viene cancellata correttamente ne restituisce la struttura Possibili risposte: 404 Not Found : Nel caso in cui il prototipo richiesto non esista. 200 Accepted : Nel caso in cui la feature venga eliminata correttamente. View Source @hug . delete ( \"/{uid}\" ) def del_feature ( uid , request = None , response = None ) : \"\"\" **Cancellazione delle Features** Se la feature viene cancellata correttamente ne restituisce la struttura Possibili risposte: - _404 Not Found_: Nel caso in cui il prototipo richiesto non esista. - _200 Accepted_: Nel caso in cui la feature venga eliminata correttamente. \"\"\" #TODO Ottimizzare passando direttamente al db out = ResponseFormatter () if uid is None : out . status = falcon . HTTP_BAD_REQUEST out . message = \"None value not allowed\" try : #out . data = json . loads ( db [ 'features' ][ uid ] . to_json ( orient = 'records' )) [ 0 ] out . data = dataframe2jsonizabledict ( db [ 'features' ][ uid ] ) out . data [ \"uid\" ]= out . data . pop ( 'uuid' ) HFeature . drop ( uuid = uid ) except KeyError as e : #traceback . print_exc () out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature '{uid}' not foud.\" response = out . format ( response = response , request = request ) return feature_info def feature_info ( uid , cntxt = None , info = [ 'geometry' , 'capabilities' ], request = None , response = None ) DESCRIZIONE: Alias di recupero informazioni della specifica feature PARAMETRI: info : Lista \"comma separated\" delle informazioni relative ad ogni feature da includere nella risposta. In generale dei sottoalberi Json. Le classi di informazione disponibili sono: capabilities : tipi di interrogazioni eseguibili sulla feature: elenco comprendente una, nessuna o pi\u00f9 voci tra queste: data , map , cloud . Vedi GET query parameters : parametri (timeseries) associati alla feature, interrogabili tramite GET query timeline : eventuale timeline globale dei parametri della feature ESEMPIO: GET features/1285beb4&info=parameters,capabilities OUTPUT: Vedi GET features RESPONSE CODES: 200 OK : Nel caso vengano trovate features corrispondenti ai criteri di ricerca 404 Not Found : Nel caso in cui nessuna feature risponda ai criteri di ricerca View Source @ hug . get ( \"/{uid}\" ) def feature_info ( uid , cntxt = None , info = [ \"geometry\" , \"capabilities\" ], request = None , response = None ) : \"\"\" DESCRIZIONE : ** Alias di recupero informazioni della specifica feature ** PARAMETRI : - ** info **: Lista \"comma separated\" delle informazioni relative ad ogni feature da includere nella \\ risposta . In generale dei sottoalberi Json . Le classi di informazione disponibili sono : - _capabilities_ : tipi di interrogazioni eseguibili sulla feature : elenco comprendente una , nessuna \\ o pi\u00f9 voci tra queste : _data_ , _map_ , _cloud_ . Vedi [ GET query ](.. / query / # get ) - _parameters_ : parametri ( timeseries ) associati alla feature , interrogabili tramite \\ [ GET query ](.. / query / # get ) - _timeline_ : eventuale timeline globale dei parametri della feature ESEMPIO : GET features / 1285 beb4 & info = parameters , capabilities OUTPUT : Vedi [ GET features ]( # get ) RESPONSE CODES : - _200 OK_ : Nel caso vengano trovate features corrispondenti ai criteri di ricerca - _404 Not Found_ : Nel caso in cui nessuna feature risponda ai criteri di ricerca \"\"\" return features_info ( uid , cntxt , info , request , response ) features_info def features_info ( uids = None , cntxt = None , info = [ 'geometry' , 'capabilities' ], request = None , response = None ) DESCRIZIONE: Recupero delle informazioni delle features. PARAMETRI: uids : Lista \"comma separated\" degli id delle features da recuperare. Nel caso in cui non venisse fornito alcun valore, verrebbe fornita in output l'intera lista delle features presenti nel sistema. cntxt : Lista \"comma separated\" dei gruppi di features da recuperare. Se presente agisce da filtro rispetto al risultato elaborato in base al parametro \"uids\" info : Lista \"comma separated\" delle informazioni relative ad ogni feature da includere nella risposta. In generale dei sottoalberi Json. Le classi di informazione disponibili sono: capabilities : tipi di interrogazioni eseguibili sulla feature: elenco comprendente una, nessuna o pi\u00f9 voci tra queste: data , map , cloud . Vedi GET query parameters : parametri (timeseries) associati alla feature, interrogabili tramite GET query timeline : eventuale timeline globale dei parametri della feature ESEMPIO: GET features?cntxt=619d00137303c&info=parameters,capabilities OUTPUT: All'interno del campo data del json di risposta standard viene restituito un oggetto \"chiave, valore\" json che \u00e9 interpretabile come GeoJson estraendo la lista dei values. L'oggetto contiene tutte le features che rientrano nei criteri di ricerca. Quindi un struttura di questo tipo: \"features\": { \"1285beb4\": { \"type\": \"Feature\", \"properties\": { \"uid\": \"1285beb4\", \"classification\": \"Source\", \"context\": \"619d00137303c\", \"description\": null, \"label\": \"CAM1\", \"location\": null, \"status\": \"0\", \"style\": \"9cecce36\", \"timestamp\": \"2021-11-10 00:00:00\", \"type\": \"PhotoMonitoring\", \"inmap\": null }, \"parameters\": [ { \"series\": \"06578ff5509871eef7e62f8d2bc175de\", \"param\": \"Displacement\", \"unit\": \"mm\", }, { \"series\": \"2388b145eed5036e78afff43114cf7f7\", \"param\": \"Correlation_Coefficient\", \"unit\": \"number\", }, ], \"timeline\": [ \"2021-11-04T15:11:45\" ], \"capabilities\": [ \"map\" ] }, } RESPONSE CODES: 200 OK : Nel caso vengano trovate features corrispondenti ai criteri di ricerca 404 Not Found : Nel caso in cui nessuna feature risponda ai criteri di ricerca View Source @ hug . get ( \"/\" ) def features_info ( uids = None , cntxt = None , info = [ \"geometry\" , \"capabilities\" ], request = None , response = None ) : \"\"\" DESCRIZIONE : ** Recupero delle informazioni delle features . ** PARAMETRI : - ** uids **: Lista \"comma separated\" degli id delle features da recuperare . Nel caso in cui non \\ venisse fornito alcun valore , verrebbe fornita in output l ' intera lista delle features presenti \\ nel sistema . - ** cntxt **: Lista \"comma separated\" dei gruppi di features da recuperare . Se presente agisce da \\ filtro rispetto al risultato elaborato in base al parametro _ \"uids\" _ \\ - ** info **: Lista \"comma separated\" delle informazioni relative ad ogni feature da includere nella \\ risposta . In generale dei sottoalberi Json . Le classi di informazione disponibili sono : - _capabilities_ : tipi di interrogazioni eseguibili sulla feature : elenco comprendente una , nessuna \\ o pi\u00f9 voci tra queste : _data_ , _map_ , _cloud_ . Vedi [ GET query ](.. / query / # get ) - _parameters_ : parametri ( timeseries ) associati alla feature , interrogabili tramite \\ [ GET query ](.. / query / # get ) - _timeline_ : eventuale timeline globale dei parametri della feature ESEMPIO : GET features ? cntxt = 619 d00137303c & info = parameters , capabilities OUTPUT : All ' interno del campo ` data ` del json di risposta standard viene restituito un oggetto \\ \"chiave, valore\" json che \u00e9 interpretabile come GeoJson estraendo la lista dei values . L ' oggetto contiene tutte le features che rientrano nei criteri di ricerca . Quindi un struttura \\ di questo tipo : \"features\" : { \"1285beb4\" : { \"type\" : \"Feature\" , \"properties\" : { \"uid\" : \"1285beb4\" , \"classification\" : \"Source\" , \"context\" : \"619d00137303c\" , \"description\" : null , \"label\" : \"CAM1\" , \"location\" : null , \"status\" : \"0\" , \"style\" : \"9cecce36\" , \"timestamp\" : \"2021-11-10 00:00:00\" , \"type\" : \"PhotoMonitoring\" , \"inmap\" : null }, \"parameters\" : [ { \"series\" : \"06578ff5509871eef7e62f8d2bc175de\" , \"param\" : \"Displacement\" , \"unit\" : \"mm\" , }, { \"series\" : \"2388b145eed5036e78afff43114cf7f7\" , \"param\" : \"Correlation_Coefficient\" , \"unit\" : \"number\" , }, ], \"timeline\" : [ \"2021-11-04T15:11:45\" ], \"capabilities\" : [ \"map\" ] }, } RESPONSE CODES : - _200 OK_ : Nel caso vengano trovate features corrispondenti ai criteri di ricerca - _404 Not Found_ : Nel caso in cui nessuna feature risponda ai criteri di ricerca \"\"\" out = ResponseFormatter () if cntxt is not None and not isinstance ( cntxt , list ) : if cntxt == \"\" : cntxt = None else : cntxt = [ cntxt ] if info is None : info = [] if not isinstance ( info , list ) : info = [ info ] info . extend ([ \"type\" , \"properties\" , \"capabilities\" ]) info = Series ( list ( set ( info ))) good_info = info [ info . isin ( db [ ' features_info ' ]. columns )] bad_info = info [ ~ info . isin ( db [ ' features_info ' ]. columns )] # TODO: GESTIONE DEI SUBITEMS \"\"\" if ' map ' in info : info . append ( ' subitemsfrommap ' ) \"\"\" try : feafra = db [ ' features_info ' ][ uids , cntxt ][ good_info ] feafra [ bad_info ] = None feafra = feafra . where ( feafra . notnull (), None ) #feafra=feafra[feafra['intent'] != 'HIDDEN'] #feafra=json.loads(feafra.droplevel(\"context\").to_json(orient='index')) feafra = dataframe2jsonizabledict ( feafra . droplevel ( \"context\" ), orient = ' index ' , squeeze = False ) out . data = { \"features\" : feafra } feafra = None except KeyError as e : out . data = { \"features\" : [] } #out.status = falcon.HTTP_NOT_FOUND out . message = e . args response = out . format ( response = response , request = request ) return mkpmaponthefly def mkpmaponthefly ( geometry ) View Source def mkpmaponthefly ( geometry ) : try : lon = geometry [ 'coordinates' ][ 0 ] lat = geometry [ 'coordinates' ][ 1 ] span = 0 . 005 maptempl = { \"extent\" : { \"minlon\" : min ( lon - span , lon + span ) , \"minlat\" : min ( lat - span , lat + span ) , \"maxlon\" : max ( lon - span , lon + span ) , \"maxlat\" : max ( lat - span , lat + span ) }, \"center\" : { \"lon\" : lon , \"lat\" : lat }, \"zoom\" : { \"default\" : 14 }, \"basemapurl\" : None , \"geographic\" : True , \"features\" : None } except Exception as e : return None return maptempl update_feature def update_feature ( uid , properties : < hielen3 . utils . JsonValidable object at 0x7f74b1fefac0 > = {}, geometry : < hielen3 . utils . JsonValidable object at 0x7f74b1fef700 > = {}, request = None , response = None ) Modifica delle properties di una feature Possibili risposte: 404 Not Found : Nel caso in cui il prototipo richiesto non esista. 200 Ok : Nel caso in cui la feature venga modificata correttamente. View Source @hug . put ( \"/{uid}\" ) def update_feature ( uid , properties : JsonValidable ( FeaturePropertiesSchema ()) = {} , geometry : JsonValidable ( GeoJSONSchema ()) = {} , request = None , response = None , ) : \"\"\" **Modifica delle properties di una feature** Possibili risposte: - _404 Not Found_: Nel caso in cui il prototipo richiesto non esista. - _200 Ok_: Nel caso in cui la feature venga modificata correttamente. \"\"\" out = ResponseFormatter () if uid is None : out . status = falcon . HTTP_BAD_REQUEST out . message = \"None value not allowed\" try : f = HFeature . update ( uuid = uid , geometry = geometry , ** properties ). uuid #out . data = json . loads ( db [ 'features' ][ f ] . to_json ( orient = 'records' )) [ 0 ] out . data = dataframe2jsonizabledict ( db [ 'features' ][ f ] ) out . data [ \"uid\" ]= out . data . pop ( 'uuid' ) f = None except KeyError as e : out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature '{uid}' not foud.\" response = out . format ( response = response , request = request ) return Classes FeaturePropertiesSchema class FeaturePropertiesSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'} Attributes Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class FeaturePropertiesSchema ( Schema ): context = fields . Str ( default = None ) label = fields . Str ( default = None ) description = fields . Str ( default = None ) location = fields . Str ( default = None ) style = fields . Str ( default = None ) status = fields . Str ( default = None ) timestamp = fields . Str ( default = None ) Ancestors (in MRO) marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING context description error_messages label location opts status style timestamp Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"Features"},{"location":"reference/hielen3/api/features/#module-hielen3apifeatures","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 #!/usr/bin/env python # coding=utf-8 import hug import falcon import json from hielen3 import db from hielen3.utils import JsonValidable , hasher , ResponseFormatter , uuid , dataframe2jsonizabledict from hielen3.feature import HFeature from hielen3.geje import GeoJSONSchema from pandas import Series from marshmallow import Schema , fields import traceback class FeaturePropertiesSchema ( Schema ): context = fields . Str ( default = None ) label = fields . Str ( default = None ) description = fields . Str ( default = None ) location = fields . Str ( default = None ) style = fields . Str ( default = None ) status = fields . Str ( default = None ) timestamp = fields . Str ( default = None ) def mkpmaponthefly ( geometry ): try : lon = geometry [ 'coordinates' ][ 0 ] lat = geometry [ 'coordinates' ][ 1 ] span = 0.005 maptempl = { \"extent\" : { \"minlon\" : min ( lon - span , lon + span ), \"minlat\" : min ( lat - span , lat + span ), \"maxlon\" : max ( lon - span , lon + span ), \"maxlat\" : max ( lat - span , lat + span ) }, \"center\" : { \"lon\" : lon , \"lat\" : lat }, \"zoom\" : { \"default\" : 14 }, \"basemapurl\" : None , \"geographic\" : True , \"features\" : None } except Exception as e : return None return maptempl @hug . post ( \"/\" ) def create_feature ( prototype , properties : JsonValidable ( FeaturePropertiesSchema ()) = {}, geometry : JsonValidable ( GeoJSONSchema ()) = None , request = None , response = None , ): \"\"\" DESCRIZIONE: **Creazione delle Features.** Ogni feature viene creata sulla il suo il suo prototipo `prototype` ed in fase di creazione \\ viene creato il campo `uid`. Questi due campi sono immutabli. Vedi [PUT feature](#put-featuresuid) PARAMETRI: - **prototype**: Definisce il tipo della feature e accetta uno dei valori recuperabili \\ attraverso l'API [GET prototype](../prototypes/#get) - **properties**: Json dei campi anagrafici della feature, utilizzati dal sistema. Nessuno di \\ essi \u00e8 obbligatorio. Lo schema \u00e8 il seguente: { \"context\": \"Stringa: gruppo in cui inserire la feature\", \"label\": \"Stringa: etichetta mnemonica della feature\", \"description\": \"Stringa: descrizione della feature\", \"location\": \"Stringa: descrizione mnemonica della posizioni\", \"style\": \"Stringa: informazioni per le direttive csv\", \"status\": \"Stringa: informaizoni di stato\", \"timestamp\": \"Stringa: data di creazione della feature nel formato YYYY-MM-DD HH:MM:SS\" } - **geometry** : Accetta un [GeoJson](https://geojson.org/) OUTPUT: Se la feature viene creata correttamente la sua struttura viene restituita all'interno del campo \\ `data` del json di risposta standard RESPONSE CODES: - _409 Conflict_: Nel caso in cui il uid fornito esista gi\u00e0. - _404 Not Found_: Nel caso in cui il prototipo richiesto non esista. - _201 Created_: Nel caso in cui la feature venga creata correttamente. \"\"\" out = ResponseFormatter ( status = falcon . HTTP_CREATED ) try : f = HFeature . create ( ftype = prototype , geometry = geometry , ** properties ) . uuid #TODO da delegare al plugin specifico se serve \"\"\" feature[\"classification\"]=feature_info.pop(\"classification\") feature[\"inmap\"]=feature_info.pop(\"inmap\") feature_info.update({\"data\":None, \"map\":None, \"cloud\":None}) \"\"\" out . data = dataframe2jsonizabledict ( db [ 'features' ][ f ]) #json.loads(db['features'][f].to_json(orient='records'))[0] out . data [ \"uid\" ] = out . data . pop ( 'uuid' ) f = None except KeyError as e : out . message = f \"prototype ' { prototype } ' not found.\" out . status = falcon . HTTP_NOT_FOUND except ValueError as e : out . message = e . args out . status = falcon . HTTP_CONFLICT response = out . format ( response = response , request = request ) return @hug . get ( \"/\" ) def features_info ( uids = None , cntxt = None , info = [ \"geometry\" , \"capabilities\" ], request = None , response = None ): \"\"\" DESCRIZIONE: **Recupero delle informazioni delle features.** PARAMETRI: - **uids**: Lista \"comma separated\" degli id delle features da recuperare. Nel caso in cui non \\ venisse fornito alcun valore, verrebbe fornita in output l'intera lista delle features presenti \\ nel sistema. - **cntxt**: Lista \"comma separated\" dei gruppi di features da recuperare. Se presente agisce da \\ filtro rispetto al risultato elaborato in base al parametro _\"uids\"_ \\ - **info**: Lista \"comma separated\" delle informazioni relative ad ogni feature da includere nella \\ risposta. In generale dei sottoalberi Json. Le classi di informazione disponibili sono: - _capabilities_: tipi di interrogazioni eseguibili sulla feature: elenco comprendente una, nessuna \\ o pi\u00f9 voci tra queste: _data_, _map_, _cloud_. Vedi [GET query](../query/#get) - _parameters_: parametri (timeseries) associati alla feature, interrogabili tramite \\ [GET query](../query/#get) - _timeline_: eventuale timeline globale dei parametri della feature ESEMPIO: GET features?cntxt=619d00137303c&info=parameters,capabilities OUTPUT: All'interno del campo `data` del json di risposta standard viene restituito un oggetto \\ \"chiave, valore\" json che \u00e9 interpretabile come GeoJson estraendo la lista dei values. L'oggetto contiene tutte le features che rientrano nei criteri di ricerca. Quindi un struttura \\ di questo tipo: \"features\": { \"1285beb4\": { \"type\": \"Feature\", \"properties\": { \"uid\": \"1285beb4\", \"classification\": \"Source\", \"context\": \"619d00137303c\", \"description\": null, \"label\": \"CAM1\", \"location\": null, \"status\": \"0\", \"style\": \"9cecce36\", \"timestamp\": \"2021-11-10 00:00:00\", \"type\": \"PhotoMonitoring\", \"inmap\": null }, \"parameters\": [ { \"series\": \"06578ff5509871eef7e62f8d2bc175de\", \"param\": \"Displacement\", \"unit\": \"mm\", }, { \"series\": \"2388b145eed5036e78afff43114cf7f7\", \"param\": \"Correlation_Coefficient\", \"unit\": \"number\", }, ], \"timeline\": [ \"2021-11-04T15:11:45\" ], \"capabilities\": [ \"map\" ] }, } RESPONSE CODES: - _200 OK_: Nel caso vengano trovate features corrispondenti ai criteri di ricerca - _404 Not Found_: Nel caso in cui nessuna feature risponda ai criteri di ricerca \"\"\" out = ResponseFormatter () if cntxt is not None and not isinstance ( cntxt , list ): if cntxt == \"\" : cntxt = None else : cntxt = [ cntxt ] if info is None : info = [] if not isinstance ( info , list ): info = [ info ] info . extend ([ \"type\" , \"properties\" , \"capabilities\" ]) info = Series ( list ( set ( info ))) good_info = info [ info . isin ( db [ 'features_info' ] . columns )] bad_info = info [ ~ info . isin ( db [ 'features_info' ] . columns )] # TODO: GESTIONE DEI SUBITEMS \"\"\" if 'map' in info: info.append('subitemsfrommap') \"\"\" try : feafra = db [ 'features_info' ][ uids , cntxt ][ good_info ] feafra [ bad_info ] = None feafra = feafra . where ( feafra . notnull (), None ) #feafra=feafra[feafra['intent'] != 'HIDDEN'] #feafra=json.loads(feafra.droplevel(\"context\").to_json(orient='index')) feafra = dataframe2jsonizabledict ( feafra . droplevel ( \"context\" ), orient = 'index' , squeeze = False ) out . data = { \"features\" : feafra } feafra = None except KeyError as e : out . data = { \"features\" :[] } #out.status = falcon.HTTP_NOT_FOUND out . message = e . args response = out . format ( response = response , request = request ) return @hug . get ( \"/ {uid} \" ) def feature_info ( uid , cntxt = None , info = [ \"geometry\" , \"capabilities\" ], request = None , response = None ): \"\"\" DESCRIZIONE: **Alias di recupero informazioni della specifica feature** PARAMETRI: - **info**: Lista \"comma separated\" delle informazioni relative ad ogni feature da includere nella \\ risposta. In generale dei sottoalberi Json. Le classi di informazione disponibili sono: - _capabilities_: tipi di interrogazioni eseguibili sulla feature: elenco comprendente una, nessuna \\ o pi\u00f9 voci tra queste: _data_, _map_, _cloud_. Vedi [GET query](../query/#get) - _parameters_: parametri (timeseries) associati alla feature, interrogabili tramite \\ [GET query](../query/#get) - _timeline_: eventuale timeline globale dei parametri della feature ESEMPIO: GET features/1285beb4&info=parameters,capabilities OUTPUT: Vedi [GET features](#get) RESPONSE CODES: - _200 OK_: Nel caso vengano trovate features corrispondenti ai criteri di ricerca - _404 Not Found_: Nel caso in cui nessuna feature risponda ai criteri di ricerca \"\"\" return features_info ( uid , cntxt , info , request , response ) @hug . put ( \"/ {uid} \" ) def update_feature ( uid , properties : JsonValidable ( FeaturePropertiesSchema ()) = {}, geometry : JsonValidable ( GeoJSONSchema ()) = {}, request = None , response = None , ): \"\"\" **Modifica delle properties di una feature** Possibili risposte: - _404 Not Found_: Nel caso in cui il prototipo richiesto non esista. - _200 Ok_: Nel caso in cui la feature venga modificata correttamente. \"\"\" out = ResponseFormatter () if uid is None : out . status = falcon . HTTP_BAD_REQUEST out . message = \"None value not allowed\" try : f = HFeature . update ( uuid = uid , geometry = geometry , ** properties ) . uuid #out.data=json.loads(db['features'][f].to_json(orient='records'))[0] out . data = dataframe2jsonizabledict ( db [ 'features' ][ f ]) out . data [ \"uid\" ] = out . data . pop ( 'uuid' ) f = None except KeyError as e : out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature ' { uid } ' not foud.\" response = out . format ( response = response , request = request ) return @hug . delete ( \"/ {uid} \" ) def del_feature ( uid , request = None , response = None ): \"\"\" **Cancellazione delle Features** Se la feature viene cancellata correttamente ne restituisce la struttura Possibili risposte: - _404 Not Found_: Nel caso in cui il prototipo richiesto non esista. - _200 Accepted_: Nel caso in cui la feature venga eliminata correttamente. \"\"\" #TODO Ottimizzare passando direttamente al db out = ResponseFormatter () if uid is None : out . status = falcon . HTTP_BAD_REQUEST out . message = \"None value not allowed\" try : #out.data=json.loads(db['features'][uid].to_json(orient='records'))[0] out . data = dataframe2jsonizabledict ( db [ 'features' ][ uid ]) out . data [ \"uid\" ] = out . data . pop ( 'uuid' ) HFeature . drop ( uuid = uid ) except KeyError as e : #traceback.print_exc() out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature ' { uid } ' not foud.\" response = out . format ( response = response , request = request ) return","title":"Module hielen3.api.features"},{"location":"reference/hielen3/api/features/#variables","text":"db","title":"Variables"},{"location":"reference/hielen3/api/features/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/api/features/#create_feature","text":"def create_feature ( prototype , properties : < hielen3 . utils . JsonValidable object at 0x7f74b1fefcd0 > = {}, geometry : < hielen3 . utils . JsonValidable object at 0x7f74b1fefa60 > = None , request = None , response = None ) DESCRIZIONE: Creazione delle Features. Ogni feature viene creata sulla il suo il suo prototipo prototype ed in fase di creazione viene creato il campo uid . Questi due campi sono immutabli. Vedi PUT feature PARAMETRI: prototype : Definisce il tipo della feature e accetta uno dei valori recuperabili attraverso l'API GET prototype properties : Json dei campi anagrafici della feature, utilizzati dal sistema. Nessuno di essi \u00e8 obbligatorio. Lo schema \u00e8 il seguente: { \"context\": \"Stringa: gruppo in cui inserire la feature\", \"label\": \"Stringa: etichetta mnemonica della feature\", \"description\": \"Stringa: descrizione della feature\", \"location\": \"Stringa: descrizione mnemonica della posizioni\", \"style\": \"Stringa: informazioni per le direttive csv\", \"status\": \"Stringa: informaizoni di stato\", \"timestamp\": \"Stringa: data di creazione della feature nel formato YYYY-MM-DD HH:MM:SS\" } geometry : Accetta un GeoJson OUTPUT: Se la feature viene creata correttamente la sua struttura viene restituita all'interno del campo data del json di risposta standard RESPONSE CODES: 409 Conflict : Nel caso in cui il uid fornito esista gi\u00e0. 404 Not Found : Nel caso in cui il prototipo richiesto non esista. 201 Created : Nel caso in cui la feature venga creata correttamente. View Source @ hug . post ( \"/\" ) def create_feature ( prototype , properties : JsonValidable ( FeaturePropertiesSchema ()) = {}, geometry : JsonValidable ( GeoJSONSchema ()) = None , request = None , response = None , ) : \"\"\" DESCRIZIONE : ** Creazione delle Features . ** Ogni feature viene creata sulla il suo il suo prototipo ` prototype ` ed in fase di creazione \\ viene creato il campo ` uid ` . Questi due campi sono immutabli . Vedi [ PUT feature ]( # put - featuresuid ) PARAMETRI : - ** prototype **: Definisce il tipo della feature e accetta uno dei valori recuperabili \\ attraverso l ' API [ GET prototype ](.. / prototypes / # get ) - ** properties **: Json dei campi anagrafici della feature , utilizzati dal sistema . Nessuno di \\ essi \u00e8 obbligatorio . Lo schema \u00e8 il seguente : { \"context\" : \"Stringa: gruppo in cui inserire la feature\" , \"label\" : \"Stringa: etichetta mnemonica della feature\" , \"description\" : \"Stringa: descrizione della feature\" , \"location\" : \"Stringa: descrizione mnemonica della posizioni\" , \"style\" : \"Stringa: informazioni per le direttive csv\" , \"status\" : \"Stringa: informaizoni di stato\" , \"timestamp\" : \"Stringa: data di creazione della feature nel formato YYYY-MM-DD HH:MM:SS\" } - ** geometry ** : Accetta un [ GeoJson ]( https : //geojson.org/) OUTPUT : Se la feature viene creata correttamente la sua struttura viene restituita all ' interno del campo \\ ` data ` del json di risposta standard RESPONSE CODES : - _409 Conflict_ : Nel caso in cui il uid fornito esista gi\u00e0 . - _404 Not Found_ : Nel caso in cui il prototipo richiesto non esista . - _201 Created_ : Nel caso in cui la feature venga creata correttamente . \"\"\" out = ResponseFormatter ( status = falcon . HTTP_CREATED ) try : f = HFeature . create ( ftype = prototype , geometry = geometry , ** properties ). uuid #TODO da delegare al plugin specifico se serve \"\"\" feature [ \"classification\" ] = feature_info . pop ( \"classification\" ) feature [ \"inmap\" ] = feature_info . pop ( \"inmap\" ) feature_info . update ({ \"data\" : None , \"map\" : None , \"cloud\" : None }) \"\"\" out . data = dataframe2jsonizabledict ( db [ ' features ' ][ f ]) #json.loads(db['features'][f].to_json(orient='records'))[0] out . data [ \"uid\" ] = out . data . pop ( ' uuid ' ) f = None except KeyError as e : out . message = f \"prototype '{prototype}' not found.\" out . status = falcon . HTTP_NOT_FOUND except ValueError as e : out . message = e . args out . status = falcon . HTTP_CONFLICT response = out . format ( response = response , request = request ) return","title":"create_feature"},{"location":"reference/hielen3/api/features/#del_feature","text":"def del_feature ( uid , request = None , response = None ) Cancellazione delle Features Se la feature viene cancellata correttamente ne restituisce la struttura Possibili risposte: 404 Not Found : Nel caso in cui il prototipo richiesto non esista. 200 Accepted : Nel caso in cui la feature venga eliminata correttamente. View Source @hug . delete ( \"/{uid}\" ) def del_feature ( uid , request = None , response = None ) : \"\"\" **Cancellazione delle Features** Se la feature viene cancellata correttamente ne restituisce la struttura Possibili risposte: - _404 Not Found_: Nel caso in cui il prototipo richiesto non esista. - _200 Accepted_: Nel caso in cui la feature venga eliminata correttamente. \"\"\" #TODO Ottimizzare passando direttamente al db out = ResponseFormatter () if uid is None : out . status = falcon . HTTP_BAD_REQUEST out . message = \"None value not allowed\" try : #out . data = json . loads ( db [ 'features' ][ uid ] . to_json ( orient = 'records' )) [ 0 ] out . data = dataframe2jsonizabledict ( db [ 'features' ][ uid ] ) out . data [ \"uid\" ]= out . data . pop ( 'uuid' ) HFeature . drop ( uuid = uid ) except KeyError as e : #traceback . print_exc () out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature '{uid}' not foud.\" response = out . format ( response = response , request = request ) return","title":"del_feature"},{"location":"reference/hielen3/api/features/#feature_info","text":"def feature_info ( uid , cntxt = None , info = [ 'geometry' , 'capabilities' ], request = None , response = None ) DESCRIZIONE: Alias di recupero informazioni della specifica feature PARAMETRI: info : Lista \"comma separated\" delle informazioni relative ad ogni feature da includere nella risposta. In generale dei sottoalberi Json. Le classi di informazione disponibili sono: capabilities : tipi di interrogazioni eseguibili sulla feature: elenco comprendente una, nessuna o pi\u00f9 voci tra queste: data , map , cloud . Vedi GET query parameters : parametri (timeseries) associati alla feature, interrogabili tramite GET query timeline : eventuale timeline globale dei parametri della feature ESEMPIO: GET features/1285beb4&info=parameters,capabilities OUTPUT: Vedi GET features RESPONSE CODES: 200 OK : Nel caso vengano trovate features corrispondenti ai criteri di ricerca 404 Not Found : Nel caso in cui nessuna feature risponda ai criteri di ricerca View Source @ hug . get ( \"/{uid}\" ) def feature_info ( uid , cntxt = None , info = [ \"geometry\" , \"capabilities\" ], request = None , response = None ) : \"\"\" DESCRIZIONE : ** Alias di recupero informazioni della specifica feature ** PARAMETRI : - ** info **: Lista \"comma separated\" delle informazioni relative ad ogni feature da includere nella \\ risposta . In generale dei sottoalberi Json . Le classi di informazione disponibili sono : - _capabilities_ : tipi di interrogazioni eseguibili sulla feature : elenco comprendente una , nessuna \\ o pi\u00f9 voci tra queste : _data_ , _map_ , _cloud_ . Vedi [ GET query ](.. / query / # get ) - _parameters_ : parametri ( timeseries ) associati alla feature , interrogabili tramite \\ [ GET query ](.. / query / # get ) - _timeline_ : eventuale timeline globale dei parametri della feature ESEMPIO : GET features / 1285 beb4 & info = parameters , capabilities OUTPUT : Vedi [ GET features ]( # get ) RESPONSE CODES : - _200 OK_ : Nel caso vengano trovate features corrispondenti ai criteri di ricerca - _404 Not Found_ : Nel caso in cui nessuna feature risponda ai criteri di ricerca \"\"\" return features_info ( uid , cntxt , info , request , response )","title":"feature_info"},{"location":"reference/hielen3/api/features/#features_info","text":"def features_info ( uids = None , cntxt = None , info = [ 'geometry' , 'capabilities' ], request = None , response = None ) DESCRIZIONE: Recupero delle informazioni delle features. PARAMETRI: uids : Lista \"comma separated\" degli id delle features da recuperare. Nel caso in cui non venisse fornito alcun valore, verrebbe fornita in output l'intera lista delle features presenti nel sistema. cntxt : Lista \"comma separated\" dei gruppi di features da recuperare. Se presente agisce da filtro rispetto al risultato elaborato in base al parametro \"uids\" info : Lista \"comma separated\" delle informazioni relative ad ogni feature da includere nella risposta. In generale dei sottoalberi Json. Le classi di informazione disponibili sono: capabilities : tipi di interrogazioni eseguibili sulla feature: elenco comprendente una, nessuna o pi\u00f9 voci tra queste: data , map , cloud . Vedi GET query parameters : parametri (timeseries) associati alla feature, interrogabili tramite GET query timeline : eventuale timeline globale dei parametri della feature ESEMPIO: GET features?cntxt=619d00137303c&info=parameters,capabilities OUTPUT: All'interno del campo data del json di risposta standard viene restituito un oggetto \"chiave, valore\" json che \u00e9 interpretabile come GeoJson estraendo la lista dei values. L'oggetto contiene tutte le features che rientrano nei criteri di ricerca. Quindi un struttura di questo tipo: \"features\": { \"1285beb4\": { \"type\": \"Feature\", \"properties\": { \"uid\": \"1285beb4\", \"classification\": \"Source\", \"context\": \"619d00137303c\", \"description\": null, \"label\": \"CAM1\", \"location\": null, \"status\": \"0\", \"style\": \"9cecce36\", \"timestamp\": \"2021-11-10 00:00:00\", \"type\": \"PhotoMonitoring\", \"inmap\": null }, \"parameters\": [ { \"series\": \"06578ff5509871eef7e62f8d2bc175de\", \"param\": \"Displacement\", \"unit\": \"mm\", }, { \"series\": \"2388b145eed5036e78afff43114cf7f7\", \"param\": \"Correlation_Coefficient\", \"unit\": \"number\", }, ], \"timeline\": [ \"2021-11-04T15:11:45\" ], \"capabilities\": [ \"map\" ] }, } RESPONSE CODES: 200 OK : Nel caso vengano trovate features corrispondenti ai criteri di ricerca 404 Not Found : Nel caso in cui nessuna feature risponda ai criteri di ricerca View Source @ hug . get ( \"/\" ) def features_info ( uids = None , cntxt = None , info = [ \"geometry\" , \"capabilities\" ], request = None , response = None ) : \"\"\" DESCRIZIONE : ** Recupero delle informazioni delle features . ** PARAMETRI : - ** uids **: Lista \"comma separated\" degli id delle features da recuperare . Nel caso in cui non \\ venisse fornito alcun valore , verrebbe fornita in output l ' intera lista delle features presenti \\ nel sistema . - ** cntxt **: Lista \"comma separated\" dei gruppi di features da recuperare . Se presente agisce da \\ filtro rispetto al risultato elaborato in base al parametro _ \"uids\" _ \\ - ** info **: Lista \"comma separated\" delle informazioni relative ad ogni feature da includere nella \\ risposta . In generale dei sottoalberi Json . Le classi di informazione disponibili sono : - _capabilities_ : tipi di interrogazioni eseguibili sulla feature : elenco comprendente una , nessuna \\ o pi\u00f9 voci tra queste : _data_ , _map_ , _cloud_ . Vedi [ GET query ](.. / query / # get ) - _parameters_ : parametri ( timeseries ) associati alla feature , interrogabili tramite \\ [ GET query ](.. / query / # get ) - _timeline_ : eventuale timeline globale dei parametri della feature ESEMPIO : GET features ? cntxt = 619 d00137303c & info = parameters , capabilities OUTPUT : All ' interno del campo ` data ` del json di risposta standard viene restituito un oggetto \\ \"chiave, valore\" json che \u00e9 interpretabile come GeoJson estraendo la lista dei values . L ' oggetto contiene tutte le features che rientrano nei criteri di ricerca . Quindi un struttura \\ di questo tipo : \"features\" : { \"1285beb4\" : { \"type\" : \"Feature\" , \"properties\" : { \"uid\" : \"1285beb4\" , \"classification\" : \"Source\" , \"context\" : \"619d00137303c\" , \"description\" : null , \"label\" : \"CAM1\" , \"location\" : null , \"status\" : \"0\" , \"style\" : \"9cecce36\" , \"timestamp\" : \"2021-11-10 00:00:00\" , \"type\" : \"PhotoMonitoring\" , \"inmap\" : null }, \"parameters\" : [ { \"series\" : \"06578ff5509871eef7e62f8d2bc175de\" , \"param\" : \"Displacement\" , \"unit\" : \"mm\" , }, { \"series\" : \"2388b145eed5036e78afff43114cf7f7\" , \"param\" : \"Correlation_Coefficient\" , \"unit\" : \"number\" , }, ], \"timeline\" : [ \"2021-11-04T15:11:45\" ], \"capabilities\" : [ \"map\" ] }, } RESPONSE CODES : - _200 OK_ : Nel caso vengano trovate features corrispondenti ai criteri di ricerca - _404 Not Found_ : Nel caso in cui nessuna feature risponda ai criteri di ricerca \"\"\" out = ResponseFormatter () if cntxt is not None and not isinstance ( cntxt , list ) : if cntxt == \"\" : cntxt = None else : cntxt = [ cntxt ] if info is None : info = [] if not isinstance ( info , list ) : info = [ info ] info . extend ([ \"type\" , \"properties\" , \"capabilities\" ]) info = Series ( list ( set ( info ))) good_info = info [ info . isin ( db [ ' features_info ' ]. columns )] bad_info = info [ ~ info . isin ( db [ ' features_info ' ]. columns )] # TODO: GESTIONE DEI SUBITEMS \"\"\" if ' map ' in info : info . append ( ' subitemsfrommap ' ) \"\"\" try : feafra = db [ ' features_info ' ][ uids , cntxt ][ good_info ] feafra [ bad_info ] = None feafra = feafra . where ( feafra . notnull (), None ) #feafra=feafra[feafra['intent'] != 'HIDDEN'] #feafra=json.loads(feafra.droplevel(\"context\").to_json(orient='index')) feafra = dataframe2jsonizabledict ( feafra . droplevel ( \"context\" ), orient = ' index ' , squeeze = False ) out . data = { \"features\" : feafra } feafra = None except KeyError as e : out . data = { \"features\" : [] } #out.status = falcon.HTTP_NOT_FOUND out . message = e . args response = out . format ( response = response , request = request ) return","title":"features_info"},{"location":"reference/hielen3/api/features/#mkpmaponthefly","text":"def mkpmaponthefly ( geometry ) View Source def mkpmaponthefly ( geometry ) : try : lon = geometry [ 'coordinates' ][ 0 ] lat = geometry [ 'coordinates' ][ 1 ] span = 0 . 005 maptempl = { \"extent\" : { \"minlon\" : min ( lon - span , lon + span ) , \"minlat\" : min ( lat - span , lat + span ) , \"maxlon\" : max ( lon - span , lon + span ) , \"maxlat\" : max ( lat - span , lat + span ) }, \"center\" : { \"lon\" : lon , \"lat\" : lat }, \"zoom\" : { \"default\" : 14 }, \"basemapurl\" : None , \"geographic\" : True , \"features\" : None } except Exception as e : return None return maptempl","title":"mkpmaponthefly"},{"location":"reference/hielen3/api/features/#update_feature","text":"def update_feature ( uid , properties : < hielen3 . utils . JsonValidable object at 0x7f74b1fefac0 > = {}, geometry : < hielen3 . utils . JsonValidable object at 0x7f74b1fef700 > = {}, request = None , response = None ) Modifica delle properties di una feature Possibili risposte: 404 Not Found : Nel caso in cui il prototipo richiesto non esista. 200 Ok : Nel caso in cui la feature venga modificata correttamente. View Source @hug . put ( \"/{uid}\" ) def update_feature ( uid , properties : JsonValidable ( FeaturePropertiesSchema ()) = {} , geometry : JsonValidable ( GeoJSONSchema ()) = {} , request = None , response = None , ) : \"\"\" **Modifica delle properties di una feature** Possibili risposte: - _404 Not Found_: Nel caso in cui il prototipo richiesto non esista. - _200 Ok_: Nel caso in cui la feature venga modificata correttamente. \"\"\" out = ResponseFormatter () if uid is None : out . status = falcon . HTTP_BAD_REQUEST out . message = \"None value not allowed\" try : f = HFeature . update ( uuid = uid , geometry = geometry , ** properties ). uuid #out . data = json . loads ( db [ 'features' ][ f ] . to_json ( orient = 'records' )) [ 0 ] out . data = dataframe2jsonizabledict ( db [ 'features' ][ f ] ) out . data [ \"uid\" ]= out . data . pop ( 'uuid' ) f = None except KeyError as e : out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature '{uid}' not foud.\" response = out . format ( response = response , request = request ) return","title":"update_feature"},{"location":"reference/hielen3/api/features/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/api/features/#featurepropertiesschema","text":"class FeaturePropertiesSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'}","title":"FeaturePropertiesSchema"},{"location":"reference/hielen3/api/features/#attributes","text":"Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class FeaturePropertiesSchema ( Schema ): context = fields . Str ( default = None ) label = fields . Str ( default = None ) description = fields . Str ( default = None ) location = fields . Str ( default = None ) style = fields . Str ( default = None ) status = fields . Str ( default = None ) timestamp = fields . Str ( default = None )","title":"Attributes"},{"location":"reference/hielen3/api/features/#ancestors-in-mro","text":"marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/api/features/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING context description error_messages label location opts status style timestamp","title":"Class variables"},{"location":"reference/hielen3/api/features/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/api/features/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/api/features/#instance-variables","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen3/api/features/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/api/features/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/api/features/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/api/features/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/api/features/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/api/features/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/api/features/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/api/features/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/api/features/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/api/glob/","text":"Module hielen3.api.glob View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 #!/usr/bin/env python # coding=utf-8 import hug from . import prototypes , query , query2 , features , actions , actionschemata , hls , queue , status , awskine , italferdatarate import falcon \"\"\" @hug.not_found() def not_found(): return {'error': { 'status': falcon.status.HTTP_NOT_FOUND, 'description': 'URL is invalid.', }} api = hug.get(on_invalid=hug.redirect.not_found) \"\"\" @hug . extend_api ( \"/hls\" ) def getstream (): return [ hls ] @hug . extend_api ( \"/queue\" ) def getstream (): return [ queue ] @hug . extend_api ( \"/prototypes\" ) def protoman (): \"\"\" Prototypes manager \"\"\" return [ prototypes ] @hug . extend_api ( \"/features\" ) def featman (): \"\"\" Features manager \"\"\" return [ features ] @hug . extend_api ( \"/actions\" ) def actiman (): \"\"\" Action manager \"\"\" return [ actions ] @hug . extend_api ( \"/actionschemata\" ) def scheman (): \"\"\" Schemata manager \"\"\" return [ actionschemata ] @hug . extend_api ( \"/query\" ) def dataman (): \"\"\" Data manager \"\"\" return [ query ] @hug . extend_api ( \"/query2\" ) def dataman (): \"\"\" Data manager \"\"\" return [ query2 ] @hug . extend_api ( \"/status\" ) def dataman (): \"\"\" Data manager \"\"\" return [ status ] @hug . extend_api ( \"/awskineresources\" ) def dataman (): \"\"\" api per aws kinemetrics \"\"\" return [ awskine ] @hug . extend_api ( \"/samplerate\" ) def dataman (): \"\"\" api per cambiare il samplerate \"\"\" return [ italferdatarate ] Functions actiman def actiman ( ) Action manager View Source @hug . extend_api ( \"/actions\" ) def actiman () : \"\"\" Action manager \"\"\" return [ actions ] dataman def dataman ( ) api per cambiare il samplerate View Source @hug . extend_api ( \"/samplerate\" ) def dataman () : \"\"\" api per cambiare il samplerate \"\"\" return [ italferdatarate ] featman def featman ( ) Features manager View Source @hug . extend_api ( \"/features\" ) def featman () : \"\"\" Features manager \"\"\" return [ features ] getstream def getstream ( ) View Source @hug . extend_api ( \"/queue\" ) def getstream () : return [ queue ] protoman def protoman ( ) Prototypes manager View Source @hug . extend_api ( \"/prototypes\" ) def protoman () : \"\"\" Prototypes manager \"\"\" return [ prototypes ] scheman def scheman ( ) Schemata manager View Source @hug . extend_api ( \"/actionschemata\" ) def scheman () : \"\"\" Schemata manager \"\"\" return [ actionschemata ]","title":"Glob"},{"location":"reference/hielen3/api/glob/#module-hielen3apiglob","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 #!/usr/bin/env python # coding=utf-8 import hug from . import prototypes , query , query2 , features , actions , actionschemata , hls , queue , status , awskine , italferdatarate import falcon \"\"\" @hug.not_found() def not_found(): return {'error': { 'status': falcon.status.HTTP_NOT_FOUND, 'description': 'URL is invalid.', }} api = hug.get(on_invalid=hug.redirect.not_found) \"\"\" @hug . extend_api ( \"/hls\" ) def getstream (): return [ hls ] @hug . extend_api ( \"/queue\" ) def getstream (): return [ queue ] @hug . extend_api ( \"/prototypes\" ) def protoman (): \"\"\" Prototypes manager \"\"\" return [ prototypes ] @hug . extend_api ( \"/features\" ) def featman (): \"\"\" Features manager \"\"\" return [ features ] @hug . extend_api ( \"/actions\" ) def actiman (): \"\"\" Action manager \"\"\" return [ actions ] @hug . extend_api ( \"/actionschemata\" ) def scheman (): \"\"\" Schemata manager \"\"\" return [ actionschemata ] @hug . extend_api ( \"/query\" ) def dataman (): \"\"\" Data manager \"\"\" return [ query ] @hug . extend_api ( \"/query2\" ) def dataman (): \"\"\" Data manager \"\"\" return [ query2 ] @hug . extend_api ( \"/status\" ) def dataman (): \"\"\" Data manager \"\"\" return [ status ] @hug . extend_api ( \"/awskineresources\" ) def dataman (): \"\"\" api per aws kinemetrics \"\"\" return [ awskine ] @hug . extend_api ( \"/samplerate\" ) def dataman (): \"\"\" api per cambiare il samplerate \"\"\" return [ italferdatarate ]","title":"Module hielen3.api.glob"},{"location":"reference/hielen3/api/glob/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/api/glob/#actiman","text":"def actiman ( ) Action manager View Source @hug . extend_api ( \"/actions\" ) def actiman () : \"\"\" Action manager \"\"\" return [ actions ]","title":"actiman"},{"location":"reference/hielen3/api/glob/#dataman","text":"def dataman ( ) api per cambiare il samplerate View Source @hug . extend_api ( \"/samplerate\" ) def dataman () : \"\"\" api per cambiare il samplerate \"\"\" return [ italferdatarate ]","title":"dataman"},{"location":"reference/hielen3/api/glob/#featman","text":"def featman ( ) Features manager View Source @hug . extend_api ( \"/features\" ) def featman () : \"\"\" Features manager \"\"\" return [ features ]","title":"featman"},{"location":"reference/hielen3/api/glob/#getstream","text":"def getstream ( ) View Source @hug . extend_api ( \"/queue\" ) def getstream () : return [ queue ]","title":"getstream"},{"location":"reference/hielen3/api/glob/#protoman","text":"def protoman ( ) Prototypes manager View Source @hug . extend_api ( \"/prototypes\" ) def protoman () : \"\"\" Prototypes manager \"\"\" return [ prototypes ]","title":"protoman"},{"location":"reference/hielen3/api/glob/#scheman","text":"def scheman ( ) Schemata manager View Source @hug . extend_api ( \"/actionschemata\" ) def scheman () : \"\"\" Schemata manager \"\"\" return [ actionschemata ]","title":"scheman"},{"location":"reference/hielen3/api/hls/","text":"Module hielen3.api.hls View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #!/usr/bin/env python # coding=utf-8 import hug from hielen3.tools import hls_facility as hls from hielen3.utils import ResponseFormatter @hug . post ( \"/\" ) def submit ( resource = None , request = None , response = None ): out = ResponseFormatter () out . data , outcode = hls . start_stream ( resource ) print ( out . data , outcode ) if outcode == 400 : out . status = falcon . HTTP_NOT_FOUND out . message = f \"resource not found: { resource } \" out . format ( request = request , response = response ) return @hug . post ( \"/ {resource} \" ) def submitr ( resource = None , request = None , response = None ): return submit ( resource = resource , request = request , response = response ) Functions submit def submit ( resource = None , request = None , response = None ) View Source @hug . post ( \"/\" ) def submit ( resource = None , request = None , response = None ) : out = ResponseFormatter () out . data , outcode = hls . start_stream ( resource ) print ( out . data , outcode ) if outcode == 400 : out . status = falcon . HTTP_NOT_FOUND out . message = f \"resource not found: {resource}\" out . format ( request = request , response = response ) return submitr def submitr ( resource = None , request = None , response = None ) View Source @hug . post ( \"/{resource}\" ) def submitr ( resource = None , request = None , response = None ) : return submit ( resource = resource , request = request , response = response )","title":"Hls"},{"location":"reference/hielen3/api/hls/#module-hielen3apihls","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #!/usr/bin/env python # coding=utf-8 import hug from hielen3.tools import hls_facility as hls from hielen3.utils import ResponseFormatter @hug . post ( \"/\" ) def submit ( resource = None , request = None , response = None ): out = ResponseFormatter () out . data , outcode = hls . start_stream ( resource ) print ( out . data , outcode ) if outcode == 400 : out . status = falcon . HTTP_NOT_FOUND out . message = f \"resource not found: { resource } \" out . format ( request = request , response = response ) return @hug . post ( \"/ {resource} \" ) def submitr ( resource = None , request = None , response = None ): return submit ( resource = resource , request = request , response = response )","title":"Module hielen3.api.hls"},{"location":"reference/hielen3/api/hls/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/api/hls/#submit","text":"def submit ( resource = None , request = None , response = None ) View Source @hug . post ( \"/\" ) def submit ( resource = None , request = None , response = None ) : out = ResponseFormatter () out . data , outcode = hls . start_stream ( resource ) print ( out . data , outcode ) if outcode == 400 : out . status = falcon . HTTP_NOT_FOUND out . message = f \"resource not found: {resource}\" out . format ( request = request , response = response ) return","title":"submit"},{"location":"reference/hielen3/api/hls/#submitr","text":"def submitr ( resource = None , request = None , response = None ) View Source @hug . post ( \"/{resource}\" ) def submitr ( resource = None , request = None , response = None ) : return submit ( resource = resource , request = request , response = response )","title":"submitr"},{"location":"reference/hielen3/api/italferdatarate/","text":"Module hielen3.api.italferdatarate View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 #!/usr/bin/env python # coding=utf-8 import hug from pycognito import Cognito import requests import falcon from hielen3.utils import ResponseFormatter from hielen3 import db , conf def changerate ( serial , time ): if time is None : time = 0 time = int ( time ) if time < 1 : raise Exception ( \"new rate under minute\" ) time = time * 60 c = Cognito ( ** conf [ \"aws\" ][ \"pool\" ]) c . authenticate ( conf [ \"aws\" ][ \"pwd\" ]) headers = { \"Authorization\" : c . id_token } url_cmnd = 'https://0xnsi8bx82.execute-api.eu-west-1.amazonaws.com/Dev/portal/post_command' data = { \"wsn_sn\" : serial , \"command_code\" : 2 , \"command_args\" :[ '\"' + str ( time ) + '\"' ]} res = requests . post ( url = url_cmnd , json = data , headers = headers ) return res @hug . get ( \"/\" ) def gettime ( features = None , request = None , response = None ): out = ResponseFormatter () q = 'select * from v_feature_rfiponti_timerate' if features is not None : if not isinstance ( features , list ): features = [ features ] features = \",\" . join ( '\"' + str ( a ) + '\"' for a in features ) q = f \" { q } where feature in ( { features } )\" try : out . data = db [ 'query' ][ q ][[ 'feature' , 'minutes' ]] . to_dict ( orient = 'records' ) except Exception as e : out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature not found: { features } \" out . format ( request = request , response = response ) return @hug . get ( \"/ {feature} \" ) def gettimer ( feature = None , request = None , response = None ): return gettime ( features = feature , request = request , response = response ) @hug . post ( \"/ {feature} \" ) def chtime ( feature , newrate , request = None , response = None ): out = ResponseFormatter () serial = db [ 'query' ][ f 'select * from v_feature_rfiponti_timerate where feature= { feature !r} ' ][ 'serial' ] . squeeze () . replace ( \"'\" , \"\" ) print ( \" \\n \" , serial , \" \\n \" ) try : res = changerate ( serial , newrate ) print ( res . __dict__ ) except Exception as e : out . status = falcon . HTTP_NOT_FOUND out . message = f \"something gone wrong: { e } \" out . format ( request = request , response = response ) return stat = f \"REPLACE into feature_rfiponti_timerate VALUES ( { feature !r} , { newrate } )\" try : en = db [ 'query' ] . engine with en . begin () as conn : conn . execute ( 'start transaction' ) conn . execute ( stat ) en . dispose () except Exception as e : out . status = falcon . HTTP_NOT_FOUND out . message = f \"something gone wrong { e } \" out . format ( request = request , response = response ) return out return gettimer ( feature = feature , request = request , response = response ) Variables conf db Functions changerate def changerate ( serial , time ) View Source def changerate ( serial , time ) : if time is None : time = 0 time = int ( time ) if time < 1 : raise Exception ( \"new rate under minute\" ) time = time * 60 c = Cognito ( ** conf [ \"aws\" ][ \"pool\" ] ) c . authenticate ( conf [ \"aws\" ][ \"pwd\" ] ) headers = { \"Authorization\" : c . id_token } url_cmnd = 'https://0xnsi8bx82.execute-api.eu-west-1.amazonaws.com/Dev/portal/post_command' data = { \"wsn_sn\" : serial , \"command_code\" : 2 , \"command_args\" :[ '\"' + str ( time ) + '\"' ]} res = requests . post ( url = url_cmnd , json = data , headers = headers ) return res chtime def chtime ( feature , newrate , request = None , response = None ) View Source @hug . post ( \"/{feature}\" ) def chtime ( feature , newrate , request = None , response = None ) : out = ResponseFormatter () serial = db [ 'query' ][ f'select * from v_feature_rfiponti_timerate where feature={feature!r}' ][ 'serial' ] . squeeze (). replace ( \"'\" , \"\" ) print ( \"\\n\" , serial , \"\\n\" ) try : res = changerate ( serial , newrate ) print ( res . __dict__ ) except Exception as e : out . status = falcon . HTTP_NOT_FOUND out . message = f \"something gone wrong: {e}\" out . format ( request = request , response = response ) return stat = f \"REPLACE into feature_rfiponti_timerate VALUES ({feature!r},{newrate})\" try : en = db [ 'query' ] . engine with en . begin () as conn : conn . execute ( 'start transaction' ) conn . execute ( stat ) en . dispose () except Exception as e : out . status = falcon . HTTP_NOT_FOUND out . message = f \"something gone wrong {e}\" out . format ( request = request , response = response ) return out return gettimer ( feature = feature , request = request , response = response ) gettime def gettime ( features = None , request = None , response = None ) View Source @hug . get ( \"/\" ) def gettime ( features = None , request = None , response = None ) : out = ResponseFormatter () q = 'select * from v_feature_rfiponti_timerate' if features is not None : if not isinstance ( features , list ) : features =[ features ] features = \",\" . join ( '\"' + str ( a ) + '\"' for a in features ) q = f \"{q} where feature in ({features})\" try : out . data = db [ 'query' ][ q ][ ['feature','minutes' ] ] . to_dict ( orient = 'records' ) except Exception as e : out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature not found: {features}\" out . format ( request = request , response = response ) return gettimer def gettimer ( feature = None , request = None , response = None ) View Source @hug . get ( \"/{feature}\" ) def gettimer ( feature = None , request = None , response = None ) : return gettime ( features = feature , request = request , response = response )","title":"Italferdatarate"},{"location":"reference/hielen3/api/italferdatarate/#module-hielen3apiitalferdatarate","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 #!/usr/bin/env python # coding=utf-8 import hug from pycognito import Cognito import requests import falcon from hielen3.utils import ResponseFormatter from hielen3 import db , conf def changerate ( serial , time ): if time is None : time = 0 time = int ( time ) if time < 1 : raise Exception ( \"new rate under minute\" ) time = time * 60 c = Cognito ( ** conf [ \"aws\" ][ \"pool\" ]) c . authenticate ( conf [ \"aws\" ][ \"pwd\" ]) headers = { \"Authorization\" : c . id_token } url_cmnd = 'https://0xnsi8bx82.execute-api.eu-west-1.amazonaws.com/Dev/portal/post_command' data = { \"wsn_sn\" : serial , \"command_code\" : 2 , \"command_args\" :[ '\"' + str ( time ) + '\"' ]} res = requests . post ( url = url_cmnd , json = data , headers = headers ) return res @hug . get ( \"/\" ) def gettime ( features = None , request = None , response = None ): out = ResponseFormatter () q = 'select * from v_feature_rfiponti_timerate' if features is not None : if not isinstance ( features , list ): features = [ features ] features = \",\" . join ( '\"' + str ( a ) + '\"' for a in features ) q = f \" { q } where feature in ( { features } )\" try : out . data = db [ 'query' ][ q ][[ 'feature' , 'minutes' ]] . to_dict ( orient = 'records' ) except Exception as e : out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature not found: { features } \" out . format ( request = request , response = response ) return @hug . get ( \"/ {feature} \" ) def gettimer ( feature = None , request = None , response = None ): return gettime ( features = feature , request = request , response = response ) @hug . post ( \"/ {feature} \" ) def chtime ( feature , newrate , request = None , response = None ): out = ResponseFormatter () serial = db [ 'query' ][ f 'select * from v_feature_rfiponti_timerate where feature= { feature !r} ' ][ 'serial' ] . squeeze () . replace ( \"'\" , \"\" ) print ( \" \\n \" , serial , \" \\n \" ) try : res = changerate ( serial , newrate ) print ( res . __dict__ ) except Exception as e : out . status = falcon . HTTP_NOT_FOUND out . message = f \"something gone wrong: { e } \" out . format ( request = request , response = response ) return stat = f \"REPLACE into feature_rfiponti_timerate VALUES ( { feature !r} , { newrate } )\" try : en = db [ 'query' ] . engine with en . begin () as conn : conn . execute ( 'start transaction' ) conn . execute ( stat ) en . dispose () except Exception as e : out . status = falcon . HTTP_NOT_FOUND out . message = f \"something gone wrong { e } \" out . format ( request = request , response = response ) return out return gettimer ( feature = feature , request = request , response = response )","title":"Module hielen3.api.italferdatarate"},{"location":"reference/hielen3/api/italferdatarate/#variables","text":"conf db","title":"Variables"},{"location":"reference/hielen3/api/italferdatarate/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/api/italferdatarate/#changerate","text":"def changerate ( serial , time ) View Source def changerate ( serial , time ) : if time is None : time = 0 time = int ( time ) if time < 1 : raise Exception ( \"new rate under minute\" ) time = time * 60 c = Cognito ( ** conf [ \"aws\" ][ \"pool\" ] ) c . authenticate ( conf [ \"aws\" ][ \"pwd\" ] ) headers = { \"Authorization\" : c . id_token } url_cmnd = 'https://0xnsi8bx82.execute-api.eu-west-1.amazonaws.com/Dev/portal/post_command' data = { \"wsn_sn\" : serial , \"command_code\" : 2 , \"command_args\" :[ '\"' + str ( time ) + '\"' ]} res = requests . post ( url = url_cmnd , json = data , headers = headers ) return res","title":"changerate"},{"location":"reference/hielen3/api/italferdatarate/#chtime","text":"def chtime ( feature , newrate , request = None , response = None ) View Source @hug . post ( \"/{feature}\" ) def chtime ( feature , newrate , request = None , response = None ) : out = ResponseFormatter () serial = db [ 'query' ][ f'select * from v_feature_rfiponti_timerate where feature={feature!r}' ][ 'serial' ] . squeeze (). replace ( \"'\" , \"\" ) print ( \"\\n\" , serial , \"\\n\" ) try : res = changerate ( serial , newrate ) print ( res . __dict__ ) except Exception as e : out . status = falcon . HTTP_NOT_FOUND out . message = f \"something gone wrong: {e}\" out . format ( request = request , response = response ) return stat = f \"REPLACE into feature_rfiponti_timerate VALUES ({feature!r},{newrate})\" try : en = db [ 'query' ] . engine with en . begin () as conn : conn . execute ( 'start transaction' ) conn . execute ( stat ) en . dispose () except Exception as e : out . status = falcon . HTTP_NOT_FOUND out . message = f \"something gone wrong {e}\" out . format ( request = request , response = response ) return out return gettimer ( feature = feature , request = request , response = response )","title":"chtime"},{"location":"reference/hielen3/api/italferdatarate/#gettime","text":"def gettime ( features = None , request = None , response = None ) View Source @hug . get ( \"/\" ) def gettime ( features = None , request = None , response = None ) : out = ResponseFormatter () q = 'select * from v_feature_rfiponti_timerate' if features is not None : if not isinstance ( features , list ) : features =[ features ] features = \",\" . join ( '\"' + str ( a ) + '\"' for a in features ) q = f \"{q} where feature in ({features})\" try : out . data = db [ 'query' ][ q ][ ['feature','minutes' ] ] . to_dict ( orient = 'records' ) except Exception as e : out . status = falcon . HTTP_NOT_FOUND out . message = f \"feature not found: {features}\" out . format ( request = request , response = response ) return","title":"gettime"},{"location":"reference/hielen3/api/italferdatarate/#gettimer","text":"def gettimer ( feature = None , request = None , response = None ) View Source @hug . get ( \"/{feature}\" ) def gettimer ( feature = None , request = None , response = None ) : return gettime ( features = feature , request = request , response = response )","title":"gettimer"},{"location":"reference/hielen3/api/prototypes/","text":"Module hielen3.api.prototypes View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #!/usr/bin/env python # coding=utf-8 import hug import falcon from hielen3 import db from hielen3.utils import ResponseFormatter @hug . get ( \"/\" ) def prototypes ( request = None , response = None ): \"\"\" **Ritorna l'elenco dei prototipi disponibili come array json** \"\"\" out = ResponseFormatter () try : out . data = list ( db [ 'features_proto' ] . db . index ) except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) @hug . get ( \"/ {prototype} \" ) def prototype_struct ( prototype , request = None , response = None ): \"\"\" **Ritorna informazioni dettagliate sullo specifico prototipo** \"\"\" out = ResponseFormatter () try : out . data = db [ \"features_proto\" ][ prototype ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) Variables db Functions prototype_struct def prototype_struct ( prototype , request = None , response = None ) Ritorna informazioni dettagliate sullo specifico prototipo View Source @hug . get ( \"/{prototype}\" ) def prototype_struct ( prototype , request = None , response = None ) : \"\"\" **Ritorna informazioni dettagliate sullo specifico prototipo** \"\"\" out = ResponseFormatter () try : out . data = db [ \"features_proto\" ][ prototype ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) prototypes def prototypes ( request = None , response = None ) Ritorna l'elenco dei prototipi disponibili come array json View Source @hug . get ( \"/\" ) def prototypes ( request = None , response = None ) : \"\"\" **Ritorna l'elenco dei prototipi disponibili come array json** \"\"\" out = ResponseFormatter () try : out . data = list ( db [ 'features_proto' ] . db . index ) except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request )","title":"Prototypes"},{"location":"reference/hielen3/api/prototypes/#module-hielen3apiprototypes","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #!/usr/bin/env python # coding=utf-8 import hug import falcon from hielen3 import db from hielen3.utils import ResponseFormatter @hug . get ( \"/\" ) def prototypes ( request = None , response = None ): \"\"\" **Ritorna l'elenco dei prototipi disponibili come array json** \"\"\" out = ResponseFormatter () try : out . data = list ( db [ 'features_proto' ] . db . index ) except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) @hug . get ( \"/ {prototype} \" ) def prototype_struct ( prototype , request = None , response = None ): \"\"\" **Ritorna informazioni dettagliate sullo specifico prototipo** \"\"\" out = ResponseFormatter () try : out . data = db [ \"features_proto\" ][ prototype ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request )","title":"Module hielen3.api.prototypes"},{"location":"reference/hielen3/api/prototypes/#variables","text":"db","title":"Variables"},{"location":"reference/hielen3/api/prototypes/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/api/prototypes/#prototype_struct","text":"def prototype_struct ( prototype , request = None , response = None ) Ritorna informazioni dettagliate sullo specifico prototipo View Source @hug . get ( \"/{prototype}\" ) def prototype_struct ( prototype , request = None , response = None ) : \"\"\" **Ritorna informazioni dettagliate sullo specifico prototipo** \"\"\" out = ResponseFormatter () try : out . data = db [ \"features_proto\" ][ prototype ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request )","title":"prototype_struct"},{"location":"reference/hielen3/api/prototypes/#prototypes","text":"def prototypes ( request = None , response = None ) Ritorna l'elenco dei prototipi disponibili come array json View Source @hug . get ( \"/\" ) def prototypes ( request = None , response = None ) : \"\"\" **Ritorna l'elenco dei prototipi disponibili come array json** \"\"\" out = ResponseFormatter () try : out . data = list ( db [ 'features_proto' ] . db . index ) except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request )","title":"prototypes"},{"location":"reference/hielen3/api/query/","text":"Module hielen3.api.query View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 #!/usr/bin/env python # coding=utf-8 import hug import falcon import json import tempfile from pathlib import Path from marshmallow import Schema , fields from numpy import nan , unique from pandas import DataFrame , to_datetime from hielen3 import db from hielen3.series import HSeries from hielen3.utils import hug_output_format_conten_type , JsonValidable , Selection , ResponseFormatter , uuid from hielen3.geje import GeoJSONSchema data_out_handler = hug_output_format_conten_type ( [ hug . output_format . json , hug . output_format . text , hug . output_format . file ] ) CSV = \"text/plain; charset=utf-8\" JSON = \"application/json; charset=utf-8\" XLSX = \"file/dynamic\" class DataMapSchema ( Schema ): \"\"\"\"\"\" times = Selection ( missing = slice ( None ), default = slice ( None ), required = False , allow_none = True ) timeref = fields . Str ( default = None , required = False , allow_none = True ) series = fields . List ( fields . Str , default = []) refresh = fields . Bool ( default = False , required = False , allow_none = True ) geometry = fields . List ( fields . Nested ( GeoJSONSchema , required = False , allow_none = True ), default = []) ####### API DATATABLE ####### @hug . get ( \"/ {capability} \" , examples = \"\" , output = data_out_handler ) def tabular_data ( capability , datamap : JsonValidable ( DataMapSchema ( many = True )), content_type = None , request = None , response = None , ** kwargs ): series = {} out = ResponseFormatter () for query in datamap : #ss = query.pop('series') try : ss = db [ 'series' ][ query . pop ( 'series' )] ss = list ( ss [ ss [ 'capability' ] == capability ][ 'uuid' ] . values ) except KeyError as e : out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) + \" not found\" response = out . format ( response = response , request = request ) return for p in ss : if p not in series . keys (): series [ p ] = [] series [ p ] . append ( HSeries ( p , orient = capability ) . thvalues ( ** query , ** kwargs ) ) df = DataFrame () for param , sers in series . items (): ser = None for r in sers : s = r . result () if ser is None : ser = s else : ser = ser . append ( s ) . sort_index () idx = unique ( ser . index . values , return_index = True )[ 1 ] ser = ser . iloc [ idx ] try : ser . columns = [ \"_\" . join ([ param , a ]) for a in ser . columns ] except Exception as e : ser . name = param df = df . join ( ser , how = \"outer\" ) df . index . name = \"timestamp\" if request is None : return df requested = data_out_handler . requested ( request ) . content_type if requested == CSV : return hug . types . text ( df . to_csv ( sep = ';' , date_format = \"%Y-%m- %d %H:%M:%S\" )) if requested == JSON : return hug . types . json ( df . to_json ( orient = \"table\" )) if requested == XLSX : filepath = Path ( tempfile . gettempdir (), f \" { uuid () } .xlsx\" ) df . to_excel ( filepath ) return filepath @hug . get ( \"/ {capability} / {feature} /\" , output = data_out_handler ) def tabular_data_el ( capability , feature , par = None , times = None , timeref = None , refresh = None , geometry = None , content_type = None , request = None , response = None , ** kwargs ): if isinstance ( geometry , list ): geometry = \",\" . join ( geometry ) if geometry is None : geometry = \"[]\" try : feature = feature . split ( \",\" ) except Exception : pass try : par = par . split ( \",\" ) except Exception : pass try : series = list ( db [ 'features_parameters' ][ feature , par ][ 'series' ] . values ) except KeyError as e : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = str ( feature ) + \" not found\" response = out . format ( response = response , request = request ) return datamap = dict ( series = series , times = times , timeref = timeref , geometry = \"#PLACEHOLDER#\" , refresh = refresh ) #print (datamap) datamap = json . dumps ( datamap ) . replace ( '\"#PLACEHOLDER#\"' , geometry ) datamap = DataMapSchema () . loads ( datamap ) return tabular_data ( capability = capability , datamap = [ datamap ], content_type = content_type , request = request , response = response , ** kwargs ) @hug . get ( \"/ {capability} / {feature} / {par} \" , output = data_out_handler ) def tabular_data_par ( capability , feature , par , times = None , timeref = None , refresh = None , geometry = None , content_type = None , request = None , response = None , ** kwargs ): return tabular_data_el ( capability = capability , feature = feature , par = par , times = times , timeref = timeref , refresh = refresh , geometry = geometry , content_type = content_type , request = request , response = response , ** kwargs ) Variables CSV JSON XLSX db nan Functions data_out_handler def data_out_handler ( data , request , response ) Supports any of the following formats: JSON (Javascript Serialized Object Notation), Free form UTF-8 text, A dynamically retrieved file View Source def output_type ( data , request , response ) : handler = requested_output_type ( request ) response . content_type = handler . content_type return handler ( data , request = request , response = response ) tabular_data def tabular_data ( capability , datamap : < hielen3 . utils . JsonValidable object at 0x7f74b1fd0130 > , content_type = None , request = None , response = None , ** kwargs ) View Source @hug . get ( \"/{capability}\" , examples = \"\" , output = data_out_handler ) def tabular_data ( capability , datamap : JsonValidable ( DataMapSchema ( many = True )), content_type = None , request = None , response = None , ** kwargs ) : series = {} out = ResponseFormatter () for query in datamap : #ss = query . pop ( 'series' ) try : ss = db [ 'series' ][ query.pop('series') ] ss = list ( ss [ ss['capability' ]== capability ] [ 'uuid' ] . values ) except KeyError as e : out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) + \" not found\" response = out . format ( response = response , request = request ) return for p in ss : if p not in series . keys () : series [ p ] = [] series [ p ] . append ( HSeries ( p , orient = capability ). thvalues ( ** query , ** kwargs ) ) df = DataFrame () for param , sers in series . items () : ser = None for r in sers : s = r . result () if ser is None : ser = s else : ser = ser . append ( s ). sort_index () idx = unique ( ser . index . values , return_index = True ) [ 1 ] ser = ser . iloc [ idx ] try : ser . columns = [ \"_\".join([param,a ] ) for a in ser . columns ] except Exception as e : ser . name = param df = df . join ( ser , how = \"outer\" ) df . index . name = \"timestamp\" if request is None : return df requested = data_out_handler . requested ( request ). content_type if requested == CSV : return hug . types . text ( df . to_csv ( sep = ';' , date_format = \"%Y-%m-%d %H:%M:%S\" )) if requested == JSON : return hug . types . json ( df . to_json ( orient = \"table\" )) if requested == XLSX : filepath = Path ( tempfile . gettempdir (), f \"{uuid()}.xlsx\" ) df . to_excel ( filepath ) return filepath tabular_data_el def tabular_data_el ( capability , feature , par = None , times = None , timeref = None , refresh = None , geometry = None , content_type = None , request = None , response = None , ** kwargs ) View Source @hug . get ( \"/{capability}/{feature}/\" , output = data_out_handler ) def tabular_data_el ( capability , feature , par = None , times = None , timeref = None , refresh = None , geometry = None , content_type = None , request = None , response = None , ** kwargs ) : if isinstance ( geometry , list ) : geometry = \",\" . join ( geometry ) if geometry is None : geometry = \"[]\" try : feature = feature . split ( \",\" ) except Exception : pass try : par = par . split ( \",\" ) except Exception : pass try : series = list ( db [ 'features_parameters' ][ feature,par ][ 'series' ] . values ) except KeyError as e : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = str ( feature ) + \" not found\" response = out . format ( response = response , request = request ) return datamap = dict ( series = series , times = times , timeref = timeref , geometry = \"#PLACEHOLDER#\" , refresh = refresh ) #print ( datamap ) datamap = json . dumps ( datamap ). replace ( '\"#PLACEHOLDER#\"' , geometry ) datamap = DataMapSchema (). loads ( datamap ) return tabular_data ( capability = capability , datamap =[ datamap ] , content_type = content_type , request = request , response = response , ** kwargs ) tabular_data_par def tabular_data_par ( capability , feature , par , times = None , timeref = None , refresh = None , geometry = None , content_type = None , request = None , response = None , ** kwargs ) View Source @hug . get ( \"/{capability}/{feature}/{par}\" , output = data_out_handler ) def tabular_data_par ( capability , feature , par , times = None , timeref = None , refresh = None , geometry = None , content_type = None , request = None , response = None , ** kwargs ) : return tabular_data_el ( capability = capability , feature = feature , par = par , times = times , timeref = timeref , refresh = refresh , geometry = geometry , content_type = content_type , request = request , response = response , ** kwargs ) Classes DataMapSchema class DataMapSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) View Source class DataMapSchema ( Schema ): \"\"\"\"\"\" times = Selection ( missing = slice ( None ), default = slice ( None ), required = False , allow_none = True ) timeref = fields . Str ( default = None , required = False , allow_none = True ) series = fields . List ( fields . Str , default =[]) refresh = fields . Bool ( default = False , required = False , allow_none = True ) geometry = fields . List ( fields . Nested ( GeoJSONSchema , required = False , allow_none = True ), default =[]) Ancestors (in MRO) marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages geometry opts refresh series timeref times Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"Query"},{"location":"reference/hielen3/api/query/#module-hielen3apiquery","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 #!/usr/bin/env python # coding=utf-8 import hug import falcon import json import tempfile from pathlib import Path from marshmallow import Schema , fields from numpy import nan , unique from pandas import DataFrame , to_datetime from hielen3 import db from hielen3.series import HSeries from hielen3.utils import hug_output_format_conten_type , JsonValidable , Selection , ResponseFormatter , uuid from hielen3.geje import GeoJSONSchema data_out_handler = hug_output_format_conten_type ( [ hug . output_format . json , hug . output_format . text , hug . output_format . file ] ) CSV = \"text/plain; charset=utf-8\" JSON = \"application/json; charset=utf-8\" XLSX = \"file/dynamic\" class DataMapSchema ( Schema ): \"\"\"\"\"\" times = Selection ( missing = slice ( None ), default = slice ( None ), required = False , allow_none = True ) timeref = fields . Str ( default = None , required = False , allow_none = True ) series = fields . List ( fields . Str , default = []) refresh = fields . Bool ( default = False , required = False , allow_none = True ) geometry = fields . List ( fields . Nested ( GeoJSONSchema , required = False , allow_none = True ), default = []) ####### API DATATABLE ####### @hug . get ( \"/ {capability} \" , examples = \"\" , output = data_out_handler ) def tabular_data ( capability , datamap : JsonValidable ( DataMapSchema ( many = True )), content_type = None , request = None , response = None , ** kwargs ): series = {} out = ResponseFormatter () for query in datamap : #ss = query.pop('series') try : ss = db [ 'series' ][ query . pop ( 'series' )] ss = list ( ss [ ss [ 'capability' ] == capability ][ 'uuid' ] . values ) except KeyError as e : out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) + \" not found\" response = out . format ( response = response , request = request ) return for p in ss : if p not in series . keys (): series [ p ] = [] series [ p ] . append ( HSeries ( p , orient = capability ) . thvalues ( ** query , ** kwargs ) ) df = DataFrame () for param , sers in series . items (): ser = None for r in sers : s = r . result () if ser is None : ser = s else : ser = ser . append ( s ) . sort_index () idx = unique ( ser . index . values , return_index = True )[ 1 ] ser = ser . iloc [ idx ] try : ser . columns = [ \"_\" . join ([ param , a ]) for a in ser . columns ] except Exception as e : ser . name = param df = df . join ( ser , how = \"outer\" ) df . index . name = \"timestamp\" if request is None : return df requested = data_out_handler . requested ( request ) . content_type if requested == CSV : return hug . types . text ( df . to_csv ( sep = ';' , date_format = \"%Y-%m- %d %H:%M:%S\" )) if requested == JSON : return hug . types . json ( df . to_json ( orient = \"table\" )) if requested == XLSX : filepath = Path ( tempfile . gettempdir (), f \" { uuid () } .xlsx\" ) df . to_excel ( filepath ) return filepath @hug . get ( \"/ {capability} / {feature} /\" , output = data_out_handler ) def tabular_data_el ( capability , feature , par = None , times = None , timeref = None , refresh = None , geometry = None , content_type = None , request = None , response = None , ** kwargs ): if isinstance ( geometry , list ): geometry = \",\" . join ( geometry ) if geometry is None : geometry = \"[]\" try : feature = feature . split ( \",\" ) except Exception : pass try : par = par . split ( \",\" ) except Exception : pass try : series = list ( db [ 'features_parameters' ][ feature , par ][ 'series' ] . values ) except KeyError as e : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = str ( feature ) + \" not found\" response = out . format ( response = response , request = request ) return datamap = dict ( series = series , times = times , timeref = timeref , geometry = \"#PLACEHOLDER#\" , refresh = refresh ) #print (datamap) datamap = json . dumps ( datamap ) . replace ( '\"#PLACEHOLDER#\"' , geometry ) datamap = DataMapSchema () . loads ( datamap ) return tabular_data ( capability = capability , datamap = [ datamap ], content_type = content_type , request = request , response = response , ** kwargs ) @hug . get ( \"/ {capability} / {feature} / {par} \" , output = data_out_handler ) def tabular_data_par ( capability , feature , par , times = None , timeref = None , refresh = None , geometry = None , content_type = None , request = None , response = None , ** kwargs ): return tabular_data_el ( capability = capability , feature = feature , par = par , times = times , timeref = timeref , refresh = refresh , geometry = geometry , content_type = content_type , request = request , response = response , ** kwargs )","title":"Module hielen3.api.query"},{"location":"reference/hielen3/api/query/#variables","text":"CSV JSON XLSX db nan","title":"Variables"},{"location":"reference/hielen3/api/query/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/api/query/#data_out_handler","text":"def data_out_handler ( data , request , response ) Supports any of the following formats: JSON (Javascript Serialized Object Notation), Free form UTF-8 text, A dynamically retrieved file View Source def output_type ( data , request , response ) : handler = requested_output_type ( request ) response . content_type = handler . content_type return handler ( data , request = request , response = response )","title":"data_out_handler"},{"location":"reference/hielen3/api/query/#tabular_data","text":"def tabular_data ( capability , datamap : < hielen3 . utils . JsonValidable object at 0x7f74b1fd0130 > , content_type = None , request = None , response = None , ** kwargs ) View Source @hug . get ( \"/{capability}\" , examples = \"\" , output = data_out_handler ) def tabular_data ( capability , datamap : JsonValidable ( DataMapSchema ( many = True )), content_type = None , request = None , response = None , ** kwargs ) : series = {} out = ResponseFormatter () for query in datamap : #ss = query . pop ( 'series' ) try : ss = db [ 'series' ][ query.pop('series') ] ss = list ( ss [ ss['capability' ]== capability ] [ 'uuid' ] . values ) except KeyError as e : out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) + \" not found\" response = out . format ( response = response , request = request ) return for p in ss : if p not in series . keys () : series [ p ] = [] series [ p ] . append ( HSeries ( p , orient = capability ). thvalues ( ** query , ** kwargs ) ) df = DataFrame () for param , sers in series . items () : ser = None for r in sers : s = r . result () if ser is None : ser = s else : ser = ser . append ( s ). sort_index () idx = unique ( ser . index . values , return_index = True ) [ 1 ] ser = ser . iloc [ idx ] try : ser . columns = [ \"_\".join([param,a ] ) for a in ser . columns ] except Exception as e : ser . name = param df = df . join ( ser , how = \"outer\" ) df . index . name = \"timestamp\" if request is None : return df requested = data_out_handler . requested ( request ). content_type if requested == CSV : return hug . types . text ( df . to_csv ( sep = ';' , date_format = \"%Y-%m-%d %H:%M:%S\" )) if requested == JSON : return hug . types . json ( df . to_json ( orient = \"table\" )) if requested == XLSX : filepath = Path ( tempfile . gettempdir (), f \"{uuid()}.xlsx\" ) df . to_excel ( filepath ) return filepath","title":"tabular_data"},{"location":"reference/hielen3/api/query/#tabular_data_el","text":"def tabular_data_el ( capability , feature , par = None , times = None , timeref = None , refresh = None , geometry = None , content_type = None , request = None , response = None , ** kwargs ) View Source @hug . get ( \"/{capability}/{feature}/\" , output = data_out_handler ) def tabular_data_el ( capability , feature , par = None , times = None , timeref = None , refresh = None , geometry = None , content_type = None , request = None , response = None , ** kwargs ) : if isinstance ( geometry , list ) : geometry = \",\" . join ( geometry ) if geometry is None : geometry = \"[]\" try : feature = feature . split ( \",\" ) except Exception : pass try : par = par . split ( \",\" ) except Exception : pass try : series = list ( db [ 'features_parameters' ][ feature,par ][ 'series' ] . values ) except KeyError as e : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = str ( feature ) + \" not found\" response = out . format ( response = response , request = request ) return datamap = dict ( series = series , times = times , timeref = timeref , geometry = \"#PLACEHOLDER#\" , refresh = refresh ) #print ( datamap ) datamap = json . dumps ( datamap ). replace ( '\"#PLACEHOLDER#\"' , geometry ) datamap = DataMapSchema (). loads ( datamap ) return tabular_data ( capability = capability , datamap =[ datamap ] , content_type = content_type , request = request , response = response , ** kwargs )","title":"tabular_data_el"},{"location":"reference/hielen3/api/query/#tabular_data_par","text":"def tabular_data_par ( capability , feature , par , times = None , timeref = None , refresh = None , geometry = None , content_type = None , request = None , response = None , ** kwargs ) View Source @hug . get ( \"/{capability}/{feature}/{par}\" , output = data_out_handler ) def tabular_data_par ( capability , feature , par , times = None , timeref = None , refresh = None , geometry = None , content_type = None , request = None , response = None , ** kwargs ) : return tabular_data_el ( capability = capability , feature = feature , par = par , times = times , timeref = timeref , refresh = refresh , geometry = geometry , content_type = content_type , request = request , response = response , ** kwargs )","title":"tabular_data_par"},{"location":"reference/hielen3/api/query/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/api/query/#datamapschema","text":"class DataMapSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) View Source class DataMapSchema ( Schema ): \"\"\"\"\"\" times = Selection ( missing = slice ( None ), default = slice ( None ), required = False , allow_none = True ) timeref = fields . Str ( default = None , required = False , allow_none = True ) series = fields . List ( fields . Str , default =[]) refresh = fields . Bool ( default = False , required = False , allow_none = True ) geometry = fields . List ( fields . Nested ( GeoJSONSchema , required = False , allow_none = True ), default =[])","title":"DataMapSchema"},{"location":"reference/hielen3/api/query/#ancestors-in-mro","text":"marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/api/query/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages geometry opts refresh series timeref times","title":"Class variables"},{"location":"reference/hielen3/api/query/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/api/query/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/api/query/#instance-variables","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen3/api/query/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/api/query/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/api/query/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/api/query/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/api/query/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/api/query/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/api/query/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/api/query/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/api/query/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/api/query2/","text":"Module hielen3.api.query2 View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 #!/usr/bin/env python # coding=utf-8 import hug import falcon import json import tempfile from pathlib import Path from marshmallow import Schema , fields from numpy import nan , unique from pandas import DataFrame , to_datetime from hielen3 import db from hielen3.series import HSeries from hielen3.utils import hug_output_format_conten_type , JsonValidable , Selection , ResponseFormatter , uuid from hielen3.geje import GeoJSONSchema data_out_handler = hug_output_format_conten_type ( [ hug . output_format . json , hug . output_format . text , hug . output_format . file ] ) CSV = \"text/plain; charset=utf-8\" JSON = \"application/json; charset=utf-8\" XLSX = \"file/dynamic\" class DataMapSchema ( Schema ): \"\"\"\"\"\" times = Selection ( missing = slice ( None ), default = slice ( None ), required = False , allow_none = True ) timeref = fields . Str ( default = None , required = False , allow_none = True ) series = fields . List ( fields . Str , default = []) refresh = fields . Bool ( default = False , required = False , allow_none = True ) geometry = fields . List ( fields . Nested ( GeoJSONSchema , required = False , allow_none = True ), default = []) ####### API DATATABLE ####### @hug . get ( \"/ {capability} \" , examples = \"\" , output = data_out_handler ) def tabular_data ( capability , datamap : JsonValidable ( DataMapSchema ( many = True )), content_type = None , request = None , response = None , ** kwargs ): series = {} out = ResponseFormatter () for query in datamap : #ss = query.pop('series') try : ss = db [ 'series' ][ query . pop ( 'series' )] ss = list ( ss [ ss [ 'capability' ] == capability ][ 'uuid' ] . values ) except KeyError as e : out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) + \" not found\" response = out . format ( response = response , request = request ) return for p in ss : if p not in series . keys (): series [ p ] = [] series [ p ] . append ( HSeries ( p ) . thvalues ( ** query , ** kwargs ) ) df = DataFrame () for param , sers in series . items (): ser = None for r in sers : s = r . result () if ser is None : ser = s else : ser = concat ([ ser , s ]) . sort_index () ser = ser [ ~ ser . index . duplicated ()] \"\"\" ser = ser.append(s).sort_index() idx = unique(ser.index.values, return_index=True)[1] ser = ser.iloc[idx] \"\"\" \"\"\" try: ser.columns = [ \"_\".join([param,a]) for a in ser.columns] except Exception as e: ser.name=param \"\"\" df = df . join ( ser , how = \"outer\" ) df . index . name = \"timestamp\" if request is None : return df requested = data_out_handler . requested ( request ) . content_type if requested == CSV : return hug . types . text ( df . to_csv ( sep = ';' , date_format = \"%Y-%m- %d %H:%M:%S\" )) if requested == JSON : df . index = df . index . astype ( 'str' ) df . columns . names = [ 'S' ] df = df . replace ({ nan : None }) out . data = { series : data . to_records () . tolist () for series , data in df . groupby ( 'S' , axis = 1 ) } response = out . format ( response = response , request = request ) return if requested == XLSX : h = db [ 'features_parameters_headers' ][ list ( df . columns )] df = df . T . join ( h [[ 'series' , 'feature' , 'parameter' ]]) . set_index ([ 'feature' , 'parameter' , 'series' ]) . sort_index () . T df . index . name = 'timestamp' filepath = Path ( tempfile . gettempdir (), f \" { uuid () } .xlsx\" ) df . to_excel ( filepath ) return filepath @hug . get ( \"/ {capability} / {feature} /\" , output = data_out_handler ) def tabular_data_el ( capability , feature , par = None , times = None , timeref = None , refresh = None , geometry = None , content_type = None , request = None , response = None , ** kwargs ): if isinstance ( geometry , list ): geometry = \",\" . join ( geometry ) if geometry is None : geometry = \"[]\" try : feature = feature . split ( \",\" ) except Exception : pass try : par = par . split ( \",\" ) except Exception : pass try : series = list ( db [ 'features_parameters' ][ feature , par ][ 'series' ] . values ) except KeyError as e : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = str ( feature ) + \" not found\" response = out . format ( response = response , request = request ) return datamap = dict ( series = series , times = times , timeref = timeref , geometry = \"#PLACEHOLDER#\" , refresh = refresh ) #print (datamap) datamap = json . dumps ( datamap ) . replace ( '\"#PLACEHOLDER#\"' , geometry ) datamap = DataMapSchema () . loads ( datamap ) return tabular_data ( capability = capability , datamap = [ datamap ], content_type = content_type , request = request , response = response , ** kwargs ) @hug . get ( \"/ {capability} / {feature} / {par} \" , output = data_out_handler ) def tabular_data_par ( capability , feature , par , times = None , timeref = None , refresh = None , geometry = None , content_type = None , request = None , response = None , ** kwargs ): return tabular_data_el ( capability = capability , feature = feature , par = par , times = times , timeref = timeref , refresh = refresh , geometry = geometry , content_type = content_type , request = request , response = response , ** kwargs ) Variables CSV JSON XLSX db nan Functions data_out_handler def data_out_handler ( data , request , response ) Supports any of the following formats: JSON (Javascript Serialized Object Notation), Free form UTF-8 text, A dynamically retrieved file View Source def output_type ( data , request , response ) : handler = requested_output_type ( request ) response . content_type = handler . content_type return handler ( data , request = request , response = response ) tabular_data def tabular_data ( capability , datamap : < hielen3 . utils . JsonValidable object at 0x7f74b1fd0f70 > , content_type = None , request = None , response = None , ** kwargs ) View Source @hug . get ( \"/{capability}\" , examples = \"\" , output = data_out_handler ) def tabular_data ( capability , datamap : JsonValidable ( DataMapSchema ( many = True )), content_type = None , request = None , response = None , ** kwargs ) : series = {} out = ResponseFormatter () for query in datamap : #ss = query . pop ( 'series' ) try : ss = db [ 'series' ][ query.pop('series') ] ss = list ( ss [ ss['capability' ]== capability ] [ 'uuid' ] . values ) except KeyError as e : out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) + \" not found\" response = out . format ( response = response , request = request ) return for p in ss : if p not in series . keys () : series [ p ] = [] series [ p ] . append ( HSeries ( p ). thvalues ( ** query , ** kwargs ) ) df = DataFrame () for param , sers in series . items () : ser = None for r in sers : s = r . result () if ser is None : ser = s else : ser = concat ( [ ser,s ] ). sort_index () ser = ser [ ~ser.index.duplicated() ] \"\"\" ser = ser.append(s).sort_index() idx = unique(ser.index.values, return_index=True)[1] ser = ser.iloc[idx] \"\"\" \"\"\" try: ser.columns = [ \" _ \".join([param,a]) for a in ser.columns] except Exception as e: ser.name=param \"\"\" df = df . join ( ser , how = \"outer\" ) df . index . name = \"timestamp\" if request is None : return df requested = data_out_handler . requested ( request ). content_type if requested == CSV : return hug . types . text ( df . to_csv ( sep = ';' , date_format = \"%Y-%m-%d %H:%M:%S\" )) if requested == JSON : df . index = df . index . astype ( 'str' ) df . columns . names =[ 'S' ] df = df . replace ( { nan : None } ) out . data = { series : data . to_records (). tolist () for series , data in df . groupby ( 'S' , axis = 1 ) } response = out . format ( response = response , request = request ) return if requested == XLSX : h = db [ 'features_parameters_headers' ][ list(df.columns) ] df = df . T . join ( h [ ['series','feature','parameter' ] ] ). set_index ( [ 'feature','parameter','series' ] ). sort_index (). T df . index . name = 'timestamp' filepath = Path ( tempfile . gettempdir (), f \"{uuid()}.xlsx\" ) df . to_excel ( filepath ) return filepath tabular_data_el def tabular_data_el ( capability , feature , par = None , times = None , timeref = None , refresh = None , geometry = None , content_type = None , request = None , response = None , ** kwargs ) View Source @hug . get ( \"/{capability}/{feature}/\" , output = data_out_handler ) def tabular_data_el ( capability , feature , par = None , times = None , timeref = None , refresh = None , geometry = None , content_type = None , request = None , response = None , ** kwargs ) : if isinstance ( geometry , list ) : geometry = \",\" . join ( geometry ) if geometry is None : geometry = \"[]\" try : feature = feature . split ( \",\" ) except Exception : pass try : par = par . split ( \",\" ) except Exception : pass try : series = list ( db [ 'features_parameters' ][ feature,par ][ 'series' ] . values ) except KeyError as e : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = str ( feature ) + \" not found\" response = out . format ( response = response , request = request ) return datamap = dict ( series = series , times = times , timeref = timeref , geometry = \"#PLACEHOLDER#\" , refresh = refresh ) #print ( datamap ) datamap = json . dumps ( datamap ). replace ( '\"#PLACEHOLDER#\"' , geometry ) datamap = DataMapSchema (). loads ( datamap ) return tabular_data ( capability = capability , datamap =[ datamap ] , content_type = content_type , request = request , response = response , ** kwargs ) tabular_data_par def tabular_data_par ( capability , feature , par , times = None , timeref = None , refresh = None , geometry = None , content_type = None , request = None , response = None , ** kwargs ) View Source @hug . get ( \"/{capability}/{feature}/{par}\" , output = data_out_handler ) def tabular_data_par ( capability , feature , par , times = None , timeref = None , refresh = None , geometry = None , content_type = None , request = None , response = None , ** kwargs ) : return tabular_data_el ( capability = capability , feature = feature , par = par , times = times , timeref = timeref , refresh = refresh , geometry = geometry , content_type = content_type , request = request , response = response , ** kwargs ) Classes DataMapSchema class DataMapSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) View Source class DataMapSchema ( Schema ): \"\"\"\"\"\" times = Selection ( missing = slice ( None ), default = slice ( None ), required = False , allow_none = True ) timeref = fields . Str ( default = None , required = False , allow_none = True ) series = fields . List ( fields . Str , default =[]) refresh = fields . Bool ( default = False , required = False , allow_none = True ) geometry = fields . List ( fields . Nested ( GeoJSONSchema , required = False , allow_none = True ), default =[]) Ancestors (in MRO) marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages geometry opts refresh series timeref times Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"Query2"},{"location":"reference/hielen3/api/query2/#module-hielen3apiquery2","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 #!/usr/bin/env python # coding=utf-8 import hug import falcon import json import tempfile from pathlib import Path from marshmallow import Schema , fields from numpy import nan , unique from pandas import DataFrame , to_datetime from hielen3 import db from hielen3.series import HSeries from hielen3.utils import hug_output_format_conten_type , JsonValidable , Selection , ResponseFormatter , uuid from hielen3.geje import GeoJSONSchema data_out_handler = hug_output_format_conten_type ( [ hug . output_format . json , hug . output_format . text , hug . output_format . file ] ) CSV = \"text/plain; charset=utf-8\" JSON = \"application/json; charset=utf-8\" XLSX = \"file/dynamic\" class DataMapSchema ( Schema ): \"\"\"\"\"\" times = Selection ( missing = slice ( None ), default = slice ( None ), required = False , allow_none = True ) timeref = fields . Str ( default = None , required = False , allow_none = True ) series = fields . List ( fields . Str , default = []) refresh = fields . Bool ( default = False , required = False , allow_none = True ) geometry = fields . List ( fields . Nested ( GeoJSONSchema , required = False , allow_none = True ), default = []) ####### API DATATABLE ####### @hug . get ( \"/ {capability} \" , examples = \"\" , output = data_out_handler ) def tabular_data ( capability , datamap : JsonValidable ( DataMapSchema ( many = True )), content_type = None , request = None , response = None , ** kwargs ): series = {} out = ResponseFormatter () for query in datamap : #ss = query.pop('series') try : ss = db [ 'series' ][ query . pop ( 'series' )] ss = list ( ss [ ss [ 'capability' ] == capability ][ 'uuid' ] . values ) except KeyError as e : out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) + \" not found\" response = out . format ( response = response , request = request ) return for p in ss : if p not in series . keys (): series [ p ] = [] series [ p ] . append ( HSeries ( p ) . thvalues ( ** query , ** kwargs ) ) df = DataFrame () for param , sers in series . items (): ser = None for r in sers : s = r . result () if ser is None : ser = s else : ser = concat ([ ser , s ]) . sort_index () ser = ser [ ~ ser . index . duplicated ()] \"\"\" ser = ser.append(s).sort_index() idx = unique(ser.index.values, return_index=True)[1] ser = ser.iloc[idx] \"\"\" \"\"\" try: ser.columns = [ \"_\".join([param,a]) for a in ser.columns] except Exception as e: ser.name=param \"\"\" df = df . join ( ser , how = \"outer\" ) df . index . name = \"timestamp\" if request is None : return df requested = data_out_handler . requested ( request ) . content_type if requested == CSV : return hug . types . text ( df . to_csv ( sep = ';' , date_format = \"%Y-%m- %d %H:%M:%S\" )) if requested == JSON : df . index = df . index . astype ( 'str' ) df . columns . names = [ 'S' ] df = df . replace ({ nan : None }) out . data = { series : data . to_records () . tolist () for series , data in df . groupby ( 'S' , axis = 1 ) } response = out . format ( response = response , request = request ) return if requested == XLSX : h = db [ 'features_parameters_headers' ][ list ( df . columns )] df = df . T . join ( h [[ 'series' , 'feature' , 'parameter' ]]) . set_index ([ 'feature' , 'parameter' , 'series' ]) . sort_index () . T df . index . name = 'timestamp' filepath = Path ( tempfile . gettempdir (), f \" { uuid () } .xlsx\" ) df . to_excel ( filepath ) return filepath @hug . get ( \"/ {capability} / {feature} /\" , output = data_out_handler ) def tabular_data_el ( capability , feature , par = None , times = None , timeref = None , refresh = None , geometry = None , content_type = None , request = None , response = None , ** kwargs ): if isinstance ( geometry , list ): geometry = \",\" . join ( geometry ) if geometry is None : geometry = \"[]\" try : feature = feature . split ( \",\" ) except Exception : pass try : par = par . split ( \",\" ) except Exception : pass try : series = list ( db [ 'features_parameters' ][ feature , par ][ 'series' ] . values ) except KeyError as e : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = str ( feature ) + \" not found\" response = out . format ( response = response , request = request ) return datamap = dict ( series = series , times = times , timeref = timeref , geometry = \"#PLACEHOLDER#\" , refresh = refresh ) #print (datamap) datamap = json . dumps ( datamap ) . replace ( '\"#PLACEHOLDER#\"' , geometry ) datamap = DataMapSchema () . loads ( datamap ) return tabular_data ( capability = capability , datamap = [ datamap ], content_type = content_type , request = request , response = response , ** kwargs ) @hug . get ( \"/ {capability} / {feature} / {par} \" , output = data_out_handler ) def tabular_data_par ( capability , feature , par , times = None , timeref = None , refresh = None , geometry = None , content_type = None , request = None , response = None , ** kwargs ): return tabular_data_el ( capability = capability , feature = feature , par = par , times = times , timeref = timeref , refresh = refresh , geometry = geometry , content_type = content_type , request = request , response = response , ** kwargs )","title":"Module hielen3.api.query2"},{"location":"reference/hielen3/api/query2/#variables","text":"CSV JSON XLSX db nan","title":"Variables"},{"location":"reference/hielen3/api/query2/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/api/query2/#data_out_handler","text":"def data_out_handler ( data , request , response ) Supports any of the following formats: JSON (Javascript Serialized Object Notation), Free form UTF-8 text, A dynamically retrieved file View Source def output_type ( data , request , response ) : handler = requested_output_type ( request ) response . content_type = handler . content_type return handler ( data , request = request , response = response )","title":"data_out_handler"},{"location":"reference/hielen3/api/query2/#tabular_data","text":"def tabular_data ( capability , datamap : < hielen3 . utils . JsonValidable object at 0x7f74b1fd0f70 > , content_type = None , request = None , response = None , ** kwargs ) View Source @hug . get ( \"/{capability}\" , examples = \"\" , output = data_out_handler ) def tabular_data ( capability , datamap : JsonValidable ( DataMapSchema ( many = True )), content_type = None , request = None , response = None , ** kwargs ) : series = {} out = ResponseFormatter () for query in datamap : #ss = query . pop ( 'series' ) try : ss = db [ 'series' ][ query.pop('series') ] ss = list ( ss [ ss['capability' ]== capability ] [ 'uuid' ] . values ) except KeyError as e : out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) + \" not found\" response = out . format ( response = response , request = request ) return for p in ss : if p not in series . keys () : series [ p ] = [] series [ p ] . append ( HSeries ( p ). thvalues ( ** query , ** kwargs ) ) df = DataFrame () for param , sers in series . items () : ser = None for r in sers : s = r . result () if ser is None : ser = s else : ser = concat ( [ ser,s ] ). sort_index () ser = ser [ ~ser.index.duplicated() ] \"\"\" ser = ser.append(s).sort_index() idx = unique(ser.index.values, return_index=True)[1] ser = ser.iloc[idx] \"\"\" \"\"\" try: ser.columns = [ \" _ \".join([param,a]) for a in ser.columns] except Exception as e: ser.name=param \"\"\" df = df . join ( ser , how = \"outer\" ) df . index . name = \"timestamp\" if request is None : return df requested = data_out_handler . requested ( request ). content_type if requested == CSV : return hug . types . text ( df . to_csv ( sep = ';' , date_format = \"%Y-%m-%d %H:%M:%S\" )) if requested == JSON : df . index = df . index . astype ( 'str' ) df . columns . names =[ 'S' ] df = df . replace ( { nan : None } ) out . data = { series : data . to_records (). tolist () for series , data in df . groupby ( 'S' , axis = 1 ) } response = out . format ( response = response , request = request ) return if requested == XLSX : h = db [ 'features_parameters_headers' ][ list(df.columns) ] df = df . T . join ( h [ ['series','feature','parameter' ] ] ). set_index ( [ 'feature','parameter','series' ] ). sort_index (). T df . index . name = 'timestamp' filepath = Path ( tempfile . gettempdir (), f \"{uuid()}.xlsx\" ) df . to_excel ( filepath ) return filepath","title":"tabular_data"},{"location":"reference/hielen3/api/query2/#tabular_data_el","text":"def tabular_data_el ( capability , feature , par = None , times = None , timeref = None , refresh = None , geometry = None , content_type = None , request = None , response = None , ** kwargs ) View Source @hug . get ( \"/{capability}/{feature}/\" , output = data_out_handler ) def tabular_data_el ( capability , feature , par = None , times = None , timeref = None , refresh = None , geometry = None , content_type = None , request = None , response = None , ** kwargs ) : if isinstance ( geometry , list ) : geometry = \",\" . join ( geometry ) if geometry is None : geometry = \"[]\" try : feature = feature . split ( \",\" ) except Exception : pass try : par = par . split ( \",\" ) except Exception : pass try : series = list ( db [ 'features_parameters' ][ feature,par ][ 'series' ] . values ) except KeyError as e : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = str ( feature ) + \" not found\" response = out . format ( response = response , request = request ) return datamap = dict ( series = series , times = times , timeref = timeref , geometry = \"#PLACEHOLDER#\" , refresh = refresh ) #print ( datamap ) datamap = json . dumps ( datamap ). replace ( '\"#PLACEHOLDER#\"' , geometry ) datamap = DataMapSchema (). loads ( datamap ) return tabular_data ( capability = capability , datamap =[ datamap ] , content_type = content_type , request = request , response = response , ** kwargs )","title":"tabular_data_el"},{"location":"reference/hielen3/api/query2/#tabular_data_par","text":"def tabular_data_par ( capability , feature , par , times = None , timeref = None , refresh = None , geometry = None , content_type = None , request = None , response = None , ** kwargs ) View Source @hug . get ( \"/{capability}/{feature}/{par}\" , output = data_out_handler ) def tabular_data_par ( capability , feature , par , times = None , timeref = None , refresh = None , geometry = None , content_type = None , request = None , response = None , ** kwargs ) : return tabular_data_el ( capability = capability , feature = feature , par = par , times = times , timeref = timeref , refresh = refresh , geometry = geometry , content_type = content_type , request = request , response = response , ** kwargs )","title":"tabular_data_par"},{"location":"reference/hielen3/api/query2/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/api/query2/#datamapschema","text":"class DataMapSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) View Source class DataMapSchema ( Schema ): \"\"\"\"\"\" times = Selection ( missing = slice ( None ), default = slice ( None ), required = False , allow_none = True ) timeref = fields . Str ( default = None , required = False , allow_none = True ) series = fields . List ( fields . Str , default =[]) refresh = fields . Bool ( default = False , required = False , allow_none = True ) geometry = fields . List ( fields . Nested ( GeoJSONSchema , required = False , allow_none = True ), default =[])","title":"DataMapSchema"},{"location":"reference/hielen3/api/query2/#ancestors-in-mro","text":"marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/api/query2/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages geometry opts refresh series timeref times","title":"Class variables"},{"location":"reference/hielen3/api/query2/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/api/query2/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/api/query2/#instance-variables","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen3/api/query2/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/api/query2/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/api/query2/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/api/query2/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/api/query2/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/api/query2/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/api/query2/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/api/query2/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/api/query2/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/api/queue/","text":"Module hielen3.api.queue View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #!/usr/bin/env python # coding=utf-8 import hug import falcon from hielen3.tools import hls_facility as hls from hielen3.utils import ResponseFormatter , dataframe2jsonizabledict @hug . get ( \"/ {queue} \" ) def retrive ( queue , request = None , response = None ): out = ResponseFormatter () out . data , outcode = hls . get_stream ( queue ) if outcode == 404 : out . status = falcon . HTTP_NOT_FOUND out . message = f \"queue not found: { queue } \" else : out . data = dataframe2jsonizabledict ( out . data ) out . format ( request = request , response = response ) return Functions retrive def retrive ( queue , request = None , response = None ) View Source @hug . get ( \"/{queue}\" ) def retrive ( queue , request = None , response = None ) : out = ResponseFormatter () out . data , outcode = hls . get_stream ( queue ) if outcode == 404 : out . status = falcon . HTTP_NOT_FOUND out . message = f \"queue not found: {queue}\" else : out . data = dataframe2jsonizabledict ( out . data ) out . format ( request = request , response = response ) return","title":"Queue"},{"location":"reference/hielen3/api/queue/#module-hielen3apiqueue","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #!/usr/bin/env python # coding=utf-8 import hug import falcon from hielen3.tools import hls_facility as hls from hielen3.utils import ResponseFormatter , dataframe2jsonizabledict @hug . get ( \"/ {queue} \" ) def retrive ( queue , request = None , response = None ): out = ResponseFormatter () out . data , outcode = hls . get_stream ( queue ) if outcode == 404 : out . status = falcon . HTTP_NOT_FOUND out . message = f \"queue not found: { queue } \" else : out . data = dataframe2jsonizabledict ( out . data ) out . format ( request = request , response = response ) return","title":"Module hielen3.api.queue"},{"location":"reference/hielen3/api/queue/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/api/queue/#retrive","text":"def retrive ( queue , request = None , response = None ) View Source @hug . get ( \"/{queue}\" ) def retrive ( queue , request = None , response = None ) : out = ResponseFormatter () out . data , outcode = hls . get_stream ( queue ) if outcode == 404 : out . status = falcon . HTTP_NOT_FOUND out . message = f \"queue not found: {queue}\" else : out . data = dataframe2jsonizabledict ( out . data ) out . format ( request = request , response = response ) return","title":"retrive"},{"location":"reference/hielen3/api/status/","text":"Module hielen3.api.status View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #!/usr/bin/env python # coding=utf-8 import hug import falcon from hielen3 import db from hielen3.utils import ResponseFormatter , dataframe2jsonizabledict import traceback @hug . get ( \"/\" ) def fands_status ( uids = None , cntxt = None , request = None , response = None ): out = ResponseFormatter () if cntxt is not None and not isinstance ( cntxt , list ): if cntxt == \"\" : cntxt = None else : cntxt = [ cntxt ] try : feafra = db [ 'status' ][ uids , cntxt ] feafra = dataframe2jsonizabledict ( feafra . droplevel ( \"context\" ), orient = 'records' , squeeze = False ) out . data = feafra feafra = None except KeyError as e : out . data = [] out . message = e . args response = out . format ( response = response , request = request ) return @hug . get ( \"/ {uid} \" ) def ffandss_status ( uid , cntxt = None , request = None , response = None ): return fands_status ( uid , cntxt , request , response ) Variables db Functions fands_status def fands_status ( uids = None , cntxt = None , request = None , response = None ) View Source @hug . get ( \"/\" ) def fands_status ( uids = None , cntxt = None , request = None , response = None ) : out = ResponseFormatter () if cntxt is not None and not isinstance ( cntxt , list ) : if cntxt == \"\" : cntxt = None else : cntxt = [ cntxt ] try : feafra = db [ 'status' ][ uids,cntxt ] feafra = dataframe2jsonizabledict ( feafra . droplevel ( \"context\" ), orient = 'records' , squeeze = False ) out . data = feafra feafra = None except KeyError as e : out . data = [] out . message = e . args response = out . format ( response = response , request = request ) return ffandss_status def ffandss_status ( uid , cntxt = None , request = None , response = None ) View Source @hug . get ( \"/{uid}\" ) def ffandss_status ( uid , cntxt = None , request = None , response = None ) : return fands_status ( uid , cntxt , request , response )","title":"Status"},{"location":"reference/hielen3/api/status/#module-hielen3apistatus","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #!/usr/bin/env python # coding=utf-8 import hug import falcon from hielen3 import db from hielen3.utils import ResponseFormatter , dataframe2jsonizabledict import traceback @hug . get ( \"/\" ) def fands_status ( uids = None , cntxt = None , request = None , response = None ): out = ResponseFormatter () if cntxt is not None and not isinstance ( cntxt , list ): if cntxt == \"\" : cntxt = None else : cntxt = [ cntxt ] try : feafra = db [ 'status' ][ uids , cntxt ] feafra = dataframe2jsonizabledict ( feafra . droplevel ( \"context\" ), orient = 'records' , squeeze = False ) out . data = feafra feafra = None except KeyError as e : out . data = [] out . message = e . args response = out . format ( response = response , request = request ) return @hug . get ( \"/ {uid} \" ) def ffandss_status ( uid , cntxt = None , request = None , response = None ): return fands_status ( uid , cntxt , request , response )","title":"Module hielen3.api.status"},{"location":"reference/hielen3/api/status/#variables","text":"db","title":"Variables"},{"location":"reference/hielen3/api/status/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/api/status/#fands_status","text":"def fands_status ( uids = None , cntxt = None , request = None , response = None ) View Source @hug . get ( \"/\" ) def fands_status ( uids = None , cntxt = None , request = None , response = None ) : out = ResponseFormatter () if cntxt is not None and not isinstance ( cntxt , list ) : if cntxt == \"\" : cntxt = None else : cntxt = [ cntxt ] try : feafra = db [ 'status' ][ uids,cntxt ] feafra = dataframe2jsonizabledict ( feafra . droplevel ( \"context\" ), orient = 'records' , squeeze = False ) out . data = feafra feafra = None except KeyError as e : out . data = [] out . message = e . args response = out . format ( response = response , request = request ) return","title":"fands_status"},{"location":"reference/hielen3/api/status/#ffandss_status","text":"def ffandss_status ( uid , cntxt = None , request = None , response = None ) View Source @hug . get ( \"/{uid}\" ) def ffandss_status ( uid , cntxt = None , request = None , response = None ) : return fands_status ( uid , cntxt , request , response )","title":"ffandss_status"},{"location":"reference/hielen3/ext/","text":"Module hielen3.ext Sub-modules hielen3.ext.feature_datetree_filesystem_source hielen3.ext.feature_hot_spot hielen3.ext.feature_instrument hielen3.ext.feature_instrument_clinometer hielen3.ext.feature_instrument_generic hielen3.ext.feature_instrument_improved hielen3.ext.feature_instrument_piezometer hielen3.ext.feature_instrument_shapearray hielen3.ext.feature_instrument_solgeo hielen3.ext.feature_logger_boviar hielen3.ext.feature_logger_capetti hielen3.ext.feature_logger_gestecno hielen3.ext.feature_logger_move hielen3.ext.feature_logger_move__ hielen3.ext.feature_logger_omnialog_temp hielen3.ext.feature_logger_smartbrik4_0 hielen3.ext.feature_logger_winecap hielen3.ext.feature_rfilogger hielen3.ext.feature_spotted_files_source","title":"Index"},{"location":"reference/hielen3/ext/#module-hielen3ext","text":"","title":"Module hielen3.ext"},{"location":"reference/hielen3/ext/#sub-modules","text":"hielen3.ext.feature_datetree_filesystem_source hielen3.ext.feature_hot_spot hielen3.ext.feature_instrument hielen3.ext.feature_instrument_clinometer hielen3.ext.feature_instrument_generic hielen3.ext.feature_instrument_improved hielen3.ext.feature_instrument_piezometer hielen3.ext.feature_instrument_shapearray hielen3.ext.feature_instrument_solgeo hielen3.ext.feature_logger_boviar hielen3.ext.feature_logger_capetti hielen3.ext.feature_logger_gestecno hielen3.ext.feature_logger_move hielen3.ext.feature_logger_move__ hielen3.ext.feature_logger_omnialog_temp hielen3.ext.feature_logger_smartbrik4_0 hielen3.ext.feature_logger_winecap hielen3.ext.feature_rfilogger hielen3.ext.feature_spotted_files_source","title":"Sub-modules"},{"location":"reference/hielen3/ext/feature_datetree_filesystem_source/","text":"Module hielen3.ext.feature_datetree_filesystem_source View Source # coding=utf-8 __name__ = \"Feature_datetree_filesystem_source\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from hielen3 import conf from pathlib import Path import traceback from glob import glob from pathlib import Path from pandas import DataFrame , read_csv , concat from datetime import datetime def loggers ( folders ): def inner (): return logger_serials ( folders ) return inner def logger_serials ( folders = {} ): # DA INSERIE IN CONFING folders = DataFrame ( folders ) folders = folders . set_index ( 'type' ) folders = folders [ 'path' ] . apply ( lambda x : str ( Path ( conf [ 'incomepath' ] , x , \"*\" )) ) . apply ( glob ) . explode () . dropna () . apply ( Path ) folders = folders [ folders . apply ( Path . is_dir ) ] . to_frame () . apply ( lambda x : { \"path\" : x [ 'path' ] . parent , \"name\" : x [ 'path' ] . name }, axis = 1 , result_type = 'expand' ) if not folders . empty : folders = folders . sort_values ( by = 'name' ) return folders def retriver ( func_loggers ): def wrap ( func_extract ): def inner ( * args , ** kwargs ): return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs ) return inner return wrap def retrive ( serials = None , times = None , columns = None , func_extract = None , func_loggers = None , ** kwargs ): def __default_extract__ ( * args , ** kwargs ): return DataFrame () def __default_folders__ ( * args , ** kwargs ): return [] if func_extract is None : func_extract = __default_extract__ if func_loggers is None : func_folders = __default_folders__ if serials is None : serials = slice ( None , None ) if isinstance ( serials , str ): serials = [ serials ] if isinstance ( times , datetime ): times = str ( times ) if times is None or isinstance ( times , str ): times = slice ( times , None , None ) start = times . start stop = times . stop if start is not None : datestart = str ( datetime . fromisoformat ( start ) . date ()) else : datestart = None times = slice ( start , stop ) dates = slice ( datestart , stop ) df = DataFrame ( dtype = 'object' ) try : folders = func_loggers () . set_index ( 'name' ) except KeyError as e : return df if isinstance ( serials , ( list , set , tuple )): serials = list ( folders . index [ folders . index . isin ( serials ) ] . drop_duplicates ()) if not serials . __len__ (): return df paths = folders . loc [ serials ] . reset_index () . apply ( lambda x : str ( x [ 'path' ] / x [ 'name' ] / \"*\" / \"*\" / \"*\" ), axis = 1 ) . apply ( glob ) . explode () . apply ( Path ) sertime = DataFrame ( paths . apply ( lambda x : ( x . parts [ - 4 ], str ( datetime ( * map ( int , x . parts [ - 3 :]))) ) ) . explode () . values . reshape ( paths . __len__ (), 2 ), columns = [ 'serial' , 'times' ] ) paths . index = sertime . index sertime [ 'path' ] = paths . apply ( lambda x : str ( x / \"*\" )) sertime = sertime . set_index ([ 'serial' , 'times' ]) . sort_index () try : sertime = sertime . to_frame () except Exception as e : pass try : sertime = sertime . loc [( serials , dates ), :] except KeyError as e : return df #print (sertime) #DEBUG for serial , paths in sertime . groupby ( 'serial' ): u = concat ( paths [ 'path' ] . apply ( glob ) . explode () . apply ( func_extract ) . values ) u [ 'serial' ] = serial u = u . set_index ([ 'serial' , 'times' ]) df = concat ([ df , u ]) #print (df) #DEBUG if df . empty : return df if columns is None : columns = list ( df . columns ) if not isinstance ( columns ,( list , tuple , set )): columns = [ columns ] columns = list ( columns ) columns = [ c for c in columns if c in df . columns ] df = df [ columns ] . sort_index () . loc [( serials , times ), :] try : if serials . __len__ () == 1 : df = df . droplevel ( 'serial' , axis = 0 ) except Exception as e : pass return df __all__ = [ \"retriver\" , \"loggers\" ] Functions loggers def loggers ( folders ) View Source def loggers ( folders ) : def inner () : return logger_serials ( folders ) return inner retriver def retriver ( func_loggers ) View Source def retriver ( func_loggers ) : def wrap ( func_extract ) : def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs ) return inner return wrap","title":"Feature Datetree Filesystem Source"},{"location":"reference/hielen3/ext/feature_datetree_filesystem_source/#module-hielen3extfeature_datetree_filesystem_source","text":"View Source # coding=utf-8 __name__ = \"Feature_datetree_filesystem_source\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from hielen3 import conf from pathlib import Path import traceback from glob import glob from pathlib import Path from pandas import DataFrame , read_csv , concat from datetime import datetime def loggers ( folders ): def inner (): return logger_serials ( folders ) return inner def logger_serials ( folders = {} ): # DA INSERIE IN CONFING folders = DataFrame ( folders ) folders = folders . set_index ( 'type' ) folders = folders [ 'path' ] . apply ( lambda x : str ( Path ( conf [ 'incomepath' ] , x , \"*\" )) ) . apply ( glob ) . explode () . dropna () . apply ( Path ) folders = folders [ folders . apply ( Path . is_dir ) ] . to_frame () . apply ( lambda x : { \"path\" : x [ 'path' ] . parent , \"name\" : x [ 'path' ] . name }, axis = 1 , result_type = 'expand' ) if not folders . empty : folders = folders . sort_values ( by = 'name' ) return folders def retriver ( func_loggers ): def wrap ( func_extract ): def inner ( * args , ** kwargs ): return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs ) return inner return wrap def retrive ( serials = None , times = None , columns = None , func_extract = None , func_loggers = None , ** kwargs ): def __default_extract__ ( * args , ** kwargs ): return DataFrame () def __default_folders__ ( * args , ** kwargs ): return [] if func_extract is None : func_extract = __default_extract__ if func_loggers is None : func_folders = __default_folders__ if serials is None : serials = slice ( None , None ) if isinstance ( serials , str ): serials = [ serials ] if isinstance ( times , datetime ): times = str ( times ) if times is None or isinstance ( times , str ): times = slice ( times , None , None ) start = times . start stop = times . stop if start is not None : datestart = str ( datetime . fromisoformat ( start ) . date ()) else : datestart = None times = slice ( start , stop ) dates = slice ( datestart , stop ) df = DataFrame ( dtype = 'object' ) try : folders = func_loggers () . set_index ( 'name' ) except KeyError as e : return df if isinstance ( serials , ( list , set , tuple )): serials = list ( folders . index [ folders . index . isin ( serials ) ] . drop_duplicates ()) if not serials . __len__ (): return df paths = folders . loc [ serials ] . reset_index () . apply ( lambda x : str ( x [ 'path' ] / x [ 'name' ] / \"*\" / \"*\" / \"*\" ), axis = 1 ) . apply ( glob ) . explode () . apply ( Path ) sertime = DataFrame ( paths . apply ( lambda x : ( x . parts [ - 4 ], str ( datetime ( * map ( int , x . parts [ - 3 :]))) ) ) . explode () . values . reshape ( paths . __len__ (), 2 ), columns = [ 'serial' , 'times' ] ) paths . index = sertime . index sertime [ 'path' ] = paths . apply ( lambda x : str ( x / \"*\" )) sertime = sertime . set_index ([ 'serial' , 'times' ]) . sort_index () try : sertime = sertime . to_frame () except Exception as e : pass try : sertime = sertime . loc [( serials , dates ), :] except KeyError as e : return df #print (sertime) #DEBUG for serial , paths in sertime . groupby ( 'serial' ): u = concat ( paths [ 'path' ] . apply ( glob ) . explode () . apply ( func_extract ) . values ) u [ 'serial' ] = serial u = u . set_index ([ 'serial' , 'times' ]) df = concat ([ df , u ]) #print (df) #DEBUG if df . empty : return df if columns is None : columns = list ( df . columns ) if not isinstance ( columns ,( list , tuple , set )): columns = [ columns ] columns = list ( columns ) columns = [ c for c in columns if c in df . columns ] df = df [ columns ] . sort_index () . loc [( serials , times ), :] try : if serials . __len__ () == 1 : df = df . droplevel ( 'serial' , axis = 0 ) except Exception as e : pass return df __all__ = [ \"retriver\" , \"loggers\" ]","title":"Module hielen3.ext.feature_datetree_filesystem_source"},{"location":"reference/hielen3/ext/feature_datetree_filesystem_source/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/ext/feature_datetree_filesystem_source/#loggers","text":"def loggers ( folders ) View Source def loggers ( folders ) : def inner () : return logger_serials ( folders ) return inner","title":"loggers"},{"location":"reference/hielen3/ext/feature_datetree_filesystem_source/#retriver","text":"def retriver ( func_loggers ) View Source def retriver ( func_loggers ) : def wrap ( func_extract ) : def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs ) return inner return wrap","title":"retriver"},{"location":"reference/hielen3/ext/feature_hot_spot/","text":"Module hielen3.ext.feature_hot_spot View Source # coding=utf-8 __name__ = \"Feature_instrument\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from hielen3.feature import HFeature from hielen3.serializaction import ActionSchema as ConfigSchema class Feature ( HFeature ): ''' Default Feature ''' def setup ( self , * args , ** kwargs ): pass def config ( self , * args , ** kwargs ): pass __all__ = [ \"Feature\" , \"ConfigSchema\" , \"__all__\" ] Variables __all__ Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ActionSchema ( HSchema ): ''' Minimal ActionSchema object. Used to define at least a timestamp ''' def _self_hints_ (): return { \"Base\" : { 0 : [ \"timestamp\" , \"Reference time\" , False , None ] } } timestamp = StringTime ( required = True , allow_none = False ) Ancestors (in MRO) hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Descendants hielen3.ext.feature_instrument_clinometer.feature.ConfigSchema hielen3.ext.feature_instrument_generic.feature.ConfigSchema hielen3.ext.feature_instrument_improved.feature.ConfigSchema hielen3.ext.feature_instrument_piezometer.feature.ConfigSchema hielen3.ext.feature_logger_boviar.logger.ConfigSchema hielen3.ext.feature_logger_capetti.logger.ConfigSchema hielen3.ext.feature_logger_gestecno.logger.ConfigSchema hielen3.ext.feature_logger_move.logger.ConfigSchema hielen3.ext.feature_logger_move__.logger.ConfigSchema hielen3.ext.feature_logger_move__.feature_logger_move.logger.ConfigSchema hielen3.ext.feature_logger_omnialog_temp.logger.ConfigSchema hielen3.ext.feature_logger_smartbrik4_0.logger.ConfigSchema hielen3.ext.feature_logger_winecap.logger.ConfigSchema hielen3.ext.feature_rfilogger.rfilogger.ConfigSchema hielen3.ext.feature_rfilogger.rfilogger_good.ConfigSchema hielen3.ext.feature_spotted_files_source.logger.ConfigSchema Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages opts timestamp Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) Default Feature Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , * args , ** kwargs ) View Source def config(self,*args,**kwargs): pass create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , * args , ** kwargs ) View Source def setup(self,*args,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Feature Hot Spot"},{"location":"reference/hielen3/ext/feature_hot_spot/#module-hielen3extfeature_hot_spot","text":"View Source # coding=utf-8 __name__ = \"Feature_instrument\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from hielen3.feature import HFeature from hielen3.serializaction import ActionSchema as ConfigSchema class Feature ( HFeature ): ''' Default Feature ''' def setup ( self , * args , ** kwargs ): pass def config ( self , * args , ** kwargs ): pass __all__ = [ \"Feature\" , \"ConfigSchema\" , \"__all__\" ]","title":"Module hielen3.ext.feature_hot_spot"},{"location":"reference/hielen3/ext/feature_hot_spot/#variables","text":"__all__","title":"Variables"},{"location":"reference/hielen3/ext/feature_hot_spot/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_hot_spot/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ActionSchema ( HSchema ): ''' Minimal ActionSchema object. Used to define at least a timestamp ''' def _self_hints_ (): return { \"Base\" : { 0 : [ \"timestamp\" , \"Reference time\" , False , None ] } } timestamp = StringTime ( required = True , allow_none = False )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_hot_spot/#ancestors-in-mro","text":"hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_hot_spot/#descendants","text":"hielen3.ext.feature_instrument_clinometer.feature.ConfigSchema hielen3.ext.feature_instrument_generic.feature.ConfigSchema hielen3.ext.feature_instrument_improved.feature.ConfigSchema hielen3.ext.feature_instrument_piezometer.feature.ConfigSchema hielen3.ext.feature_logger_boviar.logger.ConfigSchema hielen3.ext.feature_logger_capetti.logger.ConfigSchema hielen3.ext.feature_logger_gestecno.logger.ConfigSchema hielen3.ext.feature_logger_move.logger.ConfigSchema hielen3.ext.feature_logger_move__.logger.ConfigSchema hielen3.ext.feature_logger_move__.feature_logger_move.logger.ConfigSchema hielen3.ext.feature_logger_omnialog_temp.logger.ConfigSchema hielen3.ext.feature_logger_smartbrik4_0.logger.ConfigSchema hielen3.ext.feature_logger_winecap.logger.ConfigSchema hielen3.ext.feature_rfilogger.rfilogger.ConfigSchema hielen3.ext.feature_rfilogger.rfilogger_good.ConfigSchema hielen3.ext.feature_spotted_files_source.logger.ConfigSchema","title":"Descendants"},{"location":"reference/hielen3/ext/feature_hot_spot/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages opts timestamp","title":"Class variables"},{"location":"reference/hielen3/ext/feature_hot_spot/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_hot_spot/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_hot_spot/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_hot_spot/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_hot_spot/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_hot_spot/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_hot_spot/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_hot_spot/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_hot_spot/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_hot_spot/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_hot_spot/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_hot_spot/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_hot_spot/#feature","text":"class Feature ( feature ) Default Feature","title":"Feature"},{"location":"reference/hielen3/ext/feature_hot_spot/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_hot_spot/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_hot_spot/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_hot_spot/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_hot_spot/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_hot_spot/#config","text":"def config ( self , * args , ** kwargs ) View Source def config(self,*args,**kwargs): pass","title":"config"},{"location":"reference/hielen3/ext/feature_hot_spot/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_hot_spot/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_hot_spot/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_hot_spot/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_hot_spot/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_hot_spot/#retrive","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_hot_spot/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_hot_spot/#setup","text":"def setup ( self , * args , ** kwargs ) View Source def setup(self,*args,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_hot_spot/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_hot_spot/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_hot_spot/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_instrument/","text":"Module hielen3.ext.feature_instrument View Source # coding=utf-8 __name__ = \"Feature_instrument\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from hielen3.feature import HFeature from hielen3.serializaction import ActionSchema as ConfigSchema class Feature ( HFeature ): ''' Default Feature ''' def setup ( self , * args , ** kwargs ): pass def config ( self , * args , ** kwargs ): pass __all__ = [ \"Feature\" , \"ConfigSchema\" , \"__all__\" ] Variables __all__ Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ActionSchema ( HSchema ): ''' Minimal ActionSchema object. Used to define at least a timestamp ''' def _self_hints_ (): return { \"Base\" : { 0 : [ \"timestamp\" , \"Reference time\" , False , None ] } } timestamp = StringTime ( required = True , allow_none = False ) Ancestors (in MRO) hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Descendants hielen3.ext.feature_instrument_clinometer.feature.ConfigSchema hielen3.ext.feature_instrument_generic.feature.ConfigSchema hielen3.ext.feature_instrument_improved.feature.ConfigSchema hielen3.ext.feature_instrument_piezometer.feature.ConfigSchema hielen3.ext.feature_logger_boviar.logger.ConfigSchema hielen3.ext.feature_logger_capetti.logger.ConfigSchema hielen3.ext.feature_logger_gestecno.logger.ConfigSchema hielen3.ext.feature_logger_move.logger.ConfigSchema hielen3.ext.feature_logger_move__.logger.ConfigSchema hielen3.ext.feature_logger_move__.feature_logger_move.logger.ConfigSchema hielen3.ext.feature_logger_omnialog_temp.logger.ConfigSchema hielen3.ext.feature_logger_smartbrik4_0.logger.ConfigSchema hielen3.ext.feature_logger_winecap.logger.ConfigSchema hielen3.ext.feature_rfilogger.rfilogger.ConfigSchema hielen3.ext.feature_rfilogger.rfilogger_good.ConfigSchema hielen3.ext.feature_spotted_files_source.logger.ConfigSchema Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages opts timestamp Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) Default Feature Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , * args , ** kwargs ) View Source def config(self,*args,**kwargs): pass create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , * args , ** kwargs ) View Source def setup(self,*args,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Feature Instrument"},{"location":"reference/hielen3/ext/feature_instrument/#module-hielen3extfeature_instrument","text":"View Source # coding=utf-8 __name__ = \"Feature_instrument\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from hielen3.feature import HFeature from hielen3.serializaction import ActionSchema as ConfigSchema class Feature ( HFeature ): ''' Default Feature ''' def setup ( self , * args , ** kwargs ): pass def config ( self , * args , ** kwargs ): pass __all__ = [ \"Feature\" , \"ConfigSchema\" , \"__all__\" ]","title":"Module hielen3.ext.feature_instrument"},{"location":"reference/hielen3/ext/feature_instrument/#variables","text":"__all__","title":"Variables"},{"location":"reference/hielen3/ext/feature_instrument/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_instrument/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ActionSchema ( HSchema ): ''' Minimal ActionSchema object. Used to define at least a timestamp ''' def _self_hints_ (): return { \"Base\" : { 0 : [ \"timestamp\" , \"Reference time\" , False , None ] } } timestamp = StringTime ( required = True , allow_none = False )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_instrument/#ancestors-in-mro","text":"hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_instrument/#descendants","text":"hielen3.ext.feature_instrument_clinometer.feature.ConfigSchema hielen3.ext.feature_instrument_generic.feature.ConfigSchema hielen3.ext.feature_instrument_improved.feature.ConfigSchema hielen3.ext.feature_instrument_piezometer.feature.ConfigSchema hielen3.ext.feature_logger_boviar.logger.ConfigSchema hielen3.ext.feature_logger_capetti.logger.ConfigSchema hielen3.ext.feature_logger_gestecno.logger.ConfigSchema hielen3.ext.feature_logger_move.logger.ConfigSchema hielen3.ext.feature_logger_move__.logger.ConfigSchema hielen3.ext.feature_logger_move__.feature_logger_move.logger.ConfigSchema hielen3.ext.feature_logger_omnialog_temp.logger.ConfigSchema hielen3.ext.feature_logger_smartbrik4_0.logger.ConfigSchema hielen3.ext.feature_logger_winecap.logger.ConfigSchema hielen3.ext.feature_rfilogger.rfilogger.ConfigSchema hielen3.ext.feature_rfilogger.rfilogger_good.ConfigSchema hielen3.ext.feature_spotted_files_source.logger.ConfigSchema","title":"Descendants"},{"location":"reference/hielen3/ext/feature_instrument/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages opts timestamp","title":"Class variables"},{"location":"reference/hielen3/ext/feature_instrument/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_instrument/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_instrument/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_instrument/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_instrument/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_instrument/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_instrument/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_instrument/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_instrument/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_instrument/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_instrument/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_instrument/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_instrument/#feature","text":"class Feature ( feature ) Default Feature","title":"Feature"},{"location":"reference/hielen3/ext/feature_instrument/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_instrument/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_instrument/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_instrument/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_instrument/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_instrument/#config","text":"def config ( self , * args , ** kwargs ) View Source def config(self,*args,**kwargs): pass","title":"config"},{"location":"reference/hielen3/ext/feature_instrument/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_instrument/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_instrument/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_instrument/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_instrument/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_instrument/#retrive","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_instrument/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_instrument/#setup","text":"def setup ( self , * args , ** kwargs ) View Source def setup(self,*args,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_instrument/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_instrument/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_instrument/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/","text":"Module hielen3.ext.feature_instrument_shapearray View Source # coding=utf-8 __name__ = \"Feature_instrument_shapearray\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from hielen3.ext.feature_instrument import * Variables __all__ Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ActionSchema ( HSchema ): ''' Minimal ActionSchema object. Used to define at least a timestamp ''' def _self_hints_ (): return { \"Base\" : { 0 : [ \"timestamp\" , \"Reference time\" , False , None ] } } timestamp = StringTime ( required = True , allow_none = False ) Ancestors (in MRO) hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Descendants hielen3.ext.feature_instrument_clinometer.feature.ConfigSchema hielen3.ext.feature_instrument_generic.feature.ConfigSchema hielen3.ext.feature_instrument_improved.feature.ConfigSchema hielen3.ext.feature_instrument_piezometer.feature.ConfigSchema hielen3.ext.feature_logger_boviar.logger.ConfigSchema hielen3.ext.feature_logger_capetti.logger.ConfigSchema hielen3.ext.feature_logger_gestecno.logger.ConfigSchema hielen3.ext.feature_logger_move.logger.ConfigSchema hielen3.ext.feature_logger_move__.logger.ConfigSchema hielen3.ext.feature_logger_move__.feature_logger_move.logger.ConfigSchema hielen3.ext.feature_logger_omnialog_temp.logger.ConfigSchema hielen3.ext.feature_logger_smartbrik4_0.logger.ConfigSchema hielen3.ext.feature_logger_winecap.logger.ConfigSchema hielen3.ext.feature_rfilogger.rfilogger.ConfigSchema hielen3.ext.feature_rfilogger.rfilogger_good.ConfigSchema hielen3.ext.feature_spotted_files_source.logger.ConfigSchema Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages opts timestamp Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) Default Feature Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , * args , ** kwargs ) View Source def config(self,*args,**kwargs): pass create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , * args , ** kwargs ) View Source def setup(self,*args,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Feature Instrument Shapearray"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#module-hielen3extfeature_instrument_shapearray","text":"View Source # coding=utf-8 __name__ = \"Feature_instrument_shapearray\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from hielen3.ext.feature_instrument import *","title":"Module hielen3.ext.feature_instrument_shapearray"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#variables","text":"__all__","title":"Variables"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ActionSchema ( HSchema ): ''' Minimal ActionSchema object. Used to define at least a timestamp ''' def _self_hints_ (): return { \"Base\" : { 0 : [ \"timestamp\" , \"Reference time\" , False , None ] } } timestamp = StringTime ( required = True , allow_none = False )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#ancestors-in-mro","text":"hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#descendants","text":"hielen3.ext.feature_instrument_clinometer.feature.ConfigSchema hielen3.ext.feature_instrument_generic.feature.ConfigSchema hielen3.ext.feature_instrument_improved.feature.ConfigSchema hielen3.ext.feature_instrument_piezometer.feature.ConfigSchema hielen3.ext.feature_logger_boviar.logger.ConfigSchema hielen3.ext.feature_logger_capetti.logger.ConfigSchema hielen3.ext.feature_logger_gestecno.logger.ConfigSchema hielen3.ext.feature_logger_move.logger.ConfigSchema hielen3.ext.feature_logger_move__.logger.ConfigSchema hielen3.ext.feature_logger_move__.feature_logger_move.logger.ConfigSchema hielen3.ext.feature_logger_omnialog_temp.logger.ConfigSchema hielen3.ext.feature_logger_smartbrik4_0.logger.ConfigSchema hielen3.ext.feature_logger_winecap.logger.ConfigSchema hielen3.ext.feature_rfilogger.rfilogger.ConfigSchema hielen3.ext.feature_rfilogger.rfilogger_good.ConfigSchema hielen3.ext.feature_spotted_files_source.logger.ConfigSchema","title":"Descendants"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages opts timestamp","title":"Class variables"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#feature","text":"class Feature ( feature ) Default Feature","title":"Feature"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#config","text":"def config ( self , * args , ** kwargs ) View Source def config(self,*args,**kwargs): pass","title":"config"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#retrive","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#setup","text":"def setup ( self , * args , ** kwargs ) View Source def setup(self,*args,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_instrument_shapearray/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/","text":"Module hielen3.ext.feature_instrument_solgeo View Source # coding=utf-8 __name__ = \"Feature_instrument_shapearray\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from hielen3.ext.feature_instrument import * Variables __all__ Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ActionSchema ( HSchema ): ''' Minimal ActionSchema object. Used to define at least a timestamp ''' def _self_hints_ (): return { \"Base\" : { 0 : [ \"timestamp\" , \"Reference time\" , False , None ] } } timestamp = StringTime ( required = True , allow_none = False ) Ancestors (in MRO) hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Descendants hielen3.ext.feature_instrument_clinometer.feature.ConfigSchema hielen3.ext.feature_instrument_generic.feature.ConfigSchema hielen3.ext.feature_instrument_improved.feature.ConfigSchema hielen3.ext.feature_instrument_piezometer.feature.ConfigSchema hielen3.ext.feature_logger_boviar.logger.ConfigSchema hielen3.ext.feature_logger_capetti.logger.ConfigSchema hielen3.ext.feature_logger_gestecno.logger.ConfigSchema hielen3.ext.feature_logger_move.logger.ConfigSchema hielen3.ext.feature_logger_move__.logger.ConfigSchema hielen3.ext.feature_logger_move__.feature_logger_move.logger.ConfigSchema hielen3.ext.feature_logger_omnialog_temp.logger.ConfigSchema hielen3.ext.feature_logger_smartbrik4_0.logger.ConfigSchema hielen3.ext.feature_logger_winecap.logger.ConfigSchema hielen3.ext.feature_rfilogger.rfilogger.ConfigSchema hielen3.ext.feature_rfilogger.rfilogger_good.ConfigSchema hielen3.ext.feature_spotted_files_source.logger.ConfigSchema Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages opts timestamp Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) Default Feature Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , * args , ** kwargs ) View Source def config(self,*args,**kwargs): pass create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , * args , ** kwargs ) View Source def setup(self,*args,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Feature Instrument Solgeo"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#module-hielen3extfeature_instrument_solgeo","text":"View Source # coding=utf-8 __name__ = \"Feature_instrument_shapearray\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from hielen3.ext.feature_instrument import *","title":"Module hielen3.ext.feature_instrument_solgeo"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#variables","text":"__all__","title":"Variables"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ActionSchema ( HSchema ): ''' Minimal ActionSchema object. Used to define at least a timestamp ''' def _self_hints_ (): return { \"Base\" : { 0 : [ \"timestamp\" , \"Reference time\" , False , None ] } } timestamp = StringTime ( required = True , allow_none = False )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#ancestors-in-mro","text":"hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#descendants","text":"hielen3.ext.feature_instrument_clinometer.feature.ConfigSchema hielen3.ext.feature_instrument_generic.feature.ConfigSchema hielen3.ext.feature_instrument_improved.feature.ConfigSchema hielen3.ext.feature_instrument_piezometer.feature.ConfigSchema hielen3.ext.feature_logger_boviar.logger.ConfigSchema hielen3.ext.feature_logger_capetti.logger.ConfigSchema hielen3.ext.feature_logger_gestecno.logger.ConfigSchema hielen3.ext.feature_logger_move.logger.ConfigSchema hielen3.ext.feature_logger_move__.logger.ConfigSchema hielen3.ext.feature_logger_move__.feature_logger_move.logger.ConfigSchema hielen3.ext.feature_logger_omnialog_temp.logger.ConfigSchema hielen3.ext.feature_logger_smartbrik4_0.logger.ConfigSchema hielen3.ext.feature_logger_winecap.logger.ConfigSchema hielen3.ext.feature_rfilogger.rfilogger.ConfigSchema hielen3.ext.feature_rfilogger.rfilogger_good.ConfigSchema hielen3.ext.feature_spotted_files_source.logger.ConfigSchema","title":"Descendants"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages opts timestamp","title":"Class variables"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#feature","text":"class Feature ( feature ) Default Feature","title":"Feature"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#config","text":"def config ( self , * args , ** kwargs ) View Source def config(self,*args,**kwargs): pass","title":"config"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#retrive","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#setup","text":"def setup ( self , * args , ** kwargs ) View Source def setup(self,*args,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_instrument_solgeo/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/","text":"Module hielen3.ext.feature_instrument_clinometer View Source # coding=utf-8 __name__ = \"Feature_instrument_piezometer\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" #from hielen3.ext.feature_instrument import * from .feature import Feature , ConfigSchema __all__ = [ \"Feature\" , \"ConfigSchema\" ] Sub-modules hielen3.ext.feature_instrument_clinometer.feature Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Channel A\" : { 0 :[ \"A_param_name\" , \"Label of the axis. i.e.: 'X'\" , False , None ], 1 :[ \"A_source_series\" , \"Reference raw series\" , False , None ], 2 :[ \"A_coefficients\" , \"polinomial coefficients array\" , False , None ], 3 :[ \"A_termal_correction\" , \"termal correction coefficient\" , False , None ], 4 :[ \"A_start_time\" , \"starting time of the series\" , False , None ], 5 :[ \"A_zero_time\" , \"time of the zero reading\" , False , None ], }, \"Channel B\" : { 0 :[ \"B_param_name\" , \"Label of the axis. i.e.: 'X'\" , False , None ], 1 :[ \"B_source_series\" , \"Reference raw series\" , False , None ], 2 :[ \"B_coefficients\" , \"polinomial coefficients array\" , False , None ], 3 :[ \"B_termal_correction\" , \"termal correction coefficient\" , False , None ], 4 :[ \"B_start_time\" , \"starting time of the series\" , False , None ], 5 :[ \"B_zero_time\" , \"time of the zero reading\" , False , None ] }, \"Channel C\" : { 0 :[ \"C_param_name\" , \"Label of the axis. i.e.: 'X'\" , False , None ], 1 :[ \"C_param_series\" , \"Reference raw series\" , False , None ], 2 :[ \"C_coefficients\" , \"polinomial coefficients array\" , False , None ], 3 :[ \"C_termal_correction\" , \"termal correction coefficient\" , False , None ], 4 :[ \"C_start_time\" , \"starting time of the series\" , False , None ], 5 :[ \"C_zero_time\" , \"time of the zero reading\" , False , None ] }, \"Channel Temp\" : { 0 :[ \"T_source_series\" , \"Reference raw series\" , False , None ], 1 :[ \"T_zero_time\" , \"time of the zero reading\" , False , None ] }, } A_param_name = fields . String ( required = False , allow_none = True ) A_source_series = fields . String ( required = False , allow_none = True ) A_coefficients = PolyCoeff ( default =[ 0 , 1 ], required = False , allow_none = True ) A_termal_correction = fields . Number ( default = 1 , required = False , allow_none = True ) A_start_time = StringTime ( required = False , allow_none = True ) A_zero_time = StringTime ( required = False , allow_none = True ) B_param_name = fields . String ( required = False , allow_none = True ) B_source_series = fields . String ( required = False , allow_none = True ) B_coefficients = PolyCoeff ( default =[ 0 , 1 ], required = False , allow_none = True ) B_termal_correction = fields . Number ( default = 1 , required = False , allow_none = True ) B_start_time = StringTime ( required = False , allow_none = True ) B_zero_time = StringTime ( required = False , allow_none = True ) C_param_name = fields . String ( required = False , allow_none = True ) C_source_series = fields . String ( required = False , allow_none = True ) C_coefficients = PolyCoeff ( default =[ 0 , 1 ], required = False , allow_none = True ) C_termal_correction = fields . Number ( default = 1 , required = False , allow_none = True ) C_start_time = StringTime ( required = False , allow_none = True ) C_zero_time = StringTime ( required = False , allow_none = True ) T_source_series = fields . String ( required = False , allow_none = True ) T_start_time = StringTime ( required = False , allow_none = True ) Ancestors (in MRO) hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables A_coefficients A_param_name A_source_series A_start_time A_termal_correction A_zero_time B_coefficients B_param_name B_source_series B_start_time B_termal_correction B_zero_time C_coefficients C_param_name C_source_series C_start_time C_termal_correction C_zero_time Meta OPTIONS_CLASS TYPE_MAPPING T_source_series T_start_time error_messages opts Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) CLINOMETER View Source class Feature ( HFeature ) : ''' CLINOMETER ''' def setup ( self , ** kwargs ) : pass def __channel_config__ ( self , ch , param_name , source_series = None , temp_series = None , termal_correction = None , coefficients = None , start_time = None , zero_time = None , ordinal = None ) : # DA RIVEDERE IL MECCANISMO DI CONSISTENZA TRA UNA CONF E L 'ALTRA try: old_source_series = self.parameters[param_name].uuid except KeyError as e: old_source_series = None if old_source_series is None: if coefficients is None: coefficients=\"\" if temp_series is None: temp_series=0 if termal_correction is None: termal_correction=0 if source_series is None: source_series = old_source_series if source_series is not None: config=dict( param=param_name, ordinal=ordinal, cache=\"active\", mu=\"\u0394 mm/m\", modules={\"calc\":\"hielen3.tools.calc\"}, operands={\"S0\":source_series, \"T0\":temp_series}, operator=f\"calc.filter(calc.poly_trans2(S0,{coefficients})*1000 + T0 * {termal_correction}, 2, 20)\", first=start_time ) self.parameters.set(**config) # ATTENZIONE QUESTA E' UNA FEATURE COMUNE A TUTTE LE SERIRE DATI IN DELTA if zero_time is not None : df = self . parameters [ param_name ] . data () iloc_idx = df . index . get_indexer ( [ zero_time ] , method = 'nearest' ) ZERO = df . iloc [ iloc_idx ] . squeeze () config [ \"operator\" ] += f \" - {ZERO}\" self . parameters . set ( ** config ) def config ( self , ** kwargs ) : tkwargs = { \"A_param_name\" : None , \"A_source_series\" : None , \"A_coefficients\" : None , \"A_termal_correction\" : None , \"A_start_time\" : None , \"A_zero_time\" : None , \"B_param_name\" : None , \"B_source_series\" : None , \"B_coefficients\" : None , \"B_termal_correction\" : None , \"B_start_time\" : None , \"B_zero_time\" : None , \"C_param_name\" : None , \"C_source_series\" : None , \"C_coefficients\" : None , \"C_termal_correction\" : None , \"C_start_time\" : None , \"C_zero_time\" : None , \"T_source_series\" : None , \"T_zero_time\" : None } tkwargs . update ( kwargs ) A = { \"_\" . join ( k . split ( \"_\" ) [ 1: ] ) : w for k , w in tkwargs . items () if k [ 0 ] == \"A\" } B = { \"_\" . join ( k . split ( \"_\" ) [ 1: ] ) : w for k , w in tkwargs . items () if k [ 0 ] == \"B\" } C = { \"_\" . join ( k . split ( \"_\" ) [ 1: ] ) : w for k , w in tkwargs . items () if k [ 0 ] == \"C\" } T = { \"_\" . join ( k . split ( \"_\" ) [ 1: ] ) : w for k , w in tkwargs . items () if k [ 0 ] == \"T\" } try : timestamp = kwargs [ \"timestamp\" ] except KeyError as e : timestamp = None if A [ \"start_time\" ] is None : A [ \"start_time\" ] = timestamp if B [ \"start_time\" ] is None : B [ \"start_time\" ] = timestamp if C [ \"start_time\" ] is None : C [ \"start_time\" ] = timestamp if T [ \"start_time\" ] is None : T [ \"start_time\" ] = timestamp if A [ \"zero_time\" ] is None : A [ \"zero_time\" ] = A [ \"start_time\" ] if B [ \"zero_time\" ] is None : B [ \"zero_time\" ] = B [ \"start_time\" ] if C [ \"zero_time\" ] is None : C [ \"zero_time\" ] = C [ \"start_time\" ] self . parameters . set ( \"Temperatura\" , cache = \"no\" , mu = \"*C\" , modules = {} , operands = { \"S0\" : T [ \"source_series\" ] } , operator = \"S0\" , first = T [ \"start_time\" ] , ordinal = 3 ) temperature = self . parameters [ \"Temperatura\" ] self . __channel_config__ ( ch = \"A\" , ordinal = 0 , temp_series = temperature , ** A ) self . __channel_config__ ( ch = \"B\" , ordinal = 1 , temp_series = temperature , ** B ) self . __channel_config__ ( ch = \"C\" , ordinal = 2 , temp_series = temperature , ** C ) Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , ** kwargs ) View Source def config ( self , ** kwargs ) : tkwargs = { \"A_param_name\" : None , \"A_source_series\" : None , \"A_coefficients\" : None , \"A_termal_correction\" : None , \"A_start_time\" : None , \"A_zero_time\" : None , \"B_param_name\" : None , \"B_source_series\" : None , \"B_coefficients\" : None , \"B_termal_correction\" : None , \"B_start_time\" : None , \"B_zero_time\" : None , \"C_param_name\" : None , \"C_source_series\" : None , \"C_coefficients\" : None , \"C_termal_correction\" : None , \"C_start_time\" : None , \"C_zero_time\" : None , \"T_source_series\" : None , \"T_zero_time\" : None } tkwargs . update ( kwargs ) A = { \"_\" . join ( k . split ( \"_\" ) [ 1 :] ) : w for k , w in tkwargs . items () if k [ 0 ] == \"A\" } B = { \"_\" . join ( k . split ( \"_\" ) [ 1 :] ) : w for k , w in tkwargs . items () if k [ 0 ] == \"B\" } C = { \"_\" . join ( k . split ( \"_\" ) [ 1 :] ) : w for k , w in tkwargs . items () if k [ 0 ] == \"C\" } T = { \"_\" . join ( k . split ( \"_\" ) [ 1 :] ) : w for k , w in tkwargs . items () if k [ 0 ] == \"T\" } try : timestamp = kwargs [ \"timestamp\" ] except KeyError as e : timestamp = None if A [ \"start_time\" ] is None : A [ \"start_time\" ] = timestamp if B [ \"start_time\" ] is None : B [ \"start_time\" ] = timestamp if C [ \"start_time\" ] is None : C [ \"start_time\" ] = timestamp if T [ \"start_time\" ] is None : T [ \"start_time\" ] = timestamp if A [ \"zero_time\" ] is None : A [ \"zero_time\" ] = A [ \"start_time\" ] if B [ \"zero_time\" ] is None : B [ \"zero_time\" ] = B [ \"start_time\" ] if C [ \"zero_time\" ] is None : C [ \"zero_time\" ] = C [ \"start_time\" ] self . parameters . set ( \"Temperatura\" , cache = \"no\" , mu = \"*C\" , modules = {}, operands = { \"S0\" : T [ \"source_series\" ]}, operator = \"S0\" , first = T [ \"start_time\" ], ordinal = 3 ) temperature = self . parameters [ \"Temperatura\" ] self . __channel_config__ ( ch = \"A\" , ordinal = 0 , temp_series = temperature , ** A ) self . __channel_config__ ( ch = \"B\" , ordinal = 1 , temp_series = temperature , ** B ) self . __channel_config__ ( ch = \"C\" , ordinal = 2 , temp_series = temperature , ** C ) create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Index"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#module-hielen3extfeature_instrument_clinometer","text":"View Source # coding=utf-8 __name__ = \"Feature_instrument_piezometer\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" #from hielen3.ext.feature_instrument import * from .feature import Feature , ConfigSchema __all__ = [ \"Feature\" , \"ConfigSchema\" ]","title":"Module hielen3.ext.feature_instrument_clinometer"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#sub-modules","text":"hielen3.ext.feature_instrument_clinometer.feature","title":"Sub-modules"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Channel A\" : { 0 :[ \"A_param_name\" , \"Label of the axis. i.e.: 'X'\" , False , None ], 1 :[ \"A_source_series\" , \"Reference raw series\" , False , None ], 2 :[ \"A_coefficients\" , \"polinomial coefficients array\" , False , None ], 3 :[ \"A_termal_correction\" , \"termal correction coefficient\" , False , None ], 4 :[ \"A_start_time\" , \"starting time of the series\" , False , None ], 5 :[ \"A_zero_time\" , \"time of the zero reading\" , False , None ], }, \"Channel B\" : { 0 :[ \"B_param_name\" , \"Label of the axis. i.e.: 'X'\" , False , None ], 1 :[ \"B_source_series\" , \"Reference raw series\" , False , None ], 2 :[ \"B_coefficients\" , \"polinomial coefficients array\" , False , None ], 3 :[ \"B_termal_correction\" , \"termal correction coefficient\" , False , None ], 4 :[ \"B_start_time\" , \"starting time of the series\" , False , None ], 5 :[ \"B_zero_time\" , \"time of the zero reading\" , False , None ] }, \"Channel C\" : { 0 :[ \"C_param_name\" , \"Label of the axis. i.e.: 'X'\" , False , None ], 1 :[ \"C_param_series\" , \"Reference raw series\" , False , None ], 2 :[ \"C_coefficients\" , \"polinomial coefficients array\" , False , None ], 3 :[ \"C_termal_correction\" , \"termal correction coefficient\" , False , None ], 4 :[ \"C_start_time\" , \"starting time of the series\" , False , None ], 5 :[ \"C_zero_time\" , \"time of the zero reading\" , False , None ] }, \"Channel Temp\" : { 0 :[ \"T_source_series\" , \"Reference raw series\" , False , None ], 1 :[ \"T_zero_time\" , \"time of the zero reading\" , False , None ] }, } A_param_name = fields . String ( required = False , allow_none = True ) A_source_series = fields . String ( required = False , allow_none = True ) A_coefficients = PolyCoeff ( default =[ 0 , 1 ], required = False , allow_none = True ) A_termal_correction = fields . Number ( default = 1 , required = False , allow_none = True ) A_start_time = StringTime ( required = False , allow_none = True ) A_zero_time = StringTime ( required = False , allow_none = True ) B_param_name = fields . String ( required = False , allow_none = True ) B_source_series = fields . String ( required = False , allow_none = True ) B_coefficients = PolyCoeff ( default =[ 0 , 1 ], required = False , allow_none = True ) B_termal_correction = fields . Number ( default = 1 , required = False , allow_none = True ) B_start_time = StringTime ( required = False , allow_none = True ) B_zero_time = StringTime ( required = False , allow_none = True ) C_param_name = fields . String ( required = False , allow_none = True ) C_source_series = fields . String ( required = False , allow_none = True ) C_coefficients = PolyCoeff ( default =[ 0 , 1 ], required = False , allow_none = True ) C_termal_correction = fields . Number ( default = 1 , required = False , allow_none = True ) C_start_time = StringTime ( required = False , allow_none = True ) C_zero_time = StringTime ( required = False , allow_none = True ) T_source_series = fields . String ( required = False , allow_none = True ) T_start_time = StringTime ( required = False , allow_none = True )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#ancestors-in-mro","text":"hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#class-variables","text":"A_coefficients A_param_name A_source_series A_start_time A_termal_correction A_zero_time B_coefficients B_param_name B_source_series B_start_time B_termal_correction B_zero_time C_coefficients C_param_name C_source_series C_start_time C_termal_correction C_zero_time Meta OPTIONS_CLASS TYPE_MAPPING T_source_series T_start_time error_messages opts","title":"Class variables"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#feature","text":"class Feature ( feature ) CLINOMETER View Source class Feature ( HFeature ) : ''' CLINOMETER ''' def setup ( self , ** kwargs ) : pass def __channel_config__ ( self , ch , param_name , source_series = None , temp_series = None , termal_correction = None , coefficients = None , start_time = None , zero_time = None , ordinal = None ) : # DA RIVEDERE IL MECCANISMO DI CONSISTENZA TRA UNA CONF E L 'ALTRA try: old_source_series = self.parameters[param_name].uuid except KeyError as e: old_source_series = None if old_source_series is None: if coefficients is None: coefficients=\"\" if temp_series is None: temp_series=0 if termal_correction is None: termal_correction=0 if source_series is None: source_series = old_source_series if source_series is not None: config=dict( param=param_name, ordinal=ordinal, cache=\"active\", mu=\"\u0394 mm/m\", modules={\"calc\":\"hielen3.tools.calc\"}, operands={\"S0\":source_series, \"T0\":temp_series}, operator=f\"calc.filter(calc.poly_trans2(S0,{coefficients})*1000 + T0 * {termal_correction}, 2, 20)\", first=start_time ) self.parameters.set(**config) # ATTENZIONE QUESTA E' UNA FEATURE COMUNE A TUTTE LE SERIRE DATI IN DELTA if zero_time is not None : df = self . parameters [ param_name ] . data () iloc_idx = df . index . get_indexer ( [ zero_time ] , method = 'nearest' ) ZERO = df . iloc [ iloc_idx ] . squeeze () config [ \"operator\" ] += f \" - {ZERO}\" self . parameters . set ( ** config ) def config ( self , ** kwargs ) : tkwargs = { \"A_param_name\" : None , \"A_source_series\" : None , \"A_coefficients\" : None , \"A_termal_correction\" : None , \"A_start_time\" : None , \"A_zero_time\" : None , \"B_param_name\" : None , \"B_source_series\" : None , \"B_coefficients\" : None , \"B_termal_correction\" : None , \"B_start_time\" : None , \"B_zero_time\" : None , \"C_param_name\" : None , \"C_source_series\" : None , \"C_coefficients\" : None , \"C_termal_correction\" : None , \"C_start_time\" : None , \"C_zero_time\" : None , \"T_source_series\" : None , \"T_zero_time\" : None } tkwargs . update ( kwargs ) A = { \"_\" . join ( k . split ( \"_\" ) [ 1: ] ) : w for k , w in tkwargs . items () if k [ 0 ] == \"A\" } B = { \"_\" . join ( k . split ( \"_\" ) [ 1: ] ) : w for k , w in tkwargs . items () if k [ 0 ] == \"B\" } C = { \"_\" . join ( k . split ( \"_\" ) [ 1: ] ) : w for k , w in tkwargs . items () if k [ 0 ] == \"C\" } T = { \"_\" . join ( k . split ( \"_\" ) [ 1: ] ) : w for k , w in tkwargs . items () if k [ 0 ] == \"T\" } try : timestamp = kwargs [ \"timestamp\" ] except KeyError as e : timestamp = None if A [ \"start_time\" ] is None : A [ \"start_time\" ] = timestamp if B [ \"start_time\" ] is None : B [ \"start_time\" ] = timestamp if C [ \"start_time\" ] is None : C [ \"start_time\" ] = timestamp if T [ \"start_time\" ] is None : T [ \"start_time\" ] = timestamp if A [ \"zero_time\" ] is None : A [ \"zero_time\" ] = A [ \"start_time\" ] if B [ \"zero_time\" ] is None : B [ \"zero_time\" ] = B [ \"start_time\" ] if C [ \"zero_time\" ] is None : C [ \"zero_time\" ] = C [ \"start_time\" ] self . parameters . set ( \"Temperatura\" , cache = \"no\" , mu = \"*C\" , modules = {} , operands = { \"S0\" : T [ \"source_series\" ] } , operator = \"S0\" , first = T [ \"start_time\" ] , ordinal = 3 ) temperature = self . parameters [ \"Temperatura\" ] self . __channel_config__ ( ch = \"A\" , ordinal = 0 , temp_series = temperature , ** A ) self . __channel_config__ ( ch = \"B\" , ordinal = 1 , temp_series = temperature , ** B ) self . __channel_config__ ( ch = \"C\" , ordinal = 2 , temp_series = temperature , ** C )","title":"Feature"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#config","text":"def config ( self , ** kwargs ) View Source def config ( self , ** kwargs ) : tkwargs = { \"A_param_name\" : None , \"A_source_series\" : None , \"A_coefficients\" : None , \"A_termal_correction\" : None , \"A_start_time\" : None , \"A_zero_time\" : None , \"B_param_name\" : None , \"B_source_series\" : None , \"B_coefficients\" : None , \"B_termal_correction\" : None , \"B_start_time\" : None , \"B_zero_time\" : None , \"C_param_name\" : None , \"C_source_series\" : None , \"C_coefficients\" : None , \"C_termal_correction\" : None , \"C_start_time\" : None , \"C_zero_time\" : None , \"T_source_series\" : None , \"T_zero_time\" : None } tkwargs . update ( kwargs ) A = { \"_\" . join ( k . split ( \"_\" ) [ 1 :] ) : w for k , w in tkwargs . items () if k [ 0 ] == \"A\" } B = { \"_\" . join ( k . split ( \"_\" ) [ 1 :] ) : w for k , w in tkwargs . items () if k [ 0 ] == \"B\" } C = { \"_\" . join ( k . split ( \"_\" ) [ 1 :] ) : w for k , w in tkwargs . items () if k [ 0 ] == \"C\" } T = { \"_\" . join ( k . split ( \"_\" ) [ 1 :] ) : w for k , w in tkwargs . items () if k [ 0 ] == \"T\" } try : timestamp = kwargs [ \"timestamp\" ] except KeyError as e : timestamp = None if A [ \"start_time\" ] is None : A [ \"start_time\" ] = timestamp if B [ \"start_time\" ] is None : B [ \"start_time\" ] = timestamp if C [ \"start_time\" ] is None : C [ \"start_time\" ] = timestamp if T [ \"start_time\" ] is None : T [ \"start_time\" ] = timestamp if A [ \"zero_time\" ] is None : A [ \"zero_time\" ] = A [ \"start_time\" ] if B [ \"zero_time\" ] is None : B [ \"zero_time\" ] = B [ \"start_time\" ] if C [ \"zero_time\" ] is None : C [ \"zero_time\" ] = C [ \"start_time\" ] self . parameters . set ( \"Temperatura\" , cache = \"no\" , mu = \"*C\" , modules = {}, operands = { \"S0\" : T [ \"source_series\" ]}, operator = \"S0\" , first = T [ \"start_time\" ], ordinal = 3 ) temperature = self . parameters [ \"Temperatura\" ] self . __channel_config__ ( ch = \"A\" , ordinal = 0 , temp_series = temperature , ** A ) self . __channel_config__ ( ch = \"B\" , ordinal = 1 , temp_series = temperature , ** B ) self . __channel_config__ ( ch = \"C\" , ordinal = 2 , temp_series = temperature , ** C )","title":"config"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#retrive","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#setup","text":"def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/","text":"Module hielen3.ext.feature_instrument_clinometer.feature View Source # coding=utf-8 from hielen3.feature import HFeature from hielen3.serializaction import ActionSchema , PolyCoeff , StringTime from hielen3.ext.feature_instrument import ConfigSchema , Feature from marshmallow import fields import traceback class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Channel A\" : { 0 :[ \"A_param_name\" , \"Label of the axis. i.e.: 'X'\" , False , None ], 1 :[ \"A_source_series\" , \"Reference raw series\" , False , None ], 2 :[ \"A_coefficients\" , \"polinomial coefficients array\" , False , None ], 3 :[ \"A_termal_correction\" , \"termal correction coefficient\" , False , None ], 4 :[ \"A_start_time\" , \"starting time of the series\" , False , None ], 5 :[ \"A_zero_time\" , \"time of the zero reading\" , False , None ], }, \"Channel B\" : { 0 :[ \"B_param_name\" , \"Label of the axis. i.e.: 'X'\" , False , None ], 1 :[ \"B_source_series\" , \"Reference raw series\" , False , None ], 2 :[ \"B_coefficients\" , \"polinomial coefficients array\" , False , None ], 3 :[ \"B_termal_correction\" , \"termal correction coefficient\" , False , None ], 4 :[ \"B_start_time\" , \"starting time of the series\" , False , None ], 5 :[ \"B_zero_time\" , \"time of the zero reading\" , False , None ] }, \"Channel C\" : { 0 :[ \"C_param_name\" , \"Label of the axis. i.e.: 'X'\" , False , None ], 1 :[ \"C_param_series\" , \"Reference raw series\" , False , None ], 2 :[ \"C_coefficients\" , \"polinomial coefficients array\" , False , None ], 3 :[ \"C_termal_correction\" , \"termal correction coefficient\" , False , None ], 4 :[ \"C_start_time\" , \"starting time of the series\" , False , None ], 5 :[ \"C_zero_time\" , \"time of the zero reading\" , False , None ] }, \"Channel Temp\" : { 0 :[ \"T_source_series\" , \"Reference raw series\" , False , None ], 1 :[ \"T_zero_time\" , \"time of the zero reading\" , False , None ] }, } A_param_name = fields . String ( required = False , allow_none = True ) A_source_series = fields . String ( required = False , allow_none = True ) A_coefficients = PolyCoeff ( default = [ 0 , 1 ], required = False , allow_none = True ) A_termal_correction = fields . Number ( default = 1 , required = False , allow_none = True ) A_start_time = StringTime ( required = False , allow_none = True ) A_zero_time = StringTime ( required = False , allow_none = True ) B_param_name = fields . String ( required = False , allow_none = True ) B_source_series = fields . String ( required = False , allow_none = True ) B_coefficients = PolyCoeff ( default = [ 0 , 1 ], required = False , allow_none = True ) B_termal_correction = fields . Number ( default = 1 , required = False , allow_none = True ) B_start_time = StringTime ( required = False , allow_none = True ) B_zero_time = StringTime ( required = False , allow_none = True ) C_param_name = fields . String ( required = False , allow_none = True ) C_source_series = fields . String ( required = False , allow_none = True ) C_coefficients = PolyCoeff ( default = [ 0 , 1 ], required = False , allow_none = True ) C_termal_correction = fields . Number ( default = 1 , required = False , allow_none = True ) C_start_time = StringTime ( required = False , allow_none = True ) C_zero_time = StringTime ( required = False , allow_none = True ) T_source_series = fields . String ( required = False , allow_none = True ) T_start_time = StringTime ( required = False , allow_none = True ) class Feature ( HFeature ): ''' CLINOMETER ''' def setup ( self , ** kwargs ): pass def __channel_config__ ( self , ch , param_name , source_series = None , temp_series = None , termal_correction = None , coefficients = None , start_time = None , zero_time = None , ordinal = None ): # DA RIVEDERE IL MECCANISMO DI CONSISTENZA TRA UNA CONF E L'ALTRA try : old_source_series = self . parameters [ param_name ] . uuid except KeyError as e : old_source_series = None if old_source_series is None : if coefficients is None : coefficients = \"\" if temp_series is None : temp_series = 0 if termal_correction is None : termal_correction = 0 if source_series is None : source_series = old_source_series if source_series is not None : config = dict ( param = param_name , ordinal = ordinal , cache = \"active\" , mu = \"\u0394 mm/m\" , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : source_series , \"T0\" : temp_series }, operator = f \"calc.filter(calc.poly_trans2(S0, { coefficients } )*1000 + T0 * { termal_correction } , 2, 20)\" , first = start_time ) self . parameters . set ( ** config ) # ATTENZIONE QUESTA E' UNA FEATURE COMUNE A TUTTE LE SERIRE DATI IN DELTA if zero_time is not None : df = self . parameters [ param_name ] . data () iloc_idx = df . index . get_indexer ([ zero_time ], method = 'nearest' ) ZERO = df . iloc [ iloc_idx ] . squeeze () config [ \"operator\" ] += f \" - { ZERO } \" self . parameters . set ( ** config ) def config ( self , ** kwargs ): tkwargs = { \"A_param_name\" : None , \"A_source_series\" : None , \"A_coefficients\" : None , \"A_termal_correction\" : None , \"A_start_time\" : None , \"A_zero_time\" : None , \"B_param_name\" : None , \"B_source_series\" : None , \"B_coefficients\" : None , \"B_termal_correction\" : None , \"B_start_time\" : None , \"B_zero_time\" : None , \"C_param_name\" : None , \"C_source_series\" : None , \"C_coefficients\" : None , \"C_termal_correction\" : None , \"C_start_time\" : None , \"C_zero_time\" : None , \"T_source_series\" : None , \"T_zero_time\" : None } tkwargs . update ( kwargs ) A = { \"_\" . join ( k . split ( \"_\" )[ 1 :]): w for k , w in tkwargs . items () if k [ 0 ] == \"A\" } B = { \"_\" . join ( k . split ( \"_\" )[ 1 :]): w for k , w in tkwargs . items () if k [ 0 ] == \"B\" } C = { \"_\" . join ( k . split ( \"_\" )[ 1 :]): w for k , w in tkwargs . items () if k [ 0 ] == \"C\" } T = { \"_\" . join ( k . split ( \"_\" )[ 1 :]): w for k , w in tkwargs . items () if k [ 0 ] == \"T\" } try : timestamp = kwargs [ \"timestamp\" ] except KeyError as e : timestamp = None if A [ \"start_time\" ] is None : A [ \"start_time\" ] = timestamp if B [ \"start_time\" ] is None : B [ \"start_time\" ] = timestamp if C [ \"start_time\" ] is None : C [ \"start_time\" ] = timestamp if T [ \"start_time\" ] is None : T [ \"start_time\" ] = timestamp if A [ \"zero_time\" ] is None : A [ \"zero_time\" ] = A [ \"start_time\" ] if B [ \"zero_time\" ] is None : B [ \"zero_time\" ] = B [ \"start_time\" ] if C [ \"zero_time\" ] is None : C [ \"zero_time\" ] = C [ \"start_time\" ] self . parameters . set ( \"Temperatura\" , cache = \"no\" , mu = \"*C\" , modules = {}, operands = { \"S0\" : T [ \"source_series\" ]}, operator = \"S0\" , first = T [ \"start_time\" ], ordinal = 3 ) temperature = self . parameters [ \"Temperatura\" ] self . __channel_config__ ( ch = \"A\" , ordinal = 0 , temp_series = temperature , ** A ) self . __channel_config__ ( ch = \"B\" , ordinal = 1 , temp_series = temperature , ** B ) self . __channel_config__ ( ch = \"C\" , ordinal = 2 , temp_series = temperature , ** C ) Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Channel A\" : { 0 :[ \"A_param_name\" , \"Label of the axis. i.e.: 'X'\" , False , None ], 1 :[ \"A_source_series\" , \"Reference raw series\" , False , None ], 2 :[ \"A_coefficients\" , \"polinomial coefficients array\" , False , None ], 3 :[ \"A_termal_correction\" , \"termal correction coefficient\" , False , None ], 4 :[ \"A_start_time\" , \"starting time of the series\" , False , None ], 5 :[ \"A_zero_time\" , \"time of the zero reading\" , False , None ], }, \"Channel B\" : { 0 :[ \"B_param_name\" , \"Label of the axis. i.e.: 'X'\" , False , None ], 1 :[ \"B_source_series\" , \"Reference raw series\" , False , None ], 2 :[ \"B_coefficients\" , \"polinomial coefficients array\" , False , None ], 3 :[ \"B_termal_correction\" , \"termal correction coefficient\" , False , None ], 4 :[ \"B_start_time\" , \"starting time of the series\" , False , None ], 5 :[ \"B_zero_time\" , \"time of the zero reading\" , False , None ] }, \"Channel C\" : { 0 :[ \"C_param_name\" , \"Label of the axis. i.e.: 'X'\" , False , None ], 1 :[ \"C_param_series\" , \"Reference raw series\" , False , None ], 2 :[ \"C_coefficients\" , \"polinomial coefficients array\" , False , None ], 3 :[ \"C_termal_correction\" , \"termal correction coefficient\" , False , None ], 4 :[ \"C_start_time\" , \"starting time of the series\" , False , None ], 5 :[ \"C_zero_time\" , \"time of the zero reading\" , False , None ] }, \"Channel Temp\" : { 0 :[ \"T_source_series\" , \"Reference raw series\" , False , None ], 1 :[ \"T_zero_time\" , \"time of the zero reading\" , False , None ] }, } A_param_name = fields . String ( required = False , allow_none = True ) A_source_series = fields . String ( required = False , allow_none = True ) A_coefficients = PolyCoeff ( default =[ 0 , 1 ], required = False , allow_none = True ) A_termal_correction = fields . Number ( default = 1 , required = False , allow_none = True ) A_start_time = StringTime ( required = False , allow_none = True ) A_zero_time = StringTime ( required = False , allow_none = True ) B_param_name = fields . String ( required = False , allow_none = True ) B_source_series = fields . String ( required = False , allow_none = True ) B_coefficients = PolyCoeff ( default =[ 0 , 1 ], required = False , allow_none = True ) B_termal_correction = fields . Number ( default = 1 , required = False , allow_none = True ) B_start_time = StringTime ( required = False , allow_none = True ) B_zero_time = StringTime ( required = False , allow_none = True ) C_param_name = fields . String ( required = False , allow_none = True ) C_source_series = fields . String ( required = False , allow_none = True ) C_coefficients = PolyCoeff ( default =[ 0 , 1 ], required = False , allow_none = True ) C_termal_correction = fields . Number ( default = 1 , required = False , allow_none = True ) C_start_time = StringTime ( required = False , allow_none = True ) C_zero_time = StringTime ( required = False , allow_none = True ) T_source_series = fields . String ( required = False , allow_none = True ) T_start_time = StringTime ( required = False , allow_none = True ) Ancestors (in MRO) hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables A_coefficients A_param_name A_source_series A_start_time A_termal_correction A_zero_time B_coefficients B_param_name B_source_series B_start_time B_termal_correction B_zero_time C_coefficients C_param_name C_source_series C_start_time C_termal_correction C_zero_time Meta OPTIONS_CLASS TYPE_MAPPING T_source_series T_start_time error_messages opts Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) CLINOMETER View Source class Feature ( HFeature ) : ''' CLINOMETER ''' def setup ( self , ** kwargs ) : pass def __channel_config__ ( self , ch , param_name , source_series = None , temp_series = None , termal_correction = None , coefficients = None , start_time = None , zero_time = None , ordinal = None ) : # DA RIVEDERE IL MECCANISMO DI CONSISTENZA TRA UNA CONF E L 'ALTRA try: old_source_series = self.parameters[param_name].uuid except KeyError as e: old_source_series = None if old_source_series is None: if coefficients is None: coefficients=\"\" if temp_series is None: temp_series=0 if termal_correction is None: termal_correction=0 if source_series is None: source_series = old_source_series if source_series is not None: config=dict( param=param_name, ordinal=ordinal, cache=\"active\", mu=\"\u0394 mm/m\", modules={\"calc\":\"hielen3.tools.calc\"}, operands={\"S0\":source_series, \"T0\":temp_series}, operator=f\"calc.filter(calc.poly_trans2(S0,{coefficients})*1000 + T0 * {termal_correction}, 2, 20)\", first=start_time ) self.parameters.set(**config) # ATTENZIONE QUESTA E' UNA FEATURE COMUNE A TUTTE LE SERIRE DATI IN DELTA if zero_time is not None : df = self . parameters [ param_name ] . data () iloc_idx = df . index . get_indexer ( [ zero_time ] , method = 'nearest' ) ZERO = df . iloc [ iloc_idx ] . squeeze () config [ \"operator\" ] += f \" - {ZERO}\" self . parameters . set ( ** config ) def config ( self , ** kwargs ) : tkwargs = { \"A_param_name\" : None , \"A_source_series\" : None , \"A_coefficients\" : None , \"A_termal_correction\" : None , \"A_start_time\" : None , \"A_zero_time\" : None , \"B_param_name\" : None , \"B_source_series\" : None , \"B_coefficients\" : None , \"B_termal_correction\" : None , \"B_start_time\" : None , \"B_zero_time\" : None , \"C_param_name\" : None , \"C_source_series\" : None , \"C_coefficients\" : None , \"C_termal_correction\" : None , \"C_start_time\" : None , \"C_zero_time\" : None , \"T_source_series\" : None , \"T_zero_time\" : None } tkwargs . update ( kwargs ) A = { \"_\" . join ( k . split ( \"_\" ) [ 1: ] ) : w for k , w in tkwargs . items () if k [ 0 ] == \"A\" } B = { \"_\" . join ( k . split ( \"_\" ) [ 1: ] ) : w for k , w in tkwargs . items () if k [ 0 ] == \"B\" } C = { \"_\" . join ( k . split ( \"_\" ) [ 1: ] ) : w for k , w in tkwargs . items () if k [ 0 ] == \"C\" } T = { \"_\" . join ( k . split ( \"_\" ) [ 1: ] ) : w for k , w in tkwargs . items () if k [ 0 ] == \"T\" } try : timestamp = kwargs [ \"timestamp\" ] except KeyError as e : timestamp = None if A [ \"start_time\" ] is None : A [ \"start_time\" ] = timestamp if B [ \"start_time\" ] is None : B [ \"start_time\" ] = timestamp if C [ \"start_time\" ] is None : C [ \"start_time\" ] = timestamp if T [ \"start_time\" ] is None : T [ \"start_time\" ] = timestamp if A [ \"zero_time\" ] is None : A [ \"zero_time\" ] = A [ \"start_time\" ] if B [ \"zero_time\" ] is None : B [ \"zero_time\" ] = B [ \"start_time\" ] if C [ \"zero_time\" ] is None : C [ \"zero_time\" ] = C [ \"start_time\" ] self . parameters . set ( \"Temperatura\" , cache = \"no\" , mu = \"*C\" , modules = {} , operands = { \"S0\" : T [ \"source_series\" ] } , operator = \"S0\" , first = T [ \"start_time\" ] , ordinal = 3 ) temperature = self . parameters [ \"Temperatura\" ] self . __channel_config__ ( ch = \"A\" , ordinal = 0 , temp_series = temperature , ** A ) self . __channel_config__ ( ch = \"B\" , ordinal = 1 , temp_series = temperature , ** B ) self . __channel_config__ ( ch = \"C\" , ordinal = 2 , temp_series = temperature , ** C ) Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , ** kwargs ) View Source def config ( self , ** kwargs ) : tkwargs = { \"A_param_name\" : None , \"A_source_series\" : None , \"A_coefficients\" : None , \"A_termal_correction\" : None , \"A_start_time\" : None , \"A_zero_time\" : None , \"B_param_name\" : None , \"B_source_series\" : None , \"B_coefficients\" : None , \"B_termal_correction\" : None , \"B_start_time\" : None , \"B_zero_time\" : None , \"C_param_name\" : None , \"C_source_series\" : None , \"C_coefficients\" : None , \"C_termal_correction\" : None , \"C_start_time\" : None , \"C_zero_time\" : None , \"T_source_series\" : None , \"T_zero_time\" : None } tkwargs . update ( kwargs ) A = { \"_\" . join ( k . split ( \"_\" ) [ 1 :] ) : w for k , w in tkwargs . items () if k [ 0 ] == \"A\" } B = { \"_\" . join ( k . split ( \"_\" ) [ 1 :] ) : w for k , w in tkwargs . items () if k [ 0 ] == \"B\" } C = { \"_\" . join ( k . split ( \"_\" ) [ 1 :] ) : w for k , w in tkwargs . items () if k [ 0 ] == \"C\" } T = { \"_\" . join ( k . split ( \"_\" ) [ 1 :] ) : w for k , w in tkwargs . items () if k [ 0 ] == \"T\" } try : timestamp = kwargs [ \"timestamp\" ] except KeyError as e : timestamp = None if A [ \"start_time\" ] is None : A [ \"start_time\" ] = timestamp if B [ \"start_time\" ] is None : B [ \"start_time\" ] = timestamp if C [ \"start_time\" ] is None : C [ \"start_time\" ] = timestamp if T [ \"start_time\" ] is None : T [ \"start_time\" ] = timestamp if A [ \"zero_time\" ] is None : A [ \"zero_time\" ] = A [ \"start_time\" ] if B [ \"zero_time\" ] is None : B [ \"zero_time\" ] = B [ \"start_time\" ] if C [ \"zero_time\" ] is None : C [ \"zero_time\" ] = C [ \"start_time\" ] self . parameters . set ( \"Temperatura\" , cache = \"no\" , mu = \"*C\" , modules = {}, operands = { \"S0\" : T [ \"source_series\" ]}, operator = \"S0\" , first = T [ \"start_time\" ], ordinal = 3 ) temperature = self . parameters [ \"Temperatura\" ] self . __channel_config__ ( ch = \"A\" , ordinal = 0 , temp_series = temperature , ** A ) self . __channel_config__ ( ch = \"B\" , ordinal = 1 , temp_series = temperature , ** B ) self . __channel_config__ ( ch = \"C\" , ordinal = 2 , temp_series = temperature , ** C ) create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Feature"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#module-hielen3extfeature_instrument_clinometerfeature","text":"View Source # coding=utf-8 from hielen3.feature import HFeature from hielen3.serializaction import ActionSchema , PolyCoeff , StringTime from hielen3.ext.feature_instrument import ConfigSchema , Feature from marshmallow import fields import traceback class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Channel A\" : { 0 :[ \"A_param_name\" , \"Label of the axis. i.e.: 'X'\" , False , None ], 1 :[ \"A_source_series\" , \"Reference raw series\" , False , None ], 2 :[ \"A_coefficients\" , \"polinomial coefficients array\" , False , None ], 3 :[ \"A_termal_correction\" , \"termal correction coefficient\" , False , None ], 4 :[ \"A_start_time\" , \"starting time of the series\" , False , None ], 5 :[ \"A_zero_time\" , \"time of the zero reading\" , False , None ], }, \"Channel B\" : { 0 :[ \"B_param_name\" , \"Label of the axis. i.e.: 'X'\" , False , None ], 1 :[ \"B_source_series\" , \"Reference raw series\" , False , None ], 2 :[ \"B_coefficients\" , \"polinomial coefficients array\" , False , None ], 3 :[ \"B_termal_correction\" , \"termal correction coefficient\" , False , None ], 4 :[ \"B_start_time\" , \"starting time of the series\" , False , None ], 5 :[ \"B_zero_time\" , \"time of the zero reading\" , False , None ] }, \"Channel C\" : { 0 :[ \"C_param_name\" , \"Label of the axis. i.e.: 'X'\" , False , None ], 1 :[ \"C_param_series\" , \"Reference raw series\" , False , None ], 2 :[ \"C_coefficients\" , \"polinomial coefficients array\" , False , None ], 3 :[ \"C_termal_correction\" , \"termal correction coefficient\" , False , None ], 4 :[ \"C_start_time\" , \"starting time of the series\" , False , None ], 5 :[ \"C_zero_time\" , \"time of the zero reading\" , False , None ] }, \"Channel Temp\" : { 0 :[ \"T_source_series\" , \"Reference raw series\" , False , None ], 1 :[ \"T_zero_time\" , \"time of the zero reading\" , False , None ] }, } A_param_name = fields . String ( required = False , allow_none = True ) A_source_series = fields . String ( required = False , allow_none = True ) A_coefficients = PolyCoeff ( default = [ 0 , 1 ], required = False , allow_none = True ) A_termal_correction = fields . Number ( default = 1 , required = False , allow_none = True ) A_start_time = StringTime ( required = False , allow_none = True ) A_zero_time = StringTime ( required = False , allow_none = True ) B_param_name = fields . String ( required = False , allow_none = True ) B_source_series = fields . String ( required = False , allow_none = True ) B_coefficients = PolyCoeff ( default = [ 0 , 1 ], required = False , allow_none = True ) B_termal_correction = fields . Number ( default = 1 , required = False , allow_none = True ) B_start_time = StringTime ( required = False , allow_none = True ) B_zero_time = StringTime ( required = False , allow_none = True ) C_param_name = fields . String ( required = False , allow_none = True ) C_source_series = fields . String ( required = False , allow_none = True ) C_coefficients = PolyCoeff ( default = [ 0 , 1 ], required = False , allow_none = True ) C_termal_correction = fields . Number ( default = 1 , required = False , allow_none = True ) C_start_time = StringTime ( required = False , allow_none = True ) C_zero_time = StringTime ( required = False , allow_none = True ) T_source_series = fields . String ( required = False , allow_none = True ) T_start_time = StringTime ( required = False , allow_none = True ) class Feature ( HFeature ): ''' CLINOMETER ''' def setup ( self , ** kwargs ): pass def __channel_config__ ( self , ch , param_name , source_series = None , temp_series = None , termal_correction = None , coefficients = None , start_time = None , zero_time = None , ordinal = None ): # DA RIVEDERE IL MECCANISMO DI CONSISTENZA TRA UNA CONF E L'ALTRA try : old_source_series = self . parameters [ param_name ] . uuid except KeyError as e : old_source_series = None if old_source_series is None : if coefficients is None : coefficients = \"\" if temp_series is None : temp_series = 0 if termal_correction is None : termal_correction = 0 if source_series is None : source_series = old_source_series if source_series is not None : config = dict ( param = param_name , ordinal = ordinal , cache = \"active\" , mu = \"\u0394 mm/m\" , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : source_series , \"T0\" : temp_series }, operator = f \"calc.filter(calc.poly_trans2(S0, { coefficients } )*1000 + T0 * { termal_correction } , 2, 20)\" , first = start_time ) self . parameters . set ( ** config ) # ATTENZIONE QUESTA E' UNA FEATURE COMUNE A TUTTE LE SERIRE DATI IN DELTA if zero_time is not None : df = self . parameters [ param_name ] . data () iloc_idx = df . index . get_indexer ([ zero_time ], method = 'nearest' ) ZERO = df . iloc [ iloc_idx ] . squeeze () config [ \"operator\" ] += f \" - { ZERO } \" self . parameters . set ( ** config ) def config ( self , ** kwargs ): tkwargs = { \"A_param_name\" : None , \"A_source_series\" : None , \"A_coefficients\" : None , \"A_termal_correction\" : None , \"A_start_time\" : None , \"A_zero_time\" : None , \"B_param_name\" : None , \"B_source_series\" : None , \"B_coefficients\" : None , \"B_termal_correction\" : None , \"B_start_time\" : None , \"B_zero_time\" : None , \"C_param_name\" : None , \"C_source_series\" : None , \"C_coefficients\" : None , \"C_termal_correction\" : None , \"C_start_time\" : None , \"C_zero_time\" : None , \"T_source_series\" : None , \"T_zero_time\" : None } tkwargs . update ( kwargs ) A = { \"_\" . join ( k . split ( \"_\" )[ 1 :]): w for k , w in tkwargs . items () if k [ 0 ] == \"A\" } B = { \"_\" . join ( k . split ( \"_\" )[ 1 :]): w for k , w in tkwargs . items () if k [ 0 ] == \"B\" } C = { \"_\" . join ( k . split ( \"_\" )[ 1 :]): w for k , w in tkwargs . items () if k [ 0 ] == \"C\" } T = { \"_\" . join ( k . split ( \"_\" )[ 1 :]): w for k , w in tkwargs . items () if k [ 0 ] == \"T\" } try : timestamp = kwargs [ \"timestamp\" ] except KeyError as e : timestamp = None if A [ \"start_time\" ] is None : A [ \"start_time\" ] = timestamp if B [ \"start_time\" ] is None : B [ \"start_time\" ] = timestamp if C [ \"start_time\" ] is None : C [ \"start_time\" ] = timestamp if T [ \"start_time\" ] is None : T [ \"start_time\" ] = timestamp if A [ \"zero_time\" ] is None : A [ \"zero_time\" ] = A [ \"start_time\" ] if B [ \"zero_time\" ] is None : B [ \"zero_time\" ] = B [ \"start_time\" ] if C [ \"zero_time\" ] is None : C [ \"zero_time\" ] = C [ \"start_time\" ] self . parameters . set ( \"Temperatura\" , cache = \"no\" , mu = \"*C\" , modules = {}, operands = { \"S0\" : T [ \"source_series\" ]}, operator = \"S0\" , first = T [ \"start_time\" ], ordinal = 3 ) temperature = self . parameters [ \"Temperatura\" ] self . __channel_config__ ( ch = \"A\" , ordinal = 0 , temp_series = temperature , ** A ) self . __channel_config__ ( ch = \"B\" , ordinal = 1 , temp_series = temperature , ** B ) self . __channel_config__ ( ch = \"C\" , ordinal = 2 , temp_series = temperature , ** C )","title":"Module hielen3.ext.feature_instrument_clinometer.feature"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Channel A\" : { 0 :[ \"A_param_name\" , \"Label of the axis. i.e.: 'X'\" , False , None ], 1 :[ \"A_source_series\" , \"Reference raw series\" , False , None ], 2 :[ \"A_coefficients\" , \"polinomial coefficients array\" , False , None ], 3 :[ \"A_termal_correction\" , \"termal correction coefficient\" , False , None ], 4 :[ \"A_start_time\" , \"starting time of the series\" , False , None ], 5 :[ \"A_zero_time\" , \"time of the zero reading\" , False , None ], }, \"Channel B\" : { 0 :[ \"B_param_name\" , \"Label of the axis. i.e.: 'X'\" , False , None ], 1 :[ \"B_source_series\" , \"Reference raw series\" , False , None ], 2 :[ \"B_coefficients\" , \"polinomial coefficients array\" , False , None ], 3 :[ \"B_termal_correction\" , \"termal correction coefficient\" , False , None ], 4 :[ \"B_start_time\" , \"starting time of the series\" , False , None ], 5 :[ \"B_zero_time\" , \"time of the zero reading\" , False , None ] }, \"Channel C\" : { 0 :[ \"C_param_name\" , \"Label of the axis. i.e.: 'X'\" , False , None ], 1 :[ \"C_param_series\" , \"Reference raw series\" , False , None ], 2 :[ \"C_coefficients\" , \"polinomial coefficients array\" , False , None ], 3 :[ \"C_termal_correction\" , \"termal correction coefficient\" , False , None ], 4 :[ \"C_start_time\" , \"starting time of the series\" , False , None ], 5 :[ \"C_zero_time\" , \"time of the zero reading\" , False , None ] }, \"Channel Temp\" : { 0 :[ \"T_source_series\" , \"Reference raw series\" , False , None ], 1 :[ \"T_zero_time\" , \"time of the zero reading\" , False , None ] }, } A_param_name = fields . String ( required = False , allow_none = True ) A_source_series = fields . String ( required = False , allow_none = True ) A_coefficients = PolyCoeff ( default =[ 0 , 1 ], required = False , allow_none = True ) A_termal_correction = fields . Number ( default = 1 , required = False , allow_none = True ) A_start_time = StringTime ( required = False , allow_none = True ) A_zero_time = StringTime ( required = False , allow_none = True ) B_param_name = fields . String ( required = False , allow_none = True ) B_source_series = fields . String ( required = False , allow_none = True ) B_coefficients = PolyCoeff ( default =[ 0 , 1 ], required = False , allow_none = True ) B_termal_correction = fields . Number ( default = 1 , required = False , allow_none = True ) B_start_time = StringTime ( required = False , allow_none = True ) B_zero_time = StringTime ( required = False , allow_none = True ) C_param_name = fields . String ( required = False , allow_none = True ) C_source_series = fields . String ( required = False , allow_none = True ) C_coefficients = PolyCoeff ( default =[ 0 , 1 ], required = False , allow_none = True ) C_termal_correction = fields . Number ( default = 1 , required = False , allow_none = True ) C_start_time = StringTime ( required = False , allow_none = True ) C_zero_time = StringTime ( required = False , allow_none = True ) T_source_series = fields . String ( required = False , allow_none = True ) T_start_time = StringTime ( required = False , allow_none = True )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#ancestors-in-mro","text":"hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#class-variables","text":"A_coefficients A_param_name A_source_series A_start_time A_termal_correction A_zero_time B_coefficients B_param_name B_source_series B_start_time B_termal_correction B_zero_time C_coefficients C_param_name C_source_series C_start_time C_termal_correction C_zero_time Meta OPTIONS_CLASS TYPE_MAPPING T_source_series T_start_time error_messages opts","title":"Class variables"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#feature","text":"class Feature ( feature ) CLINOMETER View Source class Feature ( HFeature ) : ''' CLINOMETER ''' def setup ( self , ** kwargs ) : pass def __channel_config__ ( self , ch , param_name , source_series = None , temp_series = None , termal_correction = None , coefficients = None , start_time = None , zero_time = None , ordinal = None ) : # DA RIVEDERE IL MECCANISMO DI CONSISTENZA TRA UNA CONF E L 'ALTRA try: old_source_series = self.parameters[param_name].uuid except KeyError as e: old_source_series = None if old_source_series is None: if coefficients is None: coefficients=\"\" if temp_series is None: temp_series=0 if termal_correction is None: termal_correction=0 if source_series is None: source_series = old_source_series if source_series is not None: config=dict( param=param_name, ordinal=ordinal, cache=\"active\", mu=\"\u0394 mm/m\", modules={\"calc\":\"hielen3.tools.calc\"}, operands={\"S0\":source_series, \"T0\":temp_series}, operator=f\"calc.filter(calc.poly_trans2(S0,{coefficients})*1000 + T0 * {termal_correction}, 2, 20)\", first=start_time ) self.parameters.set(**config) # ATTENZIONE QUESTA E' UNA FEATURE COMUNE A TUTTE LE SERIRE DATI IN DELTA if zero_time is not None : df = self . parameters [ param_name ] . data () iloc_idx = df . index . get_indexer ( [ zero_time ] , method = 'nearest' ) ZERO = df . iloc [ iloc_idx ] . squeeze () config [ \"operator\" ] += f \" - {ZERO}\" self . parameters . set ( ** config ) def config ( self , ** kwargs ) : tkwargs = { \"A_param_name\" : None , \"A_source_series\" : None , \"A_coefficients\" : None , \"A_termal_correction\" : None , \"A_start_time\" : None , \"A_zero_time\" : None , \"B_param_name\" : None , \"B_source_series\" : None , \"B_coefficients\" : None , \"B_termal_correction\" : None , \"B_start_time\" : None , \"B_zero_time\" : None , \"C_param_name\" : None , \"C_source_series\" : None , \"C_coefficients\" : None , \"C_termal_correction\" : None , \"C_start_time\" : None , \"C_zero_time\" : None , \"T_source_series\" : None , \"T_zero_time\" : None } tkwargs . update ( kwargs ) A = { \"_\" . join ( k . split ( \"_\" ) [ 1: ] ) : w for k , w in tkwargs . items () if k [ 0 ] == \"A\" } B = { \"_\" . join ( k . split ( \"_\" ) [ 1: ] ) : w for k , w in tkwargs . items () if k [ 0 ] == \"B\" } C = { \"_\" . join ( k . split ( \"_\" ) [ 1: ] ) : w for k , w in tkwargs . items () if k [ 0 ] == \"C\" } T = { \"_\" . join ( k . split ( \"_\" ) [ 1: ] ) : w for k , w in tkwargs . items () if k [ 0 ] == \"T\" } try : timestamp = kwargs [ \"timestamp\" ] except KeyError as e : timestamp = None if A [ \"start_time\" ] is None : A [ \"start_time\" ] = timestamp if B [ \"start_time\" ] is None : B [ \"start_time\" ] = timestamp if C [ \"start_time\" ] is None : C [ \"start_time\" ] = timestamp if T [ \"start_time\" ] is None : T [ \"start_time\" ] = timestamp if A [ \"zero_time\" ] is None : A [ \"zero_time\" ] = A [ \"start_time\" ] if B [ \"zero_time\" ] is None : B [ \"zero_time\" ] = B [ \"start_time\" ] if C [ \"zero_time\" ] is None : C [ \"zero_time\" ] = C [ \"start_time\" ] self . parameters . set ( \"Temperatura\" , cache = \"no\" , mu = \"*C\" , modules = {} , operands = { \"S0\" : T [ \"source_series\" ] } , operator = \"S0\" , first = T [ \"start_time\" ] , ordinal = 3 ) temperature = self . parameters [ \"Temperatura\" ] self . __channel_config__ ( ch = \"A\" , ordinal = 0 , temp_series = temperature , ** A ) self . __channel_config__ ( ch = \"B\" , ordinal = 1 , temp_series = temperature , ** B ) self . __channel_config__ ( ch = \"C\" , ordinal = 2 , temp_series = temperature , ** C )","title":"Feature"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#config","text":"def config ( self , ** kwargs ) View Source def config ( self , ** kwargs ) : tkwargs = { \"A_param_name\" : None , \"A_source_series\" : None , \"A_coefficients\" : None , \"A_termal_correction\" : None , \"A_start_time\" : None , \"A_zero_time\" : None , \"B_param_name\" : None , \"B_source_series\" : None , \"B_coefficients\" : None , \"B_termal_correction\" : None , \"B_start_time\" : None , \"B_zero_time\" : None , \"C_param_name\" : None , \"C_source_series\" : None , \"C_coefficients\" : None , \"C_termal_correction\" : None , \"C_start_time\" : None , \"C_zero_time\" : None , \"T_source_series\" : None , \"T_zero_time\" : None } tkwargs . update ( kwargs ) A = { \"_\" . join ( k . split ( \"_\" ) [ 1 :] ) : w for k , w in tkwargs . items () if k [ 0 ] == \"A\" } B = { \"_\" . join ( k . split ( \"_\" ) [ 1 :] ) : w for k , w in tkwargs . items () if k [ 0 ] == \"B\" } C = { \"_\" . join ( k . split ( \"_\" ) [ 1 :] ) : w for k , w in tkwargs . items () if k [ 0 ] == \"C\" } T = { \"_\" . join ( k . split ( \"_\" ) [ 1 :] ) : w for k , w in tkwargs . items () if k [ 0 ] == \"T\" } try : timestamp = kwargs [ \"timestamp\" ] except KeyError as e : timestamp = None if A [ \"start_time\" ] is None : A [ \"start_time\" ] = timestamp if B [ \"start_time\" ] is None : B [ \"start_time\" ] = timestamp if C [ \"start_time\" ] is None : C [ \"start_time\" ] = timestamp if T [ \"start_time\" ] is None : T [ \"start_time\" ] = timestamp if A [ \"zero_time\" ] is None : A [ \"zero_time\" ] = A [ \"start_time\" ] if B [ \"zero_time\" ] is None : B [ \"zero_time\" ] = B [ \"start_time\" ] if C [ \"zero_time\" ] is None : C [ \"zero_time\" ] = C [ \"start_time\" ] self . parameters . set ( \"Temperatura\" , cache = \"no\" , mu = \"*C\" , modules = {}, operands = { \"S0\" : T [ \"source_series\" ]}, operator = \"S0\" , first = T [ \"start_time\" ], ordinal = 3 ) temperature = self . parameters [ \"Temperatura\" ] self . __channel_config__ ( ch = \"A\" , ordinal = 0 , temp_series = temperature , ** A ) self . __channel_config__ ( ch = \"B\" , ordinal = 1 , temp_series = temperature , ** B ) self . __channel_config__ ( ch = \"C\" , ordinal = 2 , temp_series = temperature , ** C )","title":"config"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#retrive","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#setup","text":"def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_instrument_clinometer/feature/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_instrument_generic/","text":"Module hielen3.ext.feature_instrument_generic View Source # coding=utf-8 __name__ = \"Feature_generic_instrument\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" #from hielen3.ext.feature_instrument import * from .feature import Feature , ConfigSchema __all__ = [ \"Feature\" , \"ConfigSchema\" ] Sub-modules hielen3.ext.feature_instrument_generic.feature Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Channels Info\" : { 0 :[ \"multi_channel_info_json\" , \"Every things it needs\" , False , None ], }, } multi_channel_info_json = fields . String ( required = False , allow_none = True ) Ancestors (in MRO) hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages multi_channel_info_json opts Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) INSTRUMENT View Source class Feature ( HFeature ): ''' INSTRUMENT ''' def setup ( self , ** kwargs ): pass def __channel_config__ ( self , param_name , source_series = None , source_label = None , source_parameter = None , coefficients = None , timestamp = None , start_time = None , zero_time = None , ordinal = None , unit = None , valid_range = None , view_range = None , thresholds = None ): if start_time is None : if zero_time is None : start_time = timestamp else : start_time = zero_time # DA RIVEDERE IL MECCANISMO DI CONSISTENZA TRA UNA CONF E L'ALTRA try : old_source_series = self . parameters [ param_name ] . uuid except KeyError as e : old_source_series = None if coefficients is not None : coefficients = \",\" . join ( map ( str , coefficients )) if old_source_series is None : if coefficients is None : coefficients = \"\" if source_label is not None and source_parameter is not None : try : source_series = HFeature . retrive_label ( source_label ) . parameters [ source_parameter ] except Exception as e : print ( e ) pass if source_series is None : source_series = old_source_series if source_series is not None : \"\"\" porcata per velocizzare valle ragone\"\"\" if self . label [ 0 ] in ( \"T\" , \"F\" ): operator = f \"calc.poly_trans2(S0,{coefficients})\" elif self . label [ 0 ] == \"I\" : operator = f \"calc.filter(calc.slope(calc.poly_trans2(S0,{coefficients}),radius=1000), 3, 10)\" else : operator = None \"\"\" fine porcata \"\"\" config = dict ( param = param_name , ordinal = ordinal , cache = \"active\" , mu = unit , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : source_series }, operator = operator , first = start_time , valid_range = valid_range , view_range = view_range , thresholds = thresholds ) self . parameters . set ( ** config ) # ATTENZIONE QUESTA E' UNA FEATURE COMUNE A TUTTE LE SERIE DATI IN DELTA if zero_time is not None : df = self . parameters [ param_name ] . data () iloc_idx = df . index . get_indexer ([ zero_time ], method = 'nearest' ) try : ZERO = df . iloc [ iloc_idx ] . squeeze () except Exception as e : ZERO = 0 config [ \"operator\" ] += f \" - {ZERO}\" self . parameters . set ( ** config ) def config ( self , multi_channel_info_json = None , timestamp = None , ** kwargs ): try : infos = json . loads ( multi_channel_info_json ) except Exception as e : raise e for info in infos : self . __channel_config__ ( timestamp = timestamp , ** info ) Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , multi_channel_info_json = None , timestamp = None , ** kwargs ) View Source def config ( self , multi_channel_info_json = None , timestamp = None , ** kwargs ): try : infos = json . loads ( multi_channel_info_json ) except Exception as e : raise e for info in infos : self . __channel_config__ ( timestamp = timestamp , ** info ) create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Index"},{"location":"reference/hielen3/ext/feature_instrument_generic/#module-hielen3extfeature_instrument_generic","text":"View Source # coding=utf-8 __name__ = \"Feature_generic_instrument\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" #from hielen3.ext.feature_instrument import * from .feature import Feature , ConfigSchema __all__ = [ \"Feature\" , \"ConfigSchema\" ]","title":"Module hielen3.ext.feature_instrument_generic"},{"location":"reference/hielen3/ext/feature_instrument_generic/#sub-modules","text":"hielen3.ext.feature_instrument_generic.feature","title":"Sub-modules"},{"location":"reference/hielen3/ext/feature_instrument_generic/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_instrument_generic/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Channels Info\" : { 0 :[ \"multi_channel_info_json\" , \"Every things it needs\" , False , None ], }, } multi_channel_info_json = fields . String ( required = False , allow_none = True )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_instrument_generic/#ancestors-in-mro","text":"hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_instrument_generic/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages multi_channel_info_json opts","title":"Class variables"},{"location":"reference/hielen3/ext/feature_instrument_generic/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_instrument_generic/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_instrument_generic/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_instrument_generic/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_instrument_generic/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_instrument_generic/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_instrument_generic/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_instrument_generic/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_instrument_generic/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_instrument_generic/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_instrument_generic/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_instrument_generic/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_instrument_generic/#feature","text":"class Feature ( feature ) INSTRUMENT View Source class Feature ( HFeature ): ''' INSTRUMENT ''' def setup ( self , ** kwargs ): pass def __channel_config__ ( self , param_name , source_series = None , source_label = None , source_parameter = None , coefficients = None , timestamp = None , start_time = None , zero_time = None , ordinal = None , unit = None , valid_range = None , view_range = None , thresholds = None ): if start_time is None : if zero_time is None : start_time = timestamp else : start_time = zero_time # DA RIVEDERE IL MECCANISMO DI CONSISTENZA TRA UNA CONF E L'ALTRA try : old_source_series = self . parameters [ param_name ] . uuid except KeyError as e : old_source_series = None if coefficients is not None : coefficients = \",\" . join ( map ( str , coefficients )) if old_source_series is None : if coefficients is None : coefficients = \"\" if source_label is not None and source_parameter is not None : try : source_series = HFeature . retrive_label ( source_label ) . parameters [ source_parameter ] except Exception as e : print ( e ) pass if source_series is None : source_series = old_source_series if source_series is not None : \"\"\" porcata per velocizzare valle ragone\"\"\" if self . label [ 0 ] in ( \"T\" , \"F\" ): operator = f \"calc.poly_trans2(S0,{coefficients})\" elif self . label [ 0 ] == \"I\" : operator = f \"calc.filter(calc.slope(calc.poly_trans2(S0,{coefficients}),radius=1000), 3, 10)\" else : operator = None \"\"\" fine porcata \"\"\" config = dict ( param = param_name , ordinal = ordinal , cache = \"active\" , mu = unit , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : source_series }, operator = operator , first = start_time , valid_range = valid_range , view_range = view_range , thresholds = thresholds ) self . parameters . set ( ** config ) # ATTENZIONE QUESTA E' UNA FEATURE COMUNE A TUTTE LE SERIE DATI IN DELTA if zero_time is not None : df = self . parameters [ param_name ] . data () iloc_idx = df . index . get_indexer ([ zero_time ], method = 'nearest' ) try : ZERO = df . iloc [ iloc_idx ] . squeeze () except Exception as e : ZERO = 0 config [ \"operator\" ] += f \" - {ZERO}\" self . parameters . set ( ** config ) def config ( self , multi_channel_info_json = None , timestamp = None , ** kwargs ): try : infos = json . loads ( multi_channel_info_json ) except Exception as e : raise e for info in infos : self . __channel_config__ ( timestamp = timestamp , ** info )","title":"Feature"},{"location":"reference/hielen3/ext/feature_instrument_generic/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_instrument_generic/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_instrument_generic/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_instrument_generic/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_instrument_generic/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_instrument_generic/#config","text":"def config ( self , multi_channel_info_json = None , timestamp = None , ** kwargs ) View Source def config ( self , multi_channel_info_json = None , timestamp = None , ** kwargs ): try : infos = json . loads ( multi_channel_info_json ) except Exception as e : raise e for info in infos : self . __channel_config__ ( timestamp = timestamp , ** info )","title":"config"},{"location":"reference/hielen3/ext/feature_instrument_generic/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_instrument_generic/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_instrument_generic/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_instrument_generic/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_instrument_generic/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_instrument_generic/#retrive","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_instrument_generic/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_instrument_generic/#setup","text":"def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_instrument_generic/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_instrument_generic/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_instrument_generic/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/","text":"Module hielen3.ext.feature_instrument_generic.feature View Source # coding=utf-8 from hielen3.feature import HFeature from hielen3.serializaction import ActionSchema , PolyCoeff , StringTime from hielen3.ext.feature_instrument import ConfigSchema , Feature from marshmallow import fields import json import traceback class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Channels Info\" : { 0 :[ \"multi_channel_info_json\" , \"Every things it needs\" , False , None ], }, } multi_channel_info_json = fields . String ( required = False , allow_none = True ) class Feature ( HFeature ): ''' INSTRUMENT ''' def setup ( self , ** kwargs ): pass def __channel_config__ ( self , param_name , source_series = None , source_label = None , source_parameter = None , coefficients = None , timestamp = None , start_time = None , zero_time = None , ordinal = None , unit = None , valid_range = None , view_range = None , thresholds = None ): if start_time is None : if zero_time is None : start_time = timestamp else : start_time = zero_time # DA RIVEDERE IL MECCANISMO DI CONSISTENZA TRA UNA CONF E L'ALTRA try : old_source_series = self . parameters [ param_name ] . uuid except KeyError as e : old_source_series = None if coefficients is not None : coefficients = \",\" . join ( map ( str , coefficients )) if old_source_series is None : if coefficients is None : coefficients = \"\" if source_label is not None and source_parameter is not None : try : source_series = HFeature . retrive_label ( source_label ) . parameters [ source_parameter ] except Exception as e : print ( e ) pass if source_series is None : source_series = old_source_series if source_series is not None : \"\"\" porcata per velocizzare valle ragone\"\"\" if self . label [ 0 ] in ( \"T\" , \"F\" ): operator = f \"calc.poly_trans2(S0, { coefficients } )\" elif self . label [ 0 ] == \"I\" : operator = f \"calc.filter(calc.slope(calc.poly_trans2(S0, { coefficients } ),radius=1000), 3, 10)\" else : operator = None \"\"\" fine porcata \"\"\" config = dict ( param = param_name , ordinal = ordinal , cache = \"active\" , mu = unit , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : source_series }, operator = operator , first = start_time , valid_range = valid_range , view_range = view_range , thresholds = thresholds ) self . parameters . set ( ** config ) # ATTENZIONE QUESTA E' UNA FEATURE COMUNE A TUTTE LE SERIE DATI IN DELTA if zero_time is not None : df = self . parameters [ param_name ] . data () iloc_idx = df . index . get_indexer ([ zero_time ], method = 'nearest' ) try : ZERO = df . iloc [ iloc_idx ] . squeeze () except Exception as e : ZERO = 0 config [ \"operator\" ] += f \" - { ZERO } \" self . parameters . set ( ** config ) def config ( self , multi_channel_info_json = None , timestamp = None , ** kwargs ): try : infos = json . loads ( multi_channel_info_json ) except Exception as e : raise e for info in infos : self . __channel_config__ ( timestamp = timestamp , ** info ) Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Channels Info\" : { 0 :[ \"multi_channel_info_json\" , \"Every things it needs\" , False , None ], }, } multi_channel_info_json = fields . String ( required = False , allow_none = True ) Ancestors (in MRO) hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages multi_channel_info_json opts Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) INSTRUMENT View Source class Feature ( HFeature ): ''' INSTRUMENT ''' def setup ( self , ** kwargs ): pass def __channel_config__ ( self , param_name , source_series = None , source_label = None , source_parameter = None , coefficients = None , timestamp = None , start_time = None , zero_time = None , ordinal = None , unit = None , valid_range = None , view_range = None , thresholds = None ): if start_time is None : if zero_time is None : start_time = timestamp else : start_time = zero_time # DA RIVEDERE IL MECCANISMO DI CONSISTENZA TRA UNA CONF E L'ALTRA try : old_source_series = self . parameters [ param_name ] . uuid except KeyError as e : old_source_series = None if coefficients is not None : coefficients = \",\" . join ( map ( str , coefficients )) if old_source_series is None : if coefficients is None : coefficients = \"\" if source_label is not None and source_parameter is not None : try : source_series = HFeature . retrive_label ( source_label ) . parameters [ source_parameter ] except Exception as e : print ( e ) pass if source_series is None : source_series = old_source_series if source_series is not None : \"\"\" porcata per velocizzare valle ragone\"\"\" if self . label [ 0 ] in ( \"T\" , \"F\" ): operator = f \"calc.poly_trans2(S0,{coefficients})\" elif self . label [ 0 ] == \"I\" : operator = f \"calc.filter(calc.slope(calc.poly_trans2(S0,{coefficients}),radius=1000), 3, 10)\" else : operator = None \"\"\" fine porcata \"\"\" config = dict ( param = param_name , ordinal = ordinal , cache = \"active\" , mu = unit , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : source_series }, operator = operator , first = start_time , valid_range = valid_range , view_range = view_range , thresholds = thresholds ) self . parameters . set ( ** config ) # ATTENZIONE QUESTA E' UNA FEATURE COMUNE A TUTTE LE SERIE DATI IN DELTA if zero_time is not None : df = self . parameters [ param_name ] . data () iloc_idx = df . index . get_indexer ([ zero_time ], method = 'nearest' ) try : ZERO = df . iloc [ iloc_idx ] . squeeze () except Exception as e : ZERO = 0 config [ \"operator\" ] += f \" - {ZERO}\" self . parameters . set ( ** config ) def config ( self , multi_channel_info_json = None , timestamp = None , ** kwargs ): try : infos = json . loads ( multi_channel_info_json ) except Exception as e : raise e for info in infos : self . __channel_config__ ( timestamp = timestamp , ** info ) Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , multi_channel_info_json = None , timestamp = None , ** kwargs ) View Source def config ( self , multi_channel_info_json = None , timestamp = None , ** kwargs ): try : infos = json . loads ( multi_channel_info_json ) except Exception as e : raise e for info in infos : self . __channel_config__ ( timestamp = timestamp , ** info ) create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Feature"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#module-hielen3extfeature_instrument_genericfeature","text":"View Source # coding=utf-8 from hielen3.feature import HFeature from hielen3.serializaction import ActionSchema , PolyCoeff , StringTime from hielen3.ext.feature_instrument import ConfigSchema , Feature from marshmallow import fields import json import traceback class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Channels Info\" : { 0 :[ \"multi_channel_info_json\" , \"Every things it needs\" , False , None ], }, } multi_channel_info_json = fields . String ( required = False , allow_none = True ) class Feature ( HFeature ): ''' INSTRUMENT ''' def setup ( self , ** kwargs ): pass def __channel_config__ ( self , param_name , source_series = None , source_label = None , source_parameter = None , coefficients = None , timestamp = None , start_time = None , zero_time = None , ordinal = None , unit = None , valid_range = None , view_range = None , thresholds = None ): if start_time is None : if zero_time is None : start_time = timestamp else : start_time = zero_time # DA RIVEDERE IL MECCANISMO DI CONSISTENZA TRA UNA CONF E L'ALTRA try : old_source_series = self . parameters [ param_name ] . uuid except KeyError as e : old_source_series = None if coefficients is not None : coefficients = \",\" . join ( map ( str , coefficients )) if old_source_series is None : if coefficients is None : coefficients = \"\" if source_label is not None and source_parameter is not None : try : source_series = HFeature . retrive_label ( source_label ) . parameters [ source_parameter ] except Exception as e : print ( e ) pass if source_series is None : source_series = old_source_series if source_series is not None : \"\"\" porcata per velocizzare valle ragone\"\"\" if self . label [ 0 ] in ( \"T\" , \"F\" ): operator = f \"calc.poly_trans2(S0, { coefficients } )\" elif self . label [ 0 ] == \"I\" : operator = f \"calc.filter(calc.slope(calc.poly_trans2(S0, { coefficients } ),radius=1000), 3, 10)\" else : operator = None \"\"\" fine porcata \"\"\" config = dict ( param = param_name , ordinal = ordinal , cache = \"active\" , mu = unit , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : source_series }, operator = operator , first = start_time , valid_range = valid_range , view_range = view_range , thresholds = thresholds ) self . parameters . set ( ** config ) # ATTENZIONE QUESTA E' UNA FEATURE COMUNE A TUTTE LE SERIE DATI IN DELTA if zero_time is not None : df = self . parameters [ param_name ] . data () iloc_idx = df . index . get_indexer ([ zero_time ], method = 'nearest' ) try : ZERO = df . iloc [ iloc_idx ] . squeeze () except Exception as e : ZERO = 0 config [ \"operator\" ] += f \" - { ZERO } \" self . parameters . set ( ** config ) def config ( self , multi_channel_info_json = None , timestamp = None , ** kwargs ): try : infos = json . loads ( multi_channel_info_json ) except Exception as e : raise e for info in infos : self . __channel_config__ ( timestamp = timestamp , ** info )","title":"Module hielen3.ext.feature_instrument_generic.feature"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Channels Info\" : { 0 :[ \"multi_channel_info_json\" , \"Every things it needs\" , False , None ], }, } multi_channel_info_json = fields . String ( required = False , allow_none = True )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#ancestors-in-mro","text":"hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages multi_channel_info_json opts","title":"Class variables"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#feature","text":"class Feature ( feature ) INSTRUMENT View Source class Feature ( HFeature ): ''' INSTRUMENT ''' def setup ( self , ** kwargs ): pass def __channel_config__ ( self , param_name , source_series = None , source_label = None , source_parameter = None , coefficients = None , timestamp = None , start_time = None , zero_time = None , ordinal = None , unit = None , valid_range = None , view_range = None , thresholds = None ): if start_time is None : if zero_time is None : start_time = timestamp else : start_time = zero_time # DA RIVEDERE IL MECCANISMO DI CONSISTENZA TRA UNA CONF E L'ALTRA try : old_source_series = self . parameters [ param_name ] . uuid except KeyError as e : old_source_series = None if coefficients is not None : coefficients = \",\" . join ( map ( str , coefficients )) if old_source_series is None : if coefficients is None : coefficients = \"\" if source_label is not None and source_parameter is not None : try : source_series = HFeature . retrive_label ( source_label ) . parameters [ source_parameter ] except Exception as e : print ( e ) pass if source_series is None : source_series = old_source_series if source_series is not None : \"\"\" porcata per velocizzare valle ragone\"\"\" if self . label [ 0 ] in ( \"T\" , \"F\" ): operator = f \"calc.poly_trans2(S0,{coefficients})\" elif self . label [ 0 ] == \"I\" : operator = f \"calc.filter(calc.slope(calc.poly_trans2(S0,{coefficients}),radius=1000), 3, 10)\" else : operator = None \"\"\" fine porcata \"\"\" config = dict ( param = param_name , ordinal = ordinal , cache = \"active\" , mu = unit , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : source_series }, operator = operator , first = start_time , valid_range = valid_range , view_range = view_range , thresholds = thresholds ) self . parameters . set ( ** config ) # ATTENZIONE QUESTA E' UNA FEATURE COMUNE A TUTTE LE SERIE DATI IN DELTA if zero_time is not None : df = self . parameters [ param_name ] . data () iloc_idx = df . index . get_indexer ([ zero_time ], method = 'nearest' ) try : ZERO = df . iloc [ iloc_idx ] . squeeze () except Exception as e : ZERO = 0 config [ \"operator\" ] += f \" - {ZERO}\" self . parameters . set ( ** config ) def config ( self , multi_channel_info_json = None , timestamp = None , ** kwargs ): try : infos = json . loads ( multi_channel_info_json ) except Exception as e : raise e for info in infos : self . __channel_config__ ( timestamp = timestamp , ** info )","title":"Feature"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#config","text":"def config ( self , multi_channel_info_json = None , timestamp = None , ** kwargs ) View Source def config ( self , multi_channel_info_json = None , timestamp = None , ** kwargs ): try : infos = json . loads ( multi_channel_info_json ) except Exception as e : raise e for info in infos : self . __channel_config__ ( timestamp = timestamp , ** info )","title":"config"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#retrive","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#setup","text":"def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_instrument_generic/feature/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_instrument_improved/","text":"Module hielen3.ext.feature_instrument_improved View Source # coding=utf-8 __name__ = \"Feature_generic_instrument\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" #from hielen3.ext.feature_instrument import * from .feature import Feature , ConfigSchema __all__ = [ \"Feature\" , \"ConfigSchema\" ] Sub-modules hielen3.ext.feature_instrument_improved.feature Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Channels Info\" : { 0 :[ \"multi_channel_info_json\" , \"Everything it needs\" , False , None ], }, } multi_channel_info_json = fields . String ( required = False , allow_none = True ) Ancestors (in MRO) hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages multi_channel_info_json opts Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) INSTRUMENT View Source class Feature ( HFeature ): ''' INSTRUMENT ''' def setup ( self , ** kwargs ): pass def __channel_config__ ( self , param_name , cache = None , operands = None , operator = None , modules = None , coefficients = None , timestamp = None , start_time = None , zero_time = None , start_offset = None , ordinal = None , mu = None , valid_range = None , view_range = None , thresholds = None , groupmap = None , orient = None ): print ( f \" \\n {param_name}\" ) \"\"\" { \"param_name\" : \"Est\"|\"Nord\"|\"Quota\", \"cache\" : \"old\", \"operands\" : FILE_CHANNEL_SERIES, \"operator\" : None, \"modules\" : {}, \"coefficients\" : [0,1000], \"timestamp\" : \"ttt\", \"start_time\" : None, \"zero_time\" : first, \"ordinal\" : 0 | 1 | 2, \"mu\" | \"\u0394 mm\", \"valid_range : None, view_range : [-10,10], thresholds : None } \"\"\" try : series = self . parameters [ param_name ] except KeyError as e : series = None try : opz = series . generator . operands except Exception as e : opz = {} new_opz = {} if modules is None : modules = {} if operands is not None : for k , w in operands . items (): if isinstance ( w , dict ): try : feat = w [ 'feature' ] if feat == 'self' : feat = self else : try : feat = HFeature . retrive ( feat ) except Exception as e : raise ValueError ( f 'error retriving {w}: {feat}' ) try : w = feat . parameters [ w [ \"param\" ]] except Exception as e : raise SelfParamError ( f 'error retriving {feat}.{w[\"param\"]}' ) except KeyError as e : pass new_opz [ k ] = w opz . update ( new_opz ) print ( \"GROUPMAP:\" , groupmap ) if groupmap is None : opz [ \"Z\" ] = 0 opz [ \"OFFSET\" ] = 0 if coefficients is None : try : coefficients = opz [ \"COEFS\" ] except KeyError as e : coefficients = None try : assert coefficients . __len__ () > 0 except Exception as e : coefficients = None if coefficients is not None and operator is not None and operator not in ( \"__ALIAS__\" ): opz [ \"COEFS\" ] = json . dumps ( coefficients ) modules . update ( { \"calc\" : \"hielen3.tools.calc\" } ) operator = f \"calc.poly_trans2({operator},*COEFS)\" if start_time is None : if zero_time is None or \"first\" in zero_time : start_time = timestamp else : start_time = zero_time if zero_time is None or \"first\" in zero_time : zero_time = start_time zero_time = datetime64 ( zero_time ) if operator is not None and operator not in ( \"__VOID__\" , \"__ALIAS__\" ): operator = f \"{operator} - Z + OFFSET\" print ( \"OPERATOR\" , operator ) config = dict ( param = param_name , ordinal = ordinal , cache = cache , mu = mu , modules = modules , operands = opz , operator = operator , first = start_time , valid_range = valid_range , view_range = view_range , thresholds = thresholds , groupmap = groupmap , orient = orient ) print ( \"\" ) print ( config ) print ( \"\" ) print ( \"------------------------------------\" ) print ( \"\" ) self . parameters . set ( ** config ) # ATTENZIONE QUESTA E' UNA FEATURE COMUNE A TUTTE LE SERIE DATI IN DELTA if zero_time is not None : df = self . parameters [ param_name ] . data ( cache = 'active' ) try : df = df . to_frame () except Exception as e : pass df = df [ df [ df . columns [ 0 ]] . notna ()] print ( \"AAAA \\n\\n \" , zero_time , \" \\n\\n AAAA\" ) iloc_idx = df . index . get_indexer ([ zero_time ], method = 'nearest' ) try : config [ 'operands' ][ 'Z' ] = df . iloc [ iloc_idx ] . squeeze () except Exception as e : print ( f \"WARN configuring ZERO for param {param_name}:\" , e ) if start_offset is not None : try : config [ 'operands' ][ 'OFFSET' ] = start_offset except Exception as e : print ( f \"WARN configuring OFFSET for param {param_name}:\" , e ) if start_offset is not None or zero_time is not None : try : self . parameters . set ( ** config ) except Exception as e : print ( f \"WARN configuring param {param_name}:\" , e ) def config ( self , multi_channel_info_json = None , timestamp = None , ** kwargs ): try : infos = json . loads ( multi_channel_info_json ) except Exception as e : raise e retryinfoslen = 0 print ( f \" \\n\\n {self.label}\" , self . uuid , \" \\n \" , \"---------------------\" ) while True : # Needed to configure self referenced parameters if the dependant # parameter comes before the dependency in the info array retryinfos = [] for info in infos : try : self . __channel_config__ ( timestamp = timestamp , ** info ) except SelfParamError as e : retryinfos . append ( info ) if retryinfos . __len__ () == 0 : return if retryinfos . __len__ () > 0 and retryinfos . __len__ () == retryinfoslen : raise ValueError ( f \"self parameters reference broken {retryinfos}\" ) retryinfoslen = retryinfos . __len__ () info = retryinfos . copy () Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , multi_channel_info_json = None , timestamp = None , ** kwargs ) View Source def config ( self , multi_channel_info_json = None , timestamp = None , ** kwargs ): try : infos = json . loads ( multi_channel_info_json ) except Exception as e : raise e retryinfoslen = 0 print ( f \" \\n\\n {self.label}\" , self . uuid , \" \\n \" , \"---------------------\" ) while True : # Needed to configure self referenced parameters if the dependant # parameter comes before the dependency in the info array retryinfos = [] for info in infos : try : self . __channel_config__ ( timestamp = timestamp , ** info ) except SelfParamError as e : retryinfos . append ( info ) if retryinfos . __len__ () == 0 : return if retryinfos . __len__ () > 0 and retryinfos . __len__ () == retryinfoslen : raise ValueError ( f \"self parameters reference broken {retryinfos}\" ) retryinfoslen = retryinfos . __len__ () info = retryinfos . copy () create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Index"},{"location":"reference/hielen3/ext/feature_instrument_improved/#module-hielen3extfeature_instrument_improved","text":"View Source # coding=utf-8 __name__ = \"Feature_generic_instrument\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" #from hielen3.ext.feature_instrument import * from .feature import Feature , ConfigSchema __all__ = [ \"Feature\" , \"ConfigSchema\" ]","title":"Module hielen3.ext.feature_instrument_improved"},{"location":"reference/hielen3/ext/feature_instrument_improved/#sub-modules","text":"hielen3.ext.feature_instrument_improved.feature","title":"Sub-modules"},{"location":"reference/hielen3/ext/feature_instrument_improved/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_instrument_improved/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Channels Info\" : { 0 :[ \"multi_channel_info_json\" , \"Everything it needs\" , False , None ], }, } multi_channel_info_json = fields . String ( required = False , allow_none = True )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_instrument_improved/#ancestors-in-mro","text":"hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_instrument_improved/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages multi_channel_info_json opts","title":"Class variables"},{"location":"reference/hielen3/ext/feature_instrument_improved/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_instrument_improved/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_instrument_improved/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_instrument_improved/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_instrument_improved/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_instrument_improved/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_instrument_improved/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_instrument_improved/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_instrument_improved/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_instrument_improved/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_instrument_improved/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_instrument_improved/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_instrument_improved/#feature","text":"class Feature ( feature ) INSTRUMENT View Source class Feature ( HFeature ): ''' INSTRUMENT ''' def setup ( self , ** kwargs ): pass def __channel_config__ ( self , param_name , cache = None , operands = None , operator = None , modules = None , coefficients = None , timestamp = None , start_time = None , zero_time = None , start_offset = None , ordinal = None , mu = None , valid_range = None , view_range = None , thresholds = None , groupmap = None , orient = None ): print ( f \" \\n {param_name}\" ) \"\"\" { \"param_name\" : \"Est\"|\"Nord\"|\"Quota\", \"cache\" : \"old\", \"operands\" : FILE_CHANNEL_SERIES, \"operator\" : None, \"modules\" : {}, \"coefficients\" : [0,1000], \"timestamp\" : \"ttt\", \"start_time\" : None, \"zero_time\" : first, \"ordinal\" : 0 | 1 | 2, \"mu\" | \"\u0394 mm\", \"valid_range : None, view_range : [-10,10], thresholds : None } \"\"\" try : series = self . parameters [ param_name ] except KeyError as e : series = None try : opz = series . generator . operands except Exception as e : opz = {} new_opz = {} if modules is None : modules = {} if operands is not None : for k , w in operands . items (): if isinstance ( w , dict ): try : feat = w [ 'feature' ] if feat == 'self' : feat = self else : try : feat = HFeature . retrive ( feat ) except Exception as e : raise ValueError ( f 'error retriving {w}: {feat}' ) try : w = feat . parameters [ w [ \"param\" ]] except Exception as e : raise SelfParamError ( f 'error retriving {feat}.{w[\"param\"]}' ) except KeyError as e : pass new_opz [ k ] = w opz . update ( new_opz ) print ( \"GROUPMAP:\" , groupmap ) if groupmap is None : opz [ \"Z\" ] = 0 opz [ \"OFFSET\" ] = 0 if coefficients is None : try : coefficients = opz [ \"COEFS\" ] except KeyError as e : coefficients = None try : assert coefficients . __len__ () > 0 except Exception as e : coefficients = None if coefficients is not None and operator is not None and operator not in ( \"__ALIAS__\" ): opz [ \"COEFS\" ] = json . dumps ( coefficients ) modules . update ( { \"calc\" : \"hielen3.tools.calc\" } ) operator = f \"calc.poly_trans2({operator},*COEFS)\" if start_time is None : if zero_time is None or \"first\" in zero_time : start_time = timestamp else : start_time = zero_time if zero_time is None or \"first\" in zero_time : zero_time = start_time zero_time = datetime64 ( zero_time ) if operator is not None and operator not in ( \"__VOID__\" , \"__ALIAS__\" ): operator = f \"{operator} - Z + OFFSET\" print ( \"OPERATOR\" , operator ) config = dict ( param = param_name , ordinal = ordinal , cache = cache , mu = mu , modules = modules , operands = opz , operator = operator , first = start_time , valid_range = valid_range , view_range = view_range , thresholds = thresholds , groupmap = groupmap , orient = orient ) print ( \"\" ) print ( config ) print ( \"\" ) print ( \"------------------------------------\" ) print ( \"\" ) self . parameters . set ( ** config ) # ATTENZIONE QUESTA E' UNA FEATURE COMUNE A TUTTE LE SERIE DATI IN DELTA if zero_time is not None : df = self . parameters [ param_name ] . data ( cache = 'active' ) try : df = df . to_frame () except Exception as e : pass df = df [ df [ df . columns [ 0 ]] . notna ()] print ( \"AAAA \\n\\n \" , zero_time , \" \\n\\n AAAA\" ) iloc_idx = df . index . get_indexer ([ zero_time ], method = 'nearest' ) try : config [ 'operands' ][ 'Z' ] = df . iloc [ iloc_idx ] . squeeze () except Exception as e : print ( f \"WARN configuring ZERO for param {param_name}:\" , e ) if start_offset is not None : try : config [ 'operands' ][ 'OFFSET' ] = start_offset except Exception as e : print ( f \"WARN configuring OFFSET for param {param_name}:\" , e ) if start_offset is not None or zero_time is not None : try : self . parameters . set ( ** config ) except Exception as e : print ( f \"WARN configuring param {param_name}:\" , e ) def config ( self , multi_channel_info_json = None , timestamp = None , ** kwargs ): try : infos = json . loads ( multi_channel_info_json ) except Exception as e : raise e retryinfoslen = 0 print ( f \" \\n\\n {self.label}\" , self . uuid , \" \\n \" , \"---------------------\" ) while True : # Needed to configure self referenced parameters if the dependant # parameter comes before the dependency in the info array retryinfos = [] for info in infos : try : self . __channel_config__ ( timestamp = timestamp , ** info ) except SelfParamError as e : retryinfos . append ( info ) if retryinfos . __len__ () == 0 : return if retryinfos . __len__ () > 0 and retryinfos . __len__ () == retryinfoslen : raise ValueError ( f \"self parameters reference broken {retryinfos}\" ) retryinfoslen = retryinfos . __len__ () info = retryinfos . copy ()","title":"Feature"},{"location":"reference/hielen3/ext/feature_instrument_improved/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_instrument_improved/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_instrument_improved/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_instrument_improved/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_instrument_improved/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_instrument_improved/#config","text":"def config ( self , multi_channel_info_json = None , timestamp = None , ** kwargs ) View Source def config ( self , multi_channel_info_json = None , timestamp = None , ** kwargs ): try : infos = json . loads ( multi_channel_info_json ) except Exception as e : raise e retryinfoslen = 0 print ( f \" \\n\\n {self.label}\" , self . uuid , \" \\n \" , \"---------------------\" ) while True : # Needed to configure self referenced parameters if the dependant # parameter comes before the dependency in the info array retryinfos = [] for info in infos : try : self . __channel_config__ ( timestamp = timestamp , ** info ) except SelfParamError as e : retryinfos . append ( info ) if retryinfos . __len__ () == 0 : return if retryinfos . __len__ () > 0 and retryinfos . __len__ () == retryinfoslen : raise ValueError ( f \"self parameters reference broken {retryinfos}\" ) retryinfoslen = retryinfos . __len__ () info = retryinfos . copy ()","title":"config"},{"location":"reference/hielen3/ext/feature_instrument_improved/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_instrument_improved/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_instrument_improved/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_instrument_improved/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_instrument_improved/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_instrument_improved/#retrive","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_instrument_improved/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_instrument_improved/#setup","text":"def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_instrument_improved/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_instrument_improved/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_instrument_improved/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/","text":"Module hielen3.ext.feature_instrument_improved.feature View Source # coding=utf-8 from hielen3.feature import HFeature from hielen3.serializaction import ActionSchema , PolyCoeff , StringTime from hielen3.ext.feature_instrument import ConfigSchema , Feature from marshmallow import fields from numpy import datetime64 import json import traceback class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Channels Info\" : { 0 :[ \"multi_channel_info_json\" , \"Everything it needs\" , False , None ], }, } multi_channel_info_json = fields . String ( required = False , allow_none = True ) class SelfParamError ( Exception ): pass class Feature ( HFeature ): ''' INSTRUMENT ''' def setup ( self , ** kwargs ): pass def __channel_config__ ( self , param_name , cache = None , operands = None , operator = None , modules = None , coefficients = None , timestamp = None , start_time = None , zero_time = None , start_offset = None , ordinal = None , mu = None , valid_range = None , view_range = None , thresholds = None , groupmap = None , orient = None ): print ( f \" \\n { param_name } \" ) \"\"\" { \"param_name\" : \"Est\"|\"Nord\"|\"Quota\", \"cache\" : \"old\", \"operands\" : FILE_CHANNEL_SERIES, \"operator\" : None, \"modules\" : {}, \"coefficients\" : [0,1000], \"timestamp\" : \"ttt\", \"start_time\" : None, \"zero_time\" : first, \"ordinal\" : 0 | 1 | 2, \"mu\" | \"\u0394 mm\", \"valid_range : None, view_range : [-10,10], thresholds : None } \"\"\" try : series = self . parameters [ param_name ] except KeyError as e : series = None try : opz = series . generator . operands except Exception as e : opz = {} new_opz = {} if modules is None : modules = {} if operands is not None : for k , w in operands . items (): if isinstance ( w , dict ): try : feat = w [ 'feature' ] if feat == 'self' : feat = self else : try : feat = HFeature . retrive ( feat ) except Exception as e : raise ValueError ( f 'error retriving { w } : { feat } ' ) try : w = feat . parameters [ w [ \"param\" ]] except Exception as e : raise SelfParamError ( f 'error retriving { feat } . { w [ \"param\" ] } ' ) except KeyError as e : pass new_opz [ k ] = w opz . update ( new_opz ) print ( \"GROUPMAP:\" , groupmap ) if groupmap is None : opz [ \"Z\" ] = 0 opz [ \"OFFSET\" ] = 0 if coefficients is None : try : coefficients = opz [ \"COEFS\" ] except KeyError as e : coefficients = None try : assert coefficients . __len__ () > 0 except Exception as e : coefficients = None if coefficients is not None and operator is not None and operator not in ( \"__ALIAS__\" ): opz [ \"COEFS\" ] = json . dumps ( coefficients ) modules . update ( { \"calc\" : \"hielen3.tools.calc\" } ) operator = f \"calc.poly_trans2( { operator } ,*COEFS)\" if start_time is None : if zero_time is None or \"first\" in zero_time : start_time = timestamp else : start_time = zero_time if zero_time is None or \"first\" in zero_time : zero_time = start_time zero_time = datetime64 ( zero_time ) if operator is not None and operator not in ( \"__VOID__\" , \"__ALIAS__\" ): operator = f \" { operator } - Z + OFFSET\" print ( \"OPERATOR\" , operator ) config = dict ( param = param_name , ordinal = ordinal , cache = cache , mu = mu , modules = modules , operands = opz , operator = operator , first = start_time , valid_range = valid_range , view_range = view_range , thresholds = thresholds , groupmap = groupmap , orient = orient ) print ( \"\" ) print ( config ) print ( \"\" ) print ( \"------------------------------------\" ) print ( \"\" ) self . parameters . set ( ** config ) # ATTENZIONE QUESTA E' UNA FEATURE COMUNE A TUTTE LE SERIE DATI IN DELTA if zero_time is not None : df = self . parameters [ param_name ] . data ( cache = 'active' ) try : df = df . to_frame () except Exception as e : pass df = df [ df [ df . columns [ 0 ]] . notna ()] print ( \"AAAA \\n\\n \" , zero_time , \" \\n\\n AAAA\" ) iloc_idx = df . index . get_indexer ([ zero_time ], method = 'nearest' ) try : config [ 'operands' ][ 'Z' ] = df . iloc [ iloc_idx ] . squeeze () except Exception as e : print ( f \"WARN configuring ZERO for param { param_name } :\" , e ) if start_offset is not None : try : config [ 'operands' ][ 'OFFSET' ] = start_offset except Exception as e : print ( f \"WARN configuring OFFSET for param { param_name } :\" , e ) if start_offset is not None or zero_time is not None : try : self . parameters . set ( ** config ) except Exception as e : print ( f \"WARN configuring param { param_name } :\" , e ) def config ( self , multi_channel_info_json = None , timestamp = None , ** kwargs ): try : infos = json . loads ( multi_channel_info_json ) except Exception as e : raise e retryinfoslen = 0 print ( f \" \\n\\n { self . label } \" , self . uuid , \" \\n \" , \"---------------------\" ) while True : # Needed to configure self referenced parameters if the dependant # parameter comes before the dependency in the info array retryinfos = [] for info in infos : try : self . __channel_config__ ( timestamp = timestamp , ** info ) except SelfParamError as e : retryinfos . append ( info ) if retryinfos . __len__ () == 0 : return if retryinfos . __len__ () > 0 and retryinfos . __len__ () == retryinfoslen : raise ValueError ( f \"self parameters reference broken { retryinfos } \" ) retryinfoslen = retryinfos . __len__ () info = retryinfos . copy () Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Channels Info\" : { 0 :[ \"multi_channel_info_json\" , \"Everything it needs\" , False , None ], }, } multi_channel_info_json = fields . String ( required = False , allow_none = True ) Ancestors (in MRO) hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages multi_channel_info_json opts Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) INSTRUMENT View Source class Feature ( HFeature ): ''' INSTRUMENT ''' def setup ( self , ** kwargs ): pass def __channel_config__ ( self , param_name , cache = None , operands = None , operator = None , modules = None , coefficients = None , timestamp = None , start_time = None , zero_time = None , start_offset = None , ordinal = None , mu = None , valid_range = None , view_range = None , thresholds = None , groupmap = None , orient = None ): print ( f \" \\n {param_name}\" ) \"\"\" { \"param_name\" : \"Est\"|\"Nord\"|\"Quota\", \"cache\" : \"old\", \"operands\" : FILE_CHANNEL_SERIES, \"operator\" : None, \"modules\" : {}, \"coefficients\" : [0,1000], \"timestamp\" : \"ttt\", \"start_time\" : None, \"zero_time\" : first, \"ordinal\" : 0 | 1 | 2, \"mu\" | \"\u0394 mm\", \"valid_range : None, view_range : [-10,10], thresholds : None } \"\"\" try : series = self . parameters [ param_name ] except KeyError as e : series = None try : opz = series . generator . operands except Exception as e : opz = {} new_opz = {} if modules is None : modules = {} if operands is not None : for k , w in operands . items (): if isinstance ( w , dict ): try : feat = w [ 'feature' ] if feat == 'self' : feat = self else : try : feat = HFeature . retrive ( feat ) except Exception as e : raise ValueError ( f 'error retriving {w}: {feat}' ) try : w = feat . parameters [ w [ \"param\" ]] except Exception as e : raise SelfParamError ( f 'error retriving {feat}.{w[\"param\"]}' ) except KeyError as e : pass new_opz [ k ] = w opz . update ( new_opz ) print ( \"GROUPMAP:\" , groupmap ) if groupmap is None : opz [ \"Z\" ] = 0 opz [ \"OFFSET\" ] = 0 if coefficients is None : try : coefficients = opz [ \"COEFS\" ] except KeyError as e : coefficients = None try : assert coefficients . __len__ () > 0 except Exception as e : coefficients = None if coefficients is not None and operator is not None and operator not in ( \"__ALIAS__\" ): opz [ \"COEFS\" ] = json . dumps ( coefficients ) modules . update ( { \"calc\" : \"hielen3.tools.calc\" } ) operator = f \"calc.poly_trans2({operator},*COEFS)\" if start_time is None : if zero_time is None or \"first\" in zero_time : start_time = timestamp else : start_time = zero_time if zero_time is None or \"first\" in zero_time : zero_time = start_time zero_time = datetime64 ( zero_time ) if operator is not None and operator not in ( \"__VOID__\" , \"__ALIAS__\" ): operator = f \"{operator} - Z + OFFSET\" print ( \"OPERATOR\" , operator ) config = dict ( param = param_name , ordinal = ordinal , cache = cache , mu = mu , modules = modules , operands = opz , operator = operator , first = start_time , valid_range = valid_range , view_range = view_range , thresholds = thresholds , groupmap = groupmap , orient = orient ) print ( \"\" ) print ( config ) print ( \"\" ) print ( \"------------------------------------\" ) print ( \"\" ) self . parameters . set ( ** config ) # ATTENZIONE QUESTA E' UNA FEATURE COMUNE A TUTTE LE SERIE DATI IN DELTA if zero_time is not None : df = self . parameters [ param_name ] . data ( cache = 'active' ) try : df = df . to_frame () except Exception as e : pass df = df [ df [ df . columns [ 0 ]] . notna ()] print ( \"AAAA \\n\\n \" , zero_time , \" \\n\\n AAAA\" ) iloc_idx = df . index . get_indexer ([ zero_time ], method = 'nearest' ) try : config [ 'operands' ][ 'Z' ] = df . iloc [ iloc_idx ] . squeeze () except Exception as e : print ( f \"WARN configuring ZERO for param {param_name}:\" , e ) if start_offset is not None : try : config [ 'operands' ][ 'OFFSET' ] = start_offset except Exception as e : print ( f \"WARN configuring OFFSET for param {param_name}:\" , e ) if start_offset is not None or zero_time is not None : try : self . parameters . set ( ** config ) except Exception as e : print ( f \"WARN configuring param {param_name}:\" , e ) def config ( self , multi_channel_info_json = None , timestamp = None , ** kwargs ): try : infos = json . loads ( multi_channel_info_json ) except Exception as e : raise e retryinfoslen = 0 print ( f \" \\n\\n {self.label}\" , self . uuid , \" \\n \" , \"---------------------\" ) while True : # Needed to configure self referenced parameters if the dependant # parameter comes before the dependency in the info array retryinfos = [] for info in infos : try : self . __channel_config__ ( timestamp = timestamp , ** info ) except SelfParamError as e : retryinfos . append ( info ) if retryinfos . __len__ () == 0 : return if retryinfos . __len__ () > 0 and retryinfos . __len__ () == retryinfoslen : raise ValueError ( f \"self parameters reference broken {retryinfos}\" ) retryinfoslen = retryinfos . __len__ () info = retryinfos . copy () Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , multi_channel_info_json = None , timestamp = None , ** kwargs ) View Source def config ( self , multi_channel_info_json = None , timestamp = None , ** kwargs ): try : infos = json . loads ( multi_channel_info_json ) except Exception as e : raise e retryinfoslen = 0 print ( f \" \\n\\n {self.label}\" , self . uuid , \" \\n \" , \"---------------------\" ) while True : # Needed to configure self referenced parameters if the dependant # parameter comes before the dependency in the info array retryinfos = [] for info in infos : try : self . __channel_config__ ( timestamp = timestamp , ** info ) except SelfParamError as e : retryinfos . append ( info ) if retryinfos . __len__ () == 0 : return if retryinfos . __len__ () > 0 and retryinfos . __len__ () == retryinfoslen : raise ValueError ( f \"self parameters reference broken {retryinfos}\" ) retryinfoslen = retryinfos . __len__ () info = retryinfos . copy () create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) SelfParamError class SelfParamError ( / , * args , ** kwargs ) Common base class for all non-exit exceptions. View Source class SelfParamError ( Exception ): pass Ancestors (in MRO) builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Feature"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#module-hielen3extfeature_instrument_improvedfeature","text":"View Source # coding=utf-8 from hielen3.feature import HFeature from hielen3.serializaction import ActionSchema , PolyCoeff , StringTime from hielen3.ext.feature_instrument import ConfigSchema , Feature from marshmallow import fields from numpy import datetime64 import json import traceback class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Channels Info\" : { 0 :[ \"multi_channel_info_json\" , \"Everything it needs\" , False , None ], }, } multi_channel_info_json = fields . String ( required = False , allow_none = True ) class SelfParamError ( Exception ): pass class Feature ( HFeature ): ''' INSTRUMENT ''' def setup ( self , ** kwargs ): pass def __channel_config__ ( self , param_name , cache = None , operands = None , operator = None , modules = None , coefficients = None , timestamp = None , start_time = None , zero_time = None , start_offset = None , ordinal = None , mu = None , valid_range = None , view_range = None , thresholds = None , groupmap = None , orient = None ): print ( f \" \\n { param_name } \" ) \"\"\" { \"param_name\" : \"Est\"|\"Nord\"|\"Quota\", \"cache\" : \"old\", \"operands\" : FILE_CHANNEL_SERIES, \"operator\" : None, \"modules\" : {}, \"coefficients\" : [0,1000], \"timestamp\" : \"ttt\", \"start_time\" : None, \"zero_time\" : first, \"ordinal\" : 0 | 1 | 2, \"mu\" | \"\u0394 mm\", \"valid_range : None, view_range : [-10,10], thresholds : None } \"\"\" try : series = self . parameters [ param_name ] except KeyError as e : series = None try : opz = series . generator . operands except Exception as e : opz = {} new_opz = {} if modules is None : modules = {} if operands is not None : for k , w in operands . items (): if isinstance ( w , dict ): try : feat = w [ 'feature' ] if feat == 'self' : feat = self else : try : feat = HFeature . retrive ( feat ) except Exception as e : raise ValueError ( f 'error retriving { w } : { feat } ' ) try : w = feat . parameters [ w [ \"param\" ]] except Exception as e : raise SelfParamError ( f 'error retriving { feat } . { w [ \"param\" ] } ' ) except KeyError as e : pass new_opz [ k ] = w opz . update ( new_opz ) print ( \"GROUPMAP:\" , groupmap ) if groupmap is None : opz [ \"Z\" ] = 0 opz [ \"OFFSET\" ] = 0 if coefficients is None : try : coefficients = opz [ \"COEFS\" ] except KeyError as e : coefficients = None try : assert coefficients . __len__ () > 0 except Exception as e : coefficients = None if coefficients is not None and operator is not None and operator not in ( \"__ALIAS__\" ): opz [ \"COEFS\" ] = json . dumps ( coefficients ) modules . update ( { \"calc\" : \"hielen3.tools.calc\" } ) operator = f \"calc.poly_trans2( { operator } ,*COEFS)\" if start_time is None : if zero_time is None or \"first\" in zero_time : start_time = timestamp else : start_time = zero_time if zero_time is None or \"first\" in zero_time : zero_time = start_time zero_time = datetime64 ( zero_time ) if operator is not None and operator not in ( \"__VOID__\" , \"__ALIAS__\" ): operator = f \" { operator } - Z + OFFSET\" print ( \"OPERATOR\" , operator ) config = dict ( param = param_name , ordinal = ordinal , cache = cache , mu = mu , modules = modules , operands = opz , operator = operator , first = start_time , valid_range = valid_range , view_range = view_range , thresholds = thresholds , groupmap = groupmap , orient = orient ) print ( \"\" ) print ( config ) print ( \"\" ) print ( \"------------------------------------\" ) print ( \"\" ) self . parameters . set ( ** config ) # ATTENZIONE QUESTA E' UNA FEATURE COMUNE A TUTTE LE SERIE DATI IN DELTA if zero_time is not None : df = self . parameters [ param_name ] . data ( cache = 'active' ) try : df = df . to_frame () except Exception as e : pass df = df [ df [ df . columns [ 0 ]] . notna ()] print ( \"AAAA \\n\\n \" , zero_time , \" \\n\\n AAAA\" ) iloc_idx = df . index . get_indexer ([ zero_time ], method = 'nearest' ) try : config [ 'operands' ][ 'Z' ] = df . iloc [ iloc_idx ] . squeeze () except Exception as e : print ( f \"WARN configuring ZERO for param { param_name } :\" , e ) if start_offset is not None : try : config [ 'operands' ][ 'OFFSET' ] = start_offset except Exception as e : print ( f \"WARN configuring OFFSET for param { param_name } :\" , e ) if start_offset is not None or zero_time is not None : try : self . parameters . set ( ** config ) except Exception as e : print ( f \"WARN configuring param { param_name } :\" , e ) def config ( self , multi_channel_info_json = None , timestamp = None , ** kwargs ): try : infos = json . loads ( multi_channel_info_json ) except Exception as e : raise e retryinfoslen = 0 print ( f \" \\n\\n { self . label } \" , self . uuid , \" \\n \" , \"---------------------\" ) while True : # Needed to configure self referenced parameters if the dependant # parameter comes before the dependency in the info array retryinfos = [] for info in infos : try : self . __channel_config__ ( timestamp = timestamp , ** info ) except SelfParamError as e : retryinfos . append ( info ) if retryinfos . __len__ () == 0 : return if retryinfos . __len__ () > 0 and retryinfos . __len__ () == retryinfoslen : raise ValueError ( f \"self parameters reference broken { retryinfos } \" ) retryinfoslen = retryinfos . __len__ () info = retryinfos . copy ()","title":"Module hielen3.ext.feature_instrument_improved.feature"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Channels Info\" : { 0 :[ \"multi_channel_info_json\" , \"Everything it needs\" , False , None ], }, } multi_channel_info_json = fields . String ( required = False , allow_none = True )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#ancestors-in-mro","text":"hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages multi_channel_info_json opts","title":"Class variables"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#feature","text":"class Feature ( feature ) INSTRUMENT View Source class Feature ( HFeature ): ''' INSTRUMENT ''' def setup ( self , ** kwargs ): pass def __channel_config__ ( self , param_name , cache = None , operands = None , operator = None , modules = None , coefficients = None , timestamp = None , start_time = None , zero_time = None , start_offset = None , ordinal = None , mu = None , valid_range = None , view_range = None , thresholds = None , groupmap = None , orient = None ): print ( f \" \\n {param_name}\" ) \"\"\" { \"param_name\" : \"Est\"|\"Nord\"|\"Quota\", \"cache\" : \"old\", \"operands\" : FILE_CHANNEL_SERIES, \"operator\" : None, \"modules\" : {}, \"coefficients\" : [0,1000], \"timestamp\" : \"ttt\", \"start_time\" : None, \"zero_time\" : first, \"ordinal\" : 0 | 1 | 2, \"mu\" | \"\u0394 mm\", \"valid_range : None, view_range : [-10,10], thresholds : None } \"\"\" try : series = self . parameters [ param_name ] except KeyError as e : series = None try : opz = series . generator . operands except Exception as e : opz = {} new_opz = {} if modules is None : modules = {} if operands is not None : for k , w in operands . items (): if isinstance ( w , dict ): try : feat = w [ 'feature' ] if feat == 'self' : feat = self else : try : feat = HFeature . retrive ( feat ) except Exception as e : raise ValueError ( f 'error retriving {w}: {feat}' ) try : w = feat . parameters [ w [ \"param\" ]] except Exception as e : raise SelfParamError ( f 'error retriving {feat}.{w[\"param\"]}' ) except KeyError as e : pass new_opz [ k ] = w opz . update ( new_opz ) print ( \"GROUPMAP:\" , groupmap ) if groupmap is None : opz [ \"Z\" ] = 0 opz [ \"OFFSET\" ] = 0 if coefficients is None : try : coefficients = opz [ \"COEFS\" ] except KeyError as e : coefficients = None try : assert coefficients . __len__ () > 0 except Exception as e : coefficients = None if coefficients is not None and operator is not None and operator not in ( \"__ALIAS__\" ): opz [ \"COEFS\" ] = json . dumps ( coefficients ) modules . update ( { \"calc\" : \"hielen3.tools.calc\" } ) operator = f \"calc.poly_trans2({operator},*COEFS)\" if start_time is None : if zero_time is None or \"first\" in zero_time : start_time = timestamp else : start_time = zero_time if zero_time is None or \"first\" in zero_time : zero_time = start_time zero_time = datetime64 ( zero_time ) if operator is not None and operator not in ( \"__VOID__\" , \"__ALIAS__\" ): operator = f \"{operator} - Z + OFFSET\" print ( \"OPERATOR\" , operator ) config = dict ( param = param_name , ordinal = ordinal , cache = cache , mu = mu , modules = modules , operands = opz , operator = operator , first = start_time , valid_range = valid_range , view_range = view_range , thresholds = thresholds , groupmap = groupmap , orient = orient ) print ( \"\" ) print ( config ) print ( \"\" ) print ( \"------------------------------------\" ) print ( \"\" ) self . parameters . set ( ** config ) # ATTENZIONE QUESTA E' UNA FEATURE COMUNE A TUTTE LE SERIE DATI IN DELTA if zero_time is not None : df = self . parameters [ param_name ] . data ( cache = 'active' ) try : df = df . to_frame () except Exception as e : pass df = df [ df [ df . columns [ 0 ]] . notna ()] print ( \"AAAA \\n\\n \" , zero_time , \" \\n\\n AAAA\" ) iloc_idx = df . index . get_indexer ([ zero_time ], method = 'nearest' ) try : config [ 'operands' ][ 'Z' ] = df . iloc [ iloc_idx ] . squeeze () except Exception as e : print ( f \"WARN configuring ZERO for param {param_name}:\" , e ) if start_offset is not None : try : config [ 'operands' ][ 'OFFSET' ] = start_offset except Exception as e : print ( f \"WARN configuring OFFSET for param {param_name}:\" , e ) if start_offset is not None or zero_time is not None : try : self . parameters . set ( ** config ) except Exception as e : print ( f \"WARN configuring param {param_name}:\" , e ) def config ( self , multi_channel_info_json = None , timestamp = None , ** kwargs ): try : infos = json . loads ( multi_channel_info_json ) except Exception as e : raise e retryinfoslen = 0 print ( f \" \\n\\n {self.label}\" , self . uuid , \" \\n \" , \"---------------------\" ) while True : # Needed to configure self referenced parameters if the dependant # parameter comes before the dependency in the info array retryinfos = [] for info in infos : try : self . __channel_config__ ( timestamp = timestamp , ** info ) except SelfParamError as e : retryinfos . append ( info ) if retryinfos . __len__ () == 0 : return if retryinfos . __len__ () > 0 and retryinfos . __len__ () == retryinfoslen : raise ValueError ( f \"self parameters reference broken {retryinfos}\" ) retryinfoslen = retryinfos . __len__ () info = retryinfos . copy ()","title":"Feature"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#config","text":"def config ( self , multi_channel_info_json = None , timestamp = None , ** kwargs ) View Source def config ( self , multi_channel_info_json = None , timestamp = None , ** kwargs ): try : infos = json . loads ( multi_channel_info_json ) except Exception as e : raise e retryinfoslen = 0 print ( f \" \\n\\n {self.label}\" , self . uuid , \" \\n \" , \"---------------------\" ) while True : # Needed to configure self referenced parameters if the dependant # parameter comes before the dependency in the info array retryinfos = [] for info in infos : try : self . __channel_config__ ( timestamp = timestamp , ** info ) except SelfParamError as e : retryinfos . append ( info ) if retryinfos . __len__ () == 0 : return if retryinfos . __len__ () > 0 and retryinfos . __len__ () == retryinfoslen : raise ValueError ( f \"self parameters reference broken {retryinfos}\" ) retryinfoslen = retryinfos . __len__ () info = retryinfos . copy ()","title":"config"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#retrive","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#setup","text":"def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#selfparamerror","text":"class SelfParamError ( / , * args , ** kwargs ) Common base class for all non-exit exceptions. View Source class SelfParamError ( Exception ): pass","title":"SelfParamError"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#ancestors-in-mro_2","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#class-variables_1","text":"args","title":"Class variables"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#methods_2","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_instrument_improved/feature/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/","text":"Module hielen3.ext.feature_instrument_piezometer View Source # coding=utf-8 __name__ = \"Feature_instrument_piezometer\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" #from hielen3.ext.feature_instrument import * from .feature import Feature , ConfigSchema __all__ = [ \"Feature\" , \"ConfigSchema\" ] Sub-modules hielen3.ext.feature_instrument_piezometer.feature Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Instruments info\" :{ 0 :[ \"source_series\" , \"Reference raw series\" , False , None ], 1 :[ \"poly\" , \"polinomial coefficients array\" , False , None ], 2 :[ \"head_height\" , \"ground zero\" , False , None ], 3 :[ \"sensor_depth\" , \"sensor distance from the groud zero\" , False , None ], 4 :[ \"timezero\" , \"time of the zero reading\" , False , None ] } } source_series = fields . String ( required = False , allow_none = False ) poly = PolyCoeff ( default =[ 0 , 1 ], required = False , allow_none = True ) head_height = fields . Number ( default = 0.0 , required = False , allow_none = True ) sensor_depth = fields . Number ( default = 0.0 , required = False , allow_none = True ) timezero = StringTime ( required = False , allow_none = True ) Ancestors (in MRO) hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages head_height opts poly sensor_depth source_series timezero Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) PIEZOMETER View Source class Feature ( HFeature ): ''' PIEZOMETER ''' def setup ( self , ** kwargs ): pass def config ( self , source_series = None , head_height = None , sensor_depth = None , poly = None , timezero = None , ** kwargs ): if not self . parameters . __len__ (): if head_height is None : head_height = 0 if sensor_depth is None : sensor_depth = 0 if poly is None : poly = \"\" if timezero is None : zero = 0 if source_series is not None and poly is not None : self . parameters . set ( 'battente' , cache = 'active' , mu = \"m\" , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : source_series }, operator = f \"calc.filter(calc.poly_trans2(S0,{poly}))\" , first = timezero , ordinal = 1 ) contribute = head_height - sensor_depth limit = 0 self . parameters . set ( 'quota falda' , cache = 'active' , mu = \"m.s.l.m.\" , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"battente\" ]}, operator = f \"calc.add(calc.threshold(S0, limit={limit}, how='<', action='clean'), {contribute})\" , ordinal = 0 ) Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , source_series = None , head_height = None , sensor_depth = None , poly = None , timezero = None , ** kwargs ) View Source def config ( self , source_series = None , head_height = None , sensor_depth = None , poly = None , timezero = None , ** kwargs ): if not self . parameters . __len__ (): if head_height is None : head_height = 0 if sensor_depth is None : sensor_depth = 0 if poly is None : poly = \"\" if timezero is None : zero = 0 if source_series is not None and poly is not None : self . parameters . set ( 'battente' , cache = 'active' , mu = \"m\" , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : source_series }, operator = f \"calc.filter(calc.poly_trans2(S0,{poly}))\" , first = timezero , ordinal = 1 ) contribute = head_height - sensor_depth limit = 0 self . parameters . set ( 'quota falda' , cache = 'active' , mu = \"m.s.l.m.\" , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"battente\" ]}, operator = f \"calc.add(calc.threshold(S0, limit={limit}, how='<', action='clean'), {contribute})\" , ordinal = 0 ) create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Index"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#module-hielen3extfeature_instrument_piezometer","text":"View Source # coding=utf-8 __name__ = \"Feature_instrument_piezometer\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" #from hielen3.ext.feature_instrument import * from .feature import Feature , ConfigSchema __all__ = [ \"Feature\" , \"ConfigSchema\" ]","title":"Module hielen3.ext.feature_instrument_piezometer"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#sub-modules","text":"hielen3.ext.feature_instrument_piezometer.feature","title":"Sub-modules"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Instruments info\" :{ 0 :[ \"source_series\" , \"Reference raw series\" , False , None ], 1 :[ \"poly\" , \"polinomial coefficients array\" , False , None ], 2 :[ \"head_height\" , \"ground zero\" , False , None ], 3 :[ \"sensor_depth\" , \"sensor distance from the groud zero\" , False , None ], 4 :[ \"timezero\" , \"time of the zero reading\" , False , None ] } } source_series = fields . String ( required = False , allow_none = False ) poly = PolyCoeff ( default =[ 0 , 1 ], required = False , allow_none = True ) head_height = fields . Number ( default = 0.0 , required = False , allow_none = True ) sensor_depth = fields . Number ( default = 0.0 , required = False , allow_none = True ) timezero = StringTime ( required = False , allow_none = True )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#ancestors-in-mro","text":"hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages head_height opts poly sensor_depth source_series timezero","title":"Class variables"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#feature","text":"class Feature ( feature ) PIEZOMETER View Source class Feature ( HFeature ): ''' PIEZOMETER ''' def setup ( self , ** kwargs ): pass def config ( self , source_series = None , head_height = None , sensor_depth = None , poly = None , timezero = None , ** kwargs ): if not self . parameters . __len__ (): if head_height is None : head_height = 0 if sensor_depth is None : sensor_depth = 0 if poly is None : poly = \"\" if timezero is None : zero = 0 if source_series is not None and poly is not None : self . parameters . set ( 'battente' , cache = 'active' , mu = \"m\" , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : source_series }, operator = f \"calc.filter(calc.poly_trans2(S0,{poly}))\" , first = timezero , ordinal = 1 ) contribute = head_height - sensor_depth limit = 0 self . parameters . set ( 'quota falda' , cache = 'active' , mu = \"m.s.l.m.\" , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"battente\" ]}, operator = f \"calc.add(calc.threshold(S0, limit={limit}, how='<', action='clean'), {contribute})\" , ordinal = 0 )","title":"Feature"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#config","text":"def config ( self , source_series = None , head_height = None , sensor_depth = None , poly = None , timezero = None , ** kwargs ) View Source def config ( self , source_series = None , head_height = None , sensor_depth = None , poly = None , timezero = None , ** kwargs ): if not self . parameters . __len__ (): if head_height is None : head_height = 0 if sensor_depth is None : sensor_depth = 0 if poly is None : poly = \"\" if timezero is None : zero = 0 if source_series is not None and poly is not None : self . parameters . set ( 'battente' , cache = 'active' , mu = \"m\" , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : source_series }, operator = f \"calc.filter(calc.poly_trans2(S0,{poly}))\" , first = timezero , ordinal = 1 ) contribute = head_height - sensor_depth limit = 0 self . parameters . set ( 'quota falda' , cache = 'active' , mu = \"m.s.l.m.\" , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"battente\" ]}, operator = f \"calc.add(calc.threshold(S0, limit={limit}, how='<', action='clean'), {contribute})\" , ordinal = 0 )","title":"config"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#retrive","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#setup","text":"def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/","text":"Module hielen3.ext.feature_instrument_piezometer.feature View Source # coding=utf-8 from hielen3.feature import HFeature from hielen3.serializaction import ActionSchema , PolyCoeff , StringTime from hielen3.ext.feature_instrument import ConfigSchema , Feature from marshmallow import fields import traceback class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Instruments info\" :{ 0 :[ \"source_series\" , \"Reference raw series\" , False , None ], 1 :[ \"poly\" , \"polinomial coefficients array\" , False , None ], 2 :[ \"head_height\" , \"ground zero\" , False , None ], 3 :[ \"sensor_depth\" , \"sensor distance from the groud zero\" , False , None ], 4 :[ \"timezero\" , \"time of the zero reading\" , False , None ] } } source_series = fields . String ( required = False , allow_none = False ) poly = PolyCoeff ( default = [ 0 , 1 ], required = False , allow_none = True ) head_height = fields . Number ( default = 0.0 , required = False , allow_none = True ) sensor_depth = fields . Number ( default = 0.0 , required = False , allow_none = True ) timezero = StringTime ( required = False , allow_none = True ) class Feature ( HFeature ): ''' PIEZOMETER ''' def setup ( self , ** kwargs ): pass def config ( self , source_series = None , head_height = None , sensor_depth = None , poly = None , timezero = None , ** kwargs ): if not self . parameters . __len__ (): if head_height is None : head_height = 0 if sensor_depth is None : sensor_depth = 0 if poly is None : poly = \"\" if timezero is None : zero = 0 if source_series is not None and poly is not None : self . parameters . set ( 'battente' , cache = 'active' , mu = \"m\" , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : source_series }, operator = f \"calc.filter(calc.poly_trans2(S0, { poly } ))\" , first = timezero , ordinal = 1 ) contribute = head_height - sensor_depth limit = 0 self . parameters . set ( 'quota falda' , cache = 'active' , mu = \"m.s.l.m.\" , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"battente\" ]}, operator = f \"calc.add(calc.threshold(S0, limit= { limit } , how='<', action='clean'), { contribute } )\" , ordinal = 0 ) Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Instruments info\" :{ 0 :[ \"source_series\" , \"Reference raw series\" , False , None ], 1 :[ \"poly\" , \"polinomial coefficients array\" , False , None ], 2 :[ \"head_height\" , \"ground zero\" , False , None ], 3 :[ \"sensor_depth\" , \"sensor distance from the groud zero\" , False , None ], 4 :[ \"timezero\" , \"time of the zero reading\" , False , None ] } } source_series = fields . String ( required = False , allow_none = False ) poly = PolyCoeff ( default =[ 0 , 1 ], required = False , allow_none = True ) head_height = fields . Number ( default = 0.0 , required = False , allow_none = True ) sensor_depth = fields . Number ( default = 0.0 , required = False , allow_none = True ) timezero = StringTime ( required = False , allow_none = True ) Ancestors (in MRO) hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages head_height opts poly sensor_depth source_series timezero Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) PIEZOMETER View Source class Feature ( HFeature ): ''' PIEZOMETER ''' def setup ( self , ** kwargs ): pass def config ( self , source_series = None , head_height = None , sensor_depth = None , poly = None , timezero = None , ** kwargs ): if not self . parameters . __len__ (): if head_height is None : head_height = 0 if sensor_depth is None : sensor_depth = 0 if poly is None : poly = \"\" if timezero is None : zero = 0 if source_series is not None and poly is not None : self . parameters . set ( 'battente' , cache = 'active' , mu = \"m\" , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : source_series }, operator = f \"calc.filter(calc.poly_trans2(S0,{poly}))\" , first = timezero , ordinal = 1 ) contribute = head_height - sensor_depth limit = 0 self . parameters . set ( 'quota falda' , cache = 'active' , mu = \"m.s.l.m.\" , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"battente\" ]}, operator = f \"calc.add(calc.threshold(S0, limit={limit}, how='<', action='clean'), {contribute})\" , ordinal = 0 ) Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , source_series = None , head_height = None , sensor_depth = None , poly = None , timezero = None , ** kwargs ) View Source def config ( self , source_series = None , head_height = None , sensor_depth = None , poly = None , timezero = None , ** kwargs ): if not self . parameters . __len__ (): if head_height is None : head_height = 0 if sensor_depth is None : sensor_depth = 0 if poly is None : poly = \"\" if timezero is None : zero = 0 if source_series is not None and poly is not None : self . parameters . set ( 'battente' , cache = 'active' , mu = \"m\" , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : source_series }, operator = f \"calc.filter(calc.poly_trans2(S0,{poly}))\" , first = timezero , ordinal = 1 ) contribute = head_height - sensor_depth limit = 0 self . parameters . set ( 'quota falda' , cache = 'active' , mu = \"m.s.l.m.\" , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"battente\" ]}, operator = f \"calc.add(calc.threshold(S0, limit={limit}, how='<', action='clean'), {contribute})\" , ordinal = 0 ) create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Feature"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#module-hielen3extfeature_instrument_piezometerfeature","text":"View Source # coding=utf-8 from hielen3.feature import HFeature from hielen3.serializaction import ActionSchema , PolyCoeff , StringTime from hielen3.ext.feature_instrument import ConfigSchema , Feature from marshmallow import fields import traceback class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Instruments info\" :{ 0 :[ \"source_series\" , \"Reference raw series\" , False , None ], 1 :[ \"poly\" , \"polinomial coefficients array\" , False , None ], 2 :[ \"head_height\" , \"ground zero\" , False , None ], 3 :[ \"sensor_depth\" , \"sensor distance from the groud zero\" , False , None ], 4 :[ \"timezero\" , \"time of the zero reading\" , False , None ] } } source_series = fields . String ( required = False , allow_none = False ) poly = PolyCoeff ( default = [ 0 , 1 ], required = False , allow_none = True ) head_height = fields . Number ( default = 0.0 , required = False , allow_none = True ) sensor_depth = fields . Number ( default = 0.0 , required = False , allow_none = True ) timezero = StringTime ( required = False , allow_none = True ) class Feature ( HFeature ): ''' PIEZOMETER ''' def setup ( self , ** kwargs ): pass def config ( self , source_series = None , head_height = None , sensor_depth = None , poly = None , timezero = None , ** kwargs ): if not self . parameters . __len__ (): if head_height is None : head_height = 0 if sensor_depth is None : sensor_depth = 0 if poly is None : poly = \"\" if timezero is None : zero = 0 if source_series is not None and poly is not None : self . parameters . set ( 'battente' , cache = 'active' , mu = \"m\" , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : source_series }, operator = f \"calc.filter(calc.poly_trans2(S0, { poly } ))\" , first = timezero , ordinal = 1 ) contribute = head_height - sensor_depth limit = 0 self . parameters . set ( 'quota falda' , cache = 'active' , mu = \"m.s.l.m.\" , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"battente\" ]}, operator = f \"calc.add(calc.threshold(S0, limit= { limit } , how='<', action='clean'), { contribute } )\" , ordinal = 0 )","title":"Module hielen3.ext.feature_instrument_piezometer.feature"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Instruments info\" :{ 0 :[ \"source_series\" , \"Reference raw series\" , False , None ], 1 :[ \"poly\" , \"polinomial coefficients array\" , False , None ], 2 :[ \"head_height\" , \"ground zero\" , False , None ], 3 :[ \"sensor_depth\" , \"sensor distance from the groud zero\" , False , None ], 4 :[ \"timezero\" , \"time of the zero reading\" , False , None ] } } source_series = fields . String ( required = False , allow_none = False ) poly = PolyCoeff ( default =[ 0 , 1 ], required = False , allow_none = True ) head_height = fields . Number ( default = 0.0 , required = False , allow_none = True ) sensor_depth = fields . Number ( default = 0.0 , required = False , allow_none = True ) timezero = StringTime ( required = False , allow_none = True )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#ancestors-in-mro","text":"hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages head_height opts poly sensor_depth source_series timezero","title":"Class variables"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#feature","text":"class Feature ( feature ) PIEZOMETER View Source class Feature ( HFeature ): ''' PIEZOMETER ''' def setup ( self , ** kwargs ): pass def config ( self , source_series = None , head_height = None , sensor_depth = None , poly = None , timezero = None , ** kwargs ): if not self . parameters . __len__ (): if head_height is None : head_height = 0 if sensor_depth is None : sensor_depth = 0 if poly is None : poly = \"\" if timezero is None : zero = 0 if source_series is not None and poly is not None : self . parameters . set ( 'battente' , cache = 'active' , mu = \"m\" , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : source_series }, operator = f \"calc.filter(calc.poly_trans2(S0,{poly}))\" , first = timezero , ordinal = 1 ) contribute = head_height - sensor_depth limit = 0 self . parameters . set ( 'quota falda' , cache = 'active' , mu = \"m.s.l.m.\" , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"battente\" ]}, operator = f \"calc.add(calc.threshold(S0, limit={limit}, how='<', action='clean'), {contribute})\" , ordinal = 0 )","title":"Feature"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#config","text":"def config ( self , source_series = None , head_height = None , sensor_depth = None , poly = None , timezero = None , ** kwargs ) View Source def config ( self , source_series = None , head_height = None , sensor_depth = None , poly = None , timezero = None , ** kwargs ): if not self . parameters . __len__ (): if head_height is None : head_height = 0 if sensor_depth is None : sensor_depth = 0 if poly is None : poly = \"\" if timezero is None : zero = 0 if source_series is not None and poly is not None : self . parameters . set ( 'battente' , cache = 'active' , mu = \"m\" , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : source_series }, operator = f \"calc.filter(calc.poly_trans2(S0,{poly}))\" , first = timezero , ordinal = 1 ) contribute = head_height - sensor_depth limit = 0 self . parameters . set ( 'quota falda' , cache = 'active' , mu = \"m.s.l.m.\" , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"battente\" ]}, operator = f \"calc.add(calc.threshold(S0, limit={limit}, how='<', action='clean'), {contribute})\" , ordinal = 0 )","title":"config"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#retrive","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#setup","text":"def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_instrument_piezometer/feature/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_logger_boviar/","text":"Module hielen3.ext.feature_logger_boviar View Source # coding=utf-8 __name__ = \"feature_logger_gestecno\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from hielen3.ext.feature_datetree_filesystem_source import loggers , retriver from pandas import read_csv , DatetimeIndex , DataFrame from .logger import Feature , ConfigSchema __all__ = [ \"Feature\" , \"ConfigSchema\" ] Sub-modules hielen3.ext.feature_logger_boviar.helper hielen3.ext.feature_logger_boviar.logger Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): try: serials = list ( func_loggers ()[ 'name' ]) except Exception as e: serials =[] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header xlsx\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = LocalFile ( required = True , allow_none = False ) Ancestors (in MRO) hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Feature ( HFeature ): def setup ( self ,** kwargs ): pass def setpar ( self , module , serial , name , unit ): self . parameters . set ( name , cache = 'active' , mu = unit , modules ={ \"source\" : module }, operator = f \"source.retrive(serials={serial!r},times=times,columns={name!r})\" ) def config ( self , serial , header , ** kwargs ): module = str ( self . __module__ ) header = read_excel ( header , header = None , index_col = 0 ) header . apply ( lambda x : self . setpar (*[ module , serial ,* x ])) Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , serial , header , ** kwargs ) View Source def config(self, serial, header, **kwargs): module=str(self.__module__) header=read_excel(header,header=None,index_col=0) header.apply(lambda x: self.setpar(*[module,serial,*x])) create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setpar def setpar ( self , module , serial , name , unit ) View Source def setpar(self,module,serial,name,unit): self.parameters.set( name, cache='active', mu=unit, modules={\"source\":module}, operator=f\"source.retrive(serials={serial!r},times=times,columns={name!r})\") setup def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Index"},{"location":"reference/hielen3/ext/feature_logger_boviar/#module-hielen3extfeature_logger_boviar","text":"View Source # coding=utf-8 __name__ = \"feature_logger_gestecno\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from hielen3.ext.feature_datetree_filesystem_source import loggers , retriver from pandas import read_csv , DatetimeIndex , DataFrame from .logger import Feature , ConfigSchema __all__ = [ \"Feature\" , \"ConfigSchema\" ]","title":"Module hielen3.ext.feature_logger_boviar"},{"location":"reference/hielen3/ext/feature_logger_boviar/#sub-modules","text":"hielen3.ext.feature_logger_boviar.helper hielen3.ext.feature_logger_boviar.logger","title":"Sub-modules"},{"location":"reference/hielen3/ext/feature_logger_boviar/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_logger_boviar/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): try: serials = list ( func_loggers ()[ 'name' ]) except Exception as e: serials =[] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header xlsx\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = LocalFile ( required = True , allow_none = False )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_logger_boviar/#ancestors-in-mro","text":"hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_boviar/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial","title":"Class variables"},{"location":"reference/hielen3/ext/feature_logger_boviar/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_logger_boviar/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_logger_boviar/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_boviar/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_boviar/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_logger_boviar/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_logger_boviar/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_logger_boviar/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_logger_boviar/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_logger_boviar/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_logger_boviar/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_logger_boviar/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_logger_boviar/#feature","text":"class Feature ( feature ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Feature ( HFeature ): def setup ( self ,** kwargs ): pass def setpar ( self , module , serial , name , unit ): self . parameters . set ( name , cache = 'active' , mu = unit , modules ={ \"source\" : module }, operator = f \"source.retrive(serials={serial!r},times=times,columns={name!r})\" ) def config ( self , serial , header , ** kwargs ): module = str ( self . __module__ ) header = read_excel ( header , header = None , index_col = 0 ) header . apply ( lambda x : self . setpar (*[ module , serial ,* x ]))","title":"Feature"},{"location":"reference/hielen3/ext/feature_logger_boviar/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_boviar/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_boviar/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_boviar/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_logger_boviar/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_logger_boviar/#config","text":"def config ( self , serial , header , ** kwargs ) View Source def config(self, serial, header, **kwargs): module=str(self.__module__) header=read_excel(header,header=None,index_col=0) header.apply(lambda x: self.setpar(*[module,serial,*x]))","title":"config"},{"location":"reference/hielen3/ext/feature_logger_boviar/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_logger_boviar/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_logger_boviar/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_logger_boviar/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_logger_boviar/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_logger_boviar/#retrive","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_logger_boviar/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_logger_boviar/#setpar","text":"def setpar ( self , module , serial , name , unit ) View Source def setpar(self,module,serial,name,unit): self.parameters.set( name, cache='active', mu=unit, modules={\"source\":module}, operator=f\"source.retrive(serials={serial!r},times=times,columns={name!r})\")","title":"setpar"},{"location":"reference/hielen3/ext/feature_logger_boviar/#setup","text":"def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_logger_boviar/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_logger_boviar/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_logger_boviar/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_logger_boviar/helper/","text":"Module hielen3.ext.feature_logger_boviar.helper View Source # coding=utf-8 from hielen3.ext.feature_datetree_filesystem_source import loggers , retriver from pandas import read_csv , DataFrame from pandas.errors import EmptyDataError folders = [ { 'type' : 'boviar' , 'path' : 'boviar' } ] func_loggers = loggers ( folders ) @retriver ( func_loggers ) def retrive ( path ): a = DataFrame ([], dtype = 'float64' ) try : a = read_csv ( path , sep = ';' , skiprows = 14 , header = None , parse_dates = [ 0 ], dayfirst = True , index_col = [ 0 ]) a . columns = map ( lambda x : x . replace ( \" \" , \"_\" ) . replace ( \"+5V\" , \"p5V\" ), read_csv ( path , sep = ';' , skiprows = 11 , nrows = 1 , header = None , index_col = 0 ) . T . squeeze () . values ) a . index . name = 'times' a = a . reset_index () except EmptyDataError as e : pass except Exception as e : raise e pass return a Variables folders Functions func_loggers def func_loggers ( ) View Source def inner () : return logger_serials ( folders ) loggers def loggers ( folders ) View Source def loggers ( folders ) : def inner () : return logger_serials ( folders ) return inner retrive def retrive ( * args , ** kwargs ) View Source def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs ) retriver def retriver ( func_loggers ) View Source def retriver ( func_loggers ) : def wrap ( func_extract ) : def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs ) return inner return wrap","title":"Helper"},{"location":"reference/hielen3/ext/feature_logger_boviar/helper/#module-hielen3extfeature_logger_boviarhelper","text":"View Source # coding=utf-8 from hielen3.ext.feature_datetree_filesystem_source import loggers , retriver from pandas import read_csv , DataFrame from pandas.errors import EmptyDataError folders = [ { 'type' : 'boviar' , 'path' : 'boviar' } ] func_loggers = loggers ( folders ) @retriver ( func_loggers ) def retrive ( path ): a = DataFrame ([], dtype = 'float64' ) try : a = read_csv ( path , sep = ';' , skiprows = 14 , header = None , parse_dates = [ 0 ], dayfirst = True , index_col = [ 0 ]) a . columns = map ( lambda x : x . replace ( \" \" , \"_\" ) . replace ( \"+5V\" , \"p5V\" ), read_csv ( path , sep = ';' , skiprows = 11 , nrows = 1 , header = None , index_col = 0 ) . T . squeeze () . values ) a . index . name = 'times' a = a . reset_index () except EmptyDataError as e : pass except Exception as e : raise e pass return a","title":"Module hielen3.ext.feature_logger_boviar.helper"},{"location":"reference/hielen3/ext/feature_logger_boviar/helper/#variables","text":"folders","title":"Variables"},{"location":"reference/hielen3/ext/feature_logger_boviar/helper/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/ext/feature_logger_boviar/helper/#func_loggers","text":"def func_loggers ( ) View Source def inner () : return logger_serials ( folders )","title":"func_loggers"},{"location":"reference/hielen3/ext/feature_logger_boviar/helper/#loggers","text":"def loggers ( folders ) View Source def loggers ( folders ) : def inner () : return logger_serials ( folders ) return inner","title":"loggers"},{"location":"reference/hielen3/ext/feature_logger_boviar/helper/#retrive","text":"def retrive ( * args , ** kwargs ) View Source def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs )","title":"retrive"},{"location":"reference/hielen3/ext/feature_logger_boviar/helper/#retriver","text":"def retriver ( func_loggers ) View Source def retriver ( func_loggers ) : def wrap ( func_extract ) : def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs ) return inner return wrap","title":"retriver"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/","text":"Module hielen3.ext.feature_logger_boviar.logger View Source # coding=utf-8 from hielen3.feature import HFeature from hielen3.serializaction import ActionSchema , LocalFile from marshmallow import fields from pandas import read_excel from .helper import func_loggers , retrive import traceback class ConfigSchema ( ActionSchema ): def _self_hints_ (): try : serials = list ( func_loggers ()[ 'name' ]) except Exception as e : serials = [] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header xlsx\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = LocalFile ( required = True , allow_none = False ) class Feature ( HFeature ): def setup ( self , ** kwargs ): pass def setpar ( self , module , serial , name , unit ): self . parameters . set ( name , cache = 'active' , mu = unit , modules = { \"source\" : module }, operator = f \"source.retrive(serials= { serial !r} ,times=times,columns= { name !r} )\" ) def config ( self , serial , header , ** kwargs ): module = str ( self . __module__ ) header = read_excel ( header , header = None , index_col = 0 ) header . apply ( lambda x : self . setpar ( * [ module , serial , * x ])) Functions func_loggers def func_loggers ( ) View Source def inner () : return logger_serials ( folders ) retrive def retrive ( * args , ** kwargs ) View Source def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs ) Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): try: serials = list ( func_loggers ()[ 'name' ]) except Exception as e: serials =[] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header xlsx\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = LocalFile ( required = True , allow_none = False ) Ancestors (in MRO) hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Feature ( HFeature ): def setup ( self ,** kwargs ): pass def setpar ( self , module , serial , name , unit ): self . parameters . set ( name , cache = 'active' , mu = unit , modules ={ \"source\" : module }, operator = f \"source.retrive(serials={serial!r},times=times,columns={name!r})\" ) def config ( self , serial , header , ** kwargs ): module = str ( self . __module__ ) header = read_excel ( header , header = None , index_col = 0 ) header . apply ( lambda x : self . setpar (*[ module , serial ,* x ])) Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , serial , header , ** kwargs ) View Source def config(self, serial, header, **kwargs): module=str(self.__module__) header=read_excel(header,header=None,index_col=0) header.apply(lambda x: self.setpar(*[module,serial,*x])) create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setpar def setpar ( self , module , serial , name , unit ) View Source def setpar(self,module,serial,name,unit): self.parameters.set( name, cache='active', mu=unit, modules={\"source\":module}, operator=f\"source.retrive(serials={serial!r},times=times,columns={name!r})\") setup def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Logger"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#module-hielen3extfeature_logger_boviarlogger","text":"View Source # coding=utf-8 from hielen3.feature import HFeature from hielen3.serializaction import ActionSchema , LocalFile from marshmallow import fields from pandas import read_excel from .helper import func_loggers , retrive import traceback class ConfigSchema ( ActionSchema ): def _self_hints_ (): try : serials = list ( func_loggers ()[ 'name' ]) except Exception as e : serials = [] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header xlsx\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = LocalFile ( required = True , allow_none = False ) class Feature ( HFeature ): def setup ( self , ** kwargs ): pass def setpar ( self , module , serial , name , unit ): self . parameters . set ( name , cache = 'active' , mu = unit , modules = { \"source\" : module }, operator = f \"source.retrive(serials= { serial !r} ,times=times,columns= { name !r} )\" ) def config ( self , serial , header , ** kwargs ): module = str ( self . __module__ ) header = read_excel ( header , header = None , index_col = 0 ) header . apply ( lambda x : self . setpar ( * [ module , serial , * x ]))","title":"Module hielen3.ext.feature_logger_boviar.logger"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#func_loggers","text":"def func_loggers ( ) View Source def inner () : return logger_serials ( folders )","title":"func_loggers"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#retrive","text":"def retrive ( * args , ** kwargs ) View Source def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs )","title":"retrive"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): try: serials = list ( func_loggers ()[ 'name' ]) except Exception as e: serials =[] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header xlsx\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = LocalFile ( required = True , allow_none = False )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#ancestors-in-mro","text":"hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial","title":"Class variables"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#feature","text":"class Feature ( feature ) Helper class that provides a standard way to create an ABC using inheritance. View Source class Feature ( HFeature ): def setup ( self ,** kwargs ): pass def setpar ( self , module , serial , name , unit ): self . parameters . set ( name , cache = 'active' , mu = unit , modules ={ \"source\" : module }, operator = f \"source.retrive(serials={serial!r},times=times,columns={name!r})\" ) def config ( self , serial , header , ** kwargs ): module = str ( self . __module__ ) header = read_excel ( header , header = None , index_col = 0 ) header . apply ( lambda x : self . setpar (*[ module , serial ,* x ]))","title":"Feature"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#config","text":"def config ( self , serial , header , ** kwargs ) View Source def config(self, serial, header, **kwargs): module=str(self.__module__) header=read_excel(header,header=None,index_col=0) header.apply(lambda x: self.setpar(*[module,serial,*x]))","title":"config"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#retrive_1","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#setpar","text":"def setpar ( self , module , serial , name , unit ) View Source def setpar(self,module,serial,name,unit): self.parameters.set( name, cache='active', mu=unit, modules={\"source\":module}, operator=f\"source.retrive(serials={serial!r},times=times,columns={name!r})\")","title":"setpar"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#setup","text":"def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_logger_boviar/logger/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_logger_capetti/","text":"Module hielen3.ext.feature_logger_capetti View Source # coding=utf-8 __name__ = \"feature_logger_capetti\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from hielen3.ext.feature_datetree_filesystem_source import loggers , retriver from pandas import read_csv , DatetimeIndex , DataFrame from .logger import Feature , ConfigSchema __all__ = [ \"Feature\" , \"ConfigSchema\" ] Sub-modules hielen3.ext.feature_logger_capetti.helper hielen3.ext.feature_logger_capetti.logger Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): try: serials = list ( func_loggers ()[ 'name' ]) except Exception as e: serials =[] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) Ancestors (in MRO) hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\" Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , timestamp , serial , header = None , ** kwargs ) header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\" : \"nomechannelN\" , \"mu\" : \"measurement_unitN\" , \"column\" : # N , \"valid_range\" : [ start , end ] } ] View Source def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\" create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Index"},{"location":"reference/hielen3/ext/feature_logger_capetti/#module-hielen3extfeature_logger_capetti","text":"View Source # coding=utf-8 __name__ = \"feature_logger_capetti\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from hielen3.ext.feature_datetree_filesystem_source import loggers , retriver from pandas import read_csv , DatetimeIndex , DataFrame from .logger import Feature , ConfigSchema __all__ = [ \"Feature\" , \"ConfigSchema\" ]","title":"Module hielen3.ext.feature_logger_capetti"},{"location":"reference/hielen3/ext/feature_logger_capetti/#sub-modules","text":"hielen3.ext.feature_logger_capetti.helper hielen3.ext.feature_logger_capetti.logger","title":"Sub-modules"},{"location":"reference/hielen3/ext/feature_logger_capetti/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_logger_capetti/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): try: serials = list ( func_loggers ()[ 'name' ]) except Exception as e: serials =[] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_logger_capetti/#ancestors-in-mro","text":"hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_capetti/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial","title":"Class variables"},{"location":"reference/hielen3/ext/feature_logger_capetti/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_logger_capetti/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_logger_capetti/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_capetti/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_capetti/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_logger_capetti/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_logger_capetti/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_logger_capetti/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_logger_capetti/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_logger_capetti/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_logger_capetti/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_logger_capetti/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_logger_capetti/#feature","text":"class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\"","title":"Feature"},{"location":"reference/hielen3/ext/feature_logger_capetti/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_capetti/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_capetti/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_capetti/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_logger_capetti/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_logger_capetti/#config","text":"def config ( self , timestamp , serial , header = None , ** kwargs ) header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\" : \"nomechannelN\" , \"mu\" : \"measurement_unitN\" , \"column\" : # N , \"valid_range\" : [ start , end ] } ] View Source def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\"","title":"config"},{"location":"reference/hielen3/ext/feature_logger_capetti/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_logger_capetti/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_logger_capetti/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_logger_capetti/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_logger_capetti/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_logger_capetti/#retrive","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_logger_capetti/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_logger_capetti/#setup","text":"def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_logger_capetti/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_logger_capetti/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_logger_capetti/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_logger_capetti/helper/","text":"Module hielen3.ext.feature_logger_capetti.helper View Source # coding=utf-8 from hielen3.ext.feature_datetree_filesystem_source import loggers , retriver from pandas import read_csv , DataFrame , to_datetime from numpy import isin folders = [ { 'type' : 'capetti' , 'path' : 'capetti' } ] func_loggers = loggers ( folders ) @retriver ( func_loggers ) def retrive ( path ): a = DataFrame ([], dtype = 'float64' ) try : a = read_csv ( path , sep = ' \\t ' , skiprows = 3 , header = None , index_col = [ 0 ]) . iloc [:, 4 :: 3 ] a = a [ ~ isin ( a . index , \"LOCAL TIME\" )] a . index = to_datetime ( a . index , format = 'ISO8601' ) a = a . astype ( 'float' ) a . index . name = 'times' a . columns = list ( range ( 1 , a . columns . __len__ () + 1 )) a = a . reset_index () #a.columns = [ 'times', *a.columns[1:] ] except Exception as e : #print(\"WARN : \", path) #raise e #DEBUG a = DataFrame ([], dtype = 'float64' ) pass return a Variables folders Functions func_loggers def func_loggers ( ) View Source def inner () : return logger_serials ( folders ) loggers def loggers ( folders ) View Source def loggers ( folders ) : def inner () : return logger_serials ( folders ) return inner retrive def retrive ( * args , ** kwargs ) View Source def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs ) retriver def retriver ( func_loggers ) View Source def retriver ( func_loggers ) : def wrap ( func_extract ) : def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs ) return inner return wrap","title":"Helper"},{"location":"reference/hielen3/ext/feature_logger_capetti/helper/#module-hielen3extfeature_logger_capettihelper","text":"View Source # coding=utf-8 from hielen3.ext.feature_datetree_filesystem_source import loggers , retriver from pandas import read_csv , DataFrame , to_datetime from numpy import isin folders = [ { 'type' : 'capetti' , 'path' : 'capetti' } ] func_loggers = loggers ( folders ) @retriver ( func_loggers ) def retrive ( path ): a = DataFrame ([], dtype = 'float64' ) try : a = read_csv ( path , sep = ' \\t ' , skiprows = 3 , header = None , index_col = [ 0 ]) . iloc [:, 4 :: 3 ] a = a [ ~ isin ( a . index , \"LOCAL TIME\" )] a . index = to_datetime ( a . index , format = 'ISO8601' ) a = a . astype ( 'float' ) a . index . name = 'times' a . columns = list ( range ( 1 , a . columns . __len__ () + 1 )) a = a . reset_index () #a.columns = [ 'times', *a.columns[1:] ] except Exception as e : #print(\"WARN : \", path) #raise e #DEBUG a = DataFrame ([], dtype = 'float64' ) pass return a","title":"Module hielen3.ext.feature_logger_capetti.helper"},{"location":"reference/hielen3/ext/feature_logger_capetti/helper/#variables","text":"folders","title":"Variables"},{"location":"reference/hielen3/ext/feature_logger_capetti/helper/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/ext/feature_logger_capetti/helper/#func_loggers","text":"def func_loggers ( ) View Source def inner () : return logger_serials ( folders )","title":"func_loggers"},{"location":"reference/hielen3/ext/feature_logger_capetti/helper/#loggers","text":"def loggers ( folders ) View Source def loggers ( folders ) : def inner () : return logger_serials ( folders ) return inner","title":"loggers"},{"location":"reference/hielen3/ext/feature_logger_capetti/helper/#retrive","text":"def retrive ( * args , ** kwargs ) View Source def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs )","title":"retrive"},{"location":"reference/hielen3/ext/feature_logger_capetti/helper/#retriver","text":"def retriver ( func_loggers ) View Source def retriver ( func_loggers ) : def wrap ( func_extract ) : def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs ) return inner return wrap","title":"retriver"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/","text":"Module hielen3.ext.feature_logger_capetti.logger View Source # coding=utf-8 from hielen3 import conf from hielen3.feature import HFeature from hielen3.serializaction import ActionSchema from marshmallow import fields from pathlib import Path from .helper import func_loggers , retrive import json import traceback class ConfigSchema ( ActionSchema ): def _self_hints_ (): try : serials = list ( func_loggers ()[ 'name' ]) except Exception as e : serials = [] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\" Variables conf Functions func_loggers def func_loggers ( ) View Source def inner () : return logger_serials ( folders ) retrive def retrive ( * args , ** kwargs ) View Source def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs ) Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): try: serials = list ( func_loggers ()[ 'name' ]) except Exception as e: serials =[] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) Ancestors (in MRO) hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\" Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , timestamp , serial , header = None , ** kwargs ) header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\" : \"nomechannelN\" , \"mu\" : \"measurement_unitN\" , \"column\" : # N , \"valid_range\" : [ start , end ] } ] View Source def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\" create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Logger"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#module-hielen3extfeature_logger_capettilogger","text":"View Source # coding=utf-8 from hielen3 import conf from hielen3.feature import HFeature from hielen3.serializaction import ActionSchema from marshmallow import fields from pathlib import Path from .helper import func_loggers , retrive import json import traceback class ConfigSchema ( ActionSchema ): def _self_hints_ (): try : serials = list ( func_loggers ()[ 'name' ]) except Exception as e : serials = [] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\"","title":"Module hielen3.ext.feature_logger_capetti.logger"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#variables","text":"conf","title":"Variables"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#func_loggers","text":"def func_loggers ( ) View Source def inner () : return logger_serials ( folders )","title":"func_loggers"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#retrive","text":"def retrive ( * args , ** kwargs ) View Source def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs )","title":"retrive"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): try: serials = list ( func_loggers ()[ 'name' ]) except Exception as e: serials =[] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#ancestors-in-mro","text":"hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial","title":"Class variables"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#feature","text":"class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\"","title":"Feature"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#config","text":"def config ( self , timestamp , serial , header = None , ** kwargs ) header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\" : \"nomechannelN\" , \"mu\" : \"measurement_unitN\" , \"column\" : # N , \"valid_range\" : [ start , end ] } ] View Source def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\"","title":"config"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#retrive_1","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#setup","text":"def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_logger_capetti/logger/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_logger_gestecno/","text":"Module hielen3.ext.feature_logger_gestecno View Source # coding=utf-8 __name__ = \"feature_logger_gestecno\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from hielen3.ext.feature_datetree_filesystem_source import loggers , retriver from pandas import read_csv , DatetimeIndex , DataFrame from .logger import Feature , ConfigSchema __all__ = [ \"Feature\" , \"ConfigSchema\" ] Sub-modules hielen3.ext.feature_logger_gestecno.helper hielen3.ext.feature_logger_gestecno.logger Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): try: serials = list ( func_loggers ()[ 'name' ]) except Exception as e: serials =[] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) Ancestors (in MRO) hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\" Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , timestamp , serial , header = None , ** kwargs ) header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\" : \"nomechannelN\" , \"mu\" : \"measurement_unitN\" , \"column\" : # N , \"valid_range\" : [ start , end ] } ] View Source def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\" create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Index"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#module-hielen3extfeature_logger_gestecno","text":"View Source # coding=utf-8 __name__ = \"feature_logger_gestecno\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from hielen3.ext.feature_datetree_filesystem_source import loggers , retriver from pandas import read_csv , DatetimeIndex , DataFrame from .logger import Feature , ConfigSchema __all__ = [ \"Feature\" , \"ConfigSchema\" ]","title":"Module hielen3.ext.feature_logger_gestecno"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#sub-modules","text":"hielen3.ext.feature_logger_gestecno.helper hielen3.ext.feature_logger_gestecno.logger","title":"Sub-modules"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): try: serials = list ( func_loggers ()[ 'name' ]) except Exception as e: serials =[] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#ancestors-in-mro","text":"hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial","title":"Class variables"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#feature","text":"class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\"","title":"Feature"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#config","text":"def config ( self , timestamp , serial , header = None , ** kwargs ) header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\" : \"nomechannelN\" , \"mu\" : \"measurement_unitN\" , \"column\" : # N , \"valid_range\" : [ start , end ] } ] View Source def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\"","title":"config"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#retrive","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#setup","text":"def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_logger_gestecno/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_logger_gestecno/helper/","text":"Module hielen3.ext.feature_logger_gestecno.helper View Source # coding=utf-8 from hielen3.ext.feature_datetree_filesystem_source import loggers , retriver from pandas import read_csv , DataFrame folders = [ { 'type' : 'gestecno' , 'path' : 'gestecno_rfi/data' }, { 'type' : 'gestecno' , 'path' : 'gestecno_saa/diag' }, { 'type' : 'gestecno' , 'path' : 'gestecno' } ] func_loggers = loggers ( folders ) @retriver ( func_loggers ) def retrive ( path ): a = DataFrame ([], dtype = 'float64' ) try : try : a = read_csv ( path , skiprows = 2 , parse_dates = [ 0 ], header = None ) if a . empty : a = read_csv ( path , parse_dates = [ 0 ], header = None ) a = a [ a [ 0 ] . apply ( lambda x : match ( '^\\d {4} -\\d {2} ' , x )) . notna ()] except UnicodeDecodeError as e : a = read_csv ( path , skiprows = 3 , parse_dates = [ 0 ], dayfirst = True , sep = \";\" , header = None , encoding = 'latin1' ) a . columns = [ 'times' , * a . columns [ 1 :] ] except Exception as e : #print(\"WARN : \", path) #raise e #DEBUG pass return a Variables folders Functions func_loggers def func_loggers ( ) View Source def inner () : return logger_serials ( folders ) loggers def loggers ( folders ) View Source def loggers ( folders ) : def inner () : return logger_serials ( folders ) return inner retrive def retrive ( * args , ** kwargs ) View Source def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs ) retriver def retriver ( func_loggers ) View Source def retriver ( func_loggers ) : def wrap ( func_extract ) : def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs ) return inner return wrap","title":"Helper"},{"location":"reference/hielen3/ext/feature_logger_gestecno/helper/#module-hielen3extfeature_logger_gestecnohelper","text":"View Source # coding=utf-8 from hielen3.ext.feature_datetree_filesystem_source import loggers , retriver from pandas import read_csv , DataFrame folders = [ { 'type' : 'gestecno' , 'path' : 'gestecno_rfi/data' }, { 'type' : 'gestecno' , 'path' : 'gestecno_saa/diag' }, { 'type' : 'gestecno' , 'path' : 'gestecno' } ] func_loggers = loggers ( folders ) @retriver ( func_loggers ) def retrive ( path ): a = DataFrame ([], dtype = 'float64' ) try : try : a = read_csv ( path , skiprows = 2 , parse_dates = [ 0 ], header = None ) if a . empty : a = read_csv ( path , parse_dates = [ 0 ], header = None ) a = a [ a [ 0 ] . apply ( lambda x : match ( '^\\d {4} -\\d {2} ' , x )) . notna ()] except UnicodeDecodeError as e : a = read_csv ( path , skiprows = 3 , parse_dates = [ 0 ], dayfirst = True , sep = \";\" , header = None , encoding = 'latin1' ) a . columns = [ 'times' , * a . columns [ 1 :] ] except Exception as e : #print(\"WARN : \", path) #raise e #DEBUG pass return a","title":"Module hielen3.ext.feature_logger_gestecno.helper"},{"location":"reference/hielen3/ext/feature_logger_gestecno/helper/#variables","text":"folders","title":"Variables"},{"location":"reference/hielen3/ext/feature_logger_gestecno/helper/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/ext/feature_logger_gestecno/helper/#func_loggers","text":"def func_loggers ( ) View Source def inner () : return logger_serials ( folders )","title":"func_loggers"},{"location":"reference/hielen3/ext/feature_logger_gestecno/helper/#loggers","text":"def loggers ( folders ) View Source def loggers ( folders ) : def inner () : return logger_serials ( folders ) return inner","title":"loggers"},{"location":"reference/hielen3/ext/feature_logger_gestecno/helper/#retrive","text":"def retrive ( * args , ** kwargs ) View Source def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs )","title":"retrive"},{"location":"reference/hielen3/ext/feature_logger_gestecno/helper/#retriver","text":"def retriver ( func_loggers ) View Source def retriver ( func_loggers ) : def wrap ( func_extract ) : def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs ) return inner return wrap","title":"retriver"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/","text":"Module hielen3.ext.feature_logger_gestecno.logger View Source # coding=utf-8 from hielen3 import conf from hielen3.feature import HFeature from hielen3.serializaction import ActionSchema from marshmallow import fields from pathlib import Path from .helper import func_loggers , retrive import json import traceback class ConfigSchema ( ActionSchema ): def _self_hints_ (): try : serials = list ( func_loggers ()[ 'name' ]) except Exception as e : serials = [] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\" Variables conf Functions func_loggers def func_loggers ( ) View Source def inner () : return logger_serials ( folders ) retrive def retrive ( * args , ** kwargs ) View Source def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs ) Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): try: serials = list ( func_loggers ()[ 'name' ]) except Exception as e: serials =[] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) Ancestors (in MRO) hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\" Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , timestamp , serial , header = None , ** kwargs ) header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\" : \"nomechannelN\" , \"mu\" : \"measurement_unitN\" , \"column\" : # N , \"valid_range\" : [ start , end ] } ] View Source def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\" create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Logger"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#module-hielen3extfeature_logger_gestecnologger","text":"View Source # coding=utf-8 from hielen3 import conf from hielen3.feature import HFeature from hielen3.serializaction import ActionSchema from marshmallow import fields from pathlib import Path from .helper import func_loggers , retrive import json import traceback class ConfigSchema ( ActionSchema ): def _self_hints_ (): try : serials = list ( func_loggers ()[ 'name' ]) except Exception as e : serials = [] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\"","title":"Module hielen3.ext.feature_logger_gestecno.logger"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#variables","text":"conf","title":"Variables"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#func_loggers","text":"def func_loggers ( ) View Source def inner () : return logger_serials ( folders )","title":"func_loggers"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#retrive","text":"def retrive ( * args , ** kwargs ) View Source def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs )","title":"retrive"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): try: serials = list ( func_loggers ()[ 'name' ]) except Exception as e: serials =[] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#ancestors-in-mro","text":"hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial","title":"Class variables"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#feature","text":"class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\"","title":"Feature"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#config","text":"def config ( self , timestamp , serial , header = None , ** kwargs ) header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\" : \"nomechannelN\" , \"mu\" : \"measurement_unitN\" , \"column\" : # N , \"valid_range\" : [ start , end ] } ] View Source def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\"","title":"config"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#retrive_1","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#setup","text":"def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_logger_gestecno/logger/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_logger_move/","text":"Module hielen3.ext.feature_logger_move View Source # coding=utf-8 __name__ = \"feature_logger_move\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from hielen3.ext.feature_datetree_filesystem_source import loggers from .logger import Feature , ConfigSchema __all__ = [ \"Feature\" , \"ConfigSchema\" ] Sub-modules hielen3.ext.feature_logger_move.helper hielen3.ext.feature_logger_move.logger Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): try: serials = list ( func_loggers ()[ 'name' ]) except Exception as e: serials =[] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) Ancestors (in MRO) hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , timestamp , serial , header = None , ** kwargs ) header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\" : \"nomechannelN\" , \"mu\" : \"measurement_unitN\" , \"column\" : # N , \"valid_range\" : [ start , end ] } ] View Source def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Index"},{"location":"reference/hielen3/ext/feature_logger_move/#module-hielen3extfeature_logger_move","text":"View Source # coding=utf-8 __name__ = \"feature_logger_move\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from hielen3.ext.feature_datetree_filesystem_source import loggers from .logger import Feature , ConfigSchema __all__ = [ \"Feature\" , \"ConfigSchema\" ]","title":"Module hielen3.ext.feature_logger_move"},{"location":"reference/hielen3/ext/feature_logger_move/#sub-modules","text":"hielen3.ext.feature_logger_move.helper hielen3.ext.feature_logger_move.logger","title":"Sub-modules"},{"location":"reference/hielen3/ext/feature_logger_move/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_logger_move/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): try: serials = list ( func_loggers ()[ 'name' ]) except Exception as e: serials =[] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_logger_move/#ancestors-in-mro","text":"hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_move/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial","title":"Class variables"},{"location":"reference/hielen3/ext/feature_logger_move/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_logger_move/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_logger_move/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_move/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_move/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_logger_move/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_logger_move/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_logger_move/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_logger_move/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_logger_move/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_logger_move/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_logger_move/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_logger_move/#feature","text":"class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] )","title":"Feature"},{"location":"reference/hielen3/ext/feature_logger_move/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_move/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_move/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_move/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_logger_move/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_logger_move/#config","text":"def config ( self , timestamp , serial , header = None , ** kwargs ) header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\" : \"nomechannelN\" , \"mu\" : \"measurement_unitN\" , \"column\" : # N , \"valid_range\" : [ start , end ] } ] View Source def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] )","title":"config"},{"location":"reference/hielen3/ext/feature_logger_move/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_logger_move/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_logger_move/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_logger_move/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_logger_move/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_logger_move/#retrive","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_logger_move/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_logger_move/#setup","text":"def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_logger_move/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_logger_move/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_logger_move/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_logger_move/helper/","text":"Module hielen3.ext.feature_logger_move.helper View Source # coding=utf-8 from hielen3.ext.feature_datetree_filesystem_source import loggers , retriver from pandas import read_csv , DataFrame , to_datetime from numpy import isin folders = [ { 'type' : 'move' , 'path' : 'move' } ] func_loggers = loggers ( folders ) ''' @retriver(func_loggers) def retrive(path): a=DataFrame([],dtype='float64') try: a=read_csv(path, sep='\\t', skiprows=3,header=None,index_col=[0]).iloc[:,4::3] a=a[~isin(a.index,\"LOCAL TIME\")] a.index=to_datetime(a.index,format='ISO8601') a=a.astype('float') a.index.name='times' a.columns=list(range(1,a.columns.__len__()+1)) a=a.reset_index() #a.columns = [ 'times', *a.columns[1:] ] except Exception as e: #print(\"WARN : \", path) #raise e #DEBUG a=DataFrame([],dtype='float64') pass return a ''' Variables folders Functions func_loggers def func_loggers ( ) View Source def inner () : return logger_serials ( folders ) loggers def loggers ( folders ) View Source def loggers ( folders ) : def inner () : return logger_serials ( folders ) return inner retriver def retriver ( func_loggers ) View Source def retriver ( func_loggers ) : def wrap ( func_extract ) : def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs ) return inner return wrap","title":"Helper"},{"location":"reference/hielen3/ext/feature_logger_move/helper/#module-hielen3extfeature_logger_movehelper","text":"View Source # coding=utf-8 from hielen3.ext.feature_datetree_filesystem_source import loggers , retriver from pandas import read_csv , DataFrame , to_datetime from numpy import isin folders = [ { 'type' : 'move' , 'path' : 'move' } ] func_loggers = loggers ( folders ) ''' @retriver(func_loggers) def retrive(path): a=DataFrame([],dtype='float64') try: a=read_csv(path, sep='\\t', skiprows=3,header=None,index_col=[0]).iloc[:,4::3] a=a[~isin(a.index,\"LOCAL TIME\")] a.index=to_datetime(a.index,format='ISO8601') a=a.astype('float') a.index.name='times' a.columns=list(range(1,a.columns.__len__()+1)) a=a.reset_index() #a.columns = [ 'times', *a.columns[1:] ] except Exception as e: #print(\"WARN : \", path) #raise e #DEBUG a=DataFrame([],dtype='float64') pass return a '''","title":"Module hielen3.ext.feature_logger_move.helper"},{"location":"reference/hielen3/ext/feature_logger_move/helper/#variables","text":"folders","title":"Variables"},{"location":"reference/hielen3/ext/feature_logger_move/helper/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/ext/feature_logger_move/helper/#func_loggers","text":"def func_loggers ( ) View Source def inner () : return logger_serials ( folders )","title":"func_loggers"},{"location":"reference/hielen3/ext/feature_logger_move/helper/#loggers","text":"def loggers ( folders ) View Source def loggers ( folders ) : def inner () : return logger_serials ( folders ) return inner","title":"loggers"},{"location":"reference/hielen3/ext/feature_logger_move/helper/#retriver","text":"def retriver ( func_loggers ) View Source def retriver ( func_loggers ) : def wrap ( func_extract ) : def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs ) return inner return wrap","title":"retriver"},{"location":"reference/hielen3/ext/feature_logger_move/logger/","text":"Module hielen3.ext.feature_logger_move.logger View Source # coding=utf-8 from hielen3 import conf from hielen3.feature import HFeature from hielen3.serializaction import ActionSchema from marshmallow import fields from pathlib import Path from pandas import read_csv , DatetimeIndex , Series #from .helper import func_loggers, retrive import json import re import traceback class ConfigSchema ( ActionSchema ): def _self_hints_ (): try : serials = list ( func_loggers ()[ 'name' ]) except Exception as e : serials = [] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) def retrive ( serials = None , times = None , columns = None , ** kwargs ): loggerpath = Path ( conf [ 'incomepath' ], 'move' , serials , 'last_load.csv' ) data = read_csv ( loggerpath ) data . index = Series ( data [ 'timestamp' ]) . astype ( str ) . apply ( lambda x : re . sub ( '.000Z$' , '' , x )) data . drop ( 'timestamp' , axis = 1 ) if not isinstance ( times , slice ): times = slice ( None , None , None ) return data [ times ][ columns ] Variables conf Functions retrive def retrive ( serials = None , times = None , columns = None , ** kwargs ) View Source def retrive ( serials = None , times = None , columns = None , ** kwargs ) : loggerpath = Path ( conf [ 'incomepath' ] , 'move' , serials , 'last_load.csv' ) data = read_csv ( loggerpath ) data . index = Series ( data [ 'timestamp' ] ). astype ( str ). apply ( lambda x : re . sub ( '.000Z$' , '' , x )) data . drop ( 'timestamp' , axis = 1 ) if not isinstance ( times , slice ) : times = slice ( None , None , None ) return data [ times ][ columns ] Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): try: serials = list ( func_loggers ()[ 'name' ]) except Exception as e: serials =[] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) Ancestors (in MRO) hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , timestamp , serial , header = None , ** kwargs ) header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\" : \"nomechannelN\" , \"mu\" : \"measurement_unitN\" , \"column\" : # N , \"valid_range\" : [ start , end ] } ] View Source def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Logger"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#module-hielen3extfeature_logger_movelogger","text":"View Source # coding=utf-8 from hielen3 import conf from hielen3.feature import HFeature from hielen3.serializaction import ActionSchema from marshmallow import fields from pathlib import Path from pandas import read_csv , DatetimeIndex , Series #from .helper import func_loggers, retrive import json import re import traceback class ConfigSchema ( ActionSchema ): def _self_hints_ (): try : serials = list ( func_loggers ()[ 'name' ]) except Exception as e : serials = [] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) def retrive ( serials = None , times = None , columns = None , ** kwargs ): loggerpath = Path ( conf [ 'incomepath' ], 'move' , serials , 'last_load.csv' ) data = read_csv ( loggerpath ) data . index = Series ( data [ 'timestamp' ]) . astype ( str ) . apply ( lambda x : re . sub ( '.000Z$' , '' , x )) data . drop ( 'timestamp' , axis = 1 ) if not isinstance ( times , slice ): times = slice ( None , None , None ) return data [ times ][ columns ]","title":"Module hielen3.ext.feature_logger_move.logger"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#variables","text":"conf","title":"Variables"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#retrive","text":"def retrive ( serials = None , times = None , columns = None , ** kwargs ) View Source def retrive ( serials = None , times = None , columns = None , ** kwargs ) : loggerpath = Path ( conf [ 'incomepath' ] , 'move' , serials , 'last_load.csv' ) data = read_csv ( loggerpath ) data . index = Series ( data [ 'timestamp' ] ). astype ( str ). apply ( lambda x : re . sub ( '.000Z$' , '' , x )) data . drop ( 'timestamp' , axis = 1 ) if not isinstance ( times , slice ) : times = slice ( None , None , None ) return data [ times ][ columns ]","title":"retrive"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): try: serials = list ( func_loggers ()[ 'name' ]) except Exception as e: serials =[] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#ancestors-in-mro","text":"hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial","title":"Class variables"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#feature","text":"class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] )","title":"Feature"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#config","text":"def config ( self , timestamp , serial , header = None , ** kwargs ) header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\" : \"nomechannelN\" , \"mu\" : \"measurement_unitN\" , \"column\" : # N , \"valid_range\" : [ start , end ] } ] View Source def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] )","title":"config"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#retrive_1","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#setup","text":"def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_logger_move/logger/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_logger_move__/","text":"Module hielen3.ext.feature_logger_move__ View Source # coding=utf-8 __name__ = \"feature_logger_winecap\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from .logger import Feature , ConfigSchema __all__ = [ \"Feature\" , \"ConfigSchema\" ] Sub-modules hielen3.ext.feature_logger_move__.feature_logger_move hielen3.ext.feature_logger_move__.logger Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , [] ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) Ancestors (in MRO) hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : print ( \"INFO_NEW:\" , info_new ) try : gwserial = info_new . pop ( \"gwserial\" ) except Exception as e : gwserial = None try : apikey = f '#{info_new.pop(\"apikey\")}' except Exception as e : apikey = None try : wsdl = info_new . pop ( \"wsdl\" ) except Exception as e : wsdl = None info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ], \"GW\" : gwserial , \"KEY\" : apikey , \"wsdl\" : wsdl }, operator = f \"source.retrive(serials=SER,columns=COL,gateway=GW, key=KEY, wsdl=wsdl, times=times)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\" Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , timestamp , serial , header = None , ** kwargs ) header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\" : \"nomechannel2\" , \"mu\" : \"measurement_unit2\" , \"column\" : #2 , \"valid_range\" : [ start , end ] \"gwserial\" : \"...\" \"apikey\" :... \"wdsl\" :... }, ... { \"channel\" : \"nomechannelN\" , \"mu\" : \"measurement_unitN\" , \"column\" : # N , \"valid_range\" : [ start , end ] \"gwserial\" : \"...\" \"apikey\" :... \"wdsl\" :... } ] View Source def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : print ( \"INFO_NEW:\" , info_new ) try : gwserial = info_new . pop ( \"gwserial\" ) except Exception as e : gwserial = None try : apikey = f '#{info_new.pop(\"apikey\")}' except Exception as e : apikey = None try : wsdl = info_new . pop ( \"wsdl\" ) except Exception as e : wsdl = None info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ], \"GW\" : gwserial , \"KEY\" : apikey , \"wsdl\" : wsdl }, operator = f \"source.retrive(serials=SER,columns=COL,gateway=GW, key=KEY, wsdl=wsdl, times=times)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\" create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Index"},{"location":"reference/hielen3/ext/feature_logger_move__/#module-hielen3extfeature_logger_move__","text":"View Source # coding=utf-8 __name__ = \"feature_logger_winecap\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from .logger import Feature , ConfigSchema __all__ = [ \"Feature\" , \"ConfigSchema\" ]","title":"Module hielen3.ext.feature_logger_move__"},{"location":"reference/hielen3/ext/feature_logger_move__/#sub-modules","text":"hielen3.ext.feature_logger_move__.feature_logger_move hielen3.ext.feature_logger_move__.logger","title":"Sub-modules"},{"location":"reference/hielen3/ext/feature_logger_move__/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_logger_move__/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , [] ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_logger_move__/#ancestors-in-mro","text":"hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_move__/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial","title":"Class variables"},{"location":"reference/hielen3/ext/feature_logger_move__/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_logger_move__/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_logger_move__/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_move__/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_move__/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_logger_move__/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_logger_move__/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_logger_move__/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_logger_move__/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_logger_move__/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_logger_move__/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_logger_move__/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_logger_move__/#feature","text":"class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : print ( \"INFO_NEW:\" , info_new ) try : gwserial = info_new . pop ( \"gwserial\" ) except Exception as e : gwserial = None try : apikey = f '#{info_new.pop(\"apikey\")}' except Exception as e : apikey = None try : wsdl = info_new . pop ( \"wsdl\" ) except Exception as e : wsdl = None info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ], \"GW\" : gwserial , \"KEY\" : apikey , \"wsdl\" : wsdl }, operator = f \"source.retrive(serials=SER,columns=COL,gateway=GW, key=KEY, wsdl=wsdl, times=times)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\"","title":"Feature"},{"location":"reference/hielen3/ext/feature_logger_move__/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_move__/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_move__/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_move__/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_logger_move__/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_logger_move__/#config","text":"def config ( self , timestamp , serial , header = None , ** kwargs ) header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\" : \"nomechannel2\" , \"mu\" : \"measurement_unit2\" , \"column\" : #2 , \"valid_range\" : [ start , end ] \"gwserial\" : \"...\" \"apikey\" :... \"wdsl\" :... }, ... { \"channel\" : \"nomechannelN\" , \"mu\" : \"measurement_unitN\" , \"column\" : # N , \"valid_range\" : [ start , end ] \"gwserial\" : \"...\" \"apikey\" :... \"wdsl\" :... } ] View Source def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : print ( \"INFO_NEW:\" , info_new ) try : gwserial = info_new . pop ( \"gwserial\" ) except Exception as e : gwserial = None try : apikey = f '#{info_new.pop(\"apikey\")}' except Exception as e : apikey = None try : wsdl = info_new . pop ( \"wsdl\" ) except Exception as e : wsdl = None info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ], \"GW\" : gwserial , \"KEY\" : apikey , \"wsdl\" : wsdl }, operator = f \"source.retrive(serials=SER,columns=COL,gateway=GW, key=KEY, wsdl=wsdl, times=times)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\"","title":"config"},{"location":"reference/hielen3/ext/feature_logger_move__/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_logger_move__/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_logger_move__/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_logger_move__/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_logger_move__/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_logger_move__/#retrive","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_logger_move__/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_logger_move__/#setup","text":"def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_logger_move__/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_logger_move__/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_logger_move__/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/","text":"Module hielen3.ext.feature_logger_move__.logger View Source # coding=utf-8 from hielen3 import conf from hielen3.feature import HFeature from hielen3.serializaction import ActionSchema from marshmallow import fields from pathlib import Path import json import traceback from pandas import DataFrame , Series , to_datetime , concat from zeep import Client from zeep.helpers import serialize_object from concurrent.futures import ThreadPoolExecutor from functools import wraps from time import time from hielen3.utils import isot2ut from datetime import datetime ''' sudo apt-get install libxml2-dev libxslt1-dev pip install lxml==4.2.5 zeep ''' class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , [] ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : print ( \"INFO_NEW:\" , info_new ) try : gwserial = info_new . pop ( \"gwserial\" ) except Exception as e : gwserial = None try : apikey = f '# { info_new . pop ( \"apikey\" ) } ' except Exception as e : apikey = None try : wsdl = info_new . pop ( \"wsdl\" ) except Exception as e : wsdl = None info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ], \"GW\" : gwserial , \"KEY\" : apikey , \"wsdl\" : wsdl }, operator = f \"source.retrive(serials=SER,columns=COL,gateway=GW, key=KEY, wsdl=wsdl, times=times)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\" def retrive ( serials = None , columns = None , gateway = None , key = None , wsdl = None , times = None ): if isinstance ( times , slice ): start = times . start stop = times . stop else : start = times stop = None if start is None : start = 1 if stop is None : stop = int ( time ()) host = 'https://main.api.move-services.it' api = 'api/v3' gatway_id = '641975b673fe125848cfce69' bearer_key = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY0MTk3NTc0NTRjOThkNzAwMjViMmNiNyIsInJvbGUiOiJsb3JhIiwiaWF0IjoxNjc5MzkwMDY5fQ.9QqWG97fCdwVxtuQWo2WhTt0Div28LqN-4gv32AnJks' EUI = 'C0EE40000101F1D6' TYPE = 'accelerations' endpoint = f ' { host } / { api } /sensors/ { EUI } /measurements/ { TYPE } ?firstDate= { start } &lastDate= { stop } &page=0&sort=%2Bdate' if isinstance ( start ,( str , datetime )): start = int ( datetime . fromisoformat ( str ( start )) . timestamp ()) if isinstance ( stop ,( str , datetime )): stop = int ( datetime . fromisoformat ( str ( stop )) . timestamp ()) ahead = True out = DataFrame () while ahead : start = \".....\" stop = datetime64 ( stop ) + timedelta64 ( 30 , 'D' ) response = requests . get ( endpoint , headers = { 'accept' : 'application/json' , 'Authorization' : 'Bearer ' + bearer_key }) u = DataFrame ( json . loads ( response . content )[ 'values' ])[[ 'date' , 'acceleration' ]] . set_index ( 'date' )[ 'acceleration' ] . apply ( Series ) inner_ahead = True if u . __len__ () < 50 : ahead = False if u . __len__ () > 0 : ## VALUTARE I PARAMETRI SUCESSIVI u = u . set_index ([ 'timeStamp' ])[ 'value' ] u . index . names = [ 'timestamp' ] start = u . index . max () + 1 out = concat ([ out , u ]) ## out = out . sort_index () out . columns = [ f \" { serials } _ { columns } \" ] out . sort_index () out . index = to_datetime ( out . index , unit = 's' ) return out Variables conf Functions retrive def retrive ( serials = None , columns = None , gateway = None , key = None , wsdl = None , times = None ) View Source def retrive ( serials = None , columns = None , gateway = None , key = None , wsdl = None , times = None ): if isinstance ( times , slice ): start = times . start stop = times . stop else : start = times stop = None if start is None : start = 1 if stop is None : stop = int ( time ()) host = 'https://main.api.move-services.it' api = 'api/v3' gatway_id = '641975b673fe125848cfce69' bearer_key = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY0MTk3NTc0NTRjOThkNzAwMjViMmNiNyIsInJvbGUiOiJsb3JhIiwiaWF0IjoxNjc5MzkwMDY5fQ.9QqWG97fCdwVxtuQWo2WhTt0Div28LqN-4gv32AnJks' EUI = 'C0EE40000101F1D6' TYPE = 'accelerations' endpoint = f '{host}/{api}/sensors/{EUI}/measurements/{TYPE}?firstDate={start}&lastDate={stop}&page=0&sort=%2Bdate' if isinstance ( start ,( str , datetime )): start = int ( datetime . fromisoformat ( str ( start )) . timestamp ()) if isinstance ( stop ,( str , datetime )): stop = int ( datetime . fromisoformat ( str ( stop )) . timestamp ()) ahead = True out = DataFrame () while ahead : start = \".....\" stop = datetime64 ( stop ) + timedelta64 ( 30 , 'D' ) response = requests . get ( endpoint , headers = { 'accept' : 'application/json' , 'Authorization' : 'Bearer ' + bearer_key }) u = DataFrame ( json . loads ( response . content )[ 'values' ])[[ 'date' , 'acceleration' ]] . set_index ( 'date' )[ 'acceleration' ] . apply ( Series ) inner_ahead = True if u . __len__ () < 50 : ahead = False if u . __len__ () > 0 : ## VALUTARE I PARAMETRI SUCESSIVI u = u . set_index ([ 'timeStamp' ])[ 'value' ] u . index . names = [ 'timestamp' ] start = u . index . max () + 1 out = concat ([ out , u ]) ## out = out . sort_index () out . columns = [ f \"{serials}_{columns}\" ] out . sort_index () out . index = to_datetime ( out . index , unit = 's' ) return out Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , [] ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) Ancestors (in MRO) hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : print ( \"INFO_NEW:\" , info_new ) try : gwserial = info_new . pop ( \"gwserial\" ) except Exception as e : gwserial = None try : apikey = f '#{info_new.pop(\"apikey\")}' except Exception as e : apikey = None try : wsdl = info_new . pop ( \"wsdl\" ) except Exception as e : wsdl = None info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ], \"GW\" : gwserial , \"KEY\" : apikey , \"wsdl\" : wsdl }, operator = f \"source.retrive(serials=SER,columns=COL,gateway=GW, key=KEY, wsdl=wsdl, times=times)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\" Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , timestamp , serial , header = None , ** kwargs ) header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\" : \"nomechannel2\" , \"mu\" : \"measurement_unit2\" , \"column\" : #2 , \"valid_range\" : [ start , end ] \"gwserial\" : \"...\" \"apikey\" :... \"wdsl\" :... }, ... { \"channel\" : \"nomechannelN\" , \"mu\" : \"measurement_unitN\" , \"column\" : # N , \"valid_range\" : [ start , end ] \"gwserial\" : \"...\" \"apikey\" :... \"wdsl\" :... } ] View Source def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : print ( \"INFO_NEW:\" , info_new ) try : gwserial = info_new . pop ( \"gwserial\" ) except Exception as e : gwserial = None try : apikey = f '#{info_new.pop(\"apikey\")}' except Exception as e : apikey = None try : wsdl = info_new . pop ( \"wsdl\" ) except Exception as e : wsdl = None info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ], \"GW\" : gwserial , \"KEY\" : apikey , \"wsdl\" : wsdl }, operator = f \"source.retrive(serials=SER,columns=COL,gateway=GW, key=KEY, wsdl=wsdl, times=times)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\" create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Logger"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#module-hielen3extfeature_logger_move__logger","text":"View Source # coding=utf-8 from hielen3 import conf from hielen3.feature import HFeature from hielen3.serializaction import ActionSchema from marshmallow import fields from pathlib import Path import json import traceback from pandas import DataFrame , Series , to_datetime , concat from zeep import Client from zeep.helpers import serialize_object from concurrent.futures import ThreadPoolExecutor from functools import wraps from time import time from hielen3.utils import isot2ut from datetime import datetime ''' sudo apt-get install libxml2-dev libxslt1-dev pip install lxml==4.2.5 zeep ''' class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , [] ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : print ( \"INFO_NEW:\" , info_new ) try : gwserial = info_new . pop ( \"gwserial\" ) except Exception as e : gwserial = None try : apikey = f '# { info_new . pop ( \"apikey\" ) } ' except Exception as e : apikey = None try : wsdl = info_new . pop ( \"wsdl\" ) except Exception as e : wsdl = None info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ], \"GW\" : gwserial , \"KEY\" : apikey , \"wsdl\" : wsdl }, operator = f \"source.retrive(serials=SER,columns=COL,gateway=GW, key=KEY, wsdl=wsdl, times=times)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\" def retrive ( serials = None , columns = None , gateway = None , key = None , wsdl = None , times = None ): if isinstance ( times , slice ): start = times . start stop = times . stop else : start = times stop = None if start is None : start = 1 if stop is None : stop = int ( time ()) host = 'https://main.api.move-services.it' api = 'api/v3' gatway_id = '641975b673fe125848cfce69' bearer_key = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY0MTk3NTc0NTRjOThkNzAwMjViMmNiNyIsInJvbGUiOiJsb3JhIiwiaWF0IjoxNjc5MzkwMDY5fQ.9QqWG97fCdwVxtuQWo2WhTt0Div28LqN-4gv32AnJks' EUI = 'C0EE40000101F1D6' TYPE = 'accelerations' endpoint = f ' { host } / { api } /sensors/ { EUI } /measurements/ { TYPE } ?firstDate= { start } &lastDate= { stop } &page=0&sort=%2Bdate' if isinstance ( start ,( str , datetime )): start = int ( datetime . fromisoformat ( str ( start )) . timestamp ()) if isinstance ( stop ,( str , datetime )): stop = int ( datetime . fromisoformat ( str ( stop )) . timestamp ()) ahead = True out = DataFrame () while ahead : start = \".....\" stop = datetime64 ( stop ) + timedelta64 ( 30 , 'D' ) response = requests . get ( endpoint , headers = { 'accept' : 'application/json' , 'Authorization' : 'Bearer ' + bearer_key }) u = DataFrame ( json . loads ( response . content )[ 'values' ])[[ 'date' , 'acceleration' ]] . set_index ( 'date' )[ 'acceleration' ] . apply ( Series ) inner_ahead = True if u . __len__ () < 50 : ahead = False if u . __len__ () > 0 : ## VALUTARE I PARAMETRI SUCESSIVI u = u . set_index ([ 'timeStamp' ])[ 'value' ] u . index . names = [ 'timestamp' ] start = u . index . max () + 1 out = concat ([ out , u ]) ## out = out . sort_index () out . columns = [ f \" { serials } _ { columns } \" ] out . sort_index () out . index = to_datetime ( out . index , unit = 's' ) return out","title":"Module hielen3.ext.feature_logger_move__.logger"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#variables","text":"conf","title":"Variables"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#retrive","text":"def retrive ( serials = None , columns = None , gateway = None , key = None , wsdl = None , times = None ) View Source def retrive ( serials = None , columns = None , gateway = None , key = None , wsdl = None , times = None ): if isinstance ( times , slice ): start = times . start stop = times . stop else : start = times stop = None if start is None : start = 1 if stop is None : stop = int ( time ()) host = 'https://main.api.move-services.it' api = 'api/v3' gatway_id = '641975b673fe125848cfce69' bearer_key = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY0MTk3NTc0NTRjOThkNzAwMjViMmNiNyIsInJvbGUiOiJsb3JhIiwiaWF0IjoxNjc5MzkwMDY5fQ.9QqWG97fCdwVxtuQWo2WhTt0Div28LqN-4gv32AnJks' EUI = 'C0EE40000101F1D6' TYPE = 'accelerations' endpoint = f '{host}/{api}/sensors/{EUI}/measurements/{TYPE}?firstDate={start}&lastDate={stop}&page=0&sort=%2Bdate' if isinstance ( start ,( str , datetime )): start = int ( datetime . fromisoformat ( str ( start )) . timestamp ()) if isinstance ( stop ,( str , datetime )): stop = int ( datetime . fromisoformat ( str ( stop )) . timestamp ()) ahead = True out = DataFrame () while ahead : start = \".....\" stop = datetime64 ( stop ) + timedelta64 ( 30 , 'D' ) response = requests . get ( endpoint , headers = { 'accept' : 'application/json' , 'Authorization' : 'Bearer ' + bearer_key }) u = DataFrame ( json . loads ( response . content )[ 'values' ])[[ 'date' , 'acceleration' ]] . set_index ( 'date' )[ 'acceleration' ] . apply ( Series ) inner_ahead = True if u . __len__ () < 50 : ahead = False if u . __len__ () > 0 : ## VALUTARE I PARAMETRI SUCESSIVI u = u . set_index ([ 'timeStamp' ])[ 'value' ] u . index . names = [ 'timestamp' ] start = u . index . max () + 1 out = concat ([ out , u ]) ## out = out . sort_index () out . columns = [ f \"{serials}_{columns}\" ] out . sort_index () out . index = to_datetime ( out . index , unit = 's' ) return out","title":"retrive"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , [] ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#ancestors-in-mro","text":"hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial","title":"Class variables"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#feature","text":"class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : print ( \"INFO_NEW:\" , info_new ) try : gwserial = info_new . pop ( \"gwserial\" ) except Exception as e : gwserial = None try : apikey = f '#{info_new.pop(\"apikey\")}' except Exception as e : apikey = None try : wsdl = info_new . pop ( \"wsdl\" ) except Exception as e : wsdl = None info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ], \"GW\" : gwserial , \"KEY\" : apikey , \"wsdl\" : wsdl }, operator = f \"source.retrive(serials=SER,columns=COL,gateway=GW, key=KEY, wsdl=wsdl, times=times)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\"","title":"Feature"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#config","text":"def config ( self , timestamp , serial , header = None , ** kwargs ) header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\" : \"nomechannel2\" , \"mu\" : \"measurement_unit2\" , \"column\" : #2 , \"valid_range\" : [ start , end ] \"gwserial\" : \"...\" \"apikey\" :... \"wdsl\" :... }, ... { \"channel\" : \"nomechannelN\" , \"mu\" : \"measurement_unitN\" , \"column\" : # N , \"valid_range\" : [ start , end ] \"gwserial\" : \"...\" \"apikey\" :... \"wdsl\" :... } ] View Source def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : print ( \"INFO_NEW:\" , info_new ) try : gwserial = info_new . pop ( \"gwserial\" ) except Exception as e : gwserial = None try : apikey = f '#{info_new.pop(\"apikey\")}' except Exception as e : apikey = None try : wsdl = info_new . pop ( \"wsdl\" ) except Exception as e : wsdl = None info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ], \"GW\" : gwserial , \"KEY\" : apikey , \"wsdl\" : wsdl }, operator = f \"source.retrive(serials=SER,columns=COL,gateway=GW, key=KEY, wsdl=wsdl, times=times)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\"","title":"config"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#retrive_1","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#setup","text":"def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_logger_move__/logger/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/","text":"Module hielen3.ext.feature_logger_move__.feature_logger_move View Source # coding=utf-8 __name__ = \"feature_logger_winecap\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from .logger import Feature , ConfigSchema __all__ = [ \"Feature\" , \"ConfigSchema\" ] Sub-modules hielen3.ext.feature_logger_move__.feature_logger_move.logger Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , [] ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) Ancestors (in MRO) hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : print ( \"INFO_NEW:\" , info_new ) try : gwserial = info_new . pop ( \"gwserial\" ) except Exception as e : gwserial = None try : apikey = f '#{info_new.pop(\"apikey\")}' except Exception as e : apikey = None try : wsdl = info_new . pop ( \"wsdl\" ) except Exception as e : wsdl = None info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ], \"GW\" : gwserial , \"KEY\" : apikey , \"wsdl\" : wsdl }, operator = f \"source.retrive(serials=SER,columns=COL,gateway=GW, key=KEY, wsdl=wsdl, times=times)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\" Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , timestamp , serial , header = None , ** kwargs ) header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\" : \"nomechannel2\" , \"mu\" : \"measurement_unit2\" , \"column\" : #2 , \"valid_range\" : [ start , end ] \"gwserial\" : \"...\" \"apikey\" :... \"wdsl\" :... }, ... { \"channel\" : \"nomechannelN\" , \"mu\" : \"measurement_unitN\" , \"column\" : # N , \"valid_range\" : [ start , end ] \"gwserial\" : \"...\" \"apikey\" :... \"wdsl\" :... } ] View Source def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : print ( \"INFO_NEW:\" , info_new ) try : gwserial = info_new . pop ( \"gwserial\" ) except Exception as e : gwserial = None try : apikey = f '#{info_new.pop(\"apikey\")}' except Exception as e : apikey = None try : wsdl = info_new . pop ( \"wsdl\" ) except Exception as e : wsdl = None info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ], \"GW\" : gwserial , \"KEY\" : apikey , \"wsdl\" : wsdl }, operator = f \"source.retrive(serials=SER,columns=COL,gateway=GW, key=KEY, wsdl=wsdl, times=times)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\" create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Index"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#module-hielen3extfeature_logger_move__feature_logger_move","text":"View Source # coding=utf-8 __name__ = \"feature_logger_winecap\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from .logger import Feature , ConfigSchema __all__ = [ \"Feature\" , \"ConfigSchema\" ]","title":"Module hielen3.ext.feature_logger_move__.feature_logger_move"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#sub-modules","text":"hielen3.ext.feature_logger_move__.feature_logger_move.logger","title":"Sub-modules"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , [] ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#ancestors-in-mro","text":"hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial","title":"Class variables"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#feature","text":"class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : print ( \"INFO_NEW:\" , info_new ) try : gwserial = info_new . pop ( \"gwserial\" ) except Exception as e : gwserial = None try : apikey = f '#{info_new.pop(\"apikey\")}' except Exception as e : apikey = None try : wsdl = info_new . pop ( \"wsdl\" ) except Exception as e : wsdl = None info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ], \"GW\" : gwserial , \"KEY\" : apikey , \"wsdl\" : wsdl }, operator = f \"source.retrive(serials=SER,columns=COL,gateway=GW, key=KEY, wsdl=wsdl, times=times)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\"","title":"Feature"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#config","text":"def config ( self , timestamp , serial , header = None , ** kwargs ) header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\" : \"nomechannel2\" , \"mu\" : \"measurement_unit2\" , \"column\" : #2 , \"valid_range\" : [ start , end ] \"gwserial\" : \"...\" \"apikey\" :... \"wdsl\" :... }, ... { \"channel\" : \"nomechannelN\" , \"mu\" : \"measurement_unitN\" , \"column\" : # N , \"valid_range\" : [ start , end ] \"gwserial\" : \"...\" \"apikey\" :... \"wdsl\" :... } ] View Source def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : print ( \"INFO_NEW:\" , info_new ) try : gwserial = info_new . pop ( \"gwserial\" ) except Exception as e : gwserial = None try : apikey = f '#{info_new.pop(\"apikey\")}' except Exception as e : apikey = None try : wsdl = info_new . pop ( \"wsdl\" ) except Exception as e : wsdl = None info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ], \"GW\" : gwserial , \"KEY\" : apikey , \"wsdl\" : wsdl }, operator = f \"source.retrive(serials=SER,columns=COL,gateway=GW, key=KEY, wsdl=wsdl, times=times)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\"","title":"config"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#retrive","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#setup","text":"def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/","text":"Module hielen3.ext.feature_logger_move__.feature_logger_move.logger View Source # coding=utf-8 from hielen3 import conf from hielen3.feature import HFeature from hielen3.serializaction import ActionSchema from marshmallow import fields from pathlib import Path import json import traceback from pandas import DataFrame , Series , to_datetime , concat from zeep import Client from zeep.helpers import serialize_object from concurrent.futures import ThreadPoolExecutor from functools import wraps from time import time from hielen3.utils import isot2ut from datetime import datetime ''' sudo apt-get install libxml2-dev libxslt1-dev pip install lxml==4.2.5 zeep ''' class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , [] ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : print ( \"INFO_NEW:\" , info_new ) try : gwserial = info_new . pop ( \"gwserial\" ) except Exception as e : gwserial = None try : apikey = f '# { info_new . pop ( \"apikey\" ) } ' except Exception as e : apikey = None try : wsdl = info_new . pop ( \"wsdl\" ) except Exception as e : wsdl = None info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ], \"GW\" : gwserial , \"KEY\" : apikey , \"wsdl\" : wsdl }, operator = f \"source.retrive(serials=SER,columns=COL,gateway=GW, key=KEY, wsdl=wsdl, times=times)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\" def retrive ( serials = None , columns = None , gateway = None , key = None , wsdl = None , times = None ): if isinstance ( times , slice ): start = times . start stop = times . stop else : start = times stop = None if start is None : start = 1 if stop is None : stop = int ( time ()) host = 'https://main.api.move-services.it' api = 'api/v3' gatway_id = '641975b673fe125848cfce69' bearer_key = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY0MTk3NTc0NTRjOThkNzAwMjViMmNiNyIsInJvbGUiOiJsb3JhIiwiaWF0IjoxNjc5MzkwMDY5fQ.9QqWG97fCdwVxtuQWo2WhTt0Div28LqN-4gv32AnJks' EUI = 'C0EE40000101F1D6' TYPE = 'accelerations' endpoint = f ' { host } / { api } /sensors/ { EUI } /measurements/ { TYPE } ?firstDate= { start } &lastDate= { stop } &page=0&sort=%2Bdate' if isinstance ( start ,( str , datetime )): start = int ( datetime . fromisoformat ( str ( start )) . timestamp ()) if isinstance ( stop ,( str , datetime )): stop = int ( datetime . fromisoformat ( str ( stop )) . timestamp ()) ahead = True out = DataFrame () while ahead : start = \".....\" stop = datetime64 ( stop ) + timedelta64 ( 30 , 'D' ) response = requests . get ( endpoint , headers = { 'accept' : 'application/json' , 'Authorization' : 'Bearer ' + bearer_key }) u = DataFrame ( json . loads ( response . content )[ 'values' ])[[ 'date' , 'acceleration' ]] . set_index ( 'date' )[ 'acceleration' ] . apply ( Series ) inner_ahead = True if u . __len__ () < 50 : ahead = False if u . __len__ () > 0 : ## VALUTARE I PARAMETRI SUCESSIVI u = u . set_index ([ 'timeStamp' ])[ 'value' ] u . index . names = [ 'timestamp' ] start = u . index . max () + 1 out = concat ([ out , u ]) ## out = out . sort_index () out . columns = [ f \" { serials } _ { columns } \" ] out . sort_index () out . index = to_datetime ( out . index , unit = 's' ) return out Variables conf Functions retrive def retrive ( serials = None , columns = None , gateway = None , key = None , wsdl = None , times = None ) View Source def retrive ( serials = None , columns = None , gateway = None , key = None , wsdl = None , times = None ): if isinstance ( times , slice ): start = times . start stop = times . stop else : start = times stop = None if start is None : start = 1 if stop is None : stop = int ( time ()) host = 'https://main.api.move-services.it' api = 'api/v3' gatway_id = '641975b673fe125848cfce69' bearer_key = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY0MTk3NTc0NTRjOThkNzAwMjViMmNiNyIsInJvbGUiOiJsb3JhIiwiaWF0IjoxNjc5MzkwMDY5fQ.9QqWG97fCdwVxtuQWo2WhTt0Div28LqN-4gv32AnJks' EUI = 'C0EE40000101F1D6' TYPE = 'accelerations' endpoint = f '{host}/{api}/sensors/{EUI}/measurements/{TYPE}?firstDate={start}&lastDate={stop}&page=0&sort=%2Bdate' if isinstance ( start ,( str , datetime )): start = int ( datetime . fromisoformat ( str ( start )) . timestamp ()) if isinstance ( stop ,( str , datetime )): stop = int ( datetime . fromisoformat ( str ( stop )) . timestamp ()) ahead = True out = DataFrame () while ahead : start = \".....\" stop = datetime64 ( stop ) + timedelta64 ( 30 , 'D' ) response = requests . get ( endpoint , headers = { 'accept' : 'application/json' , 'Authorization' : 'Bearer ' + bearer_key }) u = DataFrame ( json . loads ( response . content )[ 'values' ])[[ 'date' , 'acceleration' ]] . set_index ( 'date' )[ 'acceleration' ] . apply ( Series ) inner_ahead = True if u . __len__ () < 50 : ahead = False if u . __len__ () > 0 : ## VALUTARE I PARAMETRI SUCESSIVI u = u . set_index ([ 'timeStamp' ])[ 'value' ] u . index . names = [ 'timestamp' ] start = u . index . max () + 1 out = concat ([ out , u ]) ## out = out . sort_index () out . columns = [ f \"{serials}_{columns}\" ] out . sort_index () out . index = to_datetime ( out . index , unit = 's' ) return out Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , [] ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) Ancestors (in MRO) hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : print ( \"INFO_NEW:\" , info_new ) try : gwserial = info_new . pop ( \"gwserial\" ) except Exception as e : gwserial = None try : apikey = f '#{info_new.pop(\"apikey\")}' except Exception as e : apikey = None try : wsdl = info_new . pop ( \"wsdl\" ) except Exception as e : wsdl = None info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ], \"GW\" : gwserial , \"KEY\" : apikey , \"wsdl\" : wsdl }, operator = f \"source.retrive(serials=SER,columns=COL,gateway=GW, key=KEY, wsdl=wsdl, times=times)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\" Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , timestamp , serial , header = None , ** kwargs ) header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\" : \"nomechannel2\" , \"mu\" : \"measurement_unit2\" , \"column\" : #2 , \"valid_range\" : [ start , end ] \"gwserial\" : \"...\" \"apikey\" :... \"wdsl\" :... }, ... { \"channel\" : \"nomechannelN\" , \"mu\" : \"measurement_unitN\" , \"column\" : # N , \"valid_range\" : [ start , end ] \"gwserial\" : \"...\" \"apikey\" :... \"wdsl\" :... } ] View Source def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : print ( \"INFO_NEW:\" , info_new ) try : gwserial = info_new . pop ( \"gwserial\" ) except Exception as e : gwserial = None try : apikey = f '#{info_new.pop(\"apikey\")}' except Exception as e : apikey = None try : wsdl = info_new . pop ( \"wsdl\" ) except Exception as e : wsdl = None info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ], \"GW\" : gwserial , \"KEY\" : apikey , \"wsdl\" : wsdl }, operator = f \"source.retrive(serials=SER,columns=COL,gateway=GW, key=KEY, wsdl=wsdl, times=times)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\" create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Logger"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#module-hielen3extfeature_logger_move__feature_logger_movelogger","text":"View Source # coding=utf-8 from hielen3 import conf from hielen3.feature import HFeature from hielen3.serializaction import ActionSchema from marshmallow import fields from pathlib import Path import json import traceback from pandas import DataFrame , Series , to_datetime , concat from zeep import Client from zeep.helpers import serialize_object from concurrent.futures import ThreadPoolExecutor from functools import wraps from time import time from hielen3.utils import isot2ut from datetime import datetime ''' sudo apt-get install libxml2-dev libxslt1-dev pip install lxml==4.2.5 zeep ''' class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , [] ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : print ( \"INFO_NEW:\" , info_new ) try : gwserial = info_new . pop ( \"gwserial\" ) except Exception as e : gwserial = None try : apikey = f '# { info_new . pop ( \"apikey\" ) } ' except Exception as e : apikey = None try : wsdl = info_new . pop ( \"wsdl\" ) except Exception as e : wsdl = None info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ], \"GW\" : gwserial , \"KEY\" : apikey , \"wsdl\" : wsdl }, operator = f \"source.retrive(serials=SER,columns=COL,gateway=GW, key=KEY, wsdl=wsdl, times=times)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\" def retrive ( serials = None , columns = None , gateway = None , key = None , wsdl = None , times = None ): if isinstance ( times , slice ): start = times . start stop = times . stop else : start = times stop = None if start is None : start = 1 if stop is None : stop = int ( time ()) host = 'https://main.api.move-services.it' api = 'api/v3' gatway_id = '641975b673fe125848cfce69' bearer_key = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY0MTk3NTc0NTRjOThkNzAwMjViMmNiNyIsInJvbGUiOiJsb3JhIiwiaWF0IjoxNjc5MzkwMDY5fQ.9QqWG97fCdwVxtuQWo2WhTt0Div28LqN-4gv32AnJks' EUI = 'C0EE40000101F1D6' TYPE = 'accelerations' endpoint = f ' { host } / { api } /sensors/ { EUI } /measurements/ { TYPE } ?firstDate= { start } &lastDate= { stop } &page=0&sort=%2Bdate' if isinstance ( start ,( str , datetime )): start = int ( datetime . fromisoformat ( str ( start )) . timestamp ()) if isinstance ( stop ,( str , datetime )): stop = int ( datetime . fromisoformat ( str ( stop )) . timestamp ()) ahead = True out = DataFrame () while ahead : start = \".....\" stop = datetime64 ( stop ) + timedelta64 ( 30 , 'D' ) response = requests . get ( endpoint , headers = { 'accept' : 'application/json' , 'Authorization' : 'Bearer ' + bearer_key }) u = DataFrame ( json . loads ( response . content )[ 'values' ])[[ 'date' , 'acceleration' ]] . set_index ( 'date' )[ 'acceleration' ] . apply ( Series ) inner_ahead = True if u . __len__ () < 50 : ahead = False if u . __len__ () > 0 : ## VALUTARE I PARAMETRI SUCESSIVI u = u . set_index ([ 'timeStamp' ])[ 'value' ] u . index . names = [ 'timestamp' ] start = u . index . max () + 1 out = concat ([ out , u ]) ## out = out . sort_index () out . columns = [ f \" { serials } _ { columns } \" ] out . sort_index () out . index = to_datetime ( out . index , unit = 's' ) return out","title":"Module hielen3.ext.feature_logger_move__.feature_logger_move.logger"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#variables","text":"conf","title":"Variables"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#retrive","text":"def retrive ( serials = None , columns = None , gateway = None , key = None , wsdl = None , times = None ) View Source def retrive ( serials = None , columns = None , gateway = None , key = None , wsdl = None , times = None ): if isinstance ( times , slice ): start = times . start stop = times . stop else : start = times stop = None if start is None : start = 1 if stop is None : stop = int ( time ()) host = 'https://main.api.move-services.it' api = 'api/v3' gatway_id = '641975b673fe125848cfce69' bearer_key = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY0MTk3NTc0NTRjOThkNzAwMjViMmNiNyIsInJvbGUiOiJsb3JhIiwiaWF0IjoxNjc5MzkwMDY5fQ.9QqWG97fCdwVxtuQWo2WhTt0Div28LqN-4gv32AnJks' EUI = 'C0EE40000101F1D6' TYPE = 'accelerations' endpoint = f '{host}/{api}/sensors/{EUI}/measurements/{TYPE}?firstDate={start}&lastDate={stop}&page=0&sort=%2Bdate' if isinstance ( start ,( str , datetime )): start = int ( datetime . fromisoformat ( str ( start )) . timestamp ()) if isinstance ( stop ,( str , datetime )): stop = int ( datetime . fromisoformat ( str ( stop )) . timestamp ()) ahead = True out = DataFrame () while ahead : start = \".....\" stop = datetime64 ( stop ) + timedelta64 ( 30 , 'D' ) response = requests . get ( endpoint , headers = { 'accept' : 'application/json' , 'Authorization' : 'Bearer ' + bearer_key }) u = DataFrame ( json . loads ( response . content )[ 'values' ])[[ 'date' , 'acceleration' ]] . set_index ( 'date' )[ 'acceleration' ] . apply ( Series ) inner_ahead = True if u . __len__ () < 50 : ahead = False if u . __len__ () > 0 : ## VALUTARE I PARAMETRI SUCESSIVI u = u . set_index ([ 'timeStamp' ])[ 'value' ] u . index . names = [ 'timestamp' ] start = u . index . max () + 1 out = concat ([ out , u ]) ## out = out . sort_index () out . columns = [ f \"{serials}_{columns}\" ] out . sort_index () out . index = to_datetime ( out . index , unit = 's' ) return out","title":"retrive"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , [] ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#ancestors-in-mro","text":"hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial","title":"Class variables"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#feature","text":"class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : print ( \"INFO_NEW:\" , info_new ) try : gwserial = info_new . pop ( \"gwserial\" ) except Exception as e : gwserial = None try : apikey = f '#{info_new.pop(\"apikey\")}' except Exception as e : apikey = None try : wsdl = info_new . pop ( \"wsdl\" ) except Exception as e : wsdl = None info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ], \"GW\" : gwserial , \"KEY\" : apikey , \"wsdl\" : wsdl }, operator = f \"source.retrive(serials=SER,columns=COL,gateway=GW, key=KEY, wsdl=wsdl, times=times)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\"","title":"Feature"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#config","text":"def config ( self , timestamp , serial , header = None , ** kwargs ) header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\" : \"nomechannel2\" , \"mu\" : \"measurement_unit2\" , \"column\" : #2 , \"valid_range\" : [ start , end ] \"gwserial\" : \"...\" \"apikey\" :... \"wdsl\" :... }, ... { \"channel\" : \"nomechannelN\" , \"mu\" : \"measurement_unitN\" , \"column\" : # N , \"valid_range\" : [ start , end ] \"gwserial\" : \"...\" \"apikey\" :... \"wdsl\" :... } ] View Source def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : print ( \"INFO_NEW:\" , info_new ) try : gwserial = info_new . pop ( \"gwserial\" ) except Exception as e : gwserial = None try : apikey = f '#{info_new.pop(\"apikey\")}' except Exception as e : apikey = None try : wsdl = info_new . pop ( \"wsdl\" ) except Exception as e : wsdl = None info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ], \"GW\" : gwserial , \"KEY\" : apikey , \"wsdl\" : wsdl }, operator = f \"source.retrive(serials=SER,columns=COL,gateway=GW, key=KEY, wsdl=wsdl, times=times)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\"","title":"config"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#retrive_1","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#setup","text":"def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_logger_move__/feature_logger_move/logger/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/","text":"Module hielen3.ext.feature_logger_omnialog_temp View Source # coding=utf-8 __name__ = \"feature_logger_omnialog\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from hielen3.ext.feature_datetree_filesystem_source import loggers , retriver from pandas import read_csv , DatetimeIndex , DataFrame from .logger import Feature , ConfigSchema __all__ = [ \"Feature\" , \"ConfigSchema\" ] Sub-modules hielen3.ext.feature_logger_omnialog_temp.helper hielen3.ext.feature_logger_omnialog_temp.logger Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): try: serials = list ( func_loggers ()[ 'name' ]) except Exception as e: serials =[] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) Ancestors (in MRO) hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self ,** kwargs ): pass def config ( self , serial , ** kwargs ): header ={ 1 :{ \"name\" : \"battery\" , \"mu\" : \"V\" , \"ordinal\" : 1 }, 2 :{ \"name\" : \"temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 2 }, 4 :{ \"name\" : \"CE01_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 3 }, 5 :{ \"name\" : \"CE01_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 4 }, 6 :{ \"name\" : \"CE01_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 5 }, 7 :{ \"name\" : \"CE02_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 6 }, 8 :{ \"name\" : \"CE02_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 7 }, 9 :{ \"name\" : \"CE02_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 8 }, 10 :{ \"name\" : \"CE03_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 9 }, 11 :{ \"name\" : \"CE03_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 10 }, 12 :{ \"name\" : \"CE03_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 11 }, 13 :{ \"name\" : \"CE04_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 12 }, 14 :{ \"name\" : \"CE04_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 13 }, 15 :{ \"name\" : \"CE04_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 14 } } source = str ( self . __module__ ) for k , w in header . items (): self . parameters . set ( w [ \"name\" ], cache = 'active' , mu = w [ 'mu' ], ordinal = w [ 'ordinal' ], modules ={ \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns={k})\" ) Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , serial , ** kwargs ) View Source def config ( self , serial , ** kwargs ) : header = { 1 :{ \"name\" : \"battery\" , \"mu\" : \"V\" , \"ordinal\" : 1 }, 2 :{ \"name\" : \"temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 2 }, 4 :{ \"name\" : \"CE01_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 3 }, 5 :{ \"name\" : \"CE01_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 4 }, 6 :{ \"name\" : \"CE01_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 5 }, 7 :{ \"name\" : \"CE02_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 6 }, 8 :{ \"name\" : \"CE02_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 7 }, 9 :{ \"name\" : \"CE02_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 8 }, 10 :{ \"name\" : \"CE03_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 9 }, 11 :{ \"name\" : \"CE03_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 10 }, 12 :{ \"name\" : \"CE03_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 11 }, 13 :{ \"name\" : \"CE04_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 12 }, 14 :{ \"name\" : \"CE04_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 13 }, 15 :{ \"name\" : \"CE04_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 14 } } source = str ( self . __module__ ) for k , w in header . items () : self . parameters . set ( w [ \"name\" ], cache = 'active' , mu = w [ 'mu' ], ordinal = w [ 'ordinal' ], modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns={k})\" ) create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Index"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#module-hielen3extfeature_logger_omnialog_temp","text":"View Source # coding=utf-8 __name__ = \"feature_logger_omnialog\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from hielen3.ext.feature_datetree_filesystem_source import loggers , retriver from pandas import read_csv , DatetimeIndex , DataFrame from .logger import Feature , ConfigSchema __all__ = [ \"Feature\" , \"ConfigSchema\" ]","title":"Module hielen3.ext.feature_logger_omnialog_temp"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#sub-modules","text":"hielen3.ext.feature_logger_omnialog_temp.helper hielen3.ext.feature_logger_omnialog_temp.logger","title":"Sub-modules"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): try: serials = list ( func_loggers ()[ 'name' ]) except Exception as e: serials =[] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#ancestors-in-mro","text":"hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial","title":"Class variables"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#feature","text":"class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self ,** kwargs ): pass def config ( self , serial , ** kwargs ): header ={ 1 :{ \"name\" : \"battery\" , \"mu\" : \"V\" , \"ordinal\" : 1 }, 2 :{ \"name\" : \"temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 2 }, 4 :{ \"name\" : \"CE01_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 3 }, 5 :{ \"name\" : \"CE01_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 4 }, 6 :{ \"name\" : \"CE01_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 5 }, 7 :{ \"name\" : \"CE02_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 6 }, 8 :{ \"name\" : \"CE02_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 7 }, 9 :{ \"name\" : \"CE02_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 8 }, 10 :{ \"name\" : \"CE03_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 9 }, 11 :{ \"name\" : \"CE03_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 10 }, 12 :{ \"name\" : \"CE03_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 11 }, 13 :{ \"name\" : \"CE04_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 12 }, 14 :{ \"name\" : \"CE04_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 13 }, 15 :{ \"name\" : \"CE04_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 14 } } source = str ( self . __module__ ) for k , w in header . items (): self . parameters . set ( w [ \"name\" ], cache = 'active' , mu = w [ 'mu' ], ordinal = w [ 'ordinal' ], modules ={ \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns={k})\" )","title":"Feature"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#config","text":"def config ( self , serial , ** kwargs ) View Source def config ( self , serial , ** kwargs ) : header = { 1 :{ \"name\" : \"battery\" , \"mu\" : \"V\" , \"ordinal\" : 1 }, 2 :{ \"name\" : \"temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 2 }, 4 :{ \"name\" : \"CE01_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 3 }, 5 :{ \"name\" : \"CE01_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 4 }, 6 :{ \"name\" : \"CE01_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 5 }, 7 :{ \"name\" : \"CE02_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 6 }, 8 :{ \"name\" : \"CE02_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 7 }, 9 :{ \"name\" : \"CE02_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 8 }, 10 :{ \"name\" : \"CE03_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 9 }, 11 :{ \"name\" : \"CE03_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 10 }, 12 :{ \"name\" : \"CE03_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 11 }, 13 :{ \"name\" : \"CE04_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 12 }, 14 :{ \"name\" : \"CE04_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 13 }, 15 :{ \"name\" : \"CE04_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 14 } } source = str ( self . __module__ ) for k , w in header . items () : self . parameters . set ( w [ \"name\" ], cache = 'active' , mu = w [ 'mu' ], ordinal = w [ 'ordinal' ], modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns={k})\" )","title":"config"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#retrive","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#setup","text":"def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/helper/","text":"Module hielen3.ext.feature_logger_omnialog_temp.helper View Source # coding=utf-8 from hielen3.ext.feature_datetree_filesystem_source import loggers , retriver from pandas import read_csv , DataFrame folders = [ { 'type' : 'ominalog' , 'path' : 'omnialog' } ] func_loggers = loggers ( folders ) @retriver ( func_loggers ) def retrive ( path ): a = DataFrame ([], dtype = 'float64' ) try : a = read_csv ( path , skiprows = 1 , parse_dates = [ 0 ], header = None ) a . columns = [ 'times' , * a . columns [ 1 :] ] except Exception as e : #raise e pass return a Variables folders Functions func_loggers def func_loggers ( ) View Source def inner () : return logger_serials ( folders ) loggers def loggers ( folders ) View Source def loggers ( folders ) : def inner () : return logger_serials ( folders ) return inner retrive def retrive ( * args , ** kwargs ) View Source def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs ) retriver def retriver ( func_loggers ) View Source def retriver ( func_loggers ) : def wrap ( func_extract ) : def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs ) return inner return wrap","title":"Helper"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/helper/#module-hielen3extfeature_logger_omnialog_temphelper","text":"View Source # coding=utf-8 from hielen3.ext.feature_datetree_filesystem_source import loggers , retriver from pandas import read_csv , DataFrame folders = [ { 'type' : 'ominalog' , 'path' : 'omnialog' } ] func_loggers = loggers ( folders ) @retriver ( func_loggers ) def retrive ( path ): a = DataFrame ([], dtype = 'float64' ) try : a = read_csv ( path , skiprows = 1 , parse_dates = [ 0 ], header = None ) a . columns = [ 'times' , * a . columns [ 1 :] ] except Exception as e : #raise e pass return a","title":"Module hielen3.ext.feature_logger_omnialog_temp.helper"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/helper/#variables","text":"folders","title":"Variables"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/helper/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/helper/#func_loggers","text":"def func_loggers ( ) View Source def inner () : return logger_serials ( folders )","title":"func_loggers"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/helper/#loggers","text":"def loggers ( folders ) View Source def loggers ( folders ) : def inner () : return logger_serials ( folders ) return inner","title":"loggers"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/helper/#retrive","text":"def retrive ( * args , ** kwargs ) View Source def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs )","title":"retrive"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/helper/#retriver","text":"def retriver ( func_loggers ) View Source def retriver ( func_loggers ) : def wrap ( func_extract ) : def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs ) return inner return wrap","title":"retriver"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/","text":"Module hielen3.ext.feature_logger_omnialog_temp.logger View Source # coding=utf-8 from hielen3 import conf from hielen3.feature import HFeature from hielen3.serializaction import ActionSchema from marshmallow import fields from pathlib import Path from .helper import func_loggers , retrive import traceback class ConfigSchema ( ActionSchema ): def _self_hints_ (): try : serials = list ( func_loggers ()[ 'name' ]) except Exception as e : serials = [] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , serial , ** kwargs ): header = { 1 :{ \"name\" : \"battery\" , \"mu\" : \"V\" , \"ordinal\" : 1 }, 2 :{ \"name\" : \"temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 2 }, 4 :{ \"name\" : \"CE01_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 3 }, 5 :{ \"name\" : \"CE01_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 4 }, 6 :{ \"name\" : \"CE01_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 5 }, 7 :{ \"name\" : \"CE02_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 6 }, 8 :{ \"name\" : \"CE02_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 7 }, 9 :{ \"name\" : \"CE02_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 8 }, 10 :{ \"name\" : \"CE03_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 9 }, 11 :{ \"name\" : \"CE03_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 10 }, 12 :{ \"name\" : \"CE03_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 11 }, 13 :{ \"name\" : \"CE04_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 12 }, 14 :{ \"name\" : \"CE04_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 13 }, 15 :{ \"name\" : \"CE04_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 14 } } source = str ( self . __module__ ) for k , w in header . items (): self . parameters . set ( w [ \"name\" ], cache = 'active' , mu = w [ 'mu' ], ordinal = w [ 'ordinal' ], modules = { \"source\" : source }, operator = f \"source.retrive(serials= { serial !r} ,times=times,columns= { k } )\" ) Variables conf Functions func_loggers def func_loggers ( ) View Source def inner () : return logger_serials ( folders ) retrive def retrive ( * args , ** kwargs ) View Source def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs ) Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): try: serials = list ( func_loggers ()[ 'name' ]) except Exception as e: serials =[] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) Ancestors (in MRO) hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self ,** kwargs ): pass def config ( self , serial , ** kwargs ): header ={ 1 :{ \"name\" : \"battery\" , \"mu\" : \"V\" , \"ordinal\" : 1 }, 2 :{ \"name\" : \"temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 2 }, 4 :{ \"name\" : \"CE01_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 3 }, 5 :{ \"name\" : \"CE01_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 4 }, 6 :{ \"name\" : \"CE01_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 5 }, 7 :{ \"name\" : \"CE02_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 6 }, 8 :{ \"name\" : \"CE02_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 7 }, 9 :{ \"name\" : \"CE02_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 8 }, 10 :{ \"name\" : \"CE03_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 9 }, 11 :{ \"name\" : \"CE03_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 10 }, 12 :{ \"name\" : \"CE03_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 11 }, 13 :{ \"name\" : \"CE04_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 12 }, 14 :{ \"name\" : \"CE04_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 13 }, 15 :{ \"name\" : \"CE04_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 14 } } source = str ( self . __module__ ) for k , w in header . items (): self . parameters . set ( w [ \"name\" ], cache = 'active' , mu = w [ 'mu' ], ordinal = w [ 'ordinal' ], modules ={ \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns={k})\" ) Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , serial , ** kwargs ) View Source def config ( self , serial , ** kwargs ) : header = { 1 :{ \"name\" : \"battery\" , \"mu\" : \"V\" , \"ordinal\" : 1 }, 2 :{ \"name\" : \"temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 2 }, 4 :{ \"name\" : \"CE01_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 3 }, 5 :{ \"name\" : \"CE01_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 4 }, 6 :{ \"name\" : \"CE01_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 5 }, 7 :{ \"name\" : \"CE02_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 6 }, 8 :{ \"name\" : \"CE02_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 7 }, 9 :{ \"name\" : \"CE02_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 8 }, 10 :{ \"name\" : \"CE03_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 9 }, 11 :{ \"name\" : \"CE03_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 10 }, 12 :{ \"name\" : \"CE03_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 11 }, 13 :{ \"name\" : \"CE04_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 12 }, 14 :{ \"name\" : \"CE04_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 13 }, 15 :{ \"name\" : \"CE04_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 14 } } source = str ( self . __module__ ) for k , w in header . items () : self . parameters . set ( w [ \"name\" ], cache = 'active' , mu = w [ 'mu' ], ordinal = w [ 'ordinal' ], modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns={k})\" ) create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Logger"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#module-hielen3extfeature_logger_omnialog_templogger","text":"View Source # coding=utf-8 from hielen3 import conf from hielen3.feature import HFeature from hielen3.serializaction import ActionSchema from marshmallow import fields from pathlib import Path from .helper import func_loggers , retrive import traceback class ConfigSchema ( ActionSchema ): def _self_hints_ (): try : serials = list ( func_loggers ()[ 'name' ]) except Exception as e : serials = [] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , serial , ** kwargs ): header = { 1 :{ \"name\" : \"battery\" , \"mu\" : \"V\" , \"ordinal\" : 1 }, 2 :{ \"name\" : \"temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 2 }, 4 :{ \"name\" : \"CE01_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 3 }, 5 :{ \"name\" : \"CE01_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 4 }, 6 :{ \"name\" : \"CE01_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 5 }, 7 :{ \"name\" : \"CE02_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 6 }, 8 :{ \"name\" : \"CE02_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 7 }, 9 :{ \"name\" : \"CE02_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 8 }, 10 :{ \"name\" : \"CE03_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 9 }, 11 :{ \"name\" : \"CE03_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 10 }, 12 :{ \"name\" : \"CE03_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 11 }, 13 :{ \"name\" : \"CE04_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 12 }, 14 :{ \"name\" : \"CE04_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 13 }, 15 :{ \"name\" : \"CE04_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 14 } } source = str ( self . __module__ ) for k , w in header . items (): self . parameters . set ( w [ \"name\" ], cache = 'active' , mu = w [ 'mu' ], ordinal = w [ 'ordinal' ], modules = { \"source\" : source }, operator = f \"source.retrive(serials= { serial !r} ,times=times,columns= { k } )\" )","title":"Module hielen3.ext.feature_logger_omnialog_temp.logger"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#variables","text":"conf","title":"Variables"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#func_loggers","text":"def func_loggers ( ) View Source def inner () : return logger_serials ( folders )","title":"func_loggers"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#retrive","text":"def retrive ( * args , ** kwargs ) View Source def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs )","title":"retrive"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): try: serials = list ( func_loggers ()[ 'name' ]) except Exception as e: serials =[] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#ancestors-in-mro","text":"hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial","title":"Class variables"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#feature","text":"class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self ,** kwargs ): pass def config ( self , serial , ** kwargs ): header ={ 1 :{ \"name\" : \"battery\" , \"mu\" : \"V\" , \"ordinal\" : 1 }, 2 :{ \"name\" : \"temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 2 }, 4 :{ \"name\" : \"CE01_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 3 }, 5 :{ \"name\" : \"CE01_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 4 }, 6 :{ \"name\" : \"CE01_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 5 }, 7 :{ \"name\" : \"CE02_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 6 }, 8 :{ \"name\" : \"CE02_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 7 }, 9 :{ \"name\" : \"CE02_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 8 }, 10 :{ \"name\" : \"CE03_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 9 }, 11 :{ \"name\" : \"CE03_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 10 }, 12 :{ \"name\" : \"CE03_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 11 }, 13 :{ \"name\" : \"CE04_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 12 }, 14 :{ \"name\" : \"CE04_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 13 }, 15 :{ \"name\" : \"CE04_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 14 } } source = str ( self . __module__ ) for k , w in header . items (): self . parameters . set ( w [ \"name\" ], cache = 'active' , mu = w [ 'mu' ], ordinal = w [ 'ordinal' ], modules ={ \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns={k})\" )","title":"Feature"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#config","text":"def config ( self , serial , ** kwargs ) View Source def config ( self , serial , ** kwargs ) : header = { 1 :{ \"name\" : \"battery\" , \"mu\" : \"V\" , \"ordinal\" : 1 }, 2 :{ \"name\" : \"temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 2 }, 4 :{ \"name\" : \"CE01_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 3 }, 5 :{ \"name\" : \"CE01_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 4 }, 6 :{ \"name\" : \"CE01_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 5 }, 7 :{ \"name\" : \"CE02_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 6 }, 8 :{ \"name\" : \"CE02_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 7 }, 9 :{ \"name\" : \"CE02_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 8 }, 10 :{ \"name\" : \"CE03_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 9 }, 11 :{ \"name\" : \"CE03_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 10 }, 12 :{ \"name\" : \"CE03_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 11 }, 13 :{ \"name\" : \"CE04_ch_A\" , \"mu\" : \"mA\" , \"ordinal\" : 12 }, 14 :{ \"name\" : \"CE04_ch_B\" , \"mu\" : \"mA\" , \"ordinal\" : 13 }, 15 :{ \"name\" : \"CE04_temp\" , \"mu\" : \"\u00b0C\" , \"ordinal\" : 14 } } source = str ( self . __module__ ) for k , w in header . items () : self . parameters . set ( w [ \"name\" ], cache = 'active' , mu = w [ 'mu' ], ordinal = w [ 'ordinal' ], modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns={k})\" )","title":"config"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#retrive_1","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#setup","text":"def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_logger_omnialog_temp/logger/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/","text":"Module hielen3.ext.feature_logger_smartbrik4_0 View Source # coding=utf-8 __name__ = \"feature_logger_smartbrik4_0\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from hielen3.ext.feature_datetree_filesystem_source import loggers from .logger import Feature , ConfigSchema __all__ = [ \"Feature\" , \"ConfigSchema\" ] Sub-modules hielen3.ext.feature_logger_smartbrik4_0.helper hielen3.ext.feature_logger_smartbrik4_0.logger Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): try: serials = list ( func_loggers ()[ 'name' ]) except Exception as e: serials =[] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) Ancestors (in MRO) hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , timestamp , serial , header = None , ** kwargs ) header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\" : \"nomechannelN\" , \"mu\" : \"measurement_unitN\" , \"column\" : # N , \"valid_range\" : [ start , end ] } ] View Source def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Index"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#module-hielen3extfeature_logger_smartbrik4_0","text":"View Source # coding=utf-8 __name__ = \"feature_logger_smartbrik4_0\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from hielen3.ext.feature_datetree_filesystem_source import loggers from .logger import Feature , ConfigSchema __all__ = [ \"Feature\" , \"ConfigSchema\" ]","title":"Module hielen3.ext.feature_logger_smartbrik4_0"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#sub-modules","text":"hielen3.ext.feature_logger_smartbrik4_0.helper hielen3.ext.feature_logger_smartbrik4_0.logger","title":"Sub-modules"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): try: serials = list ( func_loggers ()[ 'name' ]) except Exception as e: serials =[] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#ancestors-in-mro","text":"hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial","title":"Class variables"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#feature","text":"class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] )","title":"Feature"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#config","text":"def config ( self , timestamp , serial , header = None , ** kwargs ) header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\" : \"nomechannelN\" , \"mu\" : \"measurement_unitN\" , \"column\" : # N , \"valid_range\" : [ start , end ] } ] View Source def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] )","title":"config"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#retrive","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#setup","text":"def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/helper/","text":"Module hielen3.ext.feature_logger_smartbrik4_0.helper View Source # coding=utf-8 from hielen3.ext.feature_datetree_filesystem_source import loggers , retriver from pandas import read_csv , DataFrame , to_datetime from numpy import isin folders = [ { 'type' : 'smartbrik4.0' , 'path' : 'smartbrik4.0' } ] func_loggers = loggers ( folders ) ''' @retriver(func_loggers) def retrive(path): a=DataFrame([],dtype='float64') try: a=read_csv(path, sep='\\t', skiprows=3,header=None,index_col=[0]).iloc[:,4::3] a=a[~isin(a.index,\"LOCAL TIME\")] a.index=to_datetime(a.index,format='ISO8601') a=a.astype('float') a.index.name='times' a.columns=list(range(1,a.columns.__len__()+1)) a=a.reset_index() #a.columns = [ 'times', *a.columns[1:] ] except Exception as e: #print(\"WARN : \", path) #raise e #DEBUG a=DataFrame([],dtype='float64') pass return a ''' Variables folders Functions func_loggers def func_loggers ( ) View Source def inner () : return logger_serials ( folders ) loggers def loggers ( folders ) View Source def loggers ( folders ) : def inner () : return logger_serials ( folders ) return inner retriver def retriver ( func_loggers ) View Source def retriver ( func_loggers ) : def wrap ( func_extract ) : def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs ) return inner return wrap","title":"Helper"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/helper/#module-hielen3extfeature_logger_smartbrik4_0helper","text":"View Source # coding=utf-8 from hielen3.ext.feature_datetree_filesystem_source import loggers , retriver from pandas import read_csv , DataFrame , to_datetime from numpy import isin folders = [ { 'type' : 'smartbrik4.0' , 'path' : 'smartbrik4.0' } ] func_loggers = loggers ( folders ) ''' @retriver(func_loggers) def retrive(path): a=DataFrame([],dtype='float64') try: a=read_csv(path, sep='\\t', skiprows=3,header=None,index_col=[0]).iloc[:,4::3] a=a[~isin(a.index,\"LOCAL TIME\")] a.index=to_datetime(a.index,format='ISO8601') a=a.astype('float') a.index.name='times' a.columns=list(range(1,a.columns.__len__()+1)) a=a.reset_index() #a.columns = [ 'times', *a.columns[1:] ] except Exception as e: #print(\"WARN : \", path) #raise e #DEBUG a=DataFrame([],dtype='float64') pass return a '''","title":"Module hielen3.ext.feature_logger_smartbrik4_0.helper"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/helper/#variables","text":"folders","title":"Variables"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/helper/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/helper/#func_loggers","text":"def func_loggers ( ) View Source def inner () : return logger_serials ( folders )","title":"func_loggers"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/helper/#loggers","text":"def loggers ( folders ) View Source def loggers ( folders ) : def inner () : return logger_serials ( folders ) return inner","title":"loggers"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/helper/#retriver","text":"def retriver ( func_loggers ) View Source def retriver ( func_loggers ) : def wrap ( func_extract ) : def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs ) return inner return wrap","title":"retriver"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/","text":"Module hielen3.ext.feature_logger_smartbrik4_0.logger View Source # coding=utf-8 from hielen3 import conf from hielen3.feature import HFeature from hielen3.serializaction import ActionSchema from marshmallow import fields from pathlib import Path from pandas import read_csv , DatetimeIndex , Series #from .helper import func_loggers, retrive import json import re import traceback class ConfigSchema ( ActionSchema ): def _self_hints_ (): try : serials = list ( func_loggers ()[ 'name' ]) except Exception as e : serials = [] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) def retrive ( serials = None , times = None , columns = None , ** kwargs ): loggerpath = Path ( conf [ 'incomepath' ], 'smartbrik4_0' , str ( serials ), 'data.csv' ) data = read_csv ( loggerpath ) data [ 'ts' ] = data [ 'ts' ] . astype ( 'datetime64[ms]' ) data = data . set_index ([ 'ts' , 'appId' ])[ 'data' ] . sort_index () . unstack ( 'appId' ) if not isinstance ( times , slice ): times = slice ( None , None , None ) return data [ times ][ columns ] Variables conf Functions retrive def retrive ( serials = None , times = None , columns = None , ** kwargs ) View Source def retrive ( serials = None , times = None , columns = None , ** kwargs ) : loggerpath = Path ( conf [ 'incomepath' ] , 'smartbrik4_0' , str ( serials ), 'data.csv' ) data = read_csv ( loggerpath ) data [ 'ts' ]= data [ 'ts' ] . astype ( 'datetime64[ms]' ) data = data . set_index ( [ 'ts','appId' ] ) [ 'data' ] . sort_index (). unstack ( 'appId' ) if not isinstance ( times , slice ) : times = slice ( None , None , None ) return data [ times ][ columns ] Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): try: serials = list ( func_loggers ()[ 'name' ]) except Exception as e: serials =[] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) Ancestors (in MRO) hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , timestamp , serial , header = None , ** kwargs ) header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\" : \"nomechannelN\" , \"mu\" : \"measurement_unitN\" , \"column\" : # N , \"valid_range\" : [ start , end ] } ] View Source def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Logger"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#module-hielen3extfeature_logger_smartbrik4_0logger","text":"View Source # coding=utf-8 from hielen3 import conf from hielen3.feature import HFeature from hielen3.serializaction import ActionSchema from marshmallow import fields from pathlib import Path from pandas import read_csv , DatetimeIndex , Series #from .helper import func_loggers, retrive import json import re import traceback class ConfigSchema ( ActionSchema ): def _self_hints_ (): try : serials = list ( func_loggers ()[ 'name' ]) except Exception as e : serials = [] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) def retrive ( serials = None , times = None , columns = None , ** kwargs ): loggerpath = Path ( conf [ 'incomepath' ], 'smartbrik4_0' , str ( serials ), 'data.csv' ) data = read_csv ( loggerpath ) data [ 'ts' ] = data [ 'ts' ] . astype ( 'datetime64[ms]' ) data = data . set_index ([ 'ts' , 'appId' ])[ 'data' ] . sort_index () . unstack ( 'appId' ) if not isinstance ( times , slice ): times = slice ( None , None , None ) return data [ times ][ columns ]","title":"Module hielen3.ext.feature_logger_smartbrik4_0.logger"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#variables","text":"conf","title":"Variables"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#retrive","text":"def retrive ( serials = None , times = None , columns = None , ** kwargs ) View Source def retrive ( serials = None , times = None , columns = None , ** kwargs ) : loggerpath = Path ( conf [ 'incomepath' ] , 'smartbrik4_0' , str ( serials ), 'data.csv' ) data = read_csv ( loggerpath ) data [ 'ts' ]= data [ 'ts' ] . astype ( 'datetime64[ms]' ) data = data . set_index ( [ 'ts','appId' ] ) [ 'data' ] . sort_index (). unstack ( 'appId' ) if not isinstance ( times , slice ) : times = slice ( None , None , None ) return data [ times ][ columns ]","title":"retrive"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): try: serials = list ( func_loggers ()[ 'name' ]) except Exception as e: serials =[] return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , serials ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#ancestors-in-mro","text":"hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial","title":"Class variables"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#feature","text":"class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] )","title":"Feature"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#config","text":"def config ( self , timestamp , serial , header = None , ** kwargs ) header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\" : \"nomechannelN\" , \"mu\" : \"measurement_unitN\" , \"column\" : # N , \"valid_range\" : [ start , end ] } ] View Source def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(serials=SER,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] )","title":"config"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#retrive_1","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#setup","text":"def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_logger_smartbrik4_0/logger/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_logger_winecap/","text":"Module hielen3.ext.feature_logger_winecap View Source # coding=utf-8 __name__ = \"feature_logger_winecap\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from .logger import Feature , ConfigSchema __all__ = [ \"Feature\" , \"ConfigSchema\" ] Sub-modules hielen3.ext.feature_logger_winecap.helper hielen3.ext.feature_logger_winecap.logger Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , [] ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) Ancestors (in MRO) hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : print ( \"INFO_NEW:\" , info_new ) try : gwserial = info_new . pop ( \"gwserial\" ) except Exception as e : gwserial = None try : apikey = f '#{info_new.pop(\"apikey\")}' except Exception as e : apikey = None try : wsdl = info_new . pop ( \"wsdl\" ) except Exception as e : wsdl = None info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ], \"GW\" : gwserial , \"KEY\" : apikey , \"wsdl\" : wsdl }, operator = f \"source.retrive(serials=SER,columns=COL,gateway=GW, key=KEY, wsdl=wsdl, times=times)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\" Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , timestamp , serial , header = None , ** kwargs ) header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\" : \"nomechannel2\" , \"mu\" : \"measurement_unit2\" , \"column\" : #2 , \"valid_range\" : [ start , end ] \"gwserial\" : \"...\" \"apikey\" :... \"wdsl\" :... }, ... { \"channel\" : \"nomechannelN\" , \"mu\" : \"measurement_unitN\" , \"column\" : # N , \"valid_range\" : [ start , end ] \"gwserial\" : \"...\" \"apikey\" :... \"wdsl\" :... } ] View Source def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : print ( \"INFO_NEW:\" , info_new ) try : gwserial = info_new . pop ( \"gwserial\" ) except Exception as e : gwserial = None try : apikey = f '#{info_new.pop(\"apikey\")}' except Exception as e : apikey = None try : wsdl = info_new . pop ( \"wsdl\" ) except Exception as e : wsdl = None info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ], \"GW\" : gwserial , \"KEY\" : apikey , \"wsdl\" : wsdl }, operator = f \"source.retrive(serials=SER,columns=COL,gateway=GW, key=KEY, wsdl=wsdl, times=times)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\" create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Index"},{"location":"reference/hielen3/ext/feature_logger_winecap/#module-hielen3extfeature_logger_winecap","text":"View Source # coding=utf-8 __name__ = \"feature_logger_winecap\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from .logger import Feature , ConfigSchema __all__ = [ \"Feature\" , \"ConfigSchema\" ]","title":"Module hielen3.ext.feature_logger_winecap"},{"location":"reference/hielen3/ext/feature_logger_winecap/#sub-modules","text":"hielen3.ext.feature_logger_winecap.helper hielen3.ext.feature_logger_winecap.logger","title":"Sub-modules"},{"location":"reference/hielen3/ext/feature_logger_winecap/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_logger_winecap/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , [] ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_logger_winecap/#ancestors-in-mro","text":"hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_winecap/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial","title":"Class variables"},{"location":"reference/hielen3/ext/feature_logger_winecap/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_logger_winecap/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_logger_winecap/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_winecap/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_winecap/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_logger_winecap/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_logger_winecap/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_logger_winecap/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_logger_winecap/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_logger_winecap/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_logger_winecap/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_logger_winecap/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_logger_winecap/#feature","text":"class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : print ( \"INFO_NEW:\" , info_new ) try : gwserial = info_new . pop ( \"gwserial\" ) except Exception as e : gwserial = None try : apikey = f '#{info_new.pop(\"apikey\")}' except Exception as e : apikey = None try : wsdl = info_new . pop ( \"wsdl\" ) except Exception as e : wsdl = None info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ], \"GW\" : gwserial , \"KEY\" : apikey , \"wsdl\" : wsdl }, operator = f \"source.retrive(serials=SER,columns=COL,gateway=GW, key=KEY, wsdl=wsdl, times=times)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\"","title":"Feature"},{"location":"reference/hielen3/ext/feature_logger_winecap/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_winecap/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_winecap/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_winecap/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_logger_winecap/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_logger_winecap/#config","text":"def config ( self , timestamp , serial , header = None , ** kwargs ) header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\" : \"nomechannel2\" , \"mu\" : \"measurement_unit2\" , \"column\" : #2 , \"valid_range\" : [ start , end ] \"gwserial\" : \"...\" \"apikey\" :... \"wdsl\" :... }, ... { \"channel\" : \"nomechannelN\" , \"mu\" : \"measurement_unitN\" , \"column\" : # N , \"valid_range\" : [ start , end ] \"gwserial\" : \"...\" \"apikey\" :... \"wdsl\" :... } ] View Source def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : print ( \"INFO_NEW:\" , info_new ) try : gwserial = info_new . pop ( \"gwserial\" ) except Exception as e : gwserial = None try : apikey = f '#{info_new.pop(\"apikey\")}' except Exception as e : apikey = None try : wsdl = info_new . pop ( \"wsdl\" ) except Exception as e : wsdl = None info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ], \"GW\" : gwserial , \"KEY\" : apikey , \"wsdl\" : wsdl }, operator = f \"source.retrive(serials=SER,columns=COL,gateway=GW, key=KEY, wsdl=wsdl, times=times)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\"","title":"config"},{"location":"reference/hielen3/ext/feature_logger_winecap/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_logger_winecap/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_logger_winecap/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_logger_winecap/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_logger_winecap/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_logger_winecap/#retrive","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_logger_winecap/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_logger_winecap/#setup","text":"def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_logger_winecap/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_logger_winecap/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_logger_winecap/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_logger_winecap/helper/","text":"Module hielen3.ext.feature_logger_winecap.helper View Source # coding=utf-8 from hielen3.ext.feature_datetree_filesystem_source import loggers , retriver from pandas import read_csv , DataFrame folders = [ { 'type' : 'capetti' , 'path' : 'capetti' } ] func_loggers = loggers ( folders ) @retriver ( func_loggers ) def retrive ( path ): a = DataFrame ([], dtype = 'float64' ) try : a = read_csv ( path , sep = ' \\t ' , skiprows = 3 , header = None , parse_dates = [ 0 ], index_col = [ 0 ]) . iloc [:, 4 :: 3 ] a . index . name = 'times' a . columns = list ( range ( 1 , a . columns . __len__ () + 1 )) a = a . reset_index () #a.columns = [ 'times', *a.columns[1:] ] except Exception as e : #print(\"WARN : \", path) #raise e #DEBUG pass return a Variables folders Functions func_loggers def func_loggers ( ) View Source def inner () : return logger_serials ( folders ) loggers def loggers ( folders ) View Source def loggers ( folders ) : def inner () : return logger_serials ( folders ) return inner retrive def retrive ( * args , ** kwargs ) View Source def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs ) retriver def retriver ( func_loggers ) View Source def retriver ( func_loggers ) : def wrap ( func_extract ) : def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs ) return inner return wrap","title":"Helper"},{"location":"reference/hielen3/ext/feature_logger_winecap/helper/#module-hielen3extfeature_logger_winecaphelper","text":"View Source # coding=utf-8 from hielen3.ext.feature_datetree_filesystem_source import loggers , retriver from pandas import read_csv , DataFrame folders = [ { 'type' : 'capetti' , 'path' : 'capetti' } ] func_loggers = loggers ( folders ) @retriver ( func_loggers ) def retrive ( path ): a = DataFrame ([], dtype = 'float64' ) try : a = read_csv ( path , sep = ' \\t ' , skiprows = 3 , header = None , parse_dates = [ 0 ], index_col = [ 0 ]) . iloc [:, 4 :: 3 ] a . index . name = 'times' a . columns = list ( range ( 1 , a . columns . __len__ () + 1 )) a = a . reset_index () #a.columns = [ 'times', *a.columns[1:] ] except Exception as e : #print(\"WARN : \", path) #raise e #DEBUG pass return a","title":"Module hielen3.ext.feature_logger_winecap.helper"},{"location":"reference/hielen3/ext/feature_logger_winecap/helper/#variables","text":"folders","title":"Variables"},{"location":"reference/hielen3/ext/feature_logger_winecap/helper/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/ext/feature_logger_winecap/helper/#func_loggers","text":"def func_loggers ( ) View Source def inner () : return logger_serials ( folders )","title":"func_loggers"},{"location":"reference/hielen3/ext/feature_logger_winecap/helper/#loggers","text":"def loggers ( folders ) View Source def loggers ( folders ) : def inner () : return logger_serials ( folders ) return inner","title":"loggers"},{"location":"reference/hielen3/ext/feature_logger_winecap/helper/#retrive","text":"def retrive ( * args , ** kwargs ) View Source def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs )","title":"retrive"},{"location":"reference/hielen3/ext/feature_logger_winecap/helper/#retriver","text":"def retriver ( func_loggers ) View Source def retriver ( func_loggers ) : def wrap ( func_extract ) : def inner ( * args , ** kwargs ) : return retrive ( * args , func_extract = func_extract , func_loggers = func_loggers , ** kwargs ) return inner return wrap","title":"retriver"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/","text":"Module hielen3.ext.feature_logger_winecap.logger View Source # coding=utf-8 from hielen3 import conf from hielen3.feature import HFeature from hielen3.serializaction import ActionSchema from marshmallow import fields from pathlib import Path import json import traceback from pandas import DataFrame , Series , to_datetime , concat from zeep import Client from zeep.helpers import serialize_object from concurrent.futures import ThreadPoolExecutor from functools import wraps from time import time from hielen3.utils import isot2ut from datetime import datetime ''' sudo apt-get install libxml2-dev libxslt1-dev pip install lxml==4.2.5 zeep ''' class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , [] ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : print ( \"INFO_NEW:\" , info_new ) try : gwserial = info_new . pop ( \"gwserial\" ) except Exception as e : gwserial = None try : apikey = f '# { info_new . pop ( \"apikey\" ) } ' except Exception as e : apikey = None try : wsdl = info_new . pop ( \"wsdl\" ) except Exception as e : wsdl = None info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ], \"GW\" : gwserial , \"KEY\" : apikey , \"wsdl\" : wsdl }, operator = f \"source.retrive(serials=SER,columns=COL,gateway=GW, key=KEY, wsdl=wsdl, times=times)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\" def retrive ( serials = None , columns = None , gateway = None , key = None , wsdl = None , times = None ): if isinstance ( times , slice ): start = times . start stop = times . stop else : start = times stop = None if start is None : start = 1 if stop is None : stop = int ( time ()) if isinstance ( start ,( str , datetime )): start = int ( datetime . fromisoformat ( str ( start )) . timestamp ()) if isinstance ( stop ,( str , datetime )): stop = int ( datetime . fromisoformat ( str ( stop )) . timestamp ()) ahead = True out = DataFrame () key = str ( key ) if key . startswith ( \"#\" ): key = key [ 1 :] if wsdl is None : wsdl = 'http://www.winecap.it/winecapws.wsdl' client = Client ( wsdl = wsdl ) gch = client . service . getChannelHistory while ahead : print ( key , gateway , serials , columns , start , stop ) u = DataFrame ( serialize_object ( gch ( key , gateway , serials , columns , start , stop ))) if u . __len__ () < 1024 : ahead = False if u . __len__ () > 0 : u = u . set_index ([ 'timeStamp' ])[ 'value' ] u . index . names = [ 'timestamp' ] start = u . index . max () + 1 out = concat ([ out , u ]) out = out . sort_index () out . columns = [ f \" { serials } _ { columns } \" ] out . sort_index () out . index = to_datetime ( out . index , unit = 's' ) return out Variables conf Functions retrive def retrive ( serials = None , columns = None , gateway = None , key = None , wsdl = None , times = None ) View Source def retrive ( serials = None , columns = None , gateway = None , key = None , wsdl = None , times = None ) : if isinstance ( times , slice ) : start = times . start stop = times . stop else : start = times stop = None if start is None : start = 1 if stop is None : stop = int ( time ()) if isinstance ( start , ( str , datetime )) : start = int ( datetime . fromisoformat ( str ( start )) . timestamp ()) if isinstance ( stop , ( str , datetime )) : stop = int ( datetime . fromisoformat ( str ( stop )) . timestamp ()) ahead = True out = DataFrame () key = str ( key ) if key . startswith ( \"#\" ) : key = key [ 1 :] if wsdl is None : wsdl = 'http://www.winecap.it/winecapws.wsdl' client = Client ( wsdl = wsdl ) gch = client . service . getChannelHistory while ahead : print ( key , gateway , serials , columns , start , stop ) u = DataFrame ( serialize_object ( gch ( key , gateway , serials , columns , start , stop ))) if u . __len__ () < 1024 : ahead = False if u . __len__ () > 0 : u = u . set_index ( [ 'timeStamp' ] ) [ 'value' ] u . index . names = [ 'timestamp' ] start = u . index . max () + 1 out = concat ( [ out , u ] ) out = out . sort_index () out . columns = [ f \"{serials}_{columns}\" ] out . sort_index () out . index = to_datetime ( out . index , unit = 's' ) return out Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , [] ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) Ancestors (in MRO) hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : print ( \"INFO_NEW:\" , info_new ) try : gwserial = info_new . pop ( \"gwserial\" ) except Exception as e : gwserial = None try : apikey = f '#{info_new.pop(\"apikey\")}' except Exception as e : apikey = None try : wsdl = info_new . pop ( \"wsdl\" ) except Exception as e : wsdl = None info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ], \"GW\" : gwserial , \"KEY\" : apikey , \"wsdl\" : wsdl }, operator = f \"source.retrive(serials=SER,columns=COL,gateway=GW, key=KEY, wsdl=wsdl, times=times)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\" Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , timestamp , serial , header = None , ** kwargs ) header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\" : \"nomechannel2\" , \"mu\" : \"measurement_unit2\" , \"column\" : #2 , \"valid_range\" : [ start , end ] \"gwserial\" : \"...\" \"apikey\" :... \"wdsl\" :... }, ... { \"channel\" : \"nomechannelN\" , \"mu\" : \"measurement_unitN\" , \"column\" : # N , \"valid_range\" : [ start , end ] \"gwserial\" : \"...\" \"apikey\" :... \"wdsl\" :... } ] View Source def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : print ( \"INFO_NEW:\" , info_new ) try : gwserial = info_new . pop ( \"gwserial\" ) except Exception as e : gwserial = None try : apikey = f '#{info_new.pop(\"apikey\")}' except Exception as e : apikey = None try : wsdl = info_new . pop ( \"wsdl\" ) except Exception as e : wsdl = None info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ], \"GW\" : gwserial , \"KEY\" : apikey , \"wsdl\" : wsdl }, operator = f \"source.retrive(serials=SER,columns=COL,gateway=GW, key=KEY, wsdl=wsdl, times=times)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\" create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Logger"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#module-hielen3extfeature_logger_winecaplogger","text":"View Source # coding=utf-8 from hielen3 import conf from hielen3.feature import HFeature from hielen3.serializaction import ActionSchema from marshmallow import fields from pathlib import Path import json import traceback from pandas import DataFrame , Series , to_datetime , concat from zeep import Client from zeep.helpers import serialize_object from concurrent.futures import ThreadPoolExecutor from functools import wraps from time import time from hielen3.utils import isot2ut from datetime import datetime ''' sudo apt-get install libxml2-dev libxslt1-dev pip install lxml==4.2.5 zeep ''' class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , [] ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : print ( \"INFO_NEW:\" , info_new ) try : gwserial = info_new . pop ( \"gwserial\" ) except Exception as e : gwserial = None try : apikey = f '# { info_new . pop ( \"apikey\" ) } ' except Exception as e : apikey = None try : wsdl = info_new . pop ( \"wsdl\" ) except Exception as e : wsdl = None info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ], \"GW\" : gwserial , \"KEY\" : apikey , \"wsdl\" : wsdl }, operator = f \"source.retrive(serials=SER,columns=COL,gateway=GW, key=KEY, wsdl=wsdl, times=times)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\" def retrive ( serials = None , columns = None , gateway = None , key = None , wsdl = None , times = None ): if isinstance ( times , slice ): start = times . start stop = times . stop else : start = times stop = None if start is None : start = 1 if stop is None : stop = int ( time ()) if isinstance ( start ,( str , datetime )): start = int ( datetime . fromisoformat ( str ( start )) . timestamp ()) if isinstance ( stop ,( str , datetime )): stop = int ( datetime . fromisoformat ( str ( stop )) . timestamp ()) ahead = True out = DataFrame () key = str ( key ) if key . startswith ( \"#\" ): key = key [ 1 :] if wsdl is None : wsdl = 'http://www.winecap.it/winecapws.wsdl' client = Client ( wsdl = wsdl ) gch = client . service . getChannelHistory while ahead : print ( key , gateway , serials , columns , start , stop ) u = DataFrame ( serialize_object ( gch ( key , gateway , serials , columns , start , stop ))) if u . __len__ () < 1024 : ahead = False if u . __len__ () > 0 : u = u . set_index ([ 'timeStamp' ])[ 'value' ] u . index . names = [ 'timestamp' ] start = u . index . max () + 1 out = concat ([ out , u ]) out = out . sort_index () out . columns = [ f \" { serials } _ { columns } \" ] out . sort_index () out . index = to_datetime ( out . index , unit = 's' ) return out","title":"Module hielen3.ext.feature_logger_winecap.logger"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#variables","text":"conf","title":"Variables"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#retrive","text":"def retrive ( serials = None , columns = None , gateway = None , key = None , wsdl = None , times = None ) View Source def retrive ( serials = None , columns = None , gateway = None , key = None , wsdl = None , times = None ) : if isinstance ( times , slice ) : start = times . start stop = times . stop else : start = times stop = None if start is None : start = 1 if stop is None : stop = int ( time ()) if isinstance ( start , ( str , datetime )) : start = int ( datetime . fromisoformat ( str ( start )) . timestamp ()) if isinstance ( stop , ( str , datetime )) : stop = int ( datetime . fromisoformat ( str ( stop )) . timestamp ()) ahead = True out = DataFrame () key = str ( key ) if key . startswith ( \"#\" ) : key = key [ 1 :] if wsdl is None : wsdl = 'http://www.winecap.it/winecapws.wsdl' client = Client ( wsdl = wsdl ) gch = client . service . getChannelHistory while ahead : print ( key , gateway , serials , columns , start , stop ) u = DataFrame ( serialize_object ( gch ( key , gateway , serials , columns , start , stop ))) if u . __len__ () < 1024 : ahead = False if u . __len__ () > 0 : u = u . set_index ( [ 'timeStamp' ] ) [ 'value' ] u . index . names = [ 'timestamp' ] start = u . index . max () + 1 out = concat ( [ out , u ] ) out = out . sort_index () out . columns = [ f \"{serials}_{columns}\" ] out . sort_index () out . index = to_datetime ( out . index , unit = 's' ) return out","title":"retrive"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , [] ], 1 :[ \"header\" , \"Logger header if needed\" , False , \"\" ] }, } serial = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#ancestors-in-mro","text":"hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts serial","title":"Class variables"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#feature","text":"class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): pass def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : print ( \"INFO_NEW:\" , info_new ) try : gwserial = info_new . pop ( \"gwserial\" ) except Exception as e : gwserial = None try : apikey = f '#{info_new.pop(\"apikey\")}' except Exception as e : apikey = None try : wsdl = info_new . pop ( \"wsdl\" ) except Exception as e : wsdl = None info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ], \"GW\" : gwserial , \"KEY\" : apikey , \"wsdl\" : wsdl }, operator = f \"source.retrive(serials=SER,columns=COL,gateway=GW, key=KEY, wsdl=wsdl, times=times)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\"","title":"Feature"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#config","text":"def config ( self , timestamp , serial , header = None , ** kwargs ) header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\" : \"nomechannel2\" , \"mu\" : \"measurement_unit2\" , \"column\" : #2 , \"valid_range\" : [ start , end ] \"gwserial\" : \"...\" \"apikey\" :... \"wdsl\" :... }, ... { \"channel\" : \"nomechannelN\" , \"mu\" : \"measurement_unitN\" , \"column\" : # N , \"valid_range\" : [ start , end ] \"gwserial\" : \"...\" \"apikey\" :... \"wdsl\" :... } ] View Source def config ( self , timestamp , serial , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] \"gwserial\": \"...\" \"apikey\":... \"wdsl\":... } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e for info_new in infos : print ( \"INFO_NEW:\" , info_new ) try : gwserial = info_new . pop ( \"gwserial\" ) except Exception as e : gwserial = None try : apikey = f '#{info_new.pop(\"apikey\")}' except Exception as e : apikey = None try : wsdl = info_new . pop ( \"wsdl\" ) except Exception as e : wsdl = None info = dict ( cache = 'old' , valid_range = None , view_range = None , thresholds = None ) info . update ( info_new ) self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"SER\" : serial , \"COL\" : info [ \"column\" ], \"GW\" : gwserial , \"KEY\" : apikey , \"wsdl\" : wsdl }, operator = f \"source.retrive(serials=SER,columns=COL,gateway=GW, key=KEY, wsdl=wsdl, times=times)\" , valid_range = info [ 'valid_range' ], view_range = info [ 'view_range' ], thresholds = info [ 'thresholds' ] ) \"\"\" self.parameters.set( \"current_1\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=5)\") self.parameters.set( \"current_2\", cache='active', mu='mA', modules={\"source\":source}, operator=f\"source.retrive(serials={serial!r},times=times,columns=6)\") \"\"\"","title":"config"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#retrive_1","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#setup","text":"def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_logger_winecap/logger/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_rfilogger/","text":"Module hielen3.ext.feature_rfilogger View Source # coding=utf-8 __name__ = \"Feature_RfiLogger\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from .rfilogger import Feature , ConfigSchema , retrive __all__ = [ \"Feature\" , \"ConfigSchema\" , \"retrive\" ] Sub-modules hielen3.ext.feature_rfilogger.rfilogger hielen3.ext.feature_rfilogger.rfilogger_good Functions retrive def retrive ( serials = None , times = None , columns = None , folder = 'gestecno_rfi/data' , func = None , ** kwargs ) View Source def retrive ( serials = None , times = None , columns = None , folder = 'gestecno_rfi/data' , func = None , ** kwargs ) : f = Path ( conf [ 'incomepath' ] ) / folder if not f . is_dir () : f = Path ( conf [ 'incomepath' ] ) / 'incomes' folder = f def __extract_gestecno__ ( path ) : a = DataFrame ( [] , dtype = 'float64' ) try : a = read_csv ( path , skiprows = 2 , parse_dates = True , header = None ) if a . empty : a = read_csv ( path , parse_dates = True , header = None ) a = a [ a[0 ] . apply ( lambda x : match ( '^\\d{4}-\\d{2}' , x )). notna () ] a . columns = [ 'times', *a.columns[1: ] ] except Exception as e : pass return a if func is None : func = __extract_gestecno__ if serials is None : serials = slice ( None , None ) if isinstance ( serials , str ) : #serials = slice ( serials , serials ) serials =[ serials ] if isinstance ( times , datetime ) : times = str ( times ) if times is None or isinstance ( times , str ) : times = slice ( times , None , None ) start = times . start stop = times . stop if start is not None : orig_start = start start = str ( datetime64 ( start ) - timedelta64 ( 1 , 'D' )) else : orig_start = None if start is not None : datestart = str ( datetime . fromisoformat ( start ). date ()) else : datestart = None times = slice ( start , stop ) orig_times = slice ( orig_start , stop ) dates = slice ( datestart , stop ) #print ( times , \"\\n\" , orig_times , \"\\n\" , dates ) paths = Series ( glob ( f '{folder}/*/*/*/*' ), dtype = 'object' ). apply ( Path ) sertime = DataFrame ( paths . apply ( lambda x : ( x . parts [ -4 ] , str ( datetime ( * map ( int , x . parts [ -3: ] ))) ) ). explode (). values . reshape ( paths . __len__ (), 2 ), columns =[ 'serial','times' ] ) sertime [ 'path' ]= paths . apply ( lambda x : str ( x / \"*\" )) sertime = sertime . set_index ( [ 'serial','times' ] ). sort_index () df = DataFrame () try : sertime = sertime . to_frame () except Exception as e : pass if isinstance ( serials , ( list , set , tuple )) : serials = list ( sertime . index [ sertime.index.isin(serials,level=0) ] . droplevel ( 1 ). drop_duplicates () ) if not serials . __len__ () : return df try : sertime = sertime . loc [ (serials,dates), : ] except KeyError as e : return df for serial , paths in sertime . groupby ( 'serial' ) : u = concat ( paths [ 'path' ] . apply ( glob ). explode (). apply ( func ). values ) u [ 'serial' ]= serial u = u . set_index ( [ 'serial','times' ] ) df = concat ( [ df,u ] ) if columns is None : columns = list ( df . columns ) if not isinstance ( columns ,( list , tuple , set )) : columns =[ columns ] columns = list ( columns ) df = df [ columns ] . sort_index (). loc [ (serials, times), : ] df = df . loc [ (serials,times), : ] try : if serials . __len__ () == 1 : df = df . droplevel ( 'serial' , axis = 0 ). squeeze () ## FILTRO LEVEL 1 , LEVEL 2 if 5 in columns or 6 in columns : df = calc . filter ( df , window = 12 ) [ orig_times ] df = df . to_frame () except Exception as e : pass return df Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , logger_serials ()] }, \"Instruments info\" : { 0 :[ \"radar_1\" , \"Radar 1 polynomial coefficients\" , False , None ], 1 :[ \"radar_2\" , \"Radar 2 polynomial coefficients\" , False , None ], 2 :[ \"pluviometer\" , \"Pluviometer polynomial coefficients\" , False , None ], 3 :[ \"h_radar_1\" , \"Quote over sea level of the radar 1\" , False , None ], 4 :[ \"h_radar_2\" , \"Quote over sea level of the radar 2\" , False , None ], 5 :[ \"h_min_span_1\" , \"Quote over the sea level of the minimum free span\" , False , None ], 6 :[ \"h_min_span_2\" , \"Quote over the sea level of the minimum free span\" , False , None ], 7 :[ \"h_riverbed\" , \"Quote over the sea level of the riverbed\" , False , None ], 8 :[ \"h_threshold_al\" , \"Alert quote level\" , False , None ], 9 :[ \"h_threshold_wa\" , \"Warning quote level\" , False , None ] } } serial = fields . String ( required = True , allow_none = False ) radar_1 = PolyCoeff ( default =[ 0 , 1 ], required = False , allow_none = True ) radar_2 = PolyCoeff ( default =[ 0 , 1 ], required = False , allow_none = True ) pluviometer = PolyCoeff ( default =[ 0 , 0.2 ], reqired = False , allow_none = True ) h_radar_1 = fields . Number ( required = True , allow_none = True ) h_radar_2 = fields . Number ( required = True , allow_none = True ) h_min_span_1 = fields . Number ( required = True , allow_none = True ) h_min_span_2 = fields . Number ( required = True , allow_none = True ) h_riverbed = fields . Number ( required = True , allow_none = True ) h_threshold_al = fields . Number ( required = True , allow_none = True ) h_threshold_wa = fields . Number ( required = True , allow_none = True ) Ancestors (in MRO) hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages h_min_span_1 h_min_span_2 h_radar_1 h_radar_2 h_riverbed h_threshold_al h_threshold_wa opts pluviometer radar_1 radar_2 serial Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) RfiLogger View Source class Feature ( HFeature ): ''' RfiLogger ''' def setup ( self , ** kwargs ): pass def config ( self , serial , radar_1 = None , radar_2 = None , pluviometer = None , h_radar_1 = None , h_radar_2 = None , h_min_span_1 = None , h_min_span_2 = None , h_riverbed = None , h_threshold_al = None , h_threshold_wa = None , ** kwargs ): \"\"\" Timestamp, 0:Alarm, 1:Temp_\u00b0C, 2:Humid_%, 3:ADC 0_V, 4:lev1_m, 5:lev2_m, 6:pio1 \"\"\" source = str ( self . __module__ ) try : timestamp = kwargs [ \"timestamp\" ] except KeyError as e : timestamp = None if not self . parameters . __len__ (): if radar_1 is None : radar_1 = \"\" if radar_2 is None : radar_2 = \"\" if h_radar_1 is None : h_radar_1 = 0 if h_radar_2 is None : h_radar_2 = 0 if h_min_span_1 is None : h_min_span_1 = 0 if h_min_span_2 is None : h_min_span_2 = 0 if not h_riverbed is None : buffer = ( h_radar_1 - h_riverbed ) * 0.01 view_range = [ h_riverbed - buffer , h_radar_1 + buffer ] else : view_range = None thresholds = [{ \"label\" : \"Sensor Height\" , \"ttype\" : \"UPPER\" , \"value\" : h_radar_1 , \"color\" : \"#505050\" }] if h_threshold_al is not None : threshold_al = { \"label\" : \"Alert\" , \"ttype\" : \"UPPER\" , \"value\" : h_threshold_al , \"color\" : \"#FF0000\" } thresholds = [ threshold_al , * thresholds ] if h_threshold_wa is not None : threshold_wa = { \"label\" : \"Warning\" , \"ttype\" : \"UPPER\" , \"value\" : h_threshold_wa , \"color\" : \"#FFA500\" } thresholds = [ threshold_wa , * thresholds ] if h_min_span_1 is not None : threshold_sp = { \"label\" : \"Minimal Span Height\" , \"ttype\" : \"UPPER\" , \"value\" : h_min_span_1 , \"color\" : \"#000000\" } thresholds = [ threshold_sp , * thresholds ] threshold_ob = [{ \"label\" : \"Obstruction\" , \"ttype\" : \"LOWER\" , \"value\" : 0 , \"color\" : \"#FF0000\" }] buffer_ob = ( h_min_span_1 - h_riverbed ) * 0.001 view_range_ob = [ 0 - buffer_ob ,( h_min_span_1 - h_riverbed ) + buffer_ob ] self . parameters . set ( \"camera\" , cache = 'inactive' , ordinal = 100 , modules = { \"hls\" : \"hielen3.tools.hls_facility\" }, operator = f \"hls.start_stream(resource={serial!r})\" , capability = \"stream\" ) self . parameters . set ( \"temperature\" , cache = 'active' , mu = '\u00b0C' , ordinal = 9 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=2)\" ) self . parameters . set ( \"humidity\" , cache = 'active' , mu = ' %% ' , ordinal = 10 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=3)\" ) self . parameters . set ( \"battery\" , cache = 'active' , mu = 'V' , ordinal = 11 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=4)\" ) self . parameters . set ( \"radar 1\" , cache = 'active' , mu = 'mA' , ordinal = 6 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=5)\" ) self . parameters . set ( \"radar 2\" , cache = 'active' , mu = 'mA' , ordinal = 7 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=6)\" ) self . parameters . set ( \"pluviometer\" , cache = 'active' , mu = 'count' , ordinal = 8 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=7)\" ) if pluviometer is not None : self . parameters . set ( 'rain' , cache = 'active' , mu = 'mm/h' , ordinal = 5 , first = timestamp , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"pluviometer\" ] . uuid }, operator = f \"calc.instant_velocity(calc.poly_trans2(S0,{pluviometer}))\" ) if radar_1 is not None : self . parameters . set ( 'level 1' , cache = 'active' , mu = \"m.s.l.m.\" , ordinal = 3 , first = timestamp , view_range = view_range , thresholds = thresholds , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"radar 1\" ] . uuid }, operator = f \"{h_radar_1} - calc.poly_trans2(S0,{radar_1})\" ) self . parameters . set ( 'free span 1' , cache = 'active' , mu = \"m\" , ordinal = 1 , thresholds = threshold_ob , first = timestamp , view_range = view_range_ob , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"level 1\" ] . uuid }, operator = f \"{h_min_span_1} - S0\" ) if radar_2 is not None : self . parameters . set ( 'level 2' , cache = 'active' , mu = \"m.s.l.m.\" , ordinal = 4 , first = timestamp , view_range = view_range , thresholds = thresholds , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"radar 2\" ] . uuid }, operator = f \"{h_radar_2} - calc.poly_trans2(S0,{radar_2})\" ) self . parameters . set ( 'free span 2' , cache = 'active' , mu = \"m\" , ordinal = 2 , first = timestamp , thresholds = threshold_ob , view_range = view_range_ob , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"level 2\" ] . uuid }, operator = f \"{h_min_span_2}-S0\" ) Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , serial , radar_1 = None , radar_2 = None , pluviometer = None , h_radar_1 = None , h_radar_2 = None , h_min_span_1 = None , h_min_span_2 = None , h_riverbed = None , h_threshold_al = None , h_threshold_wa = None , ** kwargs ) Timestamp, 0:Alarm, 1:Temp_\u00b0C, 2:Humid_%, 3:ADC 0_V, 4:lev1_m, 5:lev2_m, 6:pio1 View Source def config ( self , serial , radar_1 = None , radar_2 = None , pluviometer = None , h_radar_1 = None , h_radar_2 = None , h_min_span_1 = None , h_min_span_2 = None , h_riverbed = None , h_threshold_al = None , h_threshold_wa = None , ** kwargs ): \"\"\" Timestamp, 0:Alarm, 1:Temp_\u00b0C, 2:Humid_%, 3:ADC 0_V, 4:lev1_m, 5:lev2_m, 6:pio1 \"\"\" source = str ( self . __module__ ) try : timestamp = kwargs [ \"timestamp\" ] except KeyError as e : timestamp = None if not self . parameters . __len__ (): if radar_1 is None : radar_1 = \"\" if radar_2 is None : radar_2 = \"\" if h_radar_1 is None : h_radar_1 = 0 if h_radar_2 is None : h_radar_2 = 0 if h_min_span_1 is None : h_min_span_1 = 0 if h_min_span_2 is None : h_min_span_2 = 0 if not h_riverbed is None : buffer = ( h_radar_1 - h_riverbed ) * 0.01 view_range = [ h_riverbed - buffer , h_radar_1 + buffer ] else : view_range = None thresholds = [{ \"label\" : \"Sensor Height\" , \"ttype\" : \"UPPER\" , \"value\" : h_radar_1 , \"color\" : \"#505050\" }] if h_threshold_al is not None : threshold_al = { \"label\" : \"Alert\" , \"ttype\" : \"UPPER\" , \"value\" : h_threshold_al , \"color\" : \"#FF0000\" } thresholds = [ threshold_al , * thresholds ] if h_threshold_wa is not None : threshold_wa = { \"label\" : \"Warning\" , \"ttype\" : \"UPPER\" , \"value\" : h_threshold_wa , \"color\" : \"#FFA500\" } thresholds = [ threshold_wa , * thresholds ] if h_min_span_1 is not None : threshold_sp = { \"label\" : \"Minimal Span Height\" , \"ttype\" : \"UPPER\" , \"value\" : h_min_span_1 , \"color\" : \"#000000\" } thresholds = [ threshold_sp , * thresholds ] threshold_ob = [{ \"label\" : \"Obstruction\" , \"ttype\" : \"LOWER\" , \"value\" : 0 , \"color\" : \"#FF0000\" }] buffer_ob = ( h_min_span_1 - h_riverbed ) * 0.001 view_range_ob = [ 0 - buffer_ob ,( h_min_span_1 - h_riverbed ) + buffer_ob ] self . parameters . set ( \"camera\" , cache = 'inactive' , ordinal = 100 , modules = { \"hls\" : \"hielen3.tools.hls_facility\" }, operator = f \"hls.start_stream(resource={serial!r})\" , capability = \"stream\" ) self . parameters . set ( \"temperature\" , cache = 'active' , mu = '\u00b0C' , ordinal = 9 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=2)\" ) self . parameters . set ( \"humidity\" , cache = 'active' , mu = ' %% ' , ordinal = 10 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=3)\" ) self . parameters . set ( \"battery\" , cache = 'active' , mu = 'V' , ordinal = 11 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=4)\" ) self . parameters . set ( \"radar 1\" , cache = 'active' , mu = 'mA' , ordinal = 6 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=5)\" ) self . parameters . set ( \"radar 2\" , cache = 'active' , mu = 'mA' , ordinal = 7 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=6)\" ) self . parameters . set ( \"pluviometer\" , cache = 'active' , mu = 'count' , ordinal = 8 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=7)\" ) if pluviometer is not None : self . parameters . set ( 'rain' , cache = 'active' , mu = 'mm/h' , ordinal = 5 , first = timestamp , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"pluviometer\" ] . uuid }, operator = f \"calc.instant_velocity(calc.poly_trans2(S0,{pluviometer}))\" ) if radar_1 is not None : self . parameters . set ( 'level 1' , cache = 'active' , mu = \"m.s.l.m.\" , ordinal = 3 , first = timestamp , view_range = view_range , thresholds = thresholds , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"radar 1\" ] . uuid }, operator = f \"{h_radar_1} - calc.poly_trans2(S0,{radar_1})\" ) self . parameters . set ( 'free span 1' , cache = 'active' , mu = \"m\" , ordinal = 1 , thresholds = threshold_ob , first = timestamp , view_range = view_range_ob , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"level 1\" ] . uuid }, operator = f \"{h_min_span_1} - S0\" ) if radar_2 is not None : self . parameters . set ( 'level 2' , cache = 'active' , mu = \"m.s.l.m.\" , ordinal = 4 , first = timestamp , view_range = view_range , thresholds = thresholds , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"radar 2\" ] . uuid }, operator = f \"{h_radar_2} - calc.poly_trans2(S0,{radar_2})\" ) self . parameters . set ( 'free span 2' , cache = 'active' , mu = \"m\" , ordinal = 2 , first = timestamp , thresholds = threshold_ob , view_range = view_range_ob , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"level 2\" ] . uuid }, operator = f \"{h_min_span_2}-S0\" ) create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Index"},{"location":"reference/hielen3/ext/feature_rfilogger/#module-hielen3extfeature_rfilogger","text":"View Source # coding=utf-8 __name__ = \"Feature_RfiLogger\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from .rfilogger import Feature , ConfigSchema , retrive __all__ = [ \"Feature\" , \"ConfigSchema\" , \"retrive\" ]","title":"Module hielen3.ext.feature_rfilogger"},{"location":"reference/hielen3/ext/feature_rfilogger/#sub-modules","text":"hielen3.ext.feature_rfilogger.rfilogger hielen3.ext.feature_rfilogger.rfilogger_good","title":"Sub-modules"},{"location":"reference/hielen3/ext/feature_rfilogger/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/ext/feature_rfilogger/#retrive","text":"def retrive ( serials = None , times = None , columns = None , folder = 'gestecno_rfi/data' , func = None , ** kwargs ) View Source def retrive ( serials = None , times = None , columns = None , folder = 'gestecno_rfi/data' , func = None , ** kwargs ) : f = Path ( conf [ 'incomepath' ] ) / folder if not f . is_dir () : f = Path ( conf [ 'incomepath' ] ) / 'incomes' folder = f def __extract_gestecno__ ( path ) : a = DataFrame ( [] , dtype = 'float64' ) try : a = read_csv ( path , skiprows = 2 , parse_dates = True , header = None ) if a . empty : a = read_csv ( path , parse_dates = True , header = None ) a = a [ a[0 ] . apply ( lambda x : match ( '^\\d{4}-\\d{2}' , x )). notna () ] a . columns = [ 'times', *a.columns[1: ] ] except Exception as e : pass return a if func is None : func = __extract_gestecno__ if serials is None : serials = slice ( None , None ) if isinstance ( serials , str ) : #serials = slice ( serials , serials ) serials =[ serials ] if isinstance ( times , datetime ) : times = str ( times ) if times is None or isinstance ( times , str ) : times = slice ( times , None , None ) start = times . start stop = times . stop if start is not None : orig_start = start start = str ( datetime64 ( start ) - timedelta64 ( 1 , 'D' )) else : orig_start = None if start is not None : datestart = str ( datetime . fromisoformat ( start ). date ()) else : datestart = None times = slice ( start , stop ) orig_times = slice ( orig_start , stop ) dates = slice ( datestart , stop ) #print ( times , \"\\n\" , orig_times , \"\\n\" , dates ) paths = Series ( glob ( f '{folder}/*/*/*/*' ), dtype = 'object' ). apply ( Path ) sertime = DataFrame ( paths . apply ( lambda x : ( x . parts [ -4 ] , str ( datetime ( * map ( int , x . parts [ -3: ] ))) ) ). explode (). values . reshape ( paths . __len__ (), 2 ), columns =[ 'serial','times' ] ) sertime [ 'path' ]= paths . apply ( lambda x : str ( x / \"*\" )) sertime = sertime . set_index ( [ 'serial','times' ] ). sort_index () df = DataFrame () try : sertime = sertime . to_frame () except Exception as e : pass if isinstance ( serials , ( list , set , tuple )) : serials = list ( sertime . index [ sertime.index.isin(serials,level=0) ] . droplevel ( 1 ). drop_duplicates () ) if not serials . __len__ () : return df try : sertime = sertime . loc [ (serials,dates), : ] except KeyError as e : return df for serial , paths in sertime . groupby ( 'serial' ) : u = concat ( paths [ 'path' ] . apply ( glob ). explode (). apply ( func ). values ) u [ 'serial' ]= serial u = u . set_index ( [ 'serial','times' ] ) df = concat ( [ df,u ] ) if columns is None : columns = list ( df . columns ) if not isinstance ( columns ,( list , tuple , set )) : columns =[ columns ] columns = list ( columns ) df = df [ columns ] . sort_index (). loc [ (serials, times), : ] df = df . loc [ (serials,times), : ] try : if serials . __len__ () == 1 : df = df . droplevel ( 'serial' , axis = 0 ). squeeze () ## FILTRO LEVEL 1 , LEVEL 2 if 5 in columns or 6 in columns : df = calc . filter ( df , window = 12 ) [ orig_times ] df = df . to_frame () except Exception as e : pass return df","title":"retrive"},{"location":"reference/hielen3/ext/feature_rfilogger/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_rfilogger/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , logger_serials ()] }, \"Instruments info\" : { 0 :[ \"radar_1\" , \"Radar 1 polynomial coefficients\" , False , None ], 1 :[ \"radar_2\" , \"Radar 2 polynomial coefficients\" , False , None ], 2 :[ \"pluviometer\" , \"Pluviometer polynomial coefficients\" , False , None ], 3 :[ \"h_radar_1\" , \"Quote over sea level of the radar 1\" , False , None ], 4 :[ \"h_radar_2\" , \"Quote over sea level of the radar 2\" , False , None ], 5 :[ \"h_min_span_1\" , \"Quote over the sea level of the minimum free span\" , False , None ], 6 :[ \"h_min_span_2\" , \"Quote over the sea level of the minimum free span\" , False , None ], 7 :[ \"h_riverbed\" , \"Quote over the sea level of the riverbed\" , False , None ], 8 :[ \"h_threshold_al\" , \"Alert quote level\" , False , None ], 9 :[ \"h_threshold_wa\" , \"Warning quote level\" , False , None ] } } serial = fields . String ( required = True , allow_none = False ) radar_1 = PolyCoeff ( default =[ 0 , 1 ], required = False , allow_none = True ) radar_2 = PolyCoeff ( default =[ 0 , 1 ], required = False , allow_none = True ) pluviometer = PolyCoeff ( default =[ 0 , 0.2 ], reqired = False , allow_none = True ) h_radar_1 = fields . Number ( required = True , allow_none = True ) h_radar_2 = fields . Number ( required = True , allow_none = True ) h_min_span_1 = fields . Number ( required = True , allow_none = True ) h_min_span_2 = fields . Number ( required = True , allow_none = True ) h_riverbed = fields . Number ( required = True , allow_none = True ) h_threshold_al = fields . Number ( required = True , allow_none = True ) h_threshold_wa = fields . Number ( required = True , allow_none = True )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_rfilogger/#ancestors-in-mro","text":"hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_rfilogger/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages h_min_span_1 h_min_span_2 h_radar_1 h_radar_2 h_riverbed h_threshold_al h_threshold_wa opts pluviometer radar_1 radar_2 serial","title":"Class variables"},{"location":"reference/hielen3/ext/feature_rfilogger/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_rfilogger/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_rfilogger/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_rfilogger/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_rfilogger/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_rfilogger/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_rfilogger/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_rfilogger/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_rfilogger/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_rfilogger/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_rfilogger/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_rfilogger/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_rfilogger/#feature","text":"class Feature ( feature ) RfiLogger View Source class Feature ( HFeature ): ''' RfiLogger ''' def setup ( self , ** kwargs ): pass def config ( self , serial , radar_1 = None , radar_2 = None , pluviometer = None , h_radar_1 = None , h_radar_2 = None , h_min_span_1 = None , h_min_span_2 = None , h_riverbed = None , h_threshold_al = None , h_threshold_wa = None , ** kwargs ): \"\"\" Timestamp, 0:Alarm, 1:Temp_\u00b0C, 2:Humid_%, 3:ADC 0_V, 4:lev1_m, 5:lev2_m, 6:pio1 \"\"\" source = str ( self . __module__ ) try : timestamp = kwargs [ \"timestamp\" ] except KeyError as e : timestamp = None if not self . parameters . __len__ (): if radar_1 is None : radar_1 = \"\" if radar_2 is None : radar_2 = \"\" if h_radar_1 is None : h_radar_1 = 0 if h_radar_2 is None : h_radar_2 = 0 if h_min_span_1 is None : h_min_span_1 = 0 if h_min_span_2 is None : h_min_span_2 = 0 if not h_riverbed is None : buffer = ( h_radar_1 - h_riverbed ) * 0.01 view_range = [ h_riverbed - buffer , h_radar_1 + buffer ] else : view_range = None thresholds = [{ \"label\" : \"Sensor Height\" , \"ttype\" : \"UPPER\" , \"value\" : h_radar_1 , \"color\" : \"#505050\" }] if h_threshold_al is not None : threshold_al = { \"label\" : \"Alert\" , \"ttype\" : \"UPPER\" , \"value\" : h_threshold_al , \"color\" : \"#FF0000\" } thresholds = [ threshold_al , * thresholds ] if h_threshold_wa is not None : threshold_wa = { \"label\" : \"Warning\" , \"ttype\" : \"UPPER\" , \"value\" : h_threshold_wa , \"color\" : \"#FFA500\" } thresholds = [ threshold_wa , * thresholds ] if h_min_span_1 is not None : threshold_sp = { \"label\" : \"Minimal Span Height\" , \"ttype\" : \"UPPER\" , \"value\" : h_min_span_1 , \"color\" : \"#000000\" } thresholds = [ threshold_sp , * thresholds ] threshold_ob = [{ \"label\" : \"Obstruction\" , \"ttype\" : \"LOWER\" , \"value\" : 0 , \"color\" : \"#FF0000\" }] buffer_ob = ( h_min_span_1 - h_riverbed ) * 0.001 view_range_ob = [ 0 - buffer_ob ,( h_min_span_1 - h_riverbed ) + buffer_ob ] self . parameters . set ( \"camera\" , cache = 'inactive' , ordinal = 100 , modules = { \"hls\" : \"hielen3.tools.hls_facility\" }, operator = f \"hls.start_stream(resource={serial!r})\" , capability = \"stream\" ) self . parameters . set ( \"temperature\" , cache = 'active' , mu = '\u00b0C' , ordinal = 9 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=2)\" ) self . parameters . set ( \"humidity\" , cache = 'active' , mu = ' %% ' , ordinal = 10 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=3)\" ) self . parameters . set ( \"battery\" , cache = 'active' , mu = 'V' , ordinal = 11 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=4)\" ) self . parameters . set ( \"radar 1\" , cache = 'active' , mu = 'mA' , ordinal = 6 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=5)\" ) self . parameters . set ( \"radar 2\" , cache = 'active' , mu = 'mA' , ordinal = 7 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=6)\" ) self . parameters . set ( \"pluviometer\" , cache = 'active' , mu = 'count' , ordinal = 8 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=7)\" ) if pluviometer is not None : self . parameters . set ( 'rain' , cache = 'active' , mu = 'mm/h' , ordinal = 5 , first = timestamp , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"pluviometer\" ] . uuid }, operator = f \"calc.instant_velocity(calc.poly_trans2(S0,{pluviometer}))\" ) if radar_1 is not None : self . parameters . set ( 'level 1' , cache = 'active' , mu = \"m.s.l.m.\" , ordinal = 3 , first = timestamp , view_range = view_range , thresholds = thresholds , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"radar 1\" ] . uuid }, operator = f \"{h_radar_1} - calc.poly_trans2(S0,{radar_1})\" ) self . parameters . set ( 'free span 1' , cache = 'active' , mu = \"m\" , ordinal = 1 , thresholds = threshold_ob , first = timestamp , view_range = view_range_ob , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"level 1\" ] . uuid }, operator = f \"{h_min_span_1} - S0\" ) if radar_2 is not None : self . parameters . set ( 'level 2' , cache = 'active' , mu = \"m.s.l.m.\" , ordinal = 4 , first = timestamp , view_range = view_range , thresholds = thresholds , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"radar 2\" ] . uuid }, operator = f \"{h_radar_2} - calc.poly_trans2(S0,{radar_2})\" ) self . parameters . set ( 'free span 2' , cache = 'active' , mu = \"m\" , ordinal = 2 , first = timestamp , thresholds = threshold_ob , view_range = view_range_ob , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"level 2\" ] . uuid }, operator = f \"{h_min_span_2}-S0\" )","title":"Feature"},{"location":"reference/hielen3/ext/feature_rfilogger/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_rfilogger/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_rfilogger/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_rfilogger/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_rfilogger/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_rfilogger/#config","text":"def config ( self , serial , radar_1 = None , radar_2 = None , pluviometer = None , h_radar_1 = None , h_radar_2 = None , h_min_span_1 = None , h_min_span_2 = None , h_riverbed = None , h_threshold_al = None , h_threshold_wa = None , ** kwargs ) Timestamp, 0:Alarm, 1:Temp_\u00b0C, 2:Humid_%, 3:ADC 0_V, 4:lev1_m, 5:lev2_m, 6:pio1 View Source def config ( self , serial , radar_1 = None , radar_2 = None , pluviometer = None , h_radar_1 = None , h_radar_2 = None , h_min_span_1 = None , h_min_span_2 = None , h_riverbed = None , h_threshold_al = None , h_threshold_wa = None , ** kwargs ): \"\"\" Timestamp, 0:Alarm, 1:Temp_\u00b0C, 2:Humid_%, 3:ADC 0_V, 4:lev1_m, 5:lev2_m, 6:pio1 \"\"\" source = str ( self . __module__ ) try : timestamp = kwargs [ \"timestamp\" ] except KeyError as e : timestamp = None if not self . parameters . __len__ (): if radar_1 is None : radar_1 = \"\" if radar_2 is None : radar_2 = \"\" if h_radar_1 is None : h_radar_1 = 0 if h_radar_2 is None : h_radar_2 = 0 if h_min_span_1 is None : h_min_span_1 = 0 if h_min_span_2 is None : h_min_span_2 = 0 if not h_riverbed is None : buffer = ( h_radar_1 - h_riverbed ) * 0.01 view_range = [ h_riverbed - buffer , h_radar_1 + buffer ] else : view_range = None thresholds = [{ \"label\" : \"Sensor Height\" , \"ttype\" : \"UPPER\" , \"value\" : h_radar_1 , \"color\" : \"#505050\" }] if h_threshold_al is not None : threshold_al = { \"label\" : \"Alert\" , \"ttype\" : \"UPPER\" , \"value\" : h_threshold_al , \"color\" : \"#FF0000\" } thresholds = [ threshold_al , * thresholds ] if h_threshold_wa is not None : threshold_wa = { \"label\" : \"Warning\" , \"ttype\" : \"UPPER\" , \"value\" : h_threshold_wa , \"color\" : \"#FFA500\" } thresholds = [ threshold_wa , * thresholds ] if h_min_span_1 is not None : threshold_sp = { \"label\" : \"Minimal Span Height\" , \"ttype\" : \"UPPER\" , \"value\" : h_min_span_1 , \"color\" : \"#000000\" } thresholds = [ threshold_sp , * thresholds ] threshold_ob = [{ \"label\" : \"Obstruction\" , \"ttype\" : \"LOWER\" , \"value\" : 0 , \"color\" : \"#FF0000\" }] buffer_ob = ( h_min_span_1 - h_riverbed ) * 0.001 view_range_ob = [ 0 - buffer_ob ,( h_min_span_1 - h_riverbed ) + buffer_ob ] self . parameters . set ( \"camera\" , cache = 'inactive' , ordinal = 100 , modules = { \"hls\" : \"hielen3.tools.hls_facility\" }, operator = f \"hls.start_stream(resource={serial!r})\" , capability = \"stream\" ) self . parameters . set ( \"temperature\" , cache = 'active' , mu = '\u00b0C' , ordinal = 9 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=2)\" ) self . parameters . set ( \"humidity\" , cache = 'active' , mu = ' %% ' , ordinal = 10 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=3)\" ) self . parameters . set ( \"battery\" , cache = 'active' , mu = 'V' , ordinal = 11 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=4)\" ) self . parameters . set ( \"radar 1\" , cache = 'active' , mu = 'mA' , ordinal = 6 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=5)\" ) self . parameters . set ( \"radar 2\" , cache = 'active' , mu = 'mA' , ordinal = 7 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=6)\" ) self . parameters . set ( \"pluviometer\" , cache = 'active' , mu = 'count' , ordinal = 8 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=7)\" ) if pluviometer is not None : self . parameters . set ( 'rain' , cache = 'active' , mu = 'mm/h' , ordinal = 5 , first = timestamp , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"pluviometer\" ] . uuid }, operator = f \"calc.instant_velocity(calc.poly_trans2(S0,{pluviometer}))\" ) if radar_1 is not None : self . parameters . set ( 'level 1' , cache = 'active' , mu = \"m.s.l.m.\" , ordinal = 3 , first = timestamp , view_range = view_range , thresholds = thresholds , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"radar 1\" ] . uuid }, operator = f \"{h_radar_1} - calc.poly_trans2(S0,{radar_1})\" ) self . parameters . set ( 'free span 1' , cache = 'active' , mu = \"m\" , ordinal = 1 , thresholds = threshold_ob , first = timestamp , view_range = view_range_ob , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"level 1\" ] . uuid }, operator = f \"{h_min_span_1} - S0\" ) if radar_2 is not None : self . parameters . set ( 'level 2' , cache = 'active' , mu = \"m.s.l.m.\" , ordinal = 4 , first = timestamp , view_range = view_range , thresholds = thresholds , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"radar 2\" ] . uuid }, operator = f \"{h_radar_2} - calc.poly_trans2(S0,{radar_2})\" ) self . parameters . set ( 'free span 2' , cache = 'active' , mu = \"m\" , ordinal = 2 , first = timestamp , thresholds = threshold_ob , view_range = view_range_ob , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"level 2\" ] . uuid }, operator = f \"{h_min_span_2}-S0\" )","title":"config"},{"location":"reference/hielen3/ext/feature_rfilogger/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_rfilogger/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_rfilogger/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_rfilogger/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_rfilogger/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_rfilogger/#retrive_1","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_rfilogger/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_rfilogger/#setup","text":"def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_rfilogger/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_rfilogger/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_rfilogger/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/","text":"Module hielen3.ext.feature_rfilogger.rfilogger View Source # coding=utf-8 from hielen3 import conf from hielen3.feature import HFeature from hielen3.series import HSeries from hielen3.tools import calc from hielen3.serializaction import ActionSchema , FTPPath , PolyCoeff , LoggerHeader from marshmallow import fields #from pandas import read_csv, DatetimeIndex, Series, DataFrame from pathlib import Path import traceback from glob import glob from pathlib import Path from pandas import Series , DataFrame , read_csv , concat from datetime import datetime from numpy import datetime64 , timedelta64 def logger_serials ( folder = 'gestecno_rfi/data' ): folder = Path ( conf [ 'incomepath' ]) / folder / \"*\" serials = Series ( glob ( str ( folder )), dtype = 'object' ) . apply ( Path ) serials = serials [ serials . apply ( Path . is_dir )] return list ( serials . apply ( lambda x : x . name ) . sort_values () . values ) class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , logger_serials ()] }, \"Instruments info\" : { 0 :[ \"radar_1\" , \"Radar 1 polynomial coefficients\" , False , None ], 1 :[ \"radar_2\" , \"Radar 2 polynomial coefficients\" , False , None ], 2 :[ \"pluviometer\" , \"Pluviometer polynomial coefficients\" , False , None ], 3 :[ \"h_radar_1\" , \"Quote over sea level of the radar 1\" , False , None ], 4 :[ \"h_radar_2\" , \"Quote over sea level of the radar 2\" , False , None ], 5 :[ \"h_min_span_1\" , \"Quote over the sea level of the minimum free span\" , False , None ], 6 :[ \"h_min_span_2\" , \"Quote over the sea level of the minimum free span\" , False , None ], 7 :[ \"h_riverbed\" , \"Quote over the sea level of the riverbed\" , False , None ], 8 :[ \"h_threshold_al\" , \"Alert quote level\" , False , None ], 9 :[ \"h_threshold_wa\" , \"Warning quote level\" , False , None ] } } serial = fields . String ( required = True , allow_none = False ) radar_1 = PolyCoeff ( default = [ 0 , 1 ], required = False , allow_none = True ) radar_2 = PolyCoeff ( default = [ 0 , 1 ], required = False , allow_none = True ) pluviometer = PolyCoeff ( default = [ 0 , 0.2 ], reqired = False , allow_none = True ) h_radar_1 = fields . Number ( required = True , allow_none = True ) h_radar_2 = fields . Number ( required = True , allow_none = True ) h_min_span_1 = fields . Number ( required = True , allow_none = True ) h_min_span_2 = fields . Number ( required = True , allow_none = True ) h_riverbed = fields . Number ( required = True , allow_none = True ) h_threshold_al = fields . Number ( required = True , allow_none = True ) h_threshold_wa = fields . Number ( required = True , allow_none = True ) class Feature ( HFeature ): ''' RfiLogger ''' def setup ( self , ** kwargs ): pass def config ( self , serial , radar_1 = None , radar_2 = None , pluviometer = None , h_radar_1 = None , h_radar_2 = None , h_min_span_1 = None , h_min_span_2 = None , h_riverbed = None , h_threshold_al = None , h_threshold_wa = None , ** kwargs ): \"\"\" Timestamp, 0:Alarm, 1:Temp_\u00b0C, 2:Humid_%, 3:ADC 0_V, 4:lev1_m, 5:lev2_m, 6:pio1 \"\"\" source = str ( self . __module__ ) try : timestamp = kwargs [ \"timestamp\" ] except KeyError as e : timestamp = None if not self . parameters . __len__ (): if radar_1 is None : radar_1 = \"\" if radar_2 is None : radar_2 = \"\" if h_radar_1 is None : h_radar_1 = 0 if h_radar_2 is None : h_radar_2 = 0 if h_min_span_1 is None : h_min_span_1 = 0 if h_min_span_2 is None : h_min_span_2 = 0 if not h_riverbed is None : buffer = ( h_radar_1 - h_riverbed ) * 0.01 view_range = [ h_riverbed - buffer , h_radar_1 + buffer ] else : view_range = None thresholds = [{ \"label\" : \"Sensor Height\" , \"ttype\" : \"UPPER\" , \"value\" : h_radar_1 , \"color\" : \"#505050\" }] if h_threshold_al is not None : threshold_al = { \"label\" : \"Alert\" , \"ttype\" : \"UPPER\" , \"value\" : h_threshold_al , \"color\" : \"#FF0000\" } thresholds = [ threshold_al , * thresholds ] if h_threshold_wa is not None : threshold_wa = { \"label\" : \"Warning\" , \"ttype\" : \"UPPER\" , \"value\" : h_threshold_wa , \"color\" : \"#FFA500\" } thresholds = [ threshold_wa , * thresholds ] if h_min_span_1 is not None : threshold_sp = { \"label\" : \"Minimal Span Height\" , \"ttype\" : \"UPPER\" , \"value\" : h_min_span_1 , \"color\" : \"#000000\" } thresholds = [ threshold_sp , * thresholds ] threshold_ob = [{ \"label\" : \"Obstruction\" , \"ttype\" : \"LOWER\" , \"value\" : 0 , \"color\" : \"#FF0000\" }] buffer_ob = ( h_min_span_1 - h_riverbed ) * 0.001 view_range_ob = [ 0 - buffer_ob ,( h_min_span_1 - h_riverbed ) + buffer_ob ] self . parameters . set ( \"camera\" , cache = 'inactive' , ordinal = 100 , modules = { \"hls\" : \"hielen3.tools.hls_facility\" }, operator = f \"hls.start_stream(resource= { serial !r} )\" , capability = \"stream\" ) self . parameters . set ( \"temperature\" , cache = 'active' , mu = '\u00b0C' , ordinal = 9 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials= { serial !r} ,times=times,columns=2)\" ) self . parameters . set ( \"humidity\" , cache = 'active' , mu = ' %% ' , ordinal = 10 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials= { serial !r} ,times=times,columns=3)\" ) self . parameters . set ( \"battery\" , cache = 'active' , mu = 'V' , ordinal = 11 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials= { serial !r} ,times=times,columns=4)\" ) self . parameters . set ( \"radar 1\" , cache = 'active' , mu = 'mA' , ordinal = 6 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials= { serial !r} ,times=times,columns=5)\" ) self . parameters . set ( \"radar 2\" , cache = 'active' , mu = 'mA' , ordinal = 7 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials= { serial !r} ,times=times,columns=6)\" ) self . parameters . set ( \"pluviometer\" , cache = 'active' , mu = 'count' , ordinal = 8 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials= { serial !r} ,times=times,columns=7)\" ) if pluviometer is not None : self . parameters . set ( 'rain' , cache = 'active' , mu = 'mm/h' , ordinal = 5 , first = timestamp , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"pluviometer\" ] . uuid }, operator = f \"calc.instant_velocity(calc.poly_trans2(S0, { pluviometer } ))\" ) if radar_1 is not None : self . parameters . set ( 'level 1' , cache = 'active' , mu = \"m.s.l.m.\" , ordinal = 3 , first = timestamp , view_range = view_range , thresholds = thresholds , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"radar 1\" ] . uuid }, operator = f \" { h_radar_1 } - calc.poly_trans2(S0, { radar_1 } )\" ) self . parameters . set ( 'free span 1' , cache = 'active' , mu = \"m\" , ordinal = 1 , thresholds = threshold_ob , first = timestamp , view_range = view_range_ob , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"level 1\" ] . uuid }, operator = f \" { h_min_span_1 } - S0\" ) if radar_2 is not None : self . parameters . set ( 'level 2' , cache = 'active' , mu = \"m.s.l.m.\" , ordinal = 4 , first = timestamp , view_range = view_range , thresholds = thresholds , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"radar 2\" ] . uuid }, operator = f \" { h_radar_2 } - calc.poly_trans2(S0, { radar_2 } )\" ) self . parameters . set ( 'free span 2' , cache = 'active' , mu = \"m\" , ordinal = 2 , first = timestamp , thresholds = threshold_ob , view_range = view_range_ob , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"level 2\" ] . uuid }, operator = f \" { h_min_span_2 } -S0\" ) def retrive ( serials = None , times = None , columns = None , folder = 'gestecno_rfi/data' , func = None , ** kwargs ): f = Path ( conf [ 'incomepath' ]) / folder if not f . is_dir (): f = Path ( conf [ 'incomepath' ]) / 'incomes' folder = f def __extract_gestecno__ ( path ): a = DataFrame ([], dtype = 'float64' ) try : a = read_csv ( path , skiprows = 2 , parse_dates = True , header = None ) if a . empty : a = read_csv ( path , parse_dates = True , header = None ) a = a [ a [ 0 ] . apply ( lambda x : match ( '^\\d {4} -\\d {2} ' , x )) . notna ()] a . columns = [ 'times' , * a . columns [ 1 :] ] except Exception as e : pass return a if func is None : func = __extract_gestecno__ if serials is None : serials = slice ( None , None ) if isinstance ( serials , str ): #serials=slice(serials,serials) serials = [ serials ] if isinstance ( times , datetime ): times = str ( times ) if times is None or isinstance ( times , str ): times = slice ( times , None , None ) start = times . start stop = times . stop if start is not None : orig_start = start start = str ( datetime64 ( start ) - timedelta64 ( 1 , 'D' )) else : orig_start = None if start is not None : datestart = str ( datetime . fromisoformat ( start ) . date ()) else : datestart = None times = slice ( start , stop ) orig_times = slice ( orig_start , stop ) dates = slice ( datestart , stop ) #print (times,\"\\n\",orig_times,\"\\n\",dates) paths = Series ( glob ( f ' { folder } /*/*/*/*' ), dtype = 'object' ) . apply ( Path ) sertime = DataFrame ( paths . apply ( lambda x : ( x . parts [ - 4 ], str ( datetime ( * map ( int , x . parts [ - 3 :]))) ) ) . explode () . values . reshape ( paths . __len__ (), 2 ), columns = [ 'serial' , 'times' ] ) sertime [ 'path' ] = paths . apply ( lambda x : str ( x / \"*\" )) sertime = sertime . set_index ([ 'serial' , 'times' ]) . sort_index () df = DataFrame () try : sertime = sertime . to_frame () except Exception as e : pass if isinstance ( serials , ( list , set , tuple )): serials = list ( sertime . index [ sertime . index . isin ( serials , level = 0 ) ] . droplevel ( 1 ) . drop_duplicates () ) if not serials . __len__ (): return df try : sertime = sertime . loc [( serials , dates ), :] except KeyError as e : return df for serial , paths in sertime . groupby ( 'serial' ): u = concat ( paths [ 'path' ] . apply ( glob ) . explode () . apply ( func ) . values ) u [ 'serial' ] = serial u = u . set_index ([ 'serial' , 'times' ]) df = concat ([ df , u ]) if columns is None : columns = list ( df . columns ) if not isinstance ( columns ,( list , tuple , set )): columns = [ columns ] columns = list ( columns ) df = df [ columns ] . sort_index () . loc [( serials , times ), :] df = df . loc [( serials , times ), :] try : if serials . __len__ () == 1 : df = df . droplevel ( 'serial' , axis = 0 ) . squeeze () ## FILTRO LEVEL 1, LEVEL 2 if 5 in columns or 6 in columns : df = calc . filter ( df , window = 12 )[ orig_times ] df = df . to_frame () except Exception as e : pass return df Variables conf Functions logger_serials def logger_serials ( folder = 'gestecno_rfi/data' ) View Source def logger_serials ( folder = 'gestecno_rfi/data' ) : folder = Path ( conf [ 'incomepath' ] ) / folder / \"*\" serials = Series ( glob ( str ( folder )) , dtype = 'object' ) . apply ( Path ) serials = serials [ serials . apply ( Path . is_dir ) ] return list ( serials . apply ( lambda x : x . name ) . sort_values () . values ) retrive def retrive ( serials = None , times = None , columns = None , folder = 'gestecno_rfi/data' , func = None , ** kwargs ) View Source def retrive ( serials = None , times = None , columns = None , folder = 'gestecno_rfi/data' , func = None , ** kwargs ) : f = Path ( conf [ 'incomepath' ] ) / folder if not f . is_dir () : f = Path ( conf [ 'incomepath' ] ) / 'incomes' folder = f def __extract_gestecno__ ( path ) : a = DataFrame ( [] , dtype = 'float64' ) try : a = read_csv ( path , skiprows = 2 , parse_dates = True , header = None ) if a . empty : a = read_csv ( path , parse_dates = True , header = None ) a = a [ a[0 ] . apply ( lambda x : match ( '^\\d{4}-\\d{2}' , x )). notna () ] a . columns = [ 'times', *a.columns[1: ] ] except Exception as e : pass return a if func is None : func = __extract_gestecno__ if serials is None : serials = slice ( None , None ) if isinstance ( serials , str ) : #serials = slice ( serials , serials ) serials =[ serials ] if isinstance ( times , datetime ) : times = str ( times ) if times is None or isinstance ( times , str ) : times = slice ( times , None , None ) start = times . start stop = times . stop if start is not None : orig_start = start start = str ( datetime64 ( start ) - timedelta64 ( 1 , 'D' )) else : orig_start = None if start is not None : datestart = str ( datetime . fromisoformat ( start ). date ()) else : datestart = None times = slice ( start , stop ) orig_times = slice ( orig_start , stop ) dates = slice ( datestart , stop ) #print ( times , \"\\n\" , orig_times , \"\\n\" , dates ) paths = Series ( glob ( f '{folder}/*/*/*/*' ), dtype = 'object' ). apply ( Path ) sertime = DataFrame ( paths . apply ( lambda x : ( x . parts [ -4 ] , str ( datetime ( * map ( int , x . parts [ -3: ] ))) ) ). explode (). values . reshape ( paths . __len__ (), 2 ), columns =[ 'serial','times' ] ) sertime [ 'path' ]= paths . apply ( lambda x : str ( x / \"*\" )) sertime = sertime . set_index ( [ 'serial','times' ] ). sort_index () df = DataFrame () try : sertime = sertime . to_frame () except Exception as e : pass if isinstance ( serials , ( list , set , tuple )) : serials = list ( sertime . index [ sertime.index.isin(serials,level=0) ] . droplevel ( 1 ). drop_duplicates () ) if not serials . __len__ () : return df try : sertime = sertime . loc [ (serials,dates), : ] except KeyError as e : return df for serial , paths in sertime . groupby ( 'serial' ) : u = concat ( paths [ 'path' ] . apply ( glob ). explode (). apply ( func ). values ) u [ 'serial' ]= serial u = u . set_index ( [ 'serial','times' ] ) df = concat ( [ df,u ] ) if columns is None : columns = list ( df . columns ) if not isinstance ( columns ,( list , tuple , set )) : columns =[ columns ] columns = list ( columns ) df = df [ columns ] . sort_index (). loc [ (serials, times), : ] df = df . loc [ (serials,times), : ] try : if serials . __len__ () == 1 : df = df . droplevel ( 'serial' , axis = 0 ). squeeze () ## FILTRO LEVEL 1 , LEVEL 2 if 5 in columns or 6 in columns : df = calc . filter ( df , window = 12 ) [ orig_times ] df = df . to_frame () except Exception as e : pass return df Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , logger_serials ()] }, \"Instruments info\" : { 0 :[ \"radar_1\" , \"Radar 1 polynomial coefficients\" , False , None ], 1 :[ \"radar_2\" , \"Radar 2 polynomial coefficients\" , False , None ], 2 :[ \"pluviometer\" , \"Pluviometer polynomial coefficients\" , False , None ], 3 :[ \"h_radar_1\" , \"Quote over sea level of the radar 1\" , False , None ], 4 :[ \"h_radar_2\" , \"Quote over sea level of the radar 2\" , False , None ], 5 :[ \"h_min_span_1\" , \"Quote over the sea level of the minimum free span\" , False , None ], 6 :[ \"h_min_span_2\" , \"Quote over the sea level of the minimum free span\" , False , None ], 7 :[ \"h_riverbed\" , \"Quote over the sea level of the riverbed\" , False , None ], 8 :[ \"h_threshold_al\" , \"Alert quote level\" , False , None ], 9 :[ \"h_threshold_wa\" , \"Warning quote level\" , False , None ] } } serial = fields . String ( required = True , allow_none = False ) radar_1 = PolyCoeff ( default =[ 0 , 1 ], required = False , allow_none = True ) radar_2 = PolyCoeff ( default =[ 0 , 1 ], required = False , allow_none = True ) pluviometer = PolyCoeff ( default =[ 0 , 0.2 ], reqired = False , allow_none = True ) h_radar_1 = fields . Number ( required = True , allow_none = True ) h_radar_2 = fields . Number ( required = True , allow_none = True ) h_min_span_1 = fields . Number ( required = True , allow_none = True ) h_min_span_2 = fields . Number ( required = True , allow_none = True ) h_riverbed = fields . Number ( required = True , allow_none = True ) h_threshold_al = fields . Number ( required = True , allow_none = True ) h_threshold_wa = fields . Number ( required = True , allow_none = True ) Ancestors (in MRO) hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages h_min_span_1 h_min_span_2 h_radar_1 h_radar_2 h_riverbed h_threshold_al h_threshold_wa opts pluviometer radar_1 radar_2 serial Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) RfiLogger View Source class Feature ( HFeature ): ''' RfiLogger ''' def setup ( self , ** kwargs ): pass def config ( self , serial , radar_1 = None , radar_2 = None , pluviometer = None , h_radar_1 = None , h_radar_2 = None , h_min_span_1 = None , h_min_span_2 = None , h_riverbed = None , h_threshold_al = None , h_threshold_wa = None , ** kwargs ): \"\"\" Timestamp, 0:Alarm, 1:Temp_\u00b0C, 2:Humid_%, 3:ADC 0_V, 4:lev1_m, 5:lev2_m, 6:pio1 \"\"\" source = str ( self . __module__ ) try : timestamp = kwargs [ \"timestamp\" ] except KeyError as e : timestamp = None if not self . parameters . __len__ (): if radar_1 is None : radar_1 = \"\" if radar_2 is None : radar_2 = \"\" if h_radar_1 is None : h_radar_1 = 0 if h_radar_2 is None : h_radar_2 = 0 if h_min_span_1 is None : h_min_span_1 = 0 if h_min_span_2 is None : h_min_span_2 = 0 if not h_riverbed is None : buffer = ( h_radar_1 - h_riverbed ) * 0.01 view_range = [ h_riverbed - buffer , h_radar_1 + buffer ] else : view_range = None thresholds = [{ \"label\" : \"Sensor Height\" , \"ttype\" : \"UPPER\" , \"value\" : h_radar_1 , \"color\" : \"#505050\" }] if h_threshold_al is not None : threshold_al = { \"label\" : \"Alert\" , \"ttype\" : \"UPPER\" , \"value\" : h_threshold_al , \"color\" : \"#FF0000\" } thresholds = [ threshold_al , * thresholds ] if h_threshold_wa is not None : threshold_wa = { \"label\" : \"Warning\" , \"ttype\" : \"UPPER\" , \"value\" : h_threshold_wa , \"color\" : \"#FFA500\" } thresholds = [ threshold_wa , * thresholds ] if h_min_span_1 is not None : threshold_sp = { \"label\" : \"Minimal Span Height\" , \"ttype\" : \"UPPER\" , \"value\" : h_min_span_1 , \"color\" : \"#000000\" } thresholds = [ threshold_sp , * thresholds ] threshold_ob = [{ \"label\" : \"Obstruction\" , \"ttype\" : \"LOWER\" , \"value\" : 0 , \"color\" : \"#FF0000\" }] buffer_ob = ( h_min_span_1 - h_riverbed ) * 0.001 view_range_ob = [ 0 - buffer_ob ,( h_min_span_1 - h_riverbed ) + buffer_ob ] self . parameters . set ( \"camera\" , cache = 'inactive' , ordinal = 100 , modules = { \"hls\" : \"hielen3.tools.hls_facility\" }, operator = f \"hls.start_stream(resource={serial!r})\" , capability = \"stream\" ) self . parameters . set ( \"temperature\" , cache = 'active' , mu = '\u00b0C' , ordinal = 9 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=2)\" ) self . parameters . set ( \"humidity\" , cache = 'active' , mu = ' %% ' , ordinal = 10 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=3)\" ) self . parameters . set ( \"battery\" , cache = 'active' , mu = 'V' , ordinal = 11 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=4)\" ) self . parameters . set ( \"radar 1\" , cache = 'active' , mu = 'mA' , ordinal = 6 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=5)\" ) self . parameters . set ( \"radar 2\" , cache = 'active' , mu = 'mA' , ordinal = 7 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=6)\" ) self . parameters . set ( \"pluviometer\" , cache = 'active' , mu = 'count' , ordinal = 8 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=7)\" ) if pluviometer is not None : self . parameters . set ( 'rain' , cache = 'active' , mu = 'mm/h' , ordinal = 5 , first = timestamp , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"pluviometer\" ] . uuid }, operator = f \"calc.instant_velocity(calc.poly_trans2(S0,{pluviometer}))\" ) if radar_1 is not None : self . parameters . set ( 'level 1' , cache = 'active' , mu = \"m.s.l.m.\" , ordinal = 3 , first = timestamp , view_range = view_range , thresholds = thresholds , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"radar 1\" ] . uuid }, operator = f \"{h_radar_1} - calc.poly_trans2(S0,{radar_1})\" ) self . parameters . set ( 'free span 1' , cache = 'active' , mu = \"m\" , ordinal = 1 , thresholds = threshold_ob , first = timestamp , view_range = view_range_ob , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"level 1\" ] . uuid }, operator = f \"{h_min_span_1} - S0\" ) if radar_2 is not None : self . parameters . set ( 'level 2' , cache = 'active' , mu = \"m.s.l.m.\" , ordinal = 4 , first = timestamp , view_range = view_range , thresholds = thresholds , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"radar 2\" ] . uuid }, operator = f \"{h_radar_2} - calc.poly_trans2(S0,{radar_2})\" ) self . parameters . set ( 'free span 2' , cache = 'active' , mu = \"m\" , ordinal = 2 , first = timestamp , thresholds = threshold_ob , view_range = view_range_ob , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"level 2\" ] . uuid }, operator = f \"{h_min_span_2}-S0\" ) Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , serial , radar_1 = None , radar_2 = None , pluviometer = None , h_radar_1 = None , h_radar_2 = None , h_min_span_1 = None , h_min_span_2 = None , h_riverbed = None , h_threshold_al = None , h_threshold_wa = None , ** kwargs ) Timestamp, 0:Alarm, 1:Temp_\u00b0C, 2:Humid_%, 3:ADC 0_V, 4:lev1_m, 5:lev2_m, 6:pio1 View Source def config ( self , serial , radar_1 = None , radar_2 = None , pluviometer = None , h_radar_1 = None , h_radar_2 = None , h_min_span_1 = None , h_min_span_2 = None , h_riverbed = None , h_threshold_al = None , h_threshold_wa = None , ** kwargs ): \"\"\" Timestamp, 0:Alarm, 1:Temp_\u00b0C, 2:Humid_%, 3:ADC 0_V, 4:lev1_m, 5:lev2_m, 6:pio1 \"\"\" source = str ( self . __module__ ) try : timestamp = kwargs [ \"timestamp\" ] except KeyError as e : timestamp = None if not self . parameters . __len__ (): if radar_1 is None : radar_1 = \"\" if radar_2 is None : radar_2 = \"\" if h_radar_1 is None : h_radar_1 = 0 if h_radar_2 is None : h_radar_2 = 0 if h_min_span_1 is None : h_min_span_1 = 0 if h_min_span_2 is None : h_min_span_2 = 0 if not h_riverbed is None : buffer = ( h_radar_1 - h_riverbed ) * 0.01 view_range = [ h_riverbed - buffer , h_radar_1 + buffer ] else : view_range = None thresholds = [{ \"label\" : \"Sensor Height\" , \"ttype\" : \"UPPER\" , \"value\" : h_radar_1 , \"color\" : \"#505050\" }] if h_threshold_al is not None : threshold_al = { \"label\" : \"Alert\" , \"ttype\" : \"UPPER\" , \"value\" : h_threshold_al , \"color\" : \"#FF0000\" } thresholds = [ threshold_al , * thresholds ] if h_threshold_wa is not None : threshold_wa = { \"label\" : \"Warning\" , \"ttype\" : \"UPPER\" , \"value\" : h_threshold_wa , \"color\" : \"#FFA500\" } thresholds = [ threshold_wa , * thresholds ] if h_min_span_1 is not None : threshold_sp = { \"label\" : \"Minimal Span Height\" , \"ttype\" : \"UPPER\" , \"value\" : h_min_span_1 , \"color\" : \"#000000\" } thresholds = [ threshold_sp , * thresholds ] threshold_ob = [{ \"label\" : \"Obstruction\" , \"ttype\" : \"LOWER\" , \"value\" : 0 , \"color\" : \"#FF0000\" }] buffer_ob = ( h_min_span_1 - h_riverbed ) * 0.001 view_range_ob = [ 0 - buffer_ob ,( h_min_span_1 - h_riverbed ) + buffer_ob ] self . parameters . set ( \"camera\" , cache = 'inactive' , ordinal = 100 , modules = { \"hls\" : \"hielen3.tools.hls_facility\" }, operator = f \"hls.start_stream(resource={serial!r})\" , capability = \"stream\" ) self . parameters . set ( \"temperature\" , cache = 'active' , mu = '\u00b0C' , ordinal = 9 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=2)\" ) self . parameters . set ( \"humidity\" , cache = 'active' , mu = ' %% ' , ordinal = 10 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=3)\" ) self . parameters . set ( \"battery\" , cache = 'active' , mu = 'V' , ordinal = 11 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=4)\" ) self . parameters . set ( \"radar 1\" , cache = 'active' , mu = 'mA' , ordinal = 6 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=5)\" ) self . parameters . set ( \"radar 2\" , cache = 'active' , mu = 'mA' , ordinal = 7 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=6)\" ) self . parameters . set ( \"pluviometer\" , cache = 'active' , mu = 'count' , ordinal = 8 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=7)\" ) if pluviometer is not None : self . parameters . set ( 'rain' , cache = 'active' , mu = 'mm/h' , ordinal = 5 , first = timestamp , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"pluviometer\" ] . uuid }, operator = f \"calc.instant_velocity(calc.poly_trans2(S0,{pluviometer}))\" ) if radar_1 is not None : self . parameters . set ( 'level 1' , cache = 'active' , mu = \"m.s.l.m.\" , ordinal = 3 , first = timestamp , view_range = view_range , thresholds = thresholds , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"radar 1\" ] . uuid }, operator = f \"{h_radar_1} - calc.poly_trans2(S0,{radar_1})\" ) self . parameters . set ( 'free span 1' , cache = 'active' , mu = \"m\" , ordinal = 1 , thresholds = threshold_ob , first = timestamp , view_range = view_range_ob , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"level 1\" ] . uuid }, operator = f \"{h_min_span_1} - S0\" ) if radar_2 is not None : self . parameters . set ( 'level 2' , cache = 'active' , mu = \"m.s.l.m.\" , ordinal = 4 , first = timestamp , view_range = view_range , thresholds = thresholds , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"radar 2\" ] . uuid }, operator = f \"{h_radar_2} - calc.poly_trans2(S0,{radar_2})\" ) self . parameters . set ( 'free span 2' , cache = 'active' , mu = \"m\" , ordinal = 2 , first = timestamp , thresholds = threshold_ob , view_range = view_range_ob , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"level 2\" ] . uuid }, operator = f \"{h_min_span_2}-S0\" ) create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Rfilogger"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#module-hielen3extfeature_rfiloggerrfilogger","text":"View Source # coding=utf-8 from hielen3 import conf from hielen3.feature import HFeature from hielen3.series import HSeries from hielen3.tools import calc from hielen3.serializaction import ActionSchema , FTPPath , PolyCoeff , LoggerHeader from marshmallow import fields #from pandas import read_csv, DatetimeIndex, Series, DataFrame from pathlib import Path import traceback from glob import glob from pathlib import Path from pandas import Series , DataFrame , read_csv , concat from datetime import datetime from numpy import datetime64 , timedelta64 def logger_serials ( folder = 'gestecno_rfi/data' ): folder = Path ( conf [ 'incomepath' ]) / folder / \"*\" serials = Series ( glob ( str ( folder )), dtype = 'object' ) . apply ( Path ) serials = serials [ serials . apply ( Path . is_dir )] return list ( serials . apply ( lambda x : x . name ) . sort_values () . values ) class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , logger_serials ()] }, \"Instruments info\" : { 0 :[ \"radar_1\" , \"Radar 1 polynomial coefficients\" , False , None ], 1 :[ \"radar_2\" , \"Radar 2 polynomial coefficients\" , False , None ], 2 :[ \"pluviometer\" , \"Pluviometer polynomial coefficients\" , False , None ], 3 :[ \"h_radar_1\" , \"Quote over sea level of the radar 1\" , False , None ], 4 :[ \"h_radar_2\" , \"Quote over sea level of the radar 2\" , False , None ], 5 :[ \"h_min_span_1\" , \"Quote over the sea level of the minimum free span\" , False , None ], 6 :[ \"h_min_span_2\" , \"Quote over the sea level of the minimum free span\" , False , None ], 7 :[ \"h_riverbed\" , \"Quote over the sea level of the riverbed\" , False , None ], 8 :[ \"h_threshold_al\" , \"Alert quote level\" , False , None ], 9 :[ \"h_threshold_wa\" , \"Warning quote level\" , False , None ] } } serial = fields . String ( required = True , allow_none = False ) radar_1 = PolyCoeff ( default = [ 0 , 1 ], required = False , allow_none = True ) radar_2 = PolyCoeff ( default = [ 0 , 1 ], required = False , allow_none = True ) pluviometer = PolyCoeff ( default = [ 0 , 0.2 ], reqired = False , allow_none = True ) h_radar_1 = fields . Number ( required = True , allow_none = True ) h_radar_2 = fields . Number ( required = True , allow_none = True ) h_min_span_1 = fields . Number ( required = True , allow_none = True ) h_min_span_2 = fields . Number ( required = True , allow_none = True ) h_riverbed = fields . Number ( required = True , allow_none = True ) h_threshold_al = fields . Number ( required = True , allow_none = True ) h_threshold_wa = fields . Number ( required = True , allow_none = True ) class Feature ( HFeature ): ''' RfiLogger ''' def setup ( self , ** kwargs ): pass def config ( self , serial , radar_1 = None , radar_2 = None , pluviometer = None , h_radar_1 = None , h_radar_2 = None , h_min_span_1 = None , h_min_span_2 = None , h_riverbed = None , h_threshold_al = None , h_threshold_wa = None , ** kwargs ): \"\"\" Timestamp, 0:Alarm, 1:Temp_\u00b0C, 2:Humid_%, 3:ADC 0_V, 4:lev1_m, 5:lev2_m, 6:pio1 \"\"\" source = str ( self . __module__ ) try : timestamp = kwargs [ \"timestamp\" ] except KeyError as e : timestamp = None if not self . parameters . __len__ (): if radar_1 is None : radar_1 = \"\" if radar_2 is None : radar_2 = \"\" if h_radar_1 is None : h_radar_1 = 0 if h_radar_2 is None : h_radar_2 = 0 if h_min_span_1 is None : h_min_span_1 = 0 if h_min_span_2 is None : h_min_span_2 = 0 if not h_riverbed is None : buffer = ( h_radar_1 - h_riverbed ) * 0.01 view_range = [ h_riverbed - buffer , h_radar_1 + buffer ] else : view_range = None thresholds = [{ \"label\" : \"Sensor Height\" , \"ttype\" : \"UPPER\" , \"value\" : h_radar_1 , \"color\" : \"#505050\" }] if h_threshold_al is not None : threshold_al = { \"label\" : \"Alert\" , \"ttype\" : \"UPPER\" , \"value\" : h_threshold_al , \"color\" : \"#FF0000\" } thresholds = [ threshold_al , * thresholds ] if h_threshold_wa is not None : threshold_wa = { \"label\" : \"Warning\" , \"ttype\" : \"UPPER\" , \"value\" : h_threshold_wa , \"color\" : \"#FFA500\" } thresholds = [ threshold_wa , * thresholds ] if h_min_span_1 is not None : threshold_sp = { \"label\" : \"Minimal Span Height\" , \"ttype\" : \"UPPER\" , \"value\" : h_min_span_1 , \"color\" : \"#000000\" } thresholds = [ threshold_sp , * thresholds ] threshold_ob = [{ \"label\" : \"Obstruction\" , \"ttype\" : \"LOWER\" , \"value\" : 0 , \"color\" : \"#FF0000\" }] buffer_ob = ( h_min_span_1 - h_riverbed ) * 0.001 view_range_ob = [ 0 - buffer_ob ,( h_min_span_1 - h_riverbed ) + buffer_ob ] self . parameters . set ( \"camera\" , cache = 'inactive' , ordinal = 100 , modules = { \"hls\" : \"hielen3.tools.hls_facility\" }, operator = f \"hls.start_stream(resource= { serial !r} )\" , capability = \"stream\" ) self . parameters . set ( \"temperature\" , cache = 'active' , mu = '\u00b0C' , ordinal = 9 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials= { serial !r} ,times=times,columns=2)\" ) self . parameters . set ( \"humidity\" , cache = 'active' , mu = ' %% ' , ordinal = 10 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials= { serial !r} ,times=times,columns=3)\" ) self . parameters . set ( \"battery\" , cache = 'active' , mu = 'V' , ordinal = 11 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials= { serial !r} ,times=times,columns=4)\" ) self . parameters . set ( \"radar 1\" , cache = 'active' , mu = 'mA' , ordinal = 6 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials= { serial !r} ,times=times,columns=5)\" ) self . parameters . set ( \"radar 2\" , cache = 'active' , mu = 'mA' , ordinal = 7 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials= { serial !r} ,times=times,columns=6)\" ) self . parameters . set ( \"pluviometer\" , cache = 'active' , mu = 'count' , ordinal = 8 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials= { serial !r} ,times=times,columns=7)\" ) if pluviometer is not None : self . parameters . set ( 'rain' , cache = 'active' , mu = 'mm/h' , ordinal = 5 , first = timestamp , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"pluviometer\" ] . uuid }, operator = f \"calc.instant_velocity(calc.poly_trans2(S0, { pluviometer } ))\" ) if radar_1 is not None : self . parameters . set ( 'level 1' , cache = 'active' , mu = \"m.s.l.m.\" , ordinal = 3 , first = timestamp , view_range = view_range , thresholds = thresholds , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"radar 1\" ] . uuid }, operator = f \" { h_radar_1 } - calc.poly_trans2(S0, { radar_1 } )\" ) self . parameters . set ( 'free span 1' , cache = 'active' , mu = \"m\" , ordinal = 1 , thresholds = threshold_ob , first = timestamp , view_range = view_range_ob , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"level 1\" ] . uuid }, operator = f \" { h_min_span_1 } - S0\" ) if radar_2 is not None : self . parameters . set ( 'level 2' , cache = 'active' , mu = \"m.s.l.m.\" , ordinal = 4 , first = timestamp , view_range = view_range , thresholds = thresholds , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"radar 2\" ] . uuid }, operator = f \" { h_radar_2 } - calc.poly_trans2(S0, { radar_2 } )\" ) self . parameters . set ( 'free span 2' , cache = 'active' , mu = \"m\" , ordinal = 2 , first = timestamp , thresholds = threshold_ob , view_range = view_range_ob , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"level 2\" ] . uuid }, operator = f \" { h_min_span_2 } -S0\" ) def retrive ( serials = None , times = None , columns = None , folder = 'gestecno_rfi/data' , func = None , ** kwargs ): f = Path ( conf [ 'incomepath' ]) / folder if not f . is_dir (): f = Path ( conf [ 'incomepath' ]) / 'incomes' folder = f def __extract_gestecno__ ( path ): a = DataFrame ([], dtype = 'float64' ) try : a = read_csv ( path , skiprows = 2 , parse_dates = True , header = None ) if a . empty : a = read_csv ( path , parse_dates = True , header = None ) a = a [ a [ 0 ] . apply ( lambda x : match ( '^\\d {4} -\\d {2} ' , x )) . notna ()] a . columns = [ 'times' , * a . columns [ 1 :] ] except Exception as e : pass return a if func is None : func = __extract_gestecno__ if serials is None : serials = slice ( None , None ) if isinstance ( serials , str ): #serials=slice(serials,serials) serials = [ serials ] if isinstance ( times , datetime ): times = str ( times ) if times is None or isinstance ( times , str ): times = slice ( times , None , None ) start = times . start stop = times . stop if start is not None : orig_start = start start = str ( datetime64 ( start ) - timedelta64 ( 1 , 'D' )) else : orig_start = None if start is not None : datestart = str ( datetime . fromisoformat ( start ) . date ()) else : datestart = None times = slice ( start , stop ) orig_times = slice ( orig_start , stop ) dates = slice ( datestart , stop ) #print (times,\"\\n\",orig_times,\"\\n\",dates) paths = Series ( glob ( f ' { folder } /*/*/*/*' ), dtype = 'object' ) . apply ( Path ) sertime = DataFrame ( paths . apply ( lambda x : ( x . parts [ - 4 ], str ( datetime ( * map ( int , x . parts [ - 3 :]))) ) ) . explode () . values . reshape ( paths . __len__ (), 2 ), columns = [ 'serial' , 'times' ] ) sertime [ 'path' ] = paths . apply ( lambda x : str ( x / \"*\" )) sertime = sertime . set_index ([ 'serial' , 'times' ]) . sort_index () df = DataFrame () try : sertime = sertime . to_frame () except Exception as e : pass if isinstance ( serials , ( list , set , tuple )): serials = list ( sertime . index [ sertime . index . isin ( serials , level = 0 ) ] . droplevel ( 1 ) . drop_duplicates () ) if not serials . __len__ (): return df try : sertime = sertime . loc [( serials , dates ), :] except KeyError as e : return df for serial , paths in sertime . groupby ( 'serial' ): u = concat ( paths [ 'path' ] . apply ( glob ) . explode () . apply ( func ) . values ) u [ 'serial' ] = serial u = u . set_index ([ 'serial' , 'times' ]) df = concat ([ df , u ]) if columns is None : columns = list ( df . columns ) if not isinstance ( columns ,( list , tuple , set )): columns = [ columns ] columns = list ( columns ) df = df [ columns ] . sort_index () . loc [( serials , times ), :] df = df . loc [( serials , times ), :] try : if serials . __len__ () == 1 : df = df . droplevel ( 'serial' , axis = 0 ) . squeeze () ## FILTRO LEVEL 1, LEVEL 2 if 5 in columns or 6 in columns : df = calc . filter ( df , window = 12 )[ orig_times ] df = df . to_frame () except Exception as e : pass return df","title":"Module hielen3.ext.feature_rfilogger.rfilogger"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#variables","text":"conf","title":"Variables"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#logger_serials","text":"def logger_serials ( folder = 'gestecno_rfi/data' ) View Source def logger_serials ( folder = 'gestecno_rfi/data' ) : folder = Path ( conf [ 'incomepath' ] ) / folder / \"*\" serials = Series ( glob ( str ( folder )) , dtype = 'object' ) . apply ( Path ) serials = serials [ serials . apply ( Path . is_dir ) ] return list ( serials . apply ( lambda x : x . name ) . sort_values () . values )","title":"logger_serials"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#retrive","text":"def retrive ( serials = None , times = None , columns = None , folder = 'gestecno_rfi/data' , func = None , ** kwargs ) View Source def retrive ( serials = None , times = None , columns = None , folder = 'gestecno_rfi/data' , func = None , ** kwargs ) : f = Path ( conf [ 'incomepath' ] ) / folder if not f . is_dir () : f = Path ( conf [ 'incomepath' ] ) / 'incomes' folder = f def __extract_gestecno__ ( path ) : a = DataFrame ( [] , dtype = 'float64' ) try : a = read_csv ( path , skiprows = 2 , parse_dates = True , header = None ) if a . empty : a = read_csv ( path , parse_dates = True , header = None ) a = a [ a[0 ] . apply ( lambda x : match ( '^\\d{4}-\\d{2}' , x )). notna () ] a . columns = [ 'times', *a.columns[1: ] ] except Exception as e : pass return a if func is None : func = __extract_gestecno__ if serials is None : serials = slice ( None , None ) if isinstance ( serials , str ) : #serials = slice ( serials , serials ) serials =[ serials ] if isinstance ( times , datetime ) : times = str ( times ) if times is None or isinstance ( times , str ) : times = slice ( times , None , None ) start = times . start stop = times . stop if start is not None : orig_start = start start = str ( datetime64 ( start ) - timedelta64 ( 1 , 'D' )) else : orig_start = None if start is not None : datestart = str ( datetime . fromisoformat ( start ). date ()) else : datestart = None times = slice ( start , stop ) orig_times = slice ( orig_start , stop ) dates = slice ( datestart , stop ) #print ( times , \"\\n\" , orig_times , \"\\n\" , dates ) paths = Series ( glob ( f '{folder}/*/*/*/*' ), dtype = 'object' ). apply ( Path ) sertime = DataFrame ( paths . apply ( lambda x : ( x . parts [ -4 ] , str ( datetime ( * map ( int , x . parts [ -3: ] ))) ) ). explode (). values . reshape ( paths . __len__ (), 2 ), columns =[ 'serial','times' ] ) sertime [ 'path' ]= paths . apply ( lambda x : str ( x / \"*\" )) sertime = sertime . set_index ( [ 'serial','times' ] ). sort_index () df = DataFrame () try : sertime = sertime . to_frame () except Exception as e : pass if isinstance ( serials , ( list , set , tuple )) : serials = list ( sertime . index [ sertime.index.isin(serials,level=0) ] . droplevel ( 1 ). drop_duplicates () ) if not serials . __len__ () : return df try : sertime = sertime . loc [ (serials,dates), : ] except KeyError as e : return df for serial , paths in sertime . groupby ( 'serial' ) : u = concat ( paths [ 'path' ] . apply ( glob ). explode (). apply ( func ). values ) u [ 'serial' ]= serial u = u . set_index ( [ 'serial','times' ] ) df = concat ( [ df,u ] ) if columns is None : columns = list ( df . columns ) if not isinstance ( columns ,( list , tuple , set )) : columns =[ columns ] columns = list ( columns ) df = df [ columns ] . sort_index (). loc [ (serials, times), : ] df = df . loc [ (serials,times), : ] try : if serials . __len__ () == 1 : df = df . droplevel ( 'serial' , axis = 0 ). squeeze () ## FILTRO LEVEL 1 , LEVEL 2 if 5 in columns or 6 in columns : df = calc . filter ( df , window = 12 ) [ orig_times ] df = df . to_frame () except Exception as e : pass return df","title":"retrive"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , logger_serials ()] }, \"Instruments info\" : { 0 :[ \"radar_1\" , \"Radar 1 polynomial coefficients\" , False , None ], 1 :[ \"radar_2\" , \"Radar 2 polynomial coefficients\" , False , None ], 2 :[ \"pluviometer\" , \"Pluviometer polynomial coefficients\" , False , None ], 3 :[ \"h_radar_1\" , \"Quote over sea level of the radar 1\" , False , None ], 4 :[ \"h_radar_2\" , \"Quote over sea level of the radar 2\" , False , None ], 5 :[ \"h_min_span_1\" , \"Quote over the sea level of the minimum free span\" , False , None ], 6 :[ \"h_min_span_2\" , \"Quote over the sea level of the minimum free span\" , False , None ], 7 :[ \"h_riverbed\" , \"Quote over the sea level of the riverbed\" , False , None ], 8 :[ \"h_threshold_al\" , \"Alert quote level\" , False , None ], 9 :[ \"h_threshold_wa\" , \"Warning quote level\" , False , None ] } } serial = fields . String ( required = True , allow_none = False ) radar_1 = PolyCoeff ( default =[ 0 , 1 ], required = False , allow_none = True ) radar_2 = PolyCoeff ( default =[ 0 , 1 ], required = False , allow_none = True ) pluviometer = PolyCoeff ( default =[ 0 , 0.2 ], reqired = False , allow_none = True ) h_radar_1 = fields . Number ( required = True , allow_none = True ) h_radar_2 = fields . Number ( required = True , allow_none = True ) h_min_span_1 = fields . Number ( required = True , allow_none = True ) h_min_span_2 = fields . Number ( required = True , allow_none = True ) h_riverbed = fields . Number ( required = True , allow_none = True ) h_threshold_al = fields . Number ( required = True , allow_none = True ) h_threshold_wa = fields . Number ( required = True , allow_none = True )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#ancestors-in-mro","text":"hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages h_min_span_1 h_min_span_2 h_radar_1 h_radar_2 h_riverbed h_threshold_al h_threshold_wa opts pluviometer radar_1 radar_2 serial","title":"Class variables"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#feature","text":"class Feature ( feature ) RfiLogger View Source class Feature ( HFeature ): ''' RfiLogger ''' def setup ( self , ** kwargs ): pass def config ( self , serial , radar_1 = None , radar_2 = None , pluviometer = None , h_radar_1 = None , h_radar_2 = None , h_min_span_1 = None , h_min_span_2 = None , h_riverbed = None , h_threshold_al = None , h_threshold_wa = None , ** kwargs ): \"\"\" Timestamp, 0:Alarm, 1:Temp_\u00b0C, 2:Humid_%, 3:ADC 0_V, 4:lev1_m, 5:lev2_m, 6:pio1 \"\"\" source = str ( self . __module__ ) try : timestamp = kwargs [ \"timestamp\" ] except KeyError as e : timestamp = None if not self . parameters . __len__ (): if radar_1 is None : radar_1 = \"\" if radar_2 is None : radar_2 = \"\" if h_radar_1 is None : h_radar_1 = 0 if h_radar_2 is None : h_radar_2 = 0 if h_min_span_1 is None : h_min_span_1 = 0 if h_min_span_2 is None : h_min_span_2 = 0 if not h_riverbed is None : buffer = ( h_radar_1 - h_riverbed ) * 0.01 view_range = [ h_riverbed - buffer , h_radar_1 + buffer ] else : view_range = None thresholds = [{ \"label\" : \"Sensor Height\" , \"ttype\" : \"UPPER\" , \"value\" : h_radar_1 , \"color\" : \"#505050\" }] if h_threshold_al is not None : threshold_al = { \"label\" : \"Alert\" , \"ttype\" : \"UPPER\" , \"value\" : h_threshold_al , \"color\" : \"#FF0000\" } thresholds = [ threshold_al , * thresholds ] if h_threshold_wa is not None : threshold_wa = { \"label\" : \"Warning\" , \"ttype\" : \"UPPER\" , \"value\" : h_threshold_wa , \"color\" : \"#FFA500\" } thresholds = [ threshold_wa , * thresholds ] if h_min_span_1 is not None : threshold_sp = { \"label\" : \"Minimal Span Height\" , \"ttype\" : \"UPPER\" , \"value\" : h_min_span_1 , \"color\" : \"#000000\" } thresholds = [ threshold_sp , * thresholds ] threshold_ob = [{ \"label\" : \"Obstruction\" , \"ttype\" : \"LOWER\" , \"value\" : 0 , \"color\" : \"#FF0000\" }] buffer_ob = ( h_min_span_1 - h_riverbed ) * 0.001 view_range_ob = [ 0 - buffer_ob ,( h_min_span_1 - h_riverbed ) + buffer_ob ] self . parameters . set ( \"camera\" , cache = 'inactive' , ordinal = 100 , modules = { \"hls\" : \"hielen3.tools.hls_facility\" }, operator = f \"hls.start_stream(resource={serial!r})\" , capability = \"stream\" ) self . parameters . set ( \"temperature\" , cache = 'active' , mu = '\u00b0C' , ordinal = 9 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=2)\" ) self . parameters . set ( \"humidity\" , cache = 'active' , mu = ' %% ' , ordinal = 10 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=3)\" ) self . parameters . set ( \"battery\" , cache = 'active' , mu = 'V' , ordinal = 11 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=4)\" ) self . parameters . set ( \"radar 1\" , cache = 'active' , mu = 'mA' , ordinal = 6 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=5)\" ) self . parameters . set ( \"radar 2\" , cache = 'active' , mu = 'mA' , ordinal = 7 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=6)\" ) self . parameters . set ( \"pluviometer\" , cache = 'active' , mu = 'count' , ordinal = 8 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=7)\" ) if pluviometer is not None : self . parameters . set ( 'rain' , cache = 'active' , mu = 'mm/h' , ordinal = 5 , first = timestamp , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"pluviometer\" ] . uuid }, operator = f \"calc.instant_velocity(calc.poly_trans2(S0,{pluviometer}))\" ) if radar_1 is not None : self . parameters . set ( 'level 1' , cache = 'active' , mu = \"m.s.l.m.\" , ordinal = 3 , first = timestamp , view_range = view_range , thresholds = thresholds , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"radar 1\" ] . uuid }, operator = f \"{h_radar_1} - calc.poly_trans2(S0,{radar_1})\" ) self . parameters . set ( 'free span 1' , cache = 'active' , mu = \"m\" , ordinal = 1 , thresholds = threshold_ob , first = timestamp , view_range = view_range_ob , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"level 1\" ] . uuid }, operator = f \"{h_min_span_1} - S0\" ) if radar_2 is not None : self . parameters . set ( 'level 2' , cache = 'active' , mu = \"m.s.l.m.\" , ordinal = 4 , first = timestamp , view_range = view_range , thresholds = thresholds , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"radar 2\" ] . uuid }, operator = f \"{h_radar_2} - calc.poly_trans2(S0,{radar_2})\" ) self . parameters . set ( 'free span 2' , cache = 'active' , mu = \"m\" , ordinal = 2 , first = timestamp , thresholds = threshold_ob , view_range = view_range_ob , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"level 2\" ] . uuid }, operator = f \"{h_min_span_2}-S0\" )","title":"Feature"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#config","text":"def config ( self , serial , radar_1 = None , radar_2 = None , pluviometer = None , h_radar_1 = None , h_radar_2 = None , h_min_span_1 = None , h_min_span_2 = None , h_riverbed = None , h_threshold_al = None , h_threshold_wa = None , ** kwargs ) Timestamp, 0:Alarm, 1:Temp_\u00b0C, 2:Humid_%, 3:ADC 0_V, 4:lev1_m, 5:lev2_m, 6:pio1 View Source def config ( self , serial , radar_1 = None , radar_2 = None , pluviometer = None , h_radar_1 = None , h_radar_2 = None , h_min_span_1 = None , h_min_span_2 = None , h_riverbed = None , h_threshold_al = None , h_threshold_wa = None , ** kwargs ): \"\"\" Timestamp, 0:Alarm, 1:Temp_\u00b0C, 2:Humid_%, 3:ADC 0_V, 4:lev1_m, 5:lev2_m, 6:pio1 \"\"\" source = str ( self . __module__ ) try : timestamp = kwargs [ \"timestamp\" ] except KeyError as e : timestamp = None if not self . parameters . __len__ (): if radar_1 is None : radar_1 = \"\" if radar_2 is None : radar_2 = \"\" if h_radar_1 is None : h_radar_1 = 0 if h_radar_2 is None : h_radar_2 = 0 if h_min_span_1 is None : h_min_span_1 = 0 if h_min_span_2 is None : h_min_span_2 = 0 if not h_riverbed is None : buffer = ( h_radar_1 - h_riverbed ) * 0.01 view_range = [ h_riverbed - buffer , h_radar_1 + buffer ] else : view_range = None thresholds = [{ \"label\" : \"Sensor Height\" , \"ttype\" : \"UPPER\" , \"value\" : h_radar_1 , \"color\" : \"#505050\" }] if h_threshold_al is not None : threshold_al = { \"label\" : \"Alert\" , \"ttype\" : \"UPPER\" , \"value\" : h_threshold_al , \"color\" : \"#FF0000\" } thresholds = [ threshold_al , * thresholds ] if h_threshold_wa is not None : threshold_wa = { \"label\" : \"Warning\" , \"ttype\" : \"UPPER\" , \"value\" : h_threshold_wa , \"color\" : \"#FFA500\" } thresholds = [ threshold_wa , * thresholds ] if h_min_span_1 is not None : threshold_sp = { \"label\" : \"Minimal Span Height\" , \"ttype\" : \"UPPER\" , \"value\" : h_min_span_1 , \"color\" : \"#000000\" } thresholds = [ threshold_sp , * thresholds ] threshold_ob = [{ \"label\" : \"Obstruction\" , \"ttype\" : \"LOWER\" , \"value\" : 0 , \"color\" : \"#FF0000\" }] buffer_ob = ( h_min_span_1 - h_riverbed ) * 0.001 view_range_ob = [ 0 - buffer_ob ,( h_min_span_1 - h_riverbed ) + buffer_ob ] self . parameters . set ( \"camera\" , cache = 'inactive' , ordinal = 100 , modules = { \"hls\" : \"hielen3.tools.hls_facility\" }, operator = f \"hls.start_stream(resource={serial!r})\" , capability = \"stream\" ) self . parameters . set ( \"temperature\" , cache = 'active' , mu = '\u00b0C' , ordinal = 9 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=2)\" ) self . parameters . set ( \"humidity\" , cache = 'active' , mu = ' %% ' , ordinal = 10 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=3)\" ) self . parameters . set ( \"battery\" , cache = 'active' , mu = 'V' , ordinal = 11 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=4)\" ) self . parameters . set ( \"radar 1\" , cache = 'active' , mu = 'mA' , ordinal = 6 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=5)\" ) self . parameters . set ( \"radar 2\" , cache = 'active' , mu = 'mA' , ordinal = 7 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=6)\" ) self . parameters . set ( \"pluviometer\" , cache = 'active' , mu = 'count' , ordinal = 8 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=7)\" ) if pluviometer is not None : self . parameters . set ( 'rain' , cache = 'active' , mu = 'mm/h' , ordinal = 5 , first = timestamp , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"pluviometer\" ] . uuid }, operator = f \"calc.instant_velocity(calc.poly_trans2(S0,{pluviometer}))\" ) if radar_1 is not None : self . parameters . set ( 'level 1' , cache = 'active' , mu = \"m.s.l.m.\" , ordinal = 3 , first = timestamp , view_range = view_range , thresholds = thresholds , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"radar 1\" ] . uuid }, operator = f \"{h_radar_1} - calc.poly_trans2(S0,{radar_1})\" ) self . parameters . set ( 'free span 1' , cache = 'active' , mu = \"m\" , ordinal = 1 , thresholds = threshold_ob , first = timestamp , view_range = view_range_ob , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"level 1\" ] . uuid }, operator = f \"{h_min_span_1} - S0\" ) if radar_2 is not None : self . parameters . set ( 'level 2' , cache = 'active' , mu = \"m.s.l.m.\" , ordinal = 4 , first = timestamp , view_range = view_range , thresholds = thresholds , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"radar 2\" ] . uuid }, operator = f \"{h_radar_2} - calc.poly_trans2(S0,{radar_2})\" ) self . parameters . set ( 'free span 2' , cache = 'active' , mu = \"m\" , ordinal = 2 , first = timestamp , thresholds = threshold_ob , view_range = view_range_ob , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"level 2\" ] . uuid }, operator = f \"{h_min_span_2}-S0\" )","title":"config"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#retrive_1","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#setup","text":"def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/","text":"Module hielen3.ext.feature_rfilogger.rfilogger_good View Source # coding=utf-8 from hielen3 import conf from hielen3.feature import HFeature from hielen3.series import HSeries from hielen3.serializaction import ActionSchema , FTPPath , PolyCoeff , LoggerHeader from marshmallow import fields #from pandas import read_csv, DatetimeIndex, Series, DataFrame from pathlib import Path import traceback from glob import glob from pathlib import Path from pandas import Series , DataFrame , read_csv , concat from datetime import datetime def logger_serials ( folder = 'gestecno_rfi/data' ): folder = Path ( conf [ 'incomepath' ]) / folder / \"*\" serials = Series ( glob ( str ( folder )), dtype = 'object' ) . apply ( Path ) serials = serials [ serials . apply ( Path . is_dir )] return list ( serials . apply ( lambda x : x . name ) . sort_values () . values ) class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , logger_serials ()] }, \"Instruments info\" : { 0 :[ \"radar_1\" , \"Radar 1 polynomial coefficients\" , False , None ], 1 :[ \"radar_2\" , \"Radar 2 polynomial coefficients\" , False , None ], 2 :[ \"pluviometer\" , \"Pluviometer polynomial coefficients\" , False , None ], 3 :[ \"h_radar_1\" , \"Quote over sea level of the radar 1\" , False , None ], 4 :[ \"h_radar_2\" , \"Quote over sea level of the radar 2\" , False , None ], 5 :[ \"h_min_span_1\" , \"Quote over the sea level of the minimum free span\" , False , None ], 6 :[ \"h_min_span_2\" , \"Quote over the sea level of the minimum free span\" , False , None ], 7 :[ \"h_riverbed\" , \"Quote over the sea level of the riverbed\" , False , None ], 8 :[ \"h_threshold_al\" , \"Alert quote level\" , False , None ], 9 :[ \"h_threshold_wa\" , \"Warning quote level\" , False , None ] } } serial = fields . String ( required = True , allow_none = False ) radar_1 = PolyCoeff ( default = [ 0 , 1 ], required = False , allow_none = True ) radar_2 = PolyCoeff ( default = [ 0 , 1 ], required = False , allow_none = True ) pluviometer = PolyCoeff ( default = [ 0 , 0.2 ], reqired = False , allow_none = True ) h_radar_1 = fields . Number ( required = True , allow_none = True ) h_radar_2 = fields . Number ( required = True , allow_none = True ) h_min_span_1 = fields . Number ( required = True , allow_none = True ) h_min_span_2 = fields . Number ( required = True , allow_none = True ) h_riverbed = fields . Number ( required = True , allow_none = True ) h_threshold_al = fields . Number ( required = True , allow_none = True ) h_threshold_wa = fields . Number ( required = True , allow_none = True ) class Feature ( HFeature ): ''' RfiLogger ''' def setup ( self , ** kwargs ): pass def config ( self , serial , radar_1 = None , radar_2 = None , pluviometer = None , h_radar_1 = None , h_radar_2 = None , h_min_span_1 = None , h_min_span_2 = None , h_riverbed = None , h_threshold_al = None , h_threshold_wa = None , ** kwargs ): \"\"\" Timestamp, 0:Alarm, 1:Temp_\u00b0C, 2:Humid_%, 3:ADC 0_V, 4:lev1_m, 5:lev2_m, 6:pio1 \"\"\" source = str ( self . __module__ ) try : timestamp = kwargs [ \"timestamp\" ] except KeyError as e : timestamp = None if not self . parameters . __len__ (): if radar_1 is None : radar_1 = \"\" if radar_2 is None : radar_2 = \"\" if h_radar_1 is None : h_radar_1 = 0 if h_radar_2 is None : h_radar_2 = 0 if h_min_span_1 is None : h_min_span_1 = 0 if h_min_span_2 is None : h_min_span_2 = 0 if not h_riverbed is None : buffer = ( h_radar_1 - h_riverbed ) * 0.01 view_range = [ h_riverbed - buffer , h_radar_1 + buffer ] else : view_range = None thresholds = [{ \"label\" : \"Sensor Height\" , \"ttype\" : \"UPPER\" , \"value\" : h_radar_1 , \"color\" : \"#505050\" }] if h_threshold_al is not None : threshold_al = { \"label\" : \"Alert\" , \"ttype\" : \"UPPER\" , \"value\" : h_threshold_al , \"color\" : \"#FF0000\" } thresholds = [ threshold_al , * thresholds ] if h_threshold_wa is not None : threshold_wa = { \"label\" : \"Warning\" , \"ttype\" : \"UPPER\" , \"value\" : h_threshold_wa , \"color\" : \"#FFA500\" } thresholds = [ threshold_wa , * thresholds ] if h_min_span_1 is not None : threshold_sp = { \"label\" : \"Minimal Span Height\" , \"ttype\" : \"UPPER\" , \"value\" : h_min_span_1 , \"color\" : \"#000000\" } thresholds = [ threshold_sp , * thresholds ] threshold_ob = [{ \"label\" : \"Obstruction\" , \"ttype\" : \"LOWER\" , \"value\" : 0 , \"color\" : \"#FF0000\" }] buffer_ob = ( h_min_span_1 - h_riverbed ) * 0.001 view_range_ob = [ 0 - buffer_ob ,( h_min_span_1 - h_riverbed ) + buffer_ob ] self . parameters . set ( \"camera\" , cache = 'inactive' , ordinal = 100 , modules = { \"hls\" : \"hielen3.tools.hls_facility\" }, operator = f \"hls.start_stream(resource= { serial !r} )\" , capability = \"stream\" ) self . parameters . set ( \"temperature\" , cache = 'active' , mu = '\u00b0C' , ordinal = 9 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials= { serial !r} ,times=times,columns=2)\" ) self . parameters . set ( \"humidity\" , cache = 'active' , mu = ' %% ' , ordinal = 10 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials= { serial !r} ,times=times,columns=3)\" ) self . parameters . set ( \"battery\" , cache = 'active' , mu = 'V' , ordinal = 11 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials= { serial !r} ,times=times,columns=4)\" ) self . parameters . set ( \"radar 1\" , cache = 'active' , mu = 'mA' , ordinal = 6 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials= { serial !r} ,times=times,columns=5)\" ) self . parameters . set ( \"radar 2\" , cache = 'active' , mu = 'mA' , ordinal = 7 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials= { serial !r} ,times=times,columns=6)\" ) self . parameters . set ( \"pluviometer\" , cache = 'active' , mu = 'count' , ordinal = 8 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials= { serial !r} ,times=times,columns=7)\" ) if pluviometer is not None : self . parameters . set ( 'rain' , cache = 'active' , mu = 'mm/h' , ordinal = 5 , first = timestamp , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"pluviometer\" ] . uuid }, operator = f \"calc.instant_velocity(calc.poly_trans2(S0, { pluviometer } ))\" ) if radar_1 is not None : self . parameters . set ( 'level 1' , cache = 'active' , mu = \"m.s.l.m.\" , ordinal = 3 , first = timestamp , view_range = view_range , thresholds = thresholds , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"radar 1\" ] . uuid }, operator = f \" { h_radar_1 } - calc.poly_trans2(S0, { radar_1 } )\" ) self . parameters . set ( 'free span 1' , cache = 'active' , mu = \"m\" , ordinal = 1 , thresholds = threshold_ob , first = timestamp , view_range = view_range_ob , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"level 1\" ] . uuid }, operator = f \" { h_min_span_1 } - S0\" ) if radar_2 is not None : self . parameters . set ( 'level 2' , cache = 'active' , mu = \"m.s.l.m.\" , ordinal = 4 , first = timestamp , view_range = view_range , thresholds = thresholds , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"radar 2\" ] . uuid }, operator = f \" { h_radar_2 } - calc.poly_trans2(S0, { radar_2 } )\" ) self . parameters . set ( 'free span 2' , cache = 'active' , mu = \"m\" , ordinal = 2 , first = timestamp , thresholds = threshold_ob , view_range = view_range_ob , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"level 2\" ] . uuid }, operator = f \" { h_min_span_2 } -S0\" ) def retrive ( serials = None , times = None , columns = None , folder = 'gestecno_rfi/data' , func = None , ** kwargs ): f = Path ( conf [ 'incomepath' ]) / folder if not f . is_dir (): f = Path ( conf [ 'incomepath' ]) / 'incomes' folder = f def __extract_gestecno__ ( path ): a = DataFrame ([], dtype = 'float64' ) try : a = read_csv ( path , skiprows = 2 , parse_dates = True , header = None ) if a . empty : a = read_csv ( path , parse_dates = True , header = None ) a = a [ a [ 0 ] . apply ( lambda x : match ( '^\\d {4} -\\d {2} ' , x )) . notna ()] a . columns = [ 'times' , * a . columns [ 1 :] ] except Exception as e : pass return a if func is None : func = __extract_gestecno__ if serials is None : serials = slice ( None , None ) if isinstance ( serials , str ): #serials=slice(serials,serials) serials = [ serials ] if isinstance ( times , datetime ): times = str ( times ) if times is None or isinstance ( times , str ): times = slice ( times , None , None ) start = times . start stop = times . stop if start is not None : datestart = str ( datetime . fromisoformat ( start ) . date ()) else : datestart = None times = slice ( start , stop ) dates = slice ( datestart , stop ) paths = Series ( glob ( f ' { folder } /*/*/*/*' ), dtype = 'object' ) . apply ( Path ) sertime = DataFrame ( paths . apply ( lambda x : ( x . parts [ - 4 ], str ( datetime ( * map ( int , x . parts [ - 3 :]))) ) ) . explode () . values . reshape ( paths . __len__ (), 2 ), columns = [ 'serial' , 'times' ] ) sertime [ 'path' ] = paths . apply ( lambda x : str ( x / \"*\" )) sertime = sertime . set_index ([ 'serial' , 'times' ]) . sort_index () df = DataFrame () try : sertime = sertime . to_frame () except Exception as e : pass if isinstance ( serials , ( list , set , tuple )): serials = list ( sertime . index [ sertime . index . isin ( serials , level = 0 ) ] . droplevel ( 1 ) . drop_duplicates () ) if not serials . __len__ (): return df try : sertime = sertime . loc [( serials , dates ), :] except KeyError as e : return df for serial , paths in sertime . groupby ( 'serial' ): u = concat ( paths [ 'path' ] . apply ( glob ) . explode () . apply ( func ) . values ) u [ 'serial' ] = serial u = u . set_index ([ 'serial' , 'times' ]) df = concat ([ df , u ]) if columns is None : columns = list ( df . columns ) if not isinstance ( columns ,( list , tuple , set )): columns = [ columns ] columns = list ( columns ) df = df [ columns ] . sort_index () . loc [( serials , times ), :] try : if serials . __len__ () == 1 : df = df . droplevel ( 'serial' , axis = 0 ) except Exception as e : pass return df Variables conf Functions logger_serials def logger_serials ( folder = 'gestecno_rfi/data' ) View Source def logger_serials ( folder = 'gestecno_rfi/data' ) : folder = Path ( conf [ 'incomepath' ] ) / folder / \"*\" serials = Series ( glob ( str ( folder )) , dtype = 'object' ) . apply ( Path ) serials = serials [ serials . apply ( Path . is_dir ) ] return list ( serials . apply ( lambda x : x . name ) . sort_values () . values ) retrive def retrive ( serials = None , times = None , columns = None , folder = 'gestecno_rfi/data' , func = None , ** kwargs ) View Source def retrive ( serials = None , times = None , columns = None , folder = 'gestecno_rfi/data' , func = None , ** kwargs ) : f = Path ( conf [ 'incomepath' ] ) / folder if not f . is_dir () : f = Path ( conf [ 'incomepath' ] ) / 'incomes' folder = f def __extract_gestecno__ ( path ) : a = DataFrame ( [] , dtype = 'float64' ) try : a = read_csv ( path , skiprows = 2 , parse_dates = True , header = None ) if a . empty : a = read_csv ( path , parse_dates = True , header = None ) a = a [ a[0 ] . apply ( lambda x : match ( '^\\d{4}-\\d{2}' , x )). notna () ] a . columns = [ 'times', *a.columns[1: ] ] except Exception as e : pass return a if func is None : func = __extract_gestecno__ if serials is None : serials = slice ( None , None ) if isinstance ( serials , str ) : #serials = slice ( serials , serials ) serials =[ serials ] if isinstance ( times , datetime ) : times = str ( times ) if times is None or isinstance ( times , str ) : times = slice ( times , None , None ) start = times . start stop = times . stop if start is not None : datestart = str ( datetime . fromisoformat ( start ). date ()) else : datestart = None times = slice ( start , stop ) dates = slice ( datestart , stop ) paths = Series ( glob ( f '{folder}/*/*/*/*' ), dtype = 'object' ). apply ( Path ) sertime = DataFrame ( paths . apply ( lambda x : ( x . parts [ -4 ] , str ( datetime ( * map ( int , x . parts [ -3: ] ))) ) ). explode (). values . reshape ( paths . __len__ (), 2 ), columns =[ 'serial','times' ] ) sertime [ 'path' ]= paths . apply ( lambda x : str ( x / \"*\" )) sertime = sertime . set_index ( [ 'serial','times' ] ). sort_index () df = DataFrame () try : sertime = sertime . to_frame () except Exception as e : pass if isinstance ( serials , ( list , set , tuple )) : serials = list ( sertime . index [ sertime.index.isin(serials,level=0) ] . droplevel ( 1 ). drop_duplicates () ) if not serials . __len__ () : return df try : sertime = sertime . loc [ (serials,dates), : ] except KeyError as e : return df for serial , paths in sertime . groupby ( 'serial' ) : u = concat ( paths [ 'path' ] . apply ( glob ). explode (). apply ( func ). values ) u [ 'serial' ]= serial u = u . set_index ( [ 'serial','times' ] ) df = concat ( [ df,u ] ) if columns is None : columns = list ( df . columns ) if not isinstance ( columns ,( list , tuple , set )) : columns =[ columns ] columns = list ( columns ) df = df [ columns ] . sort_index (). loc [ (serials, times), : ] try : if serials . __len__ () == 1 : df = df . droplevel ( 'serial' , axis = 0 ) except Exception as e : pass return df Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , logger_serials ()] }, \"Instruments info\" : { 0 :[ \"radar_1\" , \"Radar 1 polynomial coefficients\" , False , None ], 1 :[ \"radar_2\" , \"Radar 2 polynomial coefficients\" , False , None ], 2 :[ \"pluviometer\" , \"Pluviometer polynomial coefficients\" , False , None ], 3 :[ \"h_radar_1\" , \"Quote over sea level of the radar 1\" , False , None ], 4 :[ \"h_radar_2\" , \"Quote over sea level of the radar 2\" , False , None ], 5 :[ \"h_min_span_1\" , \"Quote over the sea level of the minimum free span\" , False , None ], 6 :[ \"h_min_span_2\" , \"Quote over the sea level of the minimum free span\" , False , None ], 7 :[ \"h_riverbed\" , \"Quote over the sea level of the riverbed\" , False , None ], 8 :[ \"h_threshold_al\" , \"Alert quote level\" , False , None ], 9 :[ \"h_threshold_wa\" , \"Warning quote level\" , False , None ] } } serial = fields . String ( required = True , allow_none = False ) radar_1 = PolyCoeff ( default =[ 0 , 1 ], required = False , allow_none = True ) radar_2 = PolyCoeff ( default =[ 0 , 1 ], required = False , allow_none = True ) pluviometer = PolyCoeff ( default =[ 0 , 0.2 ], reqired = False , allow_none = True ) h_radar_1 = fields . Number ( required = True , allow_none = True ) h_radar_2 = fields . Number ( required = True , allow_none = True ) h_min_span_1 = fields . Number ( required = True , allow_none = True ) h_min_span_2 = fields . Number ( required = True , allow_none = True ) h_riverbed = fields . Number ( required = True , allow_none = True ) h_threshold_al = fields . Number ( required = True , allow_none = True ) h_threshold_wa = fields . Number ( required = True , allow_none = True ) Ancestors (in MRO) hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages h_min_span_1 h_min_span_2 h_radar_1 h_radar_2 h_riverbed h_threshold_al h_threshold_wa opts pluviometer radar_1 radar_2 serial Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) RfiLogger View Source class Feature ( HFeature ): ''' RfiLogger ''' def setup ( self , ** kwargs ): pass def config ( self , serial , radar_1 = None , radar_2 = None , pluviometer = None , h_radar_1 = None , h_radar_2 = None , h_min_span_1 = None , h_min_span_2 = None , h_riverbed = None , h_threshold_al = None , h_threshold_wa = None , ** kwargs ): \"\"\" Timestamp, 0:Alarm, 1:Temp_\u00b0C, 2:Humid_%, 3:ADC 0_V, 4:lev1_m, 5:lev2_m, 6:pio1 \"\"\" source = str ( self . __module__ ) try : timestamp = kwargs [ \"timestamp\" ] except KeyError as e : timestamp = None if not self . parameters . __len__ (): if radar_1 is None : radar_1 = \"\" if radar_2 is None : radar_2 = \"\" if h_radar_1 is None : h_radar_1 = 0 if h_radar_2 is None : h_radar_2 = 0 if h_min_span_1 is None : h_min_span_1 = 0 if h_min_span_2 is None : h_min_span_2 = 0 if not h_riverbed is None : buffer = ( h_radar_1 - h_riverbed ) * 0.01 view_range = [ h_riverbed - buffer , h_radar_1 + buffer ] else : view_range = None thresholds = [{ \"label\" : \"Sensor Height\" , \"ttype\" : \"UPPER\" , \"value\" : h_radar_1 , \"color\" : \"#505050\" }] if h_threshold_al is not None : threshold_al = { \"label\" : \"Alert\" , \"ttype\" : \"UPPER\" , \"value\" : h_threshold_al , \"color\" : \"#FF0000\" } thresholds = [ threshold_al , * thresholds ] if h_threshold_wa is not None : threshold_wa = { \"label\" : \"Warning\" , \"ttype\" : \"UPPER\" , \"value\" : h_threshold_wa , \"color\" : \"#FFA500\" } thresholds = [ threshold_wa , * thresholds ] if h_min_span_1 is not None : threshold_sp = { \"label\" : \"Minimal Span Height\" , \"ttype\" : \"UPPER\" , \"value\" : h_min_span_1 , \"color\" : \"#000000\" } thresholds = [ threshold_sp , * thresholds ] threshold_ob = [{ \"label\" : \"Obstruction\" , \"ttype\" : \"LOWER\" , \"value\" : 0 , \"color\" : \"#FF0000\" }] buffer_ob = ( h_min_span_1 - h_riverbed ) * 0.001 view_range_ob = [ 0 - buffer_ob ,( h_min_span_1 - h_riverbed ) + buffer_ob ] self . parameters . set ( \"camera\" , cache = 'inactive' , ordinal = 100 , modules = { \"hls\" : \"hielen3.tools.hls_facility\" }, operator = f \"hls.start_stream(resource={serial!r})\" , capability = \"stream\" ) self . parameters . set ( \"temperature\" , cache = 'active' , mu = '\u00b0C' , ordinal = 9 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=2)\" ) self . parameters . set ( \"humidity\" , cache = 'active' , mu = ' %% ' , ordinal = 10 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=3)\" ) self . parameters . set ( \"battery\" , cache = 'active' , mu = 'V' , ordinal = 11 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=4)\" ) self . parameters . set ( \"radar 1\" , cache = 'active' , mu = 'mA' , ordinal = 6 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=5)\" ) self . parameters . set ( \"radar 2\" , cache = 'active' , mu = 'mA' , ordinal = 7 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=6)\" ) self . parameters . set ( \"pluviometer\" , cache = 'active' , mu = 'count' , ordinal = 8 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=7)\" ) if pluviometer is not None : self . parameters . set ( 'rain' , cache = 'active' , mu = 'mm/h' , ordinal = 5 , first = timestamp , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"pluviometer\" ] . uuid }, operator = f \"calc.instant_velocity(calc.poly_trans2(S0,{pluviometer}))\" ) if radar_1 is not None : self . parameters . set ( 'level 1' , cache = 'active' , mu = \"m.s.l.m.\" , ordinal = 3 , first = timestamp , view_range = view_range , thresholds = thresholds , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"radar 1\" ] . uuid }, operator = f \"{h_radar_1} - calc.poly_trans2(S0,{radar_1})\" ) self . parameters . set ( 'free span 1' , cache = 'active' , mu = \"m\" , ordinal = 1 , thresholds = threshold_ob , first = timestamp , view_range = view_range_ob , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"level 1\" ] . uuid }, operator = f \"{h_min_span_1} - S0\" ) if radar_2 is not None : self . parameters . set ( 'level 2' , cache = 'active' , mu = \"m.s.l.m.\" , ordinal = 4 , first = timestamp , view_range = view_range , thresholds = thresholds , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"radar 2\" ] . uuid }, operator = f \"{h_radar_2} - calc.poly_trans2(S0,{radar_2})\" ) self . parameters . set ( 'free span 2' , cache = 'active' , mu = \"m\" , ordinal = 2 , first = timestamp , thresholds = threshold_ob , view_range = view_range_ob , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"level 2\" ] . uuid }, operator = f \"{h_min_span_2}-S0\" ) Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , serial , radar_1 = None , radar_2 = None , pluviometer = None , h_radar_1 = None , h_radar_2 = None , h_min_span_1 = None , h_min_span_2 = None , h_riverbed = None , h_threshold_al = None , h_threshold_wa = None , ** kwargs ) Timestamp, 0:Alarm, 1:Temp_\u00b0C, 2:Humid_%, 3:ADC 0_V, 4:lev1_m, 5:lev2_m, 6:pio1 View Source def config ( self , serial , radar_1 = None , radar_2 = None , pluviometer = None , h_radar_1 = None , h_radar_2 = None , h_min_span_1 = None , h_min_span_2 = None , h_riverbed = None , h_threshold_al = None , h_threshold_wa = None , ** kwargs ): \"\"\" Timestamp, 0:Alarm, 1:Temp_\u00b0C, 2:Humid_%, 3:ADC 0_V, 4:lev1_m, 5:lev2_m, 6:pio1 \"\"\" source = str ( self . __module__ ) try : timestamp = kwargs [ \"timestamp\" ] except KeyError as e : timestamp = None if not self . parameters . __len__ (): if radar_1 is None : radar_1 = \"\" if radar_2 is None : radar_2 = \"\" if h_radar_1 is None : h_radar_1 = 0 if h_radar_2 is None : h_radar_2 = 0 if h_min_span_1 is None : h_min_span_1 = 0 if h_min_span_2 is None : h_min_span_2 = 0 if not h_riverbed is None : buffer = ( h_radar_1 - h_riverbed ) * 0.01 view_range = [ h_riverbed - buffer , h_radar_1 + buffer ] else : view_range = None thresholds = [{ \"label\" : \"Sensor Height\" , \"ttype\" : \"UPPER\" , \"value\" : h_radar_1 , \"color\" : \"#505050\" }] if h_threshold_al is not None : threshold_al = { \"label\" : \"Alert\" , \"ttype\" : \"UPPER\" , \"value\" : h_threshold_al , \"color\" : \"#FF0000\" } thresholds = [ threshold_al , * thresholds ] if h_threshold_wa is not None : threshold_wa = { \"label\" : \"Warning\" , \"ttype\" : \"UPPER\" , \"value\" : h_threshold_wa , \"color\" : \"#FFA500\" } thresholds = [ threshold_wa , * thresholds ] if h_min_span_1 is not None : threshold_sp = { \"label\" : \"Minimal Span Height\" , \"ttype\" : \"UPPER\" , \"value\" : h_min_span_1 , \"color\" : \"#000000\" } thresholds = [ threshold_sp , * thresholds ] threshold_ob = [{ \"label\" : \"Obstruction\" , \"ttype\" : \"LOWER\" , \"value\" : 0 , \"color\" : \"#FF0000\" }] buffer_ob = ( h_min_span_1 - h_riverbed ) * 0.001 view_range_ob = [ 0 - buffer_ob ,( h_min_span_1 - h_riverbed ) + buffer_ob ] self . parameters . set ( \"camera\" , cache = 'inactive' , ordinal = 100 , modules = { \"hls\" : \"hielen3.tools.hls_facility\" }, operator = f \"hls.start_stream(resource={serial!r})\" , capability = \"stream\" ) self . parameters . set ( \"temperature\" , cache = 'active' , mu = '\u00b0C' , ordinal = 9 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=2)\" ) self . parameters . set ( \"humidity\" , cache = 'active' , mu = ' %% ' , ordinal = 10 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=3)\" ) self . parameters . set ( \"battery\" , cache = 'active' , mu = 'V' , ordinal = 11 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=4)\" ) self . parameters . set ( \"radar 1\" , cache = 'active' , mu = 'mA' , ordinal = 6 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=5)\" ) self . parameters . set ( \"radar 2\" , cache = 'active' , mu = 'mA' , ordinal = 7 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=6)\" ) self . parameters . set ( \"pluviometer\" , cache = 'active' , mu = 'count' , ordinal = 8 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=7)\" ) if pluviometer is not None : self . parameters . set ( 'rain' , cache = 'active' , mu = 'mm/h' , ordinal = 5 , first = timestamp , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"pluviometer\" ] . uuid }, operator = f \"calc.instant_velocity(calc.poly_trans2(S0,{pluviometer}))\" ) if radar_1 is not None : self . parameters . set ( 'level 1' , cache = 'active' , mu = \"m.s.l.m.\" , ordinal = 3 , first = timestamp , view_range = view_range , thresholds = thresholds , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"radar 1\" ] . uuid }, operator = f \"{h_radar_1} - calc.poly_trans2(S0,{radar_1})\" ) self . parameters . set ( 'free span 1' , cache = 'active' , mu = \"m\" , ordinal = 1 , thresholds = threshold_ob , first = timestamp , view_range = view_range_ob , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"level 1\" ] . uuid }, operator = f \"{h_min_span_1} - S0\" ) if radar_2 is not None : self . parameters . set ( 'level 2' , cache = 'active' , mu = \"m.s.l.m.\" , ordinal = 4 , first = timestamp , view_range = view_range , thresholds = thresholds , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"radar 2\" ] . uuid }, operator = f \"{h_radar_2} - calc.poly_trans2(S0,{radar_2})\" ) self . parameters . set ( 'free span 2' , cache = 'active' , mu = \"m\" , ordinal = 2 , first = timestamp , thresholds = threshold_ob , view_range = view_range_ob , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"level 2\" ] . uuid }, operator = f \"{h_min_span_2}-S0\" ) create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Rfilogger Good"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#module-hielen3extfeature_rfiloggerrfilogger_good","text":"View Source # coding=utf-8 from hielen3 import conf from hielen3.feature import HFeature from hielen3.series import HSeries from hielen3.serializaction import ActionSchema , FTPPath , PolyCoeff , LoggerHeader from marshmallow import fields #from pandas import read_csv, DatetimeIndex, Series, DataFrame from pathlib import Path import traceback from glob import glob from pathlib import Path from pandas import Series , DataFrame , read_csv , concat from datetime import datetime def logger_serials ( folder = 'gestecno_rfi/data' ): folder = Path ( conf [ 'incomepath' ]) / folder / \"*\" serials = Series ( glob ( str ( folder )), dtype = 'object' ) . apply ( Path ) serials = serials [ serials . apply ( Path . is_dir )] return list ( serials . apply ( lambda x : x . name ) . sort_values () . values ) class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , logger_serials ()] }, \"Instruments info\" : { 0 :[ \"radar_1\" , \"Radar 1 polynomial coefficients\" , False , None ], 1 :[ \"radar_2\" , \"Radar 2 polynomial coefficients\" , False , None ], 2 :[ \"pluviometer\" , \"Pluviometer polynomial coefficients\" , False , None ], 3 :[ \"h_radar_1\" , \"Quote over sea level of the radar 1\" , False , None ], 4 :[ \"h_radar_2\" , \"Quote over sea level of the radar 2\" , False , None ], 5 :[ \"h_min_span_1\" , \"Quote over the sea level of the minimum free span\" , False , None ], 6 :[ \"h_min_span_2\" , \"Quote over the sea level of the minimum free span\" , False , None ], 7 :[ \"h_riverbed\" , \"Quote over the sea level of the riverbed\" , False , None ], 8 :[ \"h_threshold_al\" , \"Alert quote level\" , False , None ], 9 :[ \"h_threshold_wa\" , \"Warning quote level\" , False , None ] } } serial = fields . String ( required = True , allow_none = False ) radar_1 = PolyCoeff ( default = [ 0 , 1 ], required = False , allow_none = True ) radar_2 = PolyCoeff ( default = [ 0 , 1 ], required = False , allow_none = True ) pluviometer = PolyCoeff ( default = [ 0 , 0.2 ], reqired = False , allow_none = True ) h_radar_1 = fields . Number ( required = True , allow_none = True ) h_radar_2 = fields . Number ( required = True , allow_none = True ) h_min_span_1 = fields . Number ( required = True , allow_none = True ) h_min_span_2 = fields . Number ( required = True , allow_none = True ) h_riverbed = fields . Number ( required = True , allow_none = True ) h_threshold_al = fields . Number ( required = True , allow_none = True ) h_threshold_wa = fields . Number ( required = True , allow_none = True ) class Feature ( HFeature ): ''' RfiLogger ''' def setup ( self , ** kwargs ): pass def config ( self , serial , radar_1 = None , radar_2 = None , pluviometer = None , h_radar_1 = None , h_radar_2 = None , h_min_span_1 = None , h_min_span_2 = None , h_riverbed = None , h_threshold_al = None , h_threshold_wa = None , ** kwargs ): \"\"\" Timestamp, 0:Alarm, 1:Temp_\u00b0C, 2:Humid_%, 3:ADC 0_V, 4:lev1_m, 5:lev2_m, 6:pio1 \"\"\" source = str ( self . __module__ ) try : timestamp = kwargs [ \"timestamp\" ] except KeyError as e : timestamp = None if not self . parameters . __len__ (): if radar_1 is None : radar_1 = \"\" if radar_2 is None : radar_2 = \"\" if h_radar_1 is None : h_radar_1 = 0 if h_radar_2 is None : h_radar_2 = 0 if h_min_span_1 is None : h_min_span_1 = 0 if h_min_span_2 is None : h_min_span_2 = 0 if not h_riverbed is None : buffer = ( h_radar_1 - h_riverbed ) * 0.01 view_range = [ h_riverbed - buffer , h_radar_1 + buffer ] else : view_range = None thresholds = [{ \"label\" : \"Sensor Height\" , \"ttype\" : \"UPPER\" , \"value\" : h_radar_1 , \"color\" : \"#505050\" }] if h_threshold_al is not None : threshold_al = { \"label\" : \"Alert\" , \"ttype\" : \"UPPER\" , \"value\" : h_threshold_al , \"color\" : \"#FF0000\" } thresholds = [ threshold_al , * thresholds ] if h_threshold_wa is not None : threshold_wa = { \"label\" : \"Warning\" , \"ttype\" : \"UPPER\" , \"value\" : h_threshold_wa , \"color\" : \"#FFA500\" } thresholds = [ threshold_wa , * thresholds ] if h_min_span_1 is not None : threshold_sp = { \"label\" : \"Minimal Span Height\" , \"ttype\" : \"UPPER\" , \"value\" : h_min_span_1 , \"color\" : \"#000000\" } thresholds = [ threshold_sp , * thresholds ] threshold_ob = [{ \"label\" : \"Obstruction\" , \"ttype\" : \"LOWER\" , \"value\" : 0 , \"color\" : \"#FF0000\" }] buffer_ob = ( h_min_span_1 - h_riverbed ) * 0.001 view_range_ob = [ 0 - buffer_ob ,( h_min_span_1 - h_riverbed ) + buffer_ob ] self . parameters . set ( \"camera\" , cache = 'inactive' , ordinal = 100 , modules = { \"hls\" : \"hielen3.tools.hls_facility\" }, operator = f \"hls.start_stream(resource= { serial !r} )\" , capability = \"stream\" ) self . parameters . set ( \"temperature\" , cache = 'active' , mu = '\u00b0C' , ordinal = 9 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials= { serial !r} ,times=times,columns=2)\" ) self . parameters . set ( \"humidity\" , cache = 'active' , mu = ' %% ' , ordinal = 10 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials= { serial !r} ,times=times,columns=3)\" ) self . parameters . set ( \"battery\" , cache = 'active' , mu = 'V' , ordinal = 11 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials= { serial !r} ,times=times,columns=4)\" ) self . parameters . set ( \"radar 1\" , cache = 'active' , mu = 'mA' , ordinal = 6 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials= { serial !r} ,times=times,columns=5)\" ) self . parameters . set ( \"radar 2\" , cache = 'active' , mu = 'mA' , ordinal = 7 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials= { serial !r} ,times=times,columns=6)\" ) self . parameters . set ( \"pluviometer\" , cache = 'active' , mu = 'count' , ordinal = 8 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials= { serial !r} ,times=times,columns=7)\" ) if pluviometer is not None : self . parameters . set ( 'rain' , cache = 'active' , mu = 'mm/h' , ordinal = 5 , first = timestamp , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"pluviometer\" ] . uuid }, operator = f \"calc.instant_velocity(calc.poly_trans2(S0, { pluviometer } ))\" ) if radar_1 is not None : self . parameters . set ( 'level 1' , cache = 'active' , mu = \"m.s.l.m.\" , ordinal = 3 , first = timestamp , view_range = view_range , thresholds = thresholds , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"radar 1\" ] . uuid }, operator = f \" { h_radar_1 } - calc.poly_trans2(S0, { radar_1 } )\" ) self . parameters . set ( 'free span 1' , cache = 'active' , mu = \"m\" , ordinal = 1 , thresholds = threshold_ob , first = timestamp , view_range = view_range_ob , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"level 1\" ] . uuid }, operator = f \" { h_min_span_1 } - S0\" ) if radar_2 is not None : self . parameters . set ( 'level 2' , cache = 'active' , mu = \"m.s.l.m.\" , ordinal = 4 , first = timestamp , view_range = view_range , thresholds = thresholds , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"radar 2\" ] . uuid }, operator = f \" { h_radar_2 } - calc.poly_trans2(S0, { radar_2 } )\" ) self . parameters . set ( 'free span 2' , cache = 'active' , mu = \"m\" , ordinal = 2 , first = timestamp , thresholds = threshold_ob , view_range = view_range_ob , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"level 2\" ] . uuid }, operator = f \" { h_min_span_2 } -S0\" ) def retrive ( serials = None , times = None , columns = None , folder = 'gestecno_rfi/data' , func = None , ** kwargs ): f = Path ( conf [ 'incomepath' ]) / folder if not f . is_dir (): f = Path ( conf [ 'incomepath' ]) / 'incomes' folder = f def __extract_gestecno__ ( path ): a = DataFrame ([], dtype = 'float64' ) try : a = read_csv ( path , skiprows = 2 , parse_dates = True , header = None ) if a . empty : a = read_csv ( path , parse_dates = True , header = None ) a = a [ a [ 0 ] . apply ( lambda x : match ( '^\\d {4} -\\d {2} ' , x )) . notna ()] a . columns = [ 'times' , * a . columns [ 1 :] ] except Exception as e : pass return a if func is None : func = __extract_gestecno__ if serials is None : serials = slice ( None , None ) if isinstance ( serials , str ): #serials=slice(serials,serials) serials = [ serials ] if isinstance ( times , datetime ): times = str ( times ) if times is None or isinstance ( times , str ): times = slice ( times , None , None ) start = times . start stop = times . stop if start is not None : datestart = str ( datetime . fromisoformat ( start ) . date ()) else : datestart = None times = slice ( start , stop ) dates = slice ( datestart , stop ) paths = Series ( glob ( f ' { folder } /*/*/*/*' ), dtype = 'object' ) . apply ( Path ) sertime = DataFrame ( paths . apply ( lambda x : ( x . parts [ - 4 ], str ( datetime ( * map ( int , x . parts [ - 3 :]))) ) ) . explode () . values . reshape ( paths . __len__ (), 2 ), columns = [ 'serial' , 'times' ] ) sertime [ 'path' ] = paths . apply ( lambda x : str ( x / \"*\" )) sertime = sertime . set_index ([ 'serial' , 'times' ]) . sort_index () df = DataFrame () try : sertime = sertime . to_frame () except Exception as e : pass if isinstance ( serials , ( list , set , tuple )): serials = list ( sertime . index [ sertime . index . isin ( serials , level = 0 ) ] . droplevel ( 1 ) . drop_duplicates () ) if not serials . __len__ (): return df try : sertime = sertime . loc [( serials , dates ), :] except KeyError as e : return df for serial , paths in sertime . groupby ( 'serial' ): u = concat ( paths [ 'path' ] . apply ( glob ) . explode () . apply ( func ) . values ) u [ 'serial' ] = serial u = u . set_index ([ 'serial' , 'times' ]) df = concat ([ df , u ]) if columns is None : columns = list ( df . columns ) if not isinstance ( columns ,( list , tuple , set )): columns = [ columns ] columns = list ( columns ) df = df [ columns ] . sort_index () . loc [( serials , times ), :] try : if serials . __len__ () == 1 : df = df . droplevel ( 'serial' , axis = 0 ) except Exception as e : pass return df","title":"Module hielen3.ext.feature_rfilogger.rfilogger_good"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#variables","text":"conf","title":"Variables"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#logger_serials","text":"def logger_serials ( folder = 'gestecno_rfi/data' ) View Source def logger_serials ( folder = 'gestecno_rfi/data' ) : folder = Path ( conf [ 'incomepath' ] ) / folder / \"*\" serials = Series ( glob ( str ( folder )) , dtype = 'object' ) . apply ( Path ) serials = serials [ serials . apply ( Path . is_dir ) ] return list ( serials . apply ( lambda x : x . name ) . sort_values () . values )","title":"logger_serials"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#retrive","text":"def retrive ( serials = None , times = None , columns = None , folder = 'gestecno_rfi/data' , func = None , ** kwargs ) View Source def retrive ( serials = None , times = None , columns = None , folder = 'gestecno_rfi/data' , func = None , ** kwargs ) : f = Path ( conf [ 'incomepath' ] ) / folder if not f . is_dir () : f = Path ( conf [ 'incomepath' ] ) / 'incomes' folder = f def __extract_gestecno__ ( path ) : a = DataFrame ( [] , dtype = 'float64' ) try : a = read_csv ( path , skiprows = 2 , parse_dates = True , header = None ) if a . empty : a = read_csv ( path , parse_dates = True , header = None ) a = a [ a[0 ] . apply ( lambda x : match ( '^\\d{4}-\\d{2}' , x )). notna () ] a . columns = [ 'times', *a.columns[1: ] ] except Exception as e : pass return a if func is None : func = __extract_gestecno__ if serials is None : serials = slice ( None , None ) if isinstance ( serials , str ) : #serials = slice ( serials , serials ) serials =[ serials ] if isinstance ( times , datetime ) : times = str ( times ) if times is None or isinstance ( times , str ) : times = slice ( times , None , None ) start = times . start stop = times . stop if start is not None : datestart = str ( datetime . fromisoformat ( start ). date ()) else : datestart = None times = slice ( start , stop ) dates = slice ( datestart , stop ) paths = Series ( glob ( f '{folder}/*/*/*/*' ), dtype = 'object' ). apply ( Path ) sertime = DataFrame ( paths . apply ( lambda x : ( x . parts [ -4 ] , str ( datetime ( * map ( int , x . parts [ -3: ] ))) ) ). explode (). values . reshape ( paths . __len__ (), 2 ), columns =[ 'serial','times' ] ) sertime [ 'path' ]= paths . apply ( lambda x : str ( x / \"*\" )) sertime = sertime . set_index ( [ 'serial','times' ] ). sort_index () df = DataFrame () try : sertime = sertime . to_frame () except Exception as e : pass if isinstance ( serials , ( list , set , tuple )) : serials = list ( sertime . index [ sertime.index.isin(serials,level=0) ] . droplevel ( 1 ). drop_duplicates () ) if not serials . __len__ () : return df try : sertime = sertime . loc [ (serials,dates), : ] except KeyError as e : return df for serial , paths in sertime . groupby ( 'serial' ) : u = concat ( paths [ 'path' ] . apply ( glob ). explode (). apply ( func ). values ) u [ 'serial' ]= serial u = u . set_index ( [ 'serial','times' ] ) df = concat ( [ df,u ] ) if columns is None : columns = list ( df . columns ) if not isinstance ( columns ,( list , tuple , set )) : columns =[ columns ] columns = list ( columns ) df = df [ columns ] . sort_index (). loc [ (serials, times), : ] try : if serials . __len__ () == 1 : df = df . droplevel ( 'serial' , axis = 0 ) except Exception as e : pass return df","title":"retrive"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): return { \"Logger info\" : { 0 :[ \"serial\" , \"Logger serial number\" , False , logger_serials ()] }, \"Instruments info\" : { 0 :[ \"radar_1\" , \"Radar 1 polynomial coefficients\" , False , None ], 1 :[ \"radar_2\" , \"Radar 2 polynomial coefficients\" , False , None ], 2 :[ \"pluviometer\" , \"Pluviometer polynomial coefficients\" , False , None ], 3 :[ \"h_radar_1\" , \"Quote over sea level of the radar 1\" , False , None ], 4 :[ \"h_radar_2\" , \"Quote over sea level of the radar 2\" , False , None ], 5 :[ \"h_min_span_1\" , \"Quote over the sea level of the minimum free span\" , False , None ], 6 :[ \"h_min_span_2\" , \"Quote over the sea level of the minimum free span\" , False , None ], 7 :[ \"h_riverbed\" , \"Quote over the sea level of the riverbed\" , False , None ], 8 :[ \"h_threshold_al\" , \"Alert quote level\" , False , None ], 9 :[ \"h_threshold_wa\" , \"Warning quote level\" , False , None ] } } serial = fields . String ( required = True , allow_none = False ) radar_1 = PolyCoeff ( default =[ 0 , 1 ], required = False , allow_none = True ) radar_2 = PolyCoeff ( default =[ 0 , 1 ], required = False , allow_none = True ) pluviometer = PolyCoeff ( default =[ 0 , 0.2 ], reqired = False , allow_none = True ) h_radar_1 = fields . Number ( required = True , allow_none = True ) h_radar_2 = fields . Number ( required = True , allow_none = True ) h_min_span_1 = fields . Number ( required = True , allow_none = True ) h_min_span_2 = fields . Number ( required = True , allow_none = True ) h_riverbed = fields . Number ( required = True , allow_none = True ) h_threshold_al = fields . Number ( required = True , allow_none = True ) h_threshold_wa = fields . Number ( required = True , allow_none = True )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#ancestors-in-mro","text":"hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages h_min_span_1 h_min_span_2 h_radar_1 h_radar_2 h_riverbed h_threshold_al h_threshold_wa opts pluviometer radar_1 radar_2 serial","title":"Class variables"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#feature","text":"class Feature ( feature ) RfiLogger View Source class Feature ( HFeature ): ''' RfiLogger ''' def setup ( self , ** kwargs ): pass def config ( self , serial , radar_1 = None , radar_2 = None , pluviometer = None , h_radar_1 = None , h_radar_2 = None , h_min_span_1 = None , h_min_span_2 = None , h_riverbed = None , h_threshold_al = None , h_threshold_wa = None , ** kwargs ): \"\"\" Timestamp, 0:Alarm, 1:Temp_\u00b0C, 2:Humid_%, 3:ADC 0_V, 4:lev1_m, 5:lev2_m, 6:pio1 \"\"\" source = str ( self . __module__ ) try : timestamp = kwargs [ \"timestamp\" ] except KeyError as e : timestamp = None if not self . parameters . __len__ (): if radar_1 is None : radar_1 = \"\" if radar_2 is None : radar_2 = \"\" if h_radar_1 is None : h_radar_1 = 0 if h_radar_2 is None : h_radar_2 = 0 if h_min_span_1 is None : h_min_span_1 = 0 if h_min_span_2 is None : h_min_span_2 = 0 if not h_riverbed is None : buffer = ( h_radar_1 - h_riverbed ) * 0.01 view_range = [ h_riverbed - buffer , h_radar_1 + buffer ] else : view_range = None thresholds = [{ \"label\" : \"Sensor Height\" , \"ttype\" : \"UPPER\" , \"value\" : h_radar_1 , \"color\" : \"#505050\" }] if h_threshold_al is not None : threshold_al = { \"label\" : \"Alert\" , \"ttype\" : \"UPPER\" , \"value\" : h_threshold_al , \"color\" : \"#FF0000\" } thresholds = [ threshold_al , * thresholds ] if h_threshold_wa is not None : threshold_wa = { \"label\" : \"Warning\" , \"ttype\" : \"UPPER\" , \"value\" : h_threshold_wa , \"color\" : \"#FFA500\" } thresholds = [ threshold_wa , * thresholds ] if h_min_span_1 is not None : threshold_sp = { \"label\" : \"Minimal Span Height\" , \"ttype\" : \"UPPER\" , \"value\" : h_min_span_1 , \"color\" : \"#000000\" } thresholds = [ threshold_sp , * thresholds ] threshold_ob = [{ \"label\" : \"Obstruction\" , \"ttype\" : \"LOWER\" , \"value\" : 0 , \"color\" : \"#FF0000\" }] buffer_ob = ( h_min_span_1 - h_riverbed ) * 0.001 view_range_ob = [ 0 - buffer_ob ,( h_min_span_1 - h_riverbed ) + buffer_ob ] self . parameters . set ( \"camera\" , cache = 'inactive' , ordinal = 100 , modules = { \"hls\" : \"hielen3.tools.hls_facility\" }, operator = f \"hls.start_stream(resource={serial!r})\" , capability = \"stream\" ) self . parameters . set ( \"temperature\" , cache = 'active' , mu = '\u00b0C' , ordinal = 9 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=2)\" ) self . parameters . set ( \"humidity\" , cache = 'active' , mu = ' %% ' , ordinal = 10 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=3)\" ) self . parameters . set ( \"battery\" , cache = 'active' , mu = 'V' , ordinal = 11 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=4)\" ) self . parameters . set ( \"radar 1\" , cache = 'active' , mu = 'mA' , ordinal = 6 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=5)\" ) self . parameters . set ( \"radar 2\" , cache = 'active' , mu = 'mA' , ordinal = 7 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=6)\" ) self . parameters . set ( \"pluviometer\" , cache = 'active' , mu = 'count' , ordinal = 8 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=7)\" ) if pluviometer is not None : self . parameters . set ( 'rain' , cache = 'active' , mu = 'mm/h' , ordinal = 5 , first = timestamp , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"pluviometer\" ] . uuid }, operator = f \"calc.instant_velocity(calc.poly_trans2(S0,{pluviometer}))\" ) if radar_1 is not None : self . parameters . set ( 'level 1' , cache = 'active' , mu = \"m.s.l.m.\" , ordinal = 3 , first = timestamp , view_range = view_range , thresholds = thresholds , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"radar 1\" ] . uuid }, operator = f \"{h_radar_1} - calc.poly_trans2(S0,{radar_1})\" ) self . parameters . set ( 'free span 1' , cache = 'active' , mu = \"m\" , ordinal = 1 , thresholds = threshold_ob , first = timestamp , view_range = view_range_ob , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"level 1\" ] . uuid }, operator = f \"{h_min_span_1} - S0\" ) if radar_2 is not None : self . parameters . set ( 'level 2' , cache = 'active' , mu = \"m.s.l.m.\" , ordinal = 4 , first = timestamp , view_range = view_range , thresholds = thresholds , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"radar 2\" ] . uuid }, operator = f \"{h_radar_2} - calc.poly_trans2(S0,{radar_2})\" ) self . parameters . set ( 'free span 2' , cache = 'active' , mu = \"m\" , ordinal = 2 , first = timestamp , thresholds = threshold_ob , view_range = view_range_ob , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"level 2\" ] . uuid }, operator = f \"{h_min_span_2}-S0\" )","title":"Feature"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#config","text":"def config ( self , serial , radar_1 = None , radar_2 = None , pluviometer = None , h_radar_1 = None , h_radar_2 = None , h_min_span_1 = None , h_min_span_2 = None , h_riverbed = None , h_threshold_al = None , h_threshold_wa = None , ** kwargs ) Timestamp, 0:Alarm, 1:Temp_\u00b0C, 2:Humid_%, 3:ADC 0_V, 4:lev1_m, 5:lev2_m, 6:pio1 View Source def config ( self , serial , radar_1 = None , radar_2 = None , pluviometer = None , h_radar_1 = None , h_radar_2 = None , h_min_span_1 = None , h_min_span_2 = None , h_riverbed = None , h_threshold_al = None , h_threshold_wa = None , ** kwargs ): \"\"\" Timestamp, 0:Alarm, 1:Temp_\u00b0C, 2:Humid_%, 3:ADC 0_V, 4:lev1_m, 5:lev2_m, 6:pio1 \"\"\" source = str ( self . __module__ ) try : timestamp = kwargs [ \"timestamp\" ] except KeyError as e : timestamp = None if not self . parameters . __len__ (): if radar_1 is None : radar_1 = \"\" if radar_2 is None : radar_2 = \"\" if h_radar_1 is None : h_radar_1 = 0 if h_radar_2 is None : h_radar_2 = 0 if h_min_span_1 is None : h_min_span_1 = 0 if h_min_span_2 is None : h_min_span_2 = 0 if not h_riverbed is None : buffer = ( h_radar_1 - h_riverbed ) * 0.01 view_range = [ h_riverbed - buffer , h_radar_1 + buffer ] else : view_range = None thresholds = [{ \"label\" : \"Sensor Height\" , \"ttype\" : \"UPPER\" , \"value\" : h_radar_1 , \"color\" : \"#505050\" }] if h_threshold_al is not None : threshold_al = { \"label\" : \"Alert\" , \"ttype\" : \"UPPER\" , \"value\" : h_threshold_al , \"color\" : \"#FF0000\" } thresholds = [ threshold_al , * thresholds ] if h_threshold_wa is not None : threshold_wa = { \"label\" : \"Warning\" , \"ttype\" : \"UPPER\" , \"value\" : h_threshold_wa , \"color\" : \"#FFA500\" } thresholds = [ threshold_wa , * thresholds ] if h_min_span_1 is not None : threshold_sp = { \"label\" : \"Minimal Span Height\" , \"ttype\" : \"UPPER\" , \"value\" : h_min_span_1 , \"color\" : \"#000000\" } thresholds = [ threshold_sp , * thresholds ] threshold_ob = [{ \"label\" : \"Obstruction\" , \"ttype\" : \"LOWER\" , \"value\" : 0 , \"color\" : \"#FF0000\" }] buffer_ob = ( h_min_span_1 - h_riverbed ) * 0.001 view_range_ob = [ 0 - buffer_ob ,( h_min_span_1 - h_riverbed ) + buffer_ob ] self . parameters . set ( \"camera\" , cache = 'inactive' , ordinal = 100 , modules = { \"hls\" : \"hielen3.tools.hls_facility\" }, operator = f \"hls.start_stream(resource={serial!r})\" , capability = \"stream\" ) self . parameters . set ( \"temperature\" , cache = 'active' , mu = '\u00b0C' , ordinal = 9 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=2)\" ) self . parameters . set ( \"humidity\" , cache = 'active' , mu = ' %% ' , ordinal = 10 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=3)\" ) self . parameters . set ( \"battery\" , cache = 'active' , mu = 'V' , ordinal = 11 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=4)\" ) self . parameters . set ( \"radar 1\" , cache = 'active' , mu = 'mA' , ordinal = 6 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=5)\" ) self . parameters . set ( \"radar 2\" , cache = 'active' , mu = 'mA' , ordinal = 7 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=6)\" ) self . parameters . set ( \"pluviometer\" , cache = 'active' , mu = 'count' , ordinal = 8 , first = timestamp , modules = { \"source\" : source }, operator = f \"source.retrive(serials={serial!r},times=times,columns=7)\" ) if pluviometer is not None : self . parameters . set ( 'rain' , cache = 'active' , mu = 'mm/h' , ordinal = 5 , first = timestamp , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"pluviometer\" ] . uuid }, operator = f \"calc.instant_velocity(calc.poly_trans2(S0,{pluviometer}))\" ) if radar_1 is not None : self . parameters . set ( 'level 1' , cache = 'active' , mu = \"m.s.l.m.\" , ordinal = 3 , first = timestamp , view_range = view_range , thresholds = thresholds , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"radar 1\" ] . uuid }, operator = f \"{h_radar_1} - calc.poly_trans2(S0,{radar_1})\" ) self . parameters . set ( 'free span 1' , cache = 'active' , mu = \"m\" , ordinal = 1 , thresholds = threshold_ob , first = timestamp , view_range = view_range_ob , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"level 1\" ] . uuid }, operator = f \"{h_min_span_1} - S0\" ) if radar_2 is not None : self . parameters . set ( 'level 2' , cache = 'active' , mu = \"m.s.l.m.\" , ordinal = 4 , first = timestamp , view_range = view_range , thresholds = thresholds , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"radar 2\" ] . uuid }, operator = f \"{h_radar_2} - calc.poly_trans2(S0,{radar_2})\" ) self . parameters . set ( 'free span 2' , cache = 'active' , mu = \"m\" , ordinal = 2 , first = timestamp , thresholds = threshold_ob , view_range = view_range_ob , modules = { \"calc\" : \"hielen3.tools.calc\" }, operands = { \"S0\" : self . parameters [ \"level 2\" ] . uuid }, operator = f \"{h_min_span_2}-S0\" )","title":"config"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#retrive_1","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#setup","text":"def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): pass","title":"setup"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_rfilogger/rfilogger_good/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_spotted_files_source/","text":"Module hielen3.ext.feature_spotted_files_source View Source # coding=utf-8 __name__ = \"feature_spotted_files_source\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from .logger import Feature , ConfigSchema , retrive __all__ = [ \"Feature\" , \"ConfigSchema\" , \"retrive\" ] Sub-modules hielen3.ext.feature_spotted_files_source.logger Functions retrive def retrive ( path , times = None , columns = None ) View Source def retrive ( path , times = None , columns = None ) : a = DataFrame ( [] , dtype = 'object' ) if columns is None : columns = slice ( None , None ) if isinstance ( columns , str ) : columns =[ columns ] if isinstance ( times ,( datetime , str )) : times = str ( times ) if times is None or not isinstance ( times , slice ) : times = slice ( times , None , None ) try : a = read_excel ( path , parse_dates =[ 0 ] ) a . columns = [ 'times', *a.columns[1: ] ] except Exception as e : print ( \"WARN : \" , e , path ) pass a = a . set_index ( 'times' ) return a . loc [ times,columns ] Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): try: serials = list ( func_loggers ()[ 'name' ]) except Exception as e: serials =[] return { \"file info\" : { 0 :[ \"source_file\" , \"source file under incomes MANUAL\" , False , None ], 1 :[ \"header\" , \"source file header if needed\" , False , \"\" ] } } source_file_or_path = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) Ancestors (in MRO) hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts source_file_or_path Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): self . update ( intent = \"HIDDEN\" ) def config ( self , timestamp , path , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e path = str ( Path ( conf [ 'incomepath' ]) / \"manuali\" / path ) for info in infos : template = { \"channel\" : None , \"mu\" : None , \"column\" : None , \"cache\" : \"old\" , \"valid_range\" : None } template . update ( info ) if template [ \"channel\" ] is None : template [ \"channel\" ] = template [ \"column\" ] info = template self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"PATH\" : path , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(path=PATH,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = None , thresholds = None ) Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , timestamp , path , header = None , ** kwargs ) header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\" : \"nomechannelN\" , \"mu\" : \"measurement_unitN\" , \"column\" : # N , \"valid_range\" : [ start , end ] } ] View Source def config ( self , timestamp , path , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e path = str ( Path ( conf [ 'incomepath' ]) / \"manuali\" / path ) for info in infos : template = { \"channel\" : None , \"mu\" : None , \"column\" : None , \"cache\" : \"old\" , \"valid_range\" : None } template . update ( info ) if template [ \"channel\" ] is None : template [ \"channel\" ] = template [ \"column\" ] info = template self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"PATH\" : path , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(path=PATH,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = None , thresholds = None ) create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): self.update(intent=\"HIDDEN\") truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Index"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#module-hielen3extfeature_spotted_files_source","text":"View Source # coding=utf-8 __name__ = \"feature_spotted_files_source\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"HielenSource extensione\" __license__ = \"MIT\" __uri__ = \"\" from .logger import Feature , ConfigSchema , retrive __all__ = [ \"Feature\" , \"ConfigSchema\" , \"retrive\" ]","title":"Module hielen3.ext.feature_spotted_files_source"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#sub-modules","text":"hielen3.ext.feature_spotted_files_source.logger","title":"Sub-modules"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#retrive","text":"def retrive ( path , times = None , columns = None ) View Source def retrive ( path , times = None , columns = None ) : a = DataFrame ( [] , dtype = 'object' ) if columns is None : columns = slice ( None , None ) if isinstance ( columns , str ) : columns =[ columns ] if isinstance ( times ,( datetime , str )) : times = str ( times ) if times is None or not isinstance ( times , slice ) : times = slice ( times , None , None ) try : a = read_excel ( path , parse_dates =[ 0 ] ) a . columns = [ 'times', *a.columns[1: ] ] except Exception as e : print ( \"WARN : \" , e , path ) pass a = a . set_index ( 'times' ) return a . loc [ times,columns ]","title":"retrive"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): try: serials = list ( func_loggers ()[ 'name' ]) except Exception as e: serials =[] return { \"file info\" : { 0 :[ \"source_file\" , \"source file under incomes MANUAL\" , False , None ], 1 :[ \"header\" , \"source file header if needed\" , False , \"\" ] } } source_file_or_path = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#ancestors-in-mro","text":"hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts source_file_or_path","title":"Class variables"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#feature","text":"class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): self . update ( intent = \"HIDDEN\" ) def config ( self , timestamp , path , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e path = str ( Path ( conf [ 'incomepath' ]) / \"manuali\" / path ) for info in infos : template = { \"channel\" : None , \"mu\" : None , \"column\" : None , \"cache\" : \"old\" , \"valid_range\" : None } template . update ( info ) if template [ \"channel\" ] is None : template [ \"channel\" ] = template [ \"column\" ] info = template self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"PATH\" : path , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(path=PATH,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = None , thresholds = None )","title":"Feature"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#config","text":"def config ( self , timestamp , path , header = None , ** kwargs ) header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\" : \"nomechannelN\" , \"mu\" : \"measurement_unitN\" , \"column\" : # N , \"valid_range\" : [ start , end ] } ] View Source def config ( self , timestamp , path , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e path = str ( Path ( conf [ 'incomepath' ]) / \"manuali\" / path ) for info in infos : template = { \"channel\" : None , \"mu\" : None , \"column\" : None , \"cache\" : \"old\" , \"valid_range\" : None } template . update ( info ) if template [ \"channel\" ] is None : template [ \"channel\" ] = template [ \"column\" ] info = template self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"PATH\" : path , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(path=PATH,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = None , thresholds = None )","title":"config"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#retrive_1","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#setup","text":"def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): self.update(intent=\"HIDDEN\")","title":"setup"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_spotted_files_source/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/","text":"Module hielen3.ext.feature_spotted_files_source.logger View Source # coding=utf-8 from hielen3 import conf from hielen3.feature import HFeature from hielen3.serializaction import ActionSchema from marshmallow import fields from pathlib import Path from pandas import read_excel , DataFrame from datetime import datetime import json import traceback class ConfigSchema ( ActionSchema ): def _self_hints_ (): try : serials = list ( func_loggers ()[ 'name' ]) except Exception as e : serials = [] return { \"file info\" : { 0 :[ \"source_file\" , \"source file under incomes MANUAL\" , False , None ], 1 :[ \"header\" , \"source file header if needed\" , False , \"\" ] } } source_file_or_path = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): self . update ( intent = \"HIDDEN\" ) def config ( self , timestamp , path , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e path = str ( Path ( conf [ 'incomepath' ]) / \"manuali\" / path ) for info in infos : template = { \"channel\" : None , \"mu\" : None , \"column\" : None , \"cache\" : \"old\" , \"valid_range\" : None } template . update ( info ) if template [ \"channel\" ] is None : template [ \"channel\" ] = template [ \"column\" ] info = template self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"PATH\" : path , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(path=PATH,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = None , thresholds = None ) def retrive ( path , times = None , columns = None ): a = DataFrame ([], dtype = 'object' ) if columns is None : columns = slice ( None , None ) if isinstance ( columns , str ): columns = [ columns ] if isinstance ( times ,( datetime , str )): times = str ( times ) if times is None or not isinstance ( times , slice ): times = slice ( times , None , None ) try : a = read_excel ( path , parse_dates = [ 0 ]) a . columns = [ 'times' , * a . columns [ 1 :] ] except Exception as e : print ( \"WARN : \" , e , path ) pass a = a . set_index ( 'times' ) return a . loc [ times , columns ] Variables conf Functions retrive def retrive ( path , times = None , columns = None ) View Source def retrive ( path , times = None , columns = None ) : a = DataFrame ( [] , dtype = 'object' ) if columns is None : columns = slice ( None , None ) if isinstance ( columns , str ) : columns =[ columns ] if isinstance ( times ,( datetime , str )) : times = str ( times ) if times is None or not isinstance ( times , slice ) : times = slice ( times , None , None ) try : a = read_excel ( path , parse_dates =[ 0 ] ) a . columns = [ 'times', *a.columns[1: ] ] except Exception as e : print ( \"WARN : \" , e , path ) pass a = a . set_index ( 'times' ) return a . loc [ times,columns ] Classes ConfigSchema class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): try: serials = list ( func_loggers ()[ 'name' ]) except Exception as e: serials =[] return { \"file info\" : { 0 :[ \"source_file\" , \"source file under incomes MANUAL\" , False , None ], 1 :[ \"header\" , \"source file header if needed\" , False , \"\" ] } } source_file_or_path = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) Ancestors (in MRO) hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts source_file_or_path Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class hints set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} Feature class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): self . update ( intent = \"HIDDEN\" ) def config ( self , timestamp , path , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e path = str ( Path ( conf [ 'incomepath' ]) / \"manuali\" / path ) for info in infos : template = { \"channel\" : None , \"mu\" : None , \"column\" : None , \"cache\" : \"old\" , \"valid_range\" : None } template . update ( info ) if template [ \"channel\" ] is None : template [ \"channel\" ] = template [ \"column\" ] info = template self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"PATH\" : path , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(path=PATH,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = None , thresholds = None ) Ancestors (in MRO) hielen3.feature.HFeature abc.ABC Instance variables geometry schemata Methods actions_schemata def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s cleanCache def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None config def config ( self , timestamp , path , header = None , ** kwargs ) header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\" : \"nomechannelN\" , \"mu\" : \"measurement_unitN\" , \"column\" : # N , \"valid_range\" : [ start , end ] } ] View Source def config ( self , timestamp , path , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e path = str ( Path ( conf [ 'incomepath' ]) / \"manuali\" / path ) for info in infos : template = { \"channel\" : None , \"mu\" : None , \"column\" : None , \"cache\" : \"old\" , \"valid_range\" : None } template . update ( info ) if template [ \"channel\" ] is None : template [ \"channel\" ] = template [ \"column\" ] info = template self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"PATH\" : path , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(path=PATH,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = None , thresholds = None ) create def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs ) delete def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out drop def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete() execute def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e modules def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r ) retrive def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid ) retrive_label def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' ) setup def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): self.update(intent=\"HIDDEN\") truncate_params def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series update def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs ) update_label def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"Logger"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#module-hielen3extfeature_spotted_files_sourcelogger","text":"View Source # coding=utf-8 from hielen3 import conf from hielen3.feature import HFeature from hielen3.serializaction import ActionSchema from marshmallow import fields from pathlib import Path from pandas import read_excel , DataFrame from datetime import datetime import json import traceback class ConfigSchema ( ActionSchema ): def _self_hints_ (): try : serials = list ( func_loggers ()[ 'name' ]) except Exception as e : serials = [] return { \"file info\" : { 0 :[ \"source_file\" , \"source file under incomes MANUAL\" , False , None ], 1 :[ \"header\" , \"source file header if needed\" , False , \"\" ] } } source_file_or_path = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True ) class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): self . update ( intent = \"HIDDEN\" ) def config ( self , timestamp , path , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e path = str ( Path ( conf [ 'incomepath' ]) / \"manuali\" / path ) for info in infos : template = { \"channel\" : None , \"mu\" : None , \"column\" : None , \"cache\" : \"old\" , \"valid_range\" : None } template . update ( info ) if template [ \"channel\" ] is None : template [ \"channel\" ] = template [ \"column\" ] info = template self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"PATH\" : path , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(path=PATH,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = None , thresholds = None ) def retrive ( path , times = None , columns = None ): a = DataFrame ([], dtype = 'object' ) if columns is None : columns = slice ( None , None ) if isinstance ( columns , str ): columns = [ columns ] if isinstance ( times ,( datetime , str )): times = str ( times ) if times is None or not isinstance ( times , slice ): times = slice ( times , None , None ) try : a = read_excel ( path , parse_dates = [ 0 ]) a . columns = [ 'times' , * a . columns [ 1 :] ] except Exception as e : print ( \"WARN : \" , e , path ) pass a = a . set_index ( 'times' ) return a . loc [ times , columns ]","title":"Module hielen3.ext.feature_spotted_files_source.logger"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#variables","text":"conf","title":"Variables"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#retrive","text":"def retrive ( path , times = None , columns = None ) View Source def retrive ( path , times = None , columns = None ) : a = DataFrame ( [] , dtype = 'object' ) if columns is None : columns = slice ( None , None ) if isinstance ( columns , str ) : columns =[ columns ] if isinstance ( times ,( datetime , str )) : times = str ( times ) if times is None or not isinstance ( times , slice ) : times = slice ( times , None , None ) try : a = read_excel ( path , parse_dates =[ 0 ] ) a . columns = [ 'times', *a.columns[1: ] ] except Exception as e : print ( \"WARN : \" , e , path ) pass a = a . set_index ( 'times' ) return a . loc [ times,columns ]","title":"retrive"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#configschema","text":"class ConfigSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Minimal ActionSchema object. Used to define at least a timestamp View Source class ConfigSchema ( ActionSchema ): def _self_hints_ (): try: serials = list ( func_loggers ()[ 'name' ]) except Exception as e: serials =[] return { \"file info\" : { 0 :[ \"source_file\" , \"source file under incomes MANUAL\" , False , None ], 1 :[ \"header\" , \"source file header if needed\" , False , \"\" ] } } source_file_or_path = fields . String ( required = False , allow_none = False ) header = fields . String ( required = False , allow_none = True )","title":"ConfigSchema"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#ancestors-in-mro","text":"hielen3.serializaction.ActionSchema hielen3.serializaction.HSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages header opts source_file_or_path","title":"Class variables"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#instance-variables","text":"dict_class hints set_class","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#feature","text":"class Feature ( feature ) UNIT View Source class Feature ( HFeature ): ''' UNIT ''' def setup ( self , ** kwargs ): self . update ( intent = \"HIDDEN\" ) def config ( self , timestamp , path , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e path = str ( Path ( conf [ 'incomepath' ]) / \"manuali\" / path ) for info in infos : template = { \"channel\" : None , \"mu\" : None , \"column\" : None , \"cache\" : \"old\" , \"valid_range\" : None } template . update ( info ) if template [ \"channel\" ] is None : template [ \"channel\" ] = template [ \"column\" ] info = template self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"PATH\" : path , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(path=PATH,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = None , thresholds = None )","title":"Feature"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#ancestors-in-mro_1","text":"hielen3.feature.HFeature abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#instance-variables_1","text":"geometry schemata","title":"Instance variables"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#actions_schemata","text":"def actions_schemata ( ftype = None , actions = None ) View Source def actions_schemata ( ftype = None , actions = None ) : if ftype is None : ftype = slice ( None ) if actions is None : actions = slice ( None ) s = HFeature . modules ( ftype ) . apply ( HFeature . __schemata__ , actions = actions ) . stack () s . name = 'info' s = s . reset_index () . set_index ( 'label' ) s = s . groupby ( 'label' ) . apply ( lambda x : dict ( zip ( x [ \"names\" ], x [ \"info\" ] ))) . to_dict () return s","title":"actions_schemata"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#cleancache","text":"def cleanCache ( self , params = None ) View Source def cleanCache ( self , params = None ) : self . __test_del__ () try : params = db [ 'features_parameters' ][ self . uuid , params ][ 'series' ]. values return db [ 'datacache' ]. pop ( list ( params )) except KeyError : return None","title":"cleanCache"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#config","text":"def config ( self , timestamp , path , header = None , ** kwargs ) header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\" : \"nomechannelN\" , \"mu\" : \"measurement_unitN\" , \"column\" : # N , \"valid_range\" : [ start , end ] } ] View Source def config ( self , timestamp , path , header = None , ** kwargs ): \"\"\" header= [ { \"channel\": \"nomechannel1\", \"mu\": \"measurement_unit1\", \"column\" : #1, \"valid_range\" : [start,end] }, { \"channel\": \"nomechannel2\", \"mu\": \"measurement_unit2\", \"column\" : #2, \"valid_range\" : [start,end] }, ... { \"channel\": \"nomechannelN\", \"mu\": \"measurement_unitN\", \"column\" : #N, \"valid_range\" : [start,end] } ] \"\"\" source = str ( self . __module__ ) if header is None : header = {} try : infos = json . loads ( header ) except Exception as e : raise e path = str ( Path ( conf [ 'incomepath' ]) / \"manuali\" / path ) for info in infos : template = { \"channel\" : None , \"mu\" : None , \"column\" : None , \"cache\" : \"old\" , \"valid_range\" : None } template . update ( info ) if template [ \"channel\" ] is None : template [ \"channel\" ] = template [ \"column\" ] info = template self . parameters . set ( param = info [ 'channel' ], ordinal = info [ 'column' ], cache = info [ 'cache' ], mu = info [ 'mu' ], modules = { \"source\" : source }, operands = { \"PATH\" : path , \"COL\" : info [ \"column\" ] }, operator = f \"source.retrive(path=PATH,times=times,columns=COL)\" , valid_range = info [ 'valid_range' ], view_range = None , thresholds = None )","title":"config"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#create","text":"def create ( ftype , ** kwargs ) View Source def create ( ftype , ** kwargs ) : return HFeature . __featureFactory__ ( ftype = ftype , ** kwargs )","title":"create"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#delete","text":"def delete ( self ) View Source def delete ( self ) : self . __test_del__ () out = self . __dict__ self . cleanCache () self . parameters . pop ( None ) try : db [ 'features_geometry' ]. pop ( self . uuid ) except KeyError as e : pass db [ 'features' ]. pop ( self . uuid ) self . __deleted__ = True return out","title":"delete"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#drop","text":"def drop ( uuid ) View Source def drop(uuid): HFeature.retrive(uuid).delete()","title":"drop"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#execute","text":"def execute ( self , action , ** kwargs ) View Source def execute ( self , action , ** kwargs ): self . __test_del__ () try : mod = import_module ( self . __module__ ) klass = mod . __getattribute__ ( f \"{action.capitalize()}Schema\" ) kwargs = klass () . load ( kwargs ) return self . __getattribute__ ( action )( ** kwargs ) except Exception as e : raise e","title":"execute"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#modules","text":"def modules ( ftype = None ) View Source def modules ( ftype = None ) : r = db [ 'features_type' ][ ftype ][ 'module' ] . apply ( import_module ) print ( r ) return ( r )","title":"modules"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#retrive_1","text":"def retrive ( uuid ) View Source def retrive ( uuid ) : try : return HFeature . __featureFactory__ ( uuid = uuid ) except KeyError as e : return HFeature . retrive_label ( uuid )","title":"retrive"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#retrive_label","text":"def retrive_label ( label ) View Source def retrive_label ( label ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"retrive_label"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#setup","text":"def setup ( self , ** kwargs ) View Source def setup(self,**kwargs): self.update(intent=\"HIDDEN\")","title":"setup"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#truncate_params","text":"def truncate_params ( self , params = None ) View Source def truncate_params ( self , params = None ) : try : p_series = list ( self . parameters . pop ( params ) [ 'series' ] ) self . cleanCache ( p_series ) except Exception : p_series = [] return p_series","title":"truncate_params"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#update","text":"def update ( uuid , ** kwargs ) View Source def update ( uuid , ** kwargs ) : try : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) except KeyError as e : return HFeature . update_label ( uuid , ** kwargs )","title":"update"},{"location":"reference/hielen3/ext/feature_spotted_files_source/logger/#update_label","text":"def update_label ( uuid , ** kwargs ) View Source def update_label ( uuid , ** kwargs ) : feats = db [ 'features' ][:] uuid = feats [ feats [ 'label' ] == label ][ 'uuid' ]. squeeze () if isinstance ( uuid , str ) : return HFeature . __featureFactory__ ( uuid = uuid , ** kwargs ) else : raise KeyError ( f 'Single instance of {label!r} not found.' )","title":"update_label"},{"location":"reference/hielen3/geje/","text":"Module hielen3.geje View Source from .point import PointSchema from .multi_polygon import MultiPolygonSchema from .line_string import LineStringSchema from .multi_line_string import MultiLineStringSchema from .polygon import PolygonSchema from .multi_point import MultiPointSchema from .geometry_collection import GeometryCollectionSchema from .feature import FeatureSchema from .feature_collection import FeatureCollectionSchema from .object_type import GeoJSONType from .geometry import GeometriesSchema from .geojson import GeoJSONSchema from .property import PropertiesSchema from .object_type import ( GeometryType , GeoJSONType , ) __author__ = 'Aliaksandr Vaskevich' __maintainer__ = __author__ __email__ = 'vaskevic.an@gmail.com' __license__ = 'MIT' __version__ = '0.1.18' __all__ = ( '__author__' , '__email__' , '__license__' , '__maintainer__' , '__version__' , # object type 'GeometryType' , 'GeoJSONType' , # property schemas 'PropertiesSchema' , # schemas 'PointSchema' , 'MultiPointSchema' , 'LineStringSchema' , 'MultiLineStringSchema' , 'PolygonSchema' , 'MultiPolygonSchema' , 'GeometryCollectionSchema' , 'FeatureSchema' , 'FeatureCollectionSchema' , 'GeometriesSchema' , 'GeoJSONSchema' , ) Sub-modules hielen3.geje.feature hielen3.geje.feature_collection hielen3.geje.geojson hielen3.geje.geometry hielen3.geje.geometry_collection hielen3.geje.line_string hielen3.geje.multi_line_string hielen3.geje.multi_point hielen3.geje.multi_polygon hielen3.geje.object_type hielen3.geje.point hielen3.geje.polygon hielen3.geje.property Variables __author__ __email__ __license__ __maintainer__ __version__ Classes FeatureCollectionSchema class FeatureCollectionSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'} Attributes Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class FeatureCollectionSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ FEATURE_COLLECTION ] , error = 'Invalid feature collection type' ) ) features = List ( Nested ( FeatureSchema ), required = True , ) Ancestors (in MRO) hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages features opts type Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} FeatureSchema class FeatureSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'} Attributes Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class FeatureSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ FEATURE ] , error = 'Invalid feature type' ) ) geometry = Nested ( GeometriesSchema , required = True , ) properties = Nested ( PropertiesSchema , required = True , ) Ancestors (in MRO) hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages geometry opts properties type Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} GeoJSONSchema class GeoJSONSchema ( * args , ** kwargs ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'} Attributes Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class GeoJSONSchema ( BaseSchema ) : point_schema = PointSchema multi_point_schema = MultiPointSchema line_string_schema = LineStringSchema multi_line_string_schema = MultiLineStringSchema polygon_schema = PolygonSchema multi_polygon_schema = MultiPolygonSchema geometry_collection_schema = GeometryCollectionSchema feature_schema = FeatureSchema feature_collection_schema = FeatureCollectionSchema def __init__ ( self , * args , ** kwargs ) : super ( GeoJSONSchema , self ). __init__ ( * args , ** kwargs ) self . object_type_map = { GeoJSONType . point . value : self . point_schema , GeoJSONType . multi_point . value : self . multi_point_schema , GeoJSONType . line_string . value : self . line_string_schema , GeoJSONType . multi_line_string . value : self . multi_line_string_schema , GeoJSONType . polygon . value : self . polygon_schema , GeoJSONType . multi_polygon . value : self . multi_polygon_schema , GeoJSONType . geometry_collection . value : self . geometry_collection_schema , GeoJSONType . feature . value : self . feature_schema , GeoJSONType . feature_collection . value : self . feature_collection_schema , } def __validator_geo_json_type ( self , geo_type : typing . Any ) : if geo_type not in self . object_type_map : raise ma . ValidationError ( { '_schema' : f 'Unknown object class for {geo_type}.' } ) return geo_type def get_instance_schema ( self , data ) : object_type = self . __validator_geo_json_type ( data [ 'type' ] ) schema = self . object_type_map [ object_type ] return schema () def load ( self , data : typing . Union [ typing.Mapping[str, typing.Any ] , typing . Iterable [ typing.Mapping[str, typing.Any ] ] , ] , * , many : bool = None , partial : typing . Union [ bool, types.StrSequenceOrSet ] = None , unknown : str = None ) : schema = self . get_instance_schema ( data ) return schema . load ( data , many = many , partial = partial , unknown = unknown ) def loads ( self , json_data : str , * , many : bool = None , partial : typing . Union [ bool, types.StrSequenceOrSet ] = None , unknown : str = None , ** kwargs ) : data = self . opts . render_module . loads ( json_data , ** kwargs ) schema = self . get_instance_schema ( data ) return schema . loads ( json_data , many = many , partial = partial , unknown = unknown ) Ancestors (in MRO) hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages feature_collection_schema feature_schema geometry_collection_schema line_string_schema multi_line_string_schema multi_point_schema multi_polygon_schema opts point_schema polygon_schema Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) get_instance_schema def get_instance_schema ( self , data ) View Source def get_instance_schema ( self , data ) : object_type = self . __validator_geo_json_type ( data [ 'type' ] ) schema = self . object_type_map [ object_type ] return schema () handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : Union [ Mapping [ str , Any ], Iterable [ Mapping [ str , Any ]]], * , many : bool = None , partial : Union [ bool , Sequence [ str ], Set [ str ]] = None , unknown : str = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : typing . Union [ typing . Mapping [ str , typing . Any ], typing . Iterable [ typing . Mapping [ str , typing . Any ]], ], * , many : bool = None , partial : typing . Union [ bool , types . StrSequenceOrSet ] = None , unknown : str = None ): schema = self . get_instance_schema ( data ) return schema . load ( data , many = many , partial = partial , unknown = unknown ) loads def loads ( self , json_data : str , * , many : bool = None , partial : Union [ bool , Sequence [ str ], Set [ str ]] = None , unknown : str = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool = None , partial : typing . Union [ bool , types . StrSequenceOrSet ] = None , unknown : str = None , ** kwargs ): data = self . opts . render_module . loads ( json_data , ** kwargs ) schema = self . get_instance_schema ( data ) return schema . loads ( json_data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} GeoJSONType class GeoJSONType ( / , * args , ** kwargs ) As another shorthand notation, the term \"GeoJSON types\" refers to nine case-sensitive strings: \"Feature\", \"FeatureCollection\", and the geometry types listed above. View Source class GeoJSONType ( Enum ): \"\"\" As another shorthand notation, the term \" GeoJSON types \" refers to nine case-sensitive strings: \" Feature \", \" FeatureCollection \", and the geometry types listed above. \"\"\" point = POINT multi_point = MULTI_POINT line_string = LINE_STRING multi_line_string = MULTI_LINE_STRING polygon = POLYGON multi_polygon = MULTI_POLYGON geometry_collection = GEOMETRY_COLLECTION feature = FEATURE feature_collection = FEATURE_COLLECTION Ancestors (in MRO) enum.Enum Class variables feature feature_collection geometry_collection line_string multi_line_string multi_point multi_polygon name point polygon value GeometriesSchema class GeometriesSchema ( * args , ** kwargs ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'} Attributes Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class GeometriesSchema ( BaseSchema ) : point_schema = PointSchema multi_point_schema = MultiPointSchema line_string_schema = LineStringSchema multi_line_string_schema = MultiLineStringSchema polygon_schema = PolygonSchema multi_polygon_schema = MultiPolygonSchema def __init__ ( self , * args , ** kwargs ) : super ( GeometriesSchema , self ). __init__ ( * args , ** kwargs ) self . object_type_map = { GeometryType . point . value : self . point_schema , GeometryType . multi_point . value : self . multi_point_schema , GeometryType . line_string . value : self . line_string_schema , GeometryType . multi_line_string . value : self . multi_line_string_schema , GeometryType . polygon . value : self . polygon_schema , GeometryType . multi_polygon . value : self . multi_polygon_schema , } def __validator_geometry_type ( self , geo_type : typing . Any ) : if geo_type not in self . object_type_map : raise ma . ValidationError ( { '_schema' : f 'Unknown object class for {geo_type}.' } ) return geo_type def get_instance_schema ( self , data ) : object_type = self . __validator_geometry_type ( data [ 'type' ] ) schema = self . object_type_map [ object_type ] return schema () def load ( self , data : typing . Union [ typing.Mapping[str, typing.Any ] , typing . Iterable [ typing.Mapping[str, typing.Any ] ] , ] , * , many : bool = None , partial : typing . Union [ bool, types.StrSequenceOrSet ] = None , unknown : str = None ) : schema = self . get_instance_schema ( data ) return schema . load ( data , many = many , partial = partial , unknown = unknown ) def loads ( self , json_data : str , * , many : bool = None , partial : typing . Union [ bool, types.StrSequenceOrSet ] = None , unknown : str = None , ** kwargs ) : data = self . opts . render_module . loads ( json_data , ** kwargs ) schema = self . get_instance_schema ( data ) return schema . loads ( json_data , many = many , partial = partial , unknown = unknown ) Ancestors (in MRO) hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages line_string_schema multi_line_string_schema multi_point_schema multi_polygon_schema opts point_schema polygon_schema Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) get_instance_schema def get_instance_schema ( self , data ) View Source def get_instance_schema ( self , data ) : object_type = self . __validator_geometry_type ( data [ 'type' ] ) schema = self . object_type_map [ object_type ] return schema () handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : Union [ Mapping [ str , Any ], Iterable [ Mapping [ str , Any ]]], * , many : bool = None , partial : Union [ bool , Sequence [ str ], Set [ str ]] = None , unknown : str = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : typing . Union [ typing . Mapping [ str , typing . Any ], typing . Iterable [ typing . Mapping [ str , typing . Any ]], ], * , many : bool = None , partial : typing . Union [ bool , types . StrSequenceOrSet ] = None , unknown : str = None ): schema = self . get_instance_schema ( data ) return schema . load ( data , many = many , partial = partial , unknown = unknown ) loads def loads ( self , json_data : str , * , many : bool = None , partial : Union [ bool , Sequence [ str ], Set [ str ]] = None , unknown : str = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool = None , partial : typing . Union [ bool , types . StrSequenceOrSet ] = None , unknown : str = None , ** kwargs ): data = self . opts . render_module . loads ( json_data , ** kwargs ) schema = self . get_instance_schema ( data ) return schema . loads ( json_data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} GeometryCollectionSchema class GeometryCollectionSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'} Attributes Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class GeometryCollectionSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ GEOMETRY_COLLECTION ] , error = 'Invalid geometry collection type' , ) ) geometries = List ( Nested ( GeometriesSchema ), required = True , ) Ancestors (in MRO) hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages geometries opts type Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} GeometryType class GeometryType ( / , * args , ** kwargs ) Inside this document, the term \"geometry type\" refers to seven case-sensitive strings: \"Point\", \"MultiPoint\", \"LineString\", \"MultiLineString\", \"Polygon\", \"MultiPolygon\", and \"GeometryCollection\". View Source class GeometryType ( Enum ): \"\"\" Inside this document, the term \" geometry type \" refers to seven case-sensitive strings: \" Point \", \" MultiPoint \", \" LineString \", \" MultiLineString \", \" Polygon \", \" MultiPolygon \", and \" GeometryCollection \". \"\"\" point = POINT multi_point = MULTI_POINT line_string = LINE_STRING multi_line_string = MULTI_LINE_STRING polygon = POLYGON multi_polygon = MULTI_POLYGON geometry_collection = GEOMETRY_COLLECTION Ancestors (in MRO) enum.Enum Class variables geometry_collection line_string multi_line_string multi_point multi_polygon name point polygon value LineStringSchema class LineStringSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'} Attributes Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class LineStringSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ LINE_STRING ] , error = 'Invalid line string type' ) ) coordinates = List ( List ( Number (), required = True ), required = True , ) Ancestors (in MRO) hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING coordinates error_messages opts type Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} MultiLineStringSchema class MultiLineStringSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'} Attributes Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class MultiLineStringSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ MULTI_LINE_STRING ] , error = 'Invalid multi line string string type' ) ) coordinates = List ( List ( List ( Number (), required = True ), required = True ), required = True , ) Ancestors (in MRO) hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING coordinates error_messages opts type Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} MultiPointSchema class MultiPointSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'} Attributes Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class MultiPointSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ MULTI_POINT ] , error = 'Invalid multi point type' ) ) coordinates = List ( List ( Number (), required = True ), required = True ) Ancestors (in MRO) hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING coordinates error_messages opts type Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} MultiPolygonSchema class MultiPolygonSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'} Attributes Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class MultiPolygonSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ MULTI_POLYGON ] , error = 'Invalid multi polygon type' ) ) coordinates = List ( List ( List ( List ( Number (), required = True ), required = True ), required = True , ), required = True , ) Ancestors (in MRO) hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING coordinates error_messages opts type Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} PointSchema class PointSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'} Attributes Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class PointSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ POINT ] , error = 'Invalid point type' ) ) coordinates = List ( Number (), required = True ) Ancestors (in MRO) hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING coordinates error_messages opts type Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} PolygonSchema class PolygonSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'} Attributes Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class PolygonSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ POLYGON ] , error = 'Invalid polygon type' ) ) coordinates = List ( List ( List ( Number (), required = True ), required = True ), required = True , ) Ancestors (in MRO) hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING coordinates error_messages opts type Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {} PropertiesSchema class PropertiesSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'} Attributes Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class PropertiesSchema ( BaseSchema ): pass Ancestors (in MRO) hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages opts Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"Index"},{"location":"reference/hielen3/geje/#module-hielen3geje","text":"View Source from .point import PointSchema from .multi_polygon import MultiPolygonSchema from .line_string import LineStringSchema from .multi_line_string import MultiLineStringSchema from .polygon import PolygonSchema from .multi_point import MultiPointSchema from .geometry_collection import GeometryCollectionSchema from .feature import FeatureSchema from .feature_collection import FeatureCollectionSchema from .object_type import GeoJSONType from .geometry import GeometriesSchema from .geojson import GeoJSONSchema from .property import PropertiesSchema from .object_type import ( GeometryType , GeoJSONType , ) __author__ = 'Aliaksandr Vaskevich' __maintainer__ = __author__ __email__ = 'vaskevic.an@gmail.com' __license__ = 'MIT' __version__ = '0.1.18' __all__ = ( '__author__' , '__email__' , '__license__' , '__maintainer__' , '__version__' , # object type 'GeometryType' , 'GeoJSONType' , # property schemas 'PropertiesSchema' , # schemas 'PointSchema' , 'MultiPointSchema' , 'LineStringSchema' , 'MultiLineStringSchema' , 'PolygonSchema' , 'MultiPolygonSchema' , 'GeometryCollectionSchema' , 'FeatureSchema' , 'FeatureCollectionSchema' , 'GeometriesSchema' , 'GeoJSONSchema' , )","title":"Module hielen3.geje"},{"location":"reference/hielen3/geje/#sub-modules","text":"hielen3.geje.feature hielen3.geje.feature_collection hielen3.geje.geojson hielen3.geje.geometry hielen3.geje.geometry_collection hielen3.geje.line_string hielen3.geje.multi_line_string hielen3.geje.multi_point hielen3.geje.multi_polygon hielen3.geje.object_type hielen3.geje.point hielen3.geje.polygon hielen3.geje.property","title":"Sub-modules"},{"location":"reference/hielen3/geje/#variables","text":"__author__ __email__ __license__ __maintainer__ __version__","title":"Variables"},{"location":"reference/hielen3/geje/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/geje/#featurecollectionschema","text":"class FeatureCollectionSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'}","title":"FeatureCollectionSchema"},{"location":"reference/hielen3/geje/#attributes","text":"Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class FeatureCollectionSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ FEATURE_COLLECTION ] , error = 'Invalid feature collection type' ) ) features = List ( Nested ( FeatureSchema ), required = True , )","title":"Attributes"},{"location":"reference/hielen3/geje/#ancestors-in-mro","text":"hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/geje/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages features opts type","title":"Class variables"},{"location":"reference/hielen3/geje/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/geje/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/geje/#instance-variables","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen3/geje/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/geje/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/geje/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/geje/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/geje/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/geje/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/geje/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/geje/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/geje/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/geje/#featureschema","text":"class FeatureSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'}","title":"FeatureSchema"},{"location":"reference/hielen3/geje/#attributes_1","text":"Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class FeatureSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ FEATURE ] , error = 'Invalid feature type' ) ) geometry = Nested ( GeometriesSchema , required = True , ) properties = Nested ( PropertiesSchema , required = True , )","title":"Attributes"},{"location":"reference/hielen3/geje/#ancestors-in-mro_1","text":"hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/geje/#class-variables_1","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages geometry opts properties type","title":"Class variables"},{"location":"reference/hielen3/geje/#static-methods_1","text":"","title":"Static methods"},{"location":"reference/hielen3/geje/#from_dict_1","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/geje/#instance-variables_1","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen3/geje/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen3/geje/#dump_1","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/geje/#dumps_1","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/geje/#get_attribute_1","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/geje/#handle_error_1","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/geje/#load_1","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/geje/#loads_1","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/geje/#on_bind_field_1","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/geje/#validate_1","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/geje/#geojsonschema","text":"class GeoJSONSchema ( * args , ** kwargs ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'}","title":"GeoJSONSchema"},{"location":"reference/hielen3/geje/#attributes_2","text":"Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class GeoJSONSchema ( BaseSchema ) : point_schema = PointSchema multi_point_schema = MultiPointSchema line_string_schema = LineStringSchema multi_line_string_schema = MultiLineStringSchema polygon_schema = PolygonSchema multi_polygon_schema = MultiPolygonSchema geometry_collection_schema = GeometryCollectionSchema feature_schema = FeatureSchema feature_collection_schema = FeatureCollectionSchema def __init__ ( self , * args , ** kwargs ) : super ( GeoJSONSchema , self ). __init__ ( * args , ** kwargs ) self . object_type_map = { GeoJSONType . point . value : self . point_schema , GeoJSONType . multi_point . value : self . multi_point_schema , GeoJSONType . line_string . value : self . line_string_schema , GeoJSONType . multi_line_string . value : self . multi_line_string_schema , GeoJSONType . polygon . value : self . polygon_schema , GeoJSONType . multi_polygon . value : self . multi_polygon_schema , GeoJSONType . geometry_collection . value : self . geometry_collection_schema , GeoJSONType . feature . value : self . feature_schema , GeoJSONType . feature_collection . value : self . feature_collection_schema , } def __validator_geo_json_type ( self , geo_type : typing . Any ) : if geo_type not in self . object_type_map : raise ma . ValidationError ( { '_schema' : f 'Unknown object class for {geo_type}.' } ) return geo_type def get_instance_schema ( self , data ) : object_type = self . __validator_geo_json_type ( data [ 'type' ] ) schema = self . object_type_map [ object_type ] return schema () def load ( self , data : typing . Union [ typing.Mapping[str, typing.Any ] , typing . Iterable [ typing.Mapping[str, typing.Any ] ] , ] , * , many : bool = None , partial : typing . Union [ bool, types.StrSequenceOrSet ] = None , unknown : str = None ) : schema = self . get_instance_schema ( data ) return schema . load ( data , many = many , partial = partial , unknown = unknown ) def loads ( self , json_data : str , * , many : bool = None , partial : typing . Union [ bool, types.StrSequenceOrSet ] = None , unknown : str = None , ** kwargs ) : data = self . opts . render_module . loads ( json_data , ** kwargs ) schema = self . get_instance_schema ( data ) return schema . loads ( json_data , many = many , partial = partial , unknown = unknown )","title":"Attributes"},{"location":"reference/hielen3/geje/#ancestors-in-mro_2","text":"hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/geje/#class-variables_2","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages feature_collection_schema feature_schema geometry_collection_schema line_string_schema multi_line_string_schema multi_point_schema multi_polygon_schema opts point_schema polygon_schema","title":"Class variables"},{"location":"reference/hielen3/geje/#static-methods_2","text":"","title":"Static methods"},{"location":"reference/hielen3/geje/#from_dict_2","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/geje/#instance-variables_2","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen3/geje/#methods_2","text":"","title":"Methods"},{"location":"reference/hielen3/geje/#dump_2","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/geje/#dumps_2","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/geje/#get_attribute_2","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/geje/#get_instance_schema","text":"def get_instance_schema ( self , data ) View Source def get_instance_schema ( self , data ) : object_type = self . __validator_geo_json_type ( data [ 'type' ] ) schema = self . object_type_map [ object_type ] return schema ()","title":"get_instance_schema"},{"location":"reference/hielen3/geje/#handle_error_2","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/geje/#load_2","text":"def load ( self , data : Union [ Mapping [ str , Any ], Iterable [ Mapping [ str , Any ]]], * , many : bool = None , partial : Union [ bool , Sequence [ str ], Set [ str ]] = None , unknown : str = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : typing . Union [ typing . Mapping [ str , typing . Any ], typing . Iterable [ typing . Mapping [ str , typing . Any ]], ], * , many : bool = None , partial : typing . Union [ bool , types . StrSequenceOrSet ] = None , unknown : str = None ): schema = self . get_instance_schema ( data ) return schema . load ( data , many = many , partial = partial , unknown = unknown )","title":"load"},{"location":"reference/hielen3/geje/#loads_2","text":"def loads ( self , json_data : str , * , many : bool = None , partial : Union [ bool , Sequence [ str ], Set [ str ]] = None , unknown : str = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool = None , partial : typing . Union [ bool , types . StrSequenceOrSet ] = None , unknown : str = None , ** kwargs ): data = self . opts . render_module . loads ( json_data , ** kwargs ) schema = self . get_instance_schema ( data ) return schema . loads ( json_data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/geje/#on_bind_field_2","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/geje/#validate_2","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/geje/#geojsontype","text":"class GeoJSONType ( / , * args , ** kwargs ) As another shorthand notation, the term \"GeoJSON types\" refers to nine case-sensitive strings: \"Feature\", \"FeatureCollection\", and the geometry types listed above. View Source class GeoJSONType ( Enum ): \"\"\" As another shorthand notation, the term \" GeoJSON types \" refers to nine case-sensitive strings: \" Feature \", \" FeatureCollection \", and the geometry types listed above. \"\"\" point = POINT multi_point = MULTI_POINT line_string = LINE_STRING multi_line_string = MULTI_LINE_STRING polygon = POLYGON multi_polygon = MULTI_POLYGON geometry_collection = GEOMETRY_COLLECTION feature = FEATURE feature_collection = FEATURE_COLLECTION","title":"GeoJSONType"},{"location":"reference/hielen3/geje/#ancestors-in-mro_3","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/geje/#class-variables_3","text":"feature feature_collection geometry_collection line_string multi_line_string multi_point multi_polygon name point polygon value","title":"Class variables"},{"location":"reference/hielen3/geje/#geometriesschema","text":"class GeometriesSchema ( * args , ** kwargs ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'}","title":"GeometriesSchema"},{"location":"reference/hielen3/geje/#attributes_3","text":"Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class GeometriesSchema ( BaseSchema ) : point_schema = PointSchema multi_point_schema = MultiPointSchema line_string_schema = LineStringSchema multi_line_string_schema = MultiLineStringSchema polygon_schema = PolygonSchema multi_polygon_schema = MultiPolygonSchema def __init__ ( self , * args , ** kwargs ) : super ( GeometriesSchema , self ). __init__ ( * args , ** kwargs ) self . object_type_map = { GeometryType . point . value : self . point_schema , GeometryType . multi_point . value : self . multi_point_schema , GeometryType . line_string . value : self . line_string_schema , GeometryType . multi_line_string . value : self . multi_line_string_schema , GeometryType . polygon . value : self . polygon_schema , GeometryType . multi_polygon . value : self . multi_polygon_schema , } def __validator_geometry_type ( self , geo_type : typing . Any ) : if geo_type not in self . object_type_map : raise ma . ValidationError ( { '_schema' : f 'Unknown object class for {geo_type}.' } ) return geo_type def get_instance_schema ( self , data ) : object_type = self . __validator_geometry_type ( data [ 'type' ] ) schema = self . object_type_map [ object_type ] return schema () def load ( self , data : typing . Union [ typing.Mapping[str, typing.Any ] , typing . Iterable [ typing.Mapping[str, typing.Any ] ] , ] , * , many : bool = None , partial : typing . Union [ bool, types.StrSequenceOrSet ] = None , unknown : str = None ) : schema = self . get_instance_schema ( data ) return schema . load ( data , many = many , partial = partial , unknown = unknown ) def loads ( self , json_data : str , * , many : bool = None , partial : typing . Union [ bool, types.StrSequenceOrSet ] = None , unknown : str = None , ** kwargs ) : data = self . opts . render_module . loads ( json_data , ** kwargs ) schema = self . get_instance_schema ( data ) return schema . loads ( json_data , many = many , partial = partial , unknown = unknown )","title":"Attributes"},{"location":"reference/hielen3/geje/#ancestors-in-mro_4","text":"hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/geje/#class-variables_4","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages line_string_schema multi_line_string_schema multi_point_schema multi_polygon_schema opts point_schema polygon_schema","title":"Class variables"},{"location":"reference/hielen3/geje/#static-methods_3","text":"","title":"Static methods"},{"location":"reference/hielen3/geje/#from_dict_3","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/geje/#instance-variables_3","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen3/geje/#methods_3","text":"","title":"Methods"},{"location":"reference/hielen3/geje/#dump_3","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/geje/#dumps_3","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/geje/#get_attribute_3","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/geje/#get_instance_schema_1","text":"def get_instance_schema ( self , data ) View Source def get_instance_schema ( self , data ) : object_type = self . __validator_geometry_type ( data [ 'type' ] ) schema = self . object_type_map [ object_type ] return schema ()","title":"get_instance_schema"},{"location":"reference/hielen3/geje/#handle_error_3","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/geje/#load_3","text":"def load ( self , data : Union [ Mapping [ str , Any ], Iterable [ Mapping [ str , Any ]]], * , many : bool = None , partial : Union [ bool , Sequence [ str ], Set [ str ]] = None , unknown : str = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : typing . Union [ typing . Mapping [ str , typing . Any ], typing . Iterable [ typing . Mapping [ str , typing . Any ]], ], * , many : bool = None , partial : typing . Union [ bool , types . StrSequenceOrSet ] = None , unknown : str = None ): schema = self . get_instance_schema ( data ) return schema . load ( data , many = many , partial = partial , unknown = unknown )","title":"load"},{"location":"reference/hielen3/geje/#loads_3","text":"def loads ( self , json_data : str , * , many : bool = None , partial : Union [ bool , Sequence [ str ], Set [ str ]] = None , unknown : str = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool = None , partial : typing . Union [ bool , types . StrSequenceOrSet ] = None , unknown : str = None , ** kwargs ): data = self . opts . render_module . loads ( json_data , ** kwargs ) schema = self . get_instance_schema ( data ) return schema . loads ( json_data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/geje/#on_bind_field_3","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/geje/#validate_3","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/geje/#geometrycollectionschema","text":"class GeometryCollectionSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'}","title":"GeometryCollectionSchema"},{"location":"reference/hielen3/geje/#attributes_4","text":"Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class GeometryCollectionSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ GEOMETRY_COLLECTION ] , error = 'Invalid geometry collection type' , ) ) geometries = List ( Nested ( GeometriesSchema ), required = True , )","title":"Attributes"},{"location":"reference/hielen3/geje/#ancestors-in-mro_5","text":"hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/geje/#class-variables_5","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages geometries opts type","title":"Class variables"},{"location":"reference/hielen3/geje/#static-methods_4","text":"","title":"Static methods"},{"location":"reference/hielen3/geje/#from_dict_4","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/geje/#instance-variables_4","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen3/geje/#methods_4","text":"","title":"Methods"},{"location":"reference/hielen3/geje/#dump_4","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/geje/#dumps_4","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/geje/#get_attribute_4","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/geje/#handle_error_4","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/geje/#load_4","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/geje/#loads_4","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/geje/#on_bind_field_4","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/geje/#validate_4","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/geje/#geometrytype","text":"class GeometryType ( / , * args , ** kwargs ) Inside this document, the term \"geometry type\" refers to seven case-sensitive strings: \"Point\", \"MultiPoint\", \"LineString\", \"MultiLineString\", \"Polygon\", \"MultiPolygon\", and \"GeometryCollection\". View Source class GeometryType ( Enum ): \"\"\" Inside this document, the term \" geometry type \" refers to seven case-sensitive strings: \" Point \", \" MultiPoint \", \" LineString \", \" MultiLineString \", \" Polygon \", \" MultiPolygon \", and \" GeometryCollection \". \"\"\" point = POINT multi_point = MULTI_POINT line_string = LINE_STRING multi_line_string = MULTI_LINE_STRING polygon = POLYGON multi_polygon = MULTI_POLYGON geometry_collection = GEOMETRY_COLLECTION","title":"GeometryType"},{"location":"reference/hielen3/geje/#ancestors-in-mro_6","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/geje/#class-variables_6","text":"geometry_collection line_string multi_line_string multi_point multi_polygon name point polygon value","title":"Class variables"},{"location":"reference/hielen3/geje/#linestringschema","text":"class LineStringSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'}","title":"LineStringSchema"},{"location":"reference/hielen3/geje/#attributes_5","text":"Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class LineStringSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ LINE_STRING ] , error = 'Invalid line string type' ) ) coordinates = List ( List ( Number (), required = True ), required = True , )","title":"Attributes"},{"location":"reference/hielen3/geje/#ancestors-in-mro_7","text":"hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/geje/#class-variables_7","text":"Meta OPTIONS_CLASS TYPE_MAPPING coordinates error_messages opts type","title":"Class variables"},{"location":"reference/hielen3/geje/#static-methods_5","text":"","title":"Static methods"},{"location":"reference/hielen3/geje/#from_dict_5","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/geje/#instance-variables_5","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen3/geje/#methods_5","text":"","title":"Methods"},{"location":"reference/hielen3/geje/#dump_5","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/geje/#dumps_5","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/geje/#get_attribute_5","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/geje/#handle_error_5","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/geje/#load_5","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/geje/#loads_5","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/geje/#on_bind_field_5","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/geje/#validate_5","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/geje/#multilinestringschema","text":"class MultiLineStringSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'}","title":"MultiLineStringSchema"},{"location":"reference/hielen3/geje/#attributes_6","text":"Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class MultiLineStringSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ MULTI_LINE_STRING ] , error = 'Invalid multi line string string type' ) ) coordinates = List ( List ( List ( Number (), required = True ), required = True ), required = True , )","title":"Attributes"},{"location":"reference/hielen3/geje/#ancestors-in-mro_8","text":"hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/geje/#class-variables_8","text":"Meta OPTIONS_CLASS TYPE_MAPPING coordinates error_messages opts type","title":"Class variables"},{"location":"reference/hielen3/geje/#static-methods_6","text":"","title":"Static methods"},{"location":"reference/hielen3/geje/#from_dict_6","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/geje/#instance-variables_6","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen3/geje/#methods_6","text":"","title":"Methods"},{"location":"reference/hielen3/geje/#dump_6","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/geje/#dumps_6","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/geje/#get_attribute_6","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/geje/#handle_error_6","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/geje/#load_6","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/geje/#loads_6","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/geje/#on_bind_field_6","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/geje/#validate_6","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/geje/#multipointschema","text":"class MultiPointSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'}","title":"MultiPointSchema"},{"location":"reference/hielen3/geje/#attributes_7","text":"Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class MultiPointSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ MULTI_POINT ] , error = 'Invalid multi point type' ) ) coordinates = List ( List ( Number (), required = True ), required = True )","title":"Attributes"},{"location":"reference/hielen3/geje/#ancestors-in-mro_9","text":"hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/geje/#class-variables_9","text":"Meta OPTIONS_CLASS TYPE_MAPPING coordinates error_messages opts type","title":"Class variables"},{"location":"reference/hielen3/geje/#static-methods_7","text":"","title":"Static methods"},{"location":"reference/hielen3/geje/#from_dict_7","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/geje/#instance-variables_7","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen3/geje/#methods_7","text":"","title":"Methods"},{"location":"reference/hielen3/geje/#dump_7","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/geje/#dumps_7","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/geje/#get_attribute_7","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/geje/#handle_error_7","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/geje/#load_7","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/geje/#loads_7","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/geje/#on_bind_field_7","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/geje/#validate_7","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/geje/#multipolygonschema","text":"class MultiPolygonSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'}","title":"MultiPolygonSchema"},{"location":"reference/hielen3/geje/#attributes_8","text":"Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class MultiPolygonSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ MULTI_POLYGON ] , error = 'Invalid multi polygon type' ) ) coordinates = List ( List ( List ( List ( Number (), required = True ), required = True ), required = True , ), required = True , )","title":"Attributes"},{"location":"reference/hielen3/geje/#ancestors-in-mro_10","text":"hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/geje/#class-variables_10","text":"Meta OPTIONS_CLASS TYPE_MAPPING coordinates error_messages opts type","title":"Class variables"},{"location":"reference/hielen3/geje/#static-methods_8","text":"","title":"Static methods"},{"location":"reference/hielen3/geje/#from_dict_8","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/geje/#instance-variables_8","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen3/geje/#methods_8","text":"","title":"Methods"},{"location":"reference/hielen3/geje/#dump_8","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/geje/#dumps_8","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/geje/#get_attribute_8","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/geje/#handle_error_8","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/geje/#load_8","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/geje/#loads_8","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/geje/#on_bind_field_8","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/geje/#validate_8","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/geje/#pointschema","text":"class PointSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'}","title":"PointSchema"},{"location":"reference/hielen3/geje/#attributes_9","text":"Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class PointSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ POINT ] , error = 'Invalid point type' ) ) coordinates = List ( Number (), required = True )","title":"Attributes"},{"location":"reference/hielen3/geje/#ancestors-in-mro_11","text":"hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/geje/#class-variables_11","text":"Meta OPTIONS_CLASS TYPE_MAPPING coordinates error_messages opts type","title":"Class variables"},{"location":"reference/hielen3/geje/#static-methods_9","text":"","title":"Static methods"},{"location":"reference/hielen3/geje/#from_dict_9","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/geje/#instance-variables_9","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen3/geje/#methods_9","text":"","title":"Methods"},{"location":"reference/hielen3/geje/#dump_9","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/geje/#dumps_9","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/geje/#get_attribute_9","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/geje/#handle_error_9","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/geje/#load_9","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/geje/#loads_9","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/geje/#on_bind_field_9","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/geje/#validate_9","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/geje/#polygonschema","text":"class PolygonSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'}","title":"PolygonSchema"},{"location":"reference/hielen3/geje/#attributes_10","text":"Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class PolygonSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ POLYGON ] , error = 'Invalid polygon type' ) ) coordinates = List ( List ( List ( Number (), required = True ), required = True ), required = True , )","title":"Attributes"},{"location":"reference/hielen3/geje/#ancestors-in-mro_12","text":"hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/geje/#class-variables_12","text":"Meta OPTIONS_CLASS TYPE_MAPPING coordinates error_messages opts type","title":"Class variables"},{"location":"reference/hielen3/geje/#static-methods_10","text":"","title":"Static methods"},{"location":"reference/hielen3/geje/#from_dict_10","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/geje/#instance-variables_10","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen3/geje/#methods_10","text":"","title":"Methods"},{"location":"reference/hielen3/geje/#dump_10","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/geje/#dumps_10","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/geje/#get_attribute_10","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/geje/#handle_error_10","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/geje/#load_10","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/geje/#loads_10","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/geje/#on_bind_field_10","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/geje/#validate_10","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/geje/#propertiesschema","text":"class PropertiesSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'}","title":"PropertiesSchema"},{"location":"reference/hielen3/geje/#attributes_11","text":"Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class PropertiesSchema ( BaseSchema ): pass","title":"Attributes"},{"location":"reference/hielen3/geje/#ancestors-in-mro_13","text":"hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/geje/#class-variables_13","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages opts","title":"Class variables"},{"location":"reference/hielen3/geje/#static-methods_11","text":"","title":"Static methods"},{"location":"reference/hielen3/geje/#from_dict_11","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/geje/#instance-variables_11","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen3/geje/#methods_11","text":"","title":"Methods"},{"location":"reference/hielen3/geje/#dump_11","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/geje/#dumps_11","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/geje/#get_attribute_11","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/geje/#handle_error_11","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/geje/#load_11","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/geje/#loads_11","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/geje/#on_bind_field_11","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/geje/#validate_11","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/geje/feature/","text":"Module hielen3.geje.feature View Source from marshmallow.fields import ( Nested , Str , ) from marshmallow.validate import ( OneOf , ) from .object_type import ( FEATURE , ) from ._base import BaseSchema from .geometry import GeometriesSchema from .property import PropertiesSchema class FeatureSchema ( BaseSchema ): type = Str ( required = True , validate = OneOf ( [ FEATURE ], error = 'Invalid feature type' ) ) geometry = Nested ( GeometriesSchema , required = True , ) properties = Nested ( PropertiesSchema , required = True , ) Variables FEATURE Classes FeatureSchema class FeatureSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'} Attributes Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class FeatureSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ FEATURE ] , error = 'Invalid feature type' ) ) geometry = Nested ( GeometriesSchema , required = True , ) properties = Nested ( PropertiesSchema , required = True , ) Ancestors (in MRO) hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages geometry opts properties type Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"Feature"},{"location":"reference/hielen3/geje/feature/#module-hielen3gejefeature","text":"View Source from marshmallow.fields import ( Nested , Str , ) from marshmallow.validate import ( OneOf , ) from .object_type import ( FEATURE , ) from ._base import BaseSchema from .geometry import GeometriesSchema from .property import PropertiesSchema class FeatureSchema ( BaseSchema ): type = Str ( required = True , validate = OneOf ( [ FEATURE ], error = 'Invalid feature type' ) ) geometry = Nested ( GeometriesSchema , required = True , ) properties = Nested ( PropertiesSchema , required = True , )","title":"Module hielen3.geje.feature"},{"location":"reference/hielen3/geje/feature/#variables","text":"FEATURE","title":"Variables"},{"location":"reference/hielen3/geje/feature/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/geje/feature/#featureschema","text":"class FeatureSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'}","title":"FeatureSchema"},{"location":"reference/hielen3/geje/feature/#attributes","text":"Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class FeatureSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ FEATURE ] , error = 'Invalid feature type' ) ) geometry = Nested ( GeometriesSchema , required = True , ) properties = Nested ( PropertiesSchema , required = True , )","title":"Attributes"},{"location":"reference/hielen3/geje/feature/#ancestors-in-mro","text":"hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/geje/feature/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages geometry opts properties type","title":"Class variables"},{"location":"reference/hielen3/geje/feature/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/geje/feature/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/geje/feature/#instance-variables","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen3/geje/feature/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/geje/feature/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/geje/feature/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/geje/feature/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/geje/feature/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/geje/feature/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/geje/feature/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/geje/feature/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/geje/feature/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/geje/feature_collection/","text":"Module hielen3.geje.feature_collection View Source from marshmallow.fields import ( Nested , List , Str , ) from marshmallow.validate import ( OneOf , ) from .object_type import ( FEATURE_COLLECTION , ) from ._base import BaseSchema from .feature import FeatureSchema class FeatureCollectionSchema ( BaseSchema ): type = Str ( required = True , validate = OneOf ( [ FEATURE_COLLECTION ], error = 'Invalid feature collection type' ) ) features = List ( Nested ( FeatureSchema ), required = True , ) Variables FEATURE_COLLECTION Classes FeatureCollectionSchema class FeatureCollectionSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'} Attributes Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class FeatureCollectionSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ FEATURE_COLLECTION ] , error = 'Invalid feature collection type' ) ) features = List ( Nested ( FeatureSchema ), required = True , ) Ancestors (in MRO) hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages features opts type Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"Feature Collection"},{"location":"reference/hielen3/geje/feature_collection/#module-hielen3gejefeature_collection","text":"View Source from marshmallow.fields import ( Nested , List , Str , ) from marshmallow.validate import ( OneOf , ) from .object_type import ( FEATURE_COLLECTION , ) from ._base import BaseSchema from .feature import FeatureSchema class FeatureCollectionSchema ( BaseSchema ): type = Str ( required = True , validate = OneOf ( [ FEATURE_COLLECTION ], error = 'Invalid feature collection type' ) ) features = List ( Nested ( FeatureSchema ), required = True , )","title":"Module hielen3.geje.feature_collection"},{"location":"reference/hielen3/geje/feature_collection/#variables","text":"FEATURE_COLLECTION","title":"Variables"},{"location":"reference/hielen3/geje/feature_collection/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/geje/feature_collection/#featurecollectionschema","text":"class FeatureCollectionSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'}","title":"FeatureCollectionSchema"},{"location":"reference/hielen3/geje/feature_collection/#attributes","text":"Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class FeatureCollectionSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ FEATURE_COLLECTION ] , error = 'Invalid feature collection type' ) ) features = List ( Nested ( FeatureSchema ), required = True , )","title":"Attributes"},{"location":"reference/hielen3/geje/feature_collection/#ancestors-in-mro","text":"hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/geje/feature_collection/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages features opts type","title":"Class variables"},{"location":"reference/hielen3/geje/feature_collection/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/geje/feature_collection/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/geje/feature_collection/#instance-variables","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen3/geje/feature_collection/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/geje/feature_collection/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/geje/feature_collection/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/geje/feature_collection/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/geje/feature_collection/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/geje/feature_collection/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/geje/feature_collection/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/geje/feature_collection/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/geje/feature_collection/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/geje/geojson/","text":"Module hielen3.geje.geojson View Source import typing import marshmallow as ma from marshmallow import ( types ) from .point import PointSchema from .multi_polygon import MultiPolygonSchema from .line_string import LineStringSchema from .multi_line_string import MultiLineStringSchema from .polygon import PolygonSchema from .multi_point import MultiPointSchema from .geometry_collection import GeometryCollectionSchema from .feature import FeatureSchema from .feature_collection import FeatureCollectionSchema from .object_type import GeoJSONType from ._base import BaseSchema class GeoJSONSchema ( BaseSchema ): point_schema = PointSchema multi_point_schema = MultiPointSchema line_string_schema = LineStringSchema multi_line_string_schema = MultiLineStringSchema polygon_schema = PolygonSchema multi_polygon_schema = MultiPolygonSchema geometry_collection_schema = GeometryCollectionSchema feature_schema = FeatureSchema feature_collection_schema = FeatureCollectionSchema def __init__ ( self , * args , ** kwargs ): super ( GeoJSONSchema , self ) . __init__ ( * args , ** kwargs ) self . object_type_map = { GeoJSONType . point . value : self . point_schema , GeoJSONType . multi_point . value : self . multi_point_schema , GeoJSONType . line_string . value : self . line_string_schema , GeoJSONType . multi_line_string . value : self . multi_line_string_schema , GeoJSONType . polygon . value : self . polygon_schema , GeoJSONType . multi_polygon . value : self . multi_polygon_schema , GeoJSONType . geometry_collection . value : self . geometry_collection_schema , GeoJSONType . feature . value : self . feature_schema , GeoJSONType . feature_collection . value : self . feature_collection_schema , } def __validator_geo_json_type ( self , geo_type : typing . Any ): if geo_type not in self . object_type_map : raise ma . ValidationError ( { '_schema' : f 'Unknown object class for { geo_type } .' }) return geo_type def get_instance_schema ( self , data ): object_type = self . __validator_geo_json_type ( data [ 'type' ]) schema = self . object_type_map [ object_type ] return schema () def load ( self , data : typing . Union [ typing . Mapping [ str , typing . Any ], typing . Iterable [ typing . Mapping [ str , typing . Any ]], ], * , many : bool = None , partial : typing . Union [ bool , types . StrSequenceOrSet ] = None , unknown : str = None ): schema = self . get_instance_schema ( data ) return schema . load ( data , many = many , partial = partial , unknown = unknown ) def loads ( self , json_data : str , * , many : bool = None , partial : typing . Union [ bool , types . StrSequenceOrSet ] = None , unknown : str = None , ** kwargs ): data = self . opts . render_module . loads ( json_data , ** kwargs ) schema = self . get_instance_schema ( data ) return schema . loads ( json_data , many = many , partial = partial , unknown = unknown ) Classes GeoJSONSchema class GeoJSONSchema ( * args , ** kwargs ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'} Attributes Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class GeoJSONSchema ( BaseSchema ) : point_schema = PointSchema multi_point_schema = MultiPointSchema line_string_schema = LineStringSchema multi_line_string_schema = MultiLineStringSchema polygon_schema = PolygonSchema multi_polygon_schema = MultiPolygonSchema geometry_collection_schema = GeometryCollectionSchema feature_schema = FeatureSchema feature_collection_schema = FeatureCollectionSchema def __init__ ( self , * args , ** kwargs ) : super ( GeoJSONSchema , self ). __init__ ( * args , ** kwargs ) self . object_type_map = { GeoJSONType . point . value : self . point_schema , GeoJSONType . multi_point . value : self . multi_point_schema , GeoJSONType . line_string . value : self . line_string_schema , GeoJSONType . multi_line_string . value : self . multi_line_string_schema , GeoJSONType . polygon . value : self . polygon_schema , GeoJSONType . multi_polygon . value : self . multi_polygon_schema , GeoJSONType . geometry_collection . value : self . geometry_collection_schema , GeoJSONType . feature . value : self . feature_schema , GeoJSONType . feature_collection . value : self . feature_collection_schema , } def __validator_geo_json_type ( self , geo_type : typing . Any ) : if geo_type not in self . object_type_map : raise ma . ValidationError ( { '_schema' : f 'Unknown object class for {geo_type}.' } ) return geo_type def get_instance_schema ( self , data ) : object_type = self . __validator_geo_json_type ( data [ 'type' ] ) schema = self . object_type_map [ object_type ] return schema () def load ( self , data : typing . Union [ typing.Mapping[str, typing.Any ] , typing . Iterable [ typing.Mapping[str, typing.Any ] ] , ] , * , many : bool = None , partial : typing . Union [ bool, types.StrSequenceOrSet ] = None , unknown : str = None ) : schema = self . get_instance_schema ( data ) return schema . load ( data , many = many , partial = partial , unknown = unknown ) def loads ( self , json_data : str , * , many : bool = None , partial : typing . Union [ bool, types.StrSequenceOrSet ] = None , unknown : str = None , ** kwargs ) : data = self . opts . render_module . loads ( json_data , ** kwargs ) schema = self . get_instance_schema ( data ) return schema . loads ( json_data , many = many , partial = partial , unknown = unknown ) Ancestors (in MRO) hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages feature_collection_schema feature_schema geometry_collection_schema line_string_schema multi_line_string_schema multi_point_schema multi_polygon_schema opts point_schema polygon_schema Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) get_instance_schema def get_instance_schema ( self , data ) View Source def get_instance_schema ( self , data ) : object_type = self . __validator_geo_json_type ( data [ 'type' ] ) schema = self . object_type_map [ object_type ] return schema () handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : Union [ Mapping [ str , Any ], Iterable [ Mapping [ str , Any ]]], * , many : bool = None , partial : Union [ bool , Sequence [ str ], Set [ str ]] = None , unknown : str = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : typing . Union [ typing . Mapping [ str , typing . Any ], typing . Iterable [ typing . Mapping [ str , typing . Any ]], ], * , many : bool = None , partial : typing . Union [ bool , types . StrSequenceOrSet ] = None , unknown : str = None ): schema = self . get_instance_schema ( data ) return schema . load ( data , many = many , partial = partial , unknown = unknown ) loads def loads ( self , json_data : str , * , many : bool = None , partial : Union [ bool , Sequence [ str ], Set [ str ]] = None , unknown : str = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool = None , partial : typing . Union [ bool , types . StrSequenceOrSet ] = None , unknown : str = None , ** kwargs ): data = self . opts . render_module . loads ( json_data , ** kwargs ) schema = self . get_instance_schema ( data ) return schema . loads ( json_data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"Geojson"},{"location":"reference/hielen3/geje/geojson/#module-hielen3gejegeojson","text":"View Source import typing import marshmallow as ma from marshmallow import ( types ) from .point import PointSchema from .multi_polygon import MultiPolygonSchema from .line_string import LineStringSchema from .multi_line_string import MultiLineStringSchema from .polygon import PolygonSchema from .multi_point import MultiPointSchema from .geometry_collection import GeometryCollectionSchema from .feature import FeatureSchema from .feature_collection import FeatureCollectionSchema from .object_type import GeoJSONType from ._base import BaseSchema class GeoJSONSchema ( BaseSchema ): point_schema = PointSchema multi_point_schema = MultiPointSchema line_string_schema = LineStringSchema multi_line_string_schema = MultiLineStringSchema polygon_schema = PolygonSchema multi_polygon_schema = MultiPolygonSchema geometry_collection_schema = GeometryCollectionSchema feature_schema = FeatureSchema feature_collection_schema = FeatureCollectionSchema def __init__ ( self , * args , ** kwargs ): super ( GeoJSONSchema , self ) . __init__ ( * args , ** kwargs ) self . object_type_map = { GeoJSONType . point . value : self . point_schema , GeoJSONType . multi_point . value : self . multi_point_schema , GeoJSONType . line_string . value : self . line_string_schema , GeoJSONType . multi_line_string . value : self . multi_line_string_schema , GeoJSONType . polygon . value : self . polygon_schema , GeoJSONType . multi_polygon . value : self . multi_polygon_schema , GeoJSONType . geometry_collection . value : self . geometry_collection_schema , GeoJSONType . feature . value : self . feature_schema , GeoJSONType . feature_collection . value : self . feature_collection_schema , } def __validator_geo_json_type ( self , geo_type : typing . Any ): if geo_type not in self . object_type_map : raise ma . ValidationError ( { '_schema' : f 'Unknown object class for { geo_type } .' }) return geo_type def get_instance_schema ( self , data ): object_type = self . __validator_geo_json_type ( data [ 'type' ]) schema = self . object_type_map [ object_type ] return schema () def load ( self , data : typing . Union [ typing . Mapping [ str , typing . Any ], typing . Iterable [ typing . Mapping [ str , typing . Any ]], ], * , many : bool = None , partial : typing . Union [ bool , types . StrSequenceOrSet ] = None , unknown : str = None ): schema = self . get_instance_schema ( data ) return schema . load ( data , many = many , partial = partial , unknown = unknown ) def loads ( self , json_data : str , * , many : bool = None , partial : typing . Union [ bool , types . StrSequenceOrSet ] = None , unknown : str = None , ** kwargs ): data = self . opts . render_module . loads ( json_data , ** kwargs ) schema = self . get_instance_schema ( data ) return schema . loads ( json_data , many = many , partial = partial , unknown = unknown )","title":"Module hielen3.geje.geojson"},{"location":"reference/hielen3/geje/geojson/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/geje/geojson/#geojsonschema","text":"class GeoJSONSchema ( * args , ** kwargs ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'}","title":"GeoJSONSchema"},{"location":"reference/hielen3/geje/geojson/#attributes","text":"Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class GeoJSONSchema ( BaseSchema ) : point_schema = PointSchema multi_point_schema = MultiPointSchema line_string_schema = LineStringSchema multi_line_string_schema = MultiLineStringSchema polygon_schema = PolygonSchema multi_polygon_schema = MultiPolygonSchema geometry_collection_schema = GeometryCollectionSchema feature_schema = FeatureSchema feature_collection_schema = FeatureCollectionSchema def __init__ ( self , * args , ** kwargs ) : super ( GeoJSONSchema , self ). __init__ ( * args , ** kwargs ) self . object_type_map = { GeoJSONType . point . value : self . point_schema , GeoJSONType . multi_point . value : self . multi_point_schema , GeoJSONType . line_string . value : self . line_string_schema , GeoJSONType . multi_line_string . value : self . multi_line_string_schema , GeoJSONType . polygon . value : self . polygon_schema , GeoJSONType . multi_polygon . value : self . multi_polygon_schema , GeoJSONType . geometry_collection . value : self . geometry_collection_schema , GeoJSONType . feature . value : self . feature_schema , GeoJSONType . feature_collection . value : self . feature_collection_schema , } def __validator_geo_json_type ( self , geo_type : typing . Any ) : if geo_type not in self . object_type_map : raise ma . ValidationError ( { '_schema' : f 'Unknown object class for {geo_type}.' } ) return geo_type def get_instance_schema ( self , data ) : object_type = self . __validator_geo_json_type ( data [ 'type' ] ) schema = self . object_type_map [ object_type ] return schema () def load ( self , data : typing . Union [ typing.Mapping[str, typing.Any ] , typing . Iterable [ typing.Mapping[str, typing.Any ] ] , ] , * , many : bool = None , partial : typing . Union [ bool, types.StrSequenceOrSet ] = None , unknown : str = None ) : schema = self . get_instance_schema ( data ) return schema . load ( data , many = many , partial = partial , unknown = unknown ) def loads ( self , json_data : str , * , many : bool = None , partial : typing . Union [ bool, types.StrSequenceOrSet ] = None , unknown : str = None , ** kwargs ) : data = self . opts . render_module . loads ( json_data , ** kwargs ) schema = self . get_instance_schema ( data ) return schema . loads ( json_data , many = many , partial = partial , unknown = unknown )","title":"Attributes"},{"location":"reference/hielen3/geje/geojson/#ancestors-in-mro","text":"hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/geje/geojson/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages feature_collection_schema feature_schema geometry_collection_schema line_string_schema multi_line_string_schema multi_point_schema multi_polygon_schema opts point_schema polygon_schema","title":"Class variables"},{"location":"reference/hielen3/geje/geojson/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/geje/geojson/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/geje/geojson/#instance-variables","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen3/geje/geojson/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/geje/geojson/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/geje/geojson/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/geje/geojson/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/geje/geojson/#get_instance_schema","text":"def get_instance_schema ( self , data ) View Source def get_instance_schema ( self , data ) : object_type = self . __validator_geo_json_type ( data [ 'type' ] ) schema = self . object_type_map [ object_type ] return schema ()","title":"get_instance_schema"},{"location":"reference/hielen3/geje/geojson/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/geje/geojson/#load","text":"def load ( self , data : Union [ Mapping [ str , Any ], Iterable [ Mapping [ str , Any ]]], * , many : bool = None , partial : Union [ bool , Sequence [ str ], Set [ str ]] = None , unknown : str = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : typing . Union [ typing . Mapping [ str , typing . Any ], typing . Iterable [ typing . Mapping [ str , typing . Any ]], ], * , many : bool = None , partial : typing . Union [ bool , types . StrSequenceOrSet ] = None , unknown : str = None ): schema = self . get_instance_schema ( data ) return schema . load ( data , many = many , partial = partial , unknown = unknown )","title":"load"},{"location":"reference/hielen3/geje/geojson/#loads","text":"def loads ( self , json_data : str , * , many : bool = None , partial : Union [ bool , Sequence [ str ], Set [ str ]] = None , unknown : str = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool = None , partial : typing . Union [ bool , types . StrSequenceOrSet ] = None , unknown : str = None , ** kwargs ): data = self . opts . render_module . loads ( json_data , ** kwargs ) schema = self . get_instance_schema ( data ) return schema . loads ( json_data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/geje/geojson/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/geje/geojson/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/geje/geometry/","text":"Module hielen3.geje.geometry View Source import typing import marshmallow as ma from marshmallow import types from ._base import BaseSchema from .point import PointSchema from .multi_polygon import MultiPolygonSchema from .line_string import LineStringSchema from .multi_line_string import MultiLineStringSchema from .polygon import PolygonSchema from .multi_point import MultiPointSchema from .object_type import GeometryType class GeometriesSchema ( BaseSchema ): point_schema = PointSchema multi_point_schema = MultiPointSchema line_string_schema = LineStringSchema multi_line_string_schema = MultiLineStringSchema polygon_schema = PolygonSchema multi_polygon_schema = MultiPolygonSchema def __init__ ( self , * args , ** kwargs ): super ( GeometriesSchema , self ) . __init__ ( * args , ** kwargs ) self . object_type_map = { GeometryType . point . value : self . point_schema , GeometryType . multi_point . value : self . multi_point_schema , GeometryType . line_string . value : self . line_string_schema , GeometryType . multi_line_string . value : self . multi_line_string_schema , GeometryType . polygon . value : self . polygon_schema , GeometryType . multi_polygon . value : self . multi_polygon_schema , } def __validator_geometry_type ( self , geo_type : typing . Any ): if geo_type not in self . object_type_map : raise ma . ValidationError ( { '_schema' : f 'Unknown object class for { geo_type } .' }) return geo_type def get_instance_schema ( self , data ): object_type = self . __validator_geometry_type ( data [ 'type' ]) schema = self . object_type_map [ object_type ] return schema () def load ( self , data : typing . Union [ typing . Mapping [ str , typing . Any ], typing . Iterable [ typing . Mapping [ str , typing . Any ]], ], * , many : bool = None , partial : typing . Union [ bool , types . StrSequenceOrSet ] = None , unknown : str = None ): schema = self . get_instance_schema ( data ) return schema . load ( data , many = many , partial = partial , unknown = unknown ) def loads ( self , json_data : str , * , many : bool = None , partial : typing . Union [ bool , types . StrSequenceOrSet ] = None , unknown : str = None , ** kwargs ): data = self . opts . render_module . loads ( json_data , ** kwargs ) schema = self . get_instance_schema ( data ) return schema . loads ( json_data , many = many , partial = partial , unknown = unknown ) Classes GeometriesSchema class GeometriesSchema ( * args , ** kwargs ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'} Attributes Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class GeometriesSchema ( BaseSchema ) : point_schema = PointSchema multi_point_schema = MultiPointSchema line_string_schema = LineStringSchema multi_line_string_schema = MultiLineStringSchema polygon_schema = PolygonSchema multi_polygon_schema = MultiPolygonSchema def __init__ ( self , * args , ** kwargs ) : super ( GeometriesSchema , self ). __init__ ( * args , ** kwargs ) self . object_type_map = { GeometryType . point . value : self . point_schema , GeometryType . multi_point . value : self . multi_point_schema , GeometryType . line_string . value : self . line_string_schema , GeometryType . multi_line_string . value : self . multi_line_string_schema , GeometryType . polygon . value : self . polygon_schema , GeometryType . multi_polygon . value : self . multi_polygon_schema , } def __validator_geometry_type ( self , geo_type : typing . Any ) : if geo_type not in self . object_type_map : raise ma . ValidationError ( { '_schema' : f 'Unknown object class for {geo_type}.' } ) return geo_type def get_instance_schema ( self , data ) : object_type = self . __validator_geometry_type ( data [ 'type' ] ) schema = self . object_type_map [ object_type ] return schema () def load ( self , data : typing . Union [ typing.Mapping[str, typing.Any ] , typing . Iterable [ typing.Mapping[str, typing.Any ] ] , ] , * , many : bool = None , partial : typing . Union [ bool, types.StrSequenceOrSet ] = None , unknown : str = None ) : schema = self . get_instance_schema ( data ) return schema . load ( data , many = many , partial = partial , unknown = unknown ) def loads ( self , json_data : str , * , many : bool = None , partial : typing . Union [ bool, types.StrSequenceOrSet ] = None , unknown : str = None , ** kwargs ) : data = self . opts . render_module . loads ( json_data , ** kwargs ) schema = self . get_instance_schema ( data ) return schema . loads ( json_data , many = many , partial = partial , unknown = unknown ) Ancestors (in MRO) hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages line_string_schema multi_line_string_schema multi_point_schema multi_polygon_schema opts point_schema polygon_schema Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) get_instance_schema def get_instance_schema ( self , data ) View Source def get_instance_schema ( self , data ) : object_type = self . __validator_geometry_type ( data [ 'type' ] ) schema = self . object_type_map [ object_type ] return schema () handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : Union [ Mapping [ str , Any ], Iterable [ Mapping [ str , Any ]]], * , many : bool = None , partial : Union [ bool , Sequence [ str ], Set [ str ]] = None , unknown : str = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : typing . Union [ typing . Mapping [ str , typing . Any ], typing . Iterable [ typing . Mapping [ str , typing . Any ]], ], * , many : bool = None , partial : typing . Union [ bool , types . StrSequenceOrSet ] = None , unknown : str = None ): schema = self . get_instance_schema ( data ) return schema . load ( data , many = many , partial = partial , unknown = unknown ) loads def loads ( self , json_data : str , * , many : bool = None , partial : Union [ bool , Sequence [ str ], Set [ str ]] = None , unknown : str = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool = None , partial : typing . Union [ bool , types . StrSequenceOrSet ] = None , unknown : str = None , ** kwargs ): data = self . opts . render_module . loads ( json_data , ** kwargs ) schema = self . get_instance_schema ( data ) return schema . loads ( json_data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"Geometry"},{"location":"reference/hielen3/geje/geometry/#module-hielen3gejegeometry","text":"View Source import typing import marshmallow as ma from marshmallow import types from ._base import BaseSchema from .point import PointSchema from .multi_polygon import MultiPolygonSchema from .line_string import LineStringSchema from .multi_line_string import MultiLineStringSchema from .polygon import PolygonSchema from .multi_point import MultiPointSchema from .object_type import GeometryType class GeometriesSchema ( BaseSchema ): point_schema = PointSchema multi_point_schema = MultiPointSchema line_string_schema = LineStringSchema multi_line_string_schema = MultiLineStringSchema polygon_schema = PolygonSchema multi_polygon_schema = MultiPolygonSchema def __init__ ( self , * args , ** kwargs ): super ( GeometriesSchema , self ) . __init__ ( * args , ** kwargs ) self . object_type_map = { GeometryType . point . value : self . point_schema , GeometryType . multi_point . value : self . multi_point_schema , GeometryType . line_string . value : self . line_string_schema , GeometryType . multi_line_string . value : self . multi_line_string_schema , GeometryType . polygon . value : self . polygon_schema , GeometryType . multi_polygon . value : self . multi_polygon_schema , } def __validator_geometry_type ( self , geo_type : typing . Any ): if geo_type not in self . object_type_map : raise ma . ValidationError ( { '_schema' : f 'Unknown object class for { geo_type } .' }) return geo_type def get_instance_schema ( self , data ): object_type = self . __validator_geometry_type ( data [ 'type' ]) schema = self . object_type_map [ object_type ] return schema () def load ( self , data : typing . Union [ typing . Mapping [ str , typing . Any ], typing . Iterable [ typing . Mapping [ str , typing . Any ]], ], * , many : bool = None , partial : typing . Union [ bool , types . StrSequenceOrSet ] = None , unknown : str = None ): schema = self . get_instance_schema ( data ) return schema . load ( data , many = many , partial = partial , unknown = unknown ) def loads ( self , json_data : str , * , many : bool = None , partial : typing . Union [ bool , types . StrSequenceOrSet ] = None , unknown : str = None , ** kwargs ): data = self . opts . render_module . loads ( json_data , ** kwargs ) schema = self . get_instance_schema ( data ) return schema . loads ( json_data , many = many , partial = partial , unknown = unknown )","title":"Module hielen3.geje.geometry"},{"location":"reference/hielen3/geje/geometry/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/geje/geometry/#geometriesschema","text":"class GeometriesSchema ( * args , ** kwargs ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'}","title":"GeometriesSchema"},{"location":"reference/hielen3/geje/geometry/#attributes","text":"Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class GeometriesSchema ( BaseSchema ) : point_schema = PointSchema multi_point_schema = MultiPointSchema line_string_schema = LineStringSchema multi_line_string_schema = MultiLineStringSchema polygon_schema = PolygonSchema multi_polygon_schema = MultiPolygonSchema def __init__ ( self , * args , ** kwargs ) : super ( GeometriesSchema , self ). __init__ ( * args , ** kwargs ) self . object_type_map = { GeometryType . point . value : self . point_schema , GeometryType . multi_point . value : self . multi_point_schema , GeometryType . line_string . value : self . line_string_schema , GeometryType . multi_line_string . value : self . multi_line_string_schema , GeometryType . polygon . value : self . polygon_schema , GeometryType . multi_polygon . value : self . multi_polygon_schema , } def __validator_geometry_type ( self , geo_type : typing . Any ) : if geo_type not in self . object_type_map : raise ma . ValidationError ( { '_schema' : f 'Unknown object class for {geo_type}.' } ) return geo_type def get_instance_schema ( self , data ) : object_type = self . __validator_geometry_type ( data [ 'type' ] ) schema = self . object_type_map [ object_type ] return schema () def load ( self , data : typing . Union [ typing.Mapping[str, typing.Any ] , typing . Iterable [ typing.Mapping[str, typing.Any ] ] , ] , * , many : bool = None , partial : typing . Union [ bool, types.StrSequenceOrSet ] = None , unknown : str = None ) : schema = self . get_instance_schema ( data ) return schema . load ( data , many = many , partial = partial , unknown = unknown ) def loads ( self , json_data : str , * , many : bool = None , partial : typing . Union [ bool, types.StrSequenceOrSet ] = None , unknown : str = None , ** kwargs ) : data = self . opts . render_module . loads ( json_data , ** kwargs ) schema = self . get_instance_schema ( data ) return schema . loads ( json_data , many = many , partial = partial , unknown = unknown )","title":"Attributes"},{"location":"reference/hielen3/geje/geometry/#ancestors-in-mro","text":"hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/geje/geometry/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages line_string_schema multi_line_string_schema multi_point_schema multi_polygon_schema opts point_schema polygon_schema","title":"Class variables"},{"location":"reference/hielen3/geje/geometry/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/geje/geometry/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/geje/geometry/#instance-variables","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen3/geje/geometry/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/geje/geometry/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/geje/geometry/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/geje/geometry/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/geje/geometry/#get_instance_schema","text":"def get_instance_schema ( self , data ) View Source def get_instance_schema ( self , data ) : object_type = self . __validator_geometry_type ( data [ 'type' ] ) schema = self . object_type_map [ object_type ] return schema ()","title":"get_instance_schema"},{"location":"reference/hielen3/geje/geometry/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/geje/geometry/#load","text":"def load ( self , data : Union [ Mapping [ str , Any ], Iterable [ Mapping [ str , Any ]]], * , many : bool = None , partial : Union [ bool , Sequence [ str ], Set [ str ]] = None , unknown : str = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : typing . Union [ typing . Mapping [ str , typing . Any ], typing . Iterable [ typing . Mapping [ str , typing . Any ]], ], * , many : bool = None , partial : typing . Union [ bool , types . StrSequenceOrSet ] = None , unknown : str = None ): schema = self . get_instance_schema ( data ) return schema . load ( data , many = many , partial = partial , unknown = unknown )","title":"load"},{"location":"reference/hielen3/geje/geometry/#loads","text":"def loads ( self , json_data : str , * , many : bool = None , partial : Union [ bool , Sequence [ str ], Set [ str ]] = None , unknown : str = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool = None , partial : typing . Union [ bool , types . StrSequenceOrSet ] = None , unknown : str = None , ** kwargs ): data = self . opts . render_module . loads ( json_data , ** kwargs ) schema = self . get_instance_schema ( data ) return schema . loads ( json_data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/geje/geometry/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/geje/geometry/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/geje/geometry_collection/","text":"Module hielen3.geje.geometry_collection View Source from marshmallow.fields import ( Nested , List , Str , ) from marshmallow.validate import ( OneOf , ) from .object_type import ( GEOMETRY_COLLECTION , ) from ._base import BaseSchema from .geometry import GeometriesSchema class GeometryCollectionSchema ( BaseSchema ): type = Str ( required = True , validate = OneOf ( [ GEOMETRY_COLLECTION ], error = 'Invalid geometry collection type' , ) ) geometries = List ( Nested ( GeometriesSchema ), required = True , ) Variables GEOMETRY_COLLECTION Classes GeometryCollectionSchema class GeometryCollectionSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'} Attributes Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class GeometryCollectionSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ GEOMETRY_COLLECTION ] , error = 'Invalid geometry collection type' , ) ) geometries = List ( Nested ( GeometriesSchema ), required = True , ) Ancestors (in MRO) hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages geometries opts type Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"Geometry Collection"},{"location":"reference/hielen3/geje/geometry_collection/#module-hielen3gejegeometry_collection","text":"View Source from marshmallow.fields import ( Nested , List , Str , ) from marshmallow.validate import ( OneOf , ) from .object_type import ( GEOMETRY_COLLECTION , ) from ._base import BaseSchema from .geometry import GeometriesSchema class GeometryCollectionSchema ( BaseSchema ): type = Str ( required = True , validate = OneOf ( [ GEOMETRY_COLLECTION ], error = 'Invalid geometry collection type' , ) ) geometries = List ( Nested ( GeometriesSchema ), required = True , )","title":"Module hielen3.geje.geometry_collection"},{"location":"reference/hielen3/geje/geometry_collection/#variables","text":"GEOMETRY_COLLECTION","title":"Variables"},{"location":"reference/hielen3/geje/geometry_collection/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/geje/geometry_collection/#geometrycollectionschema","text":"class GeometryCollectionSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'}","title":"GeometryCollectionSchema"},{"location":"reference/hielen3/geje/geometry_collection/#attributes","text":"Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class GeometryCollectionSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ GEOMETRY_COLLECTION ] , error = 'Invalid geometry collection type' , ) ) geometries = List ( Nested ( GeometriesSchema ), required = True , )","title":"Attributes"},{"location":"reference/hielen3/geje/geometry_collection/#ancestors-in-mro","text":"hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/geje/geometry_collection/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages geometries opts type","title":"Class variables"},{"location":"reference/hielen3/geje/geometry_collection/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/geje/geometry_collection/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/geje/geometry_collection/#instance-variables","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen3/geje/geometry_collection/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/geje/geometry_collection/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/geje/geometry_collection/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/geje/geometry_collection/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/geje/geometry_collection/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/geje/geometry_collection/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/geje/geometry_collection/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/geje/geometry_collection/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/geje/geometry_collection/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/geje/line_string/","text":"Module hielen3.geje.line_string View Source from marshmallow.fields import ( List , Str , Number ) from marshmallow.validate import ( OneOf , ) from .object_type import ( LINE_STRING , ) from ._base import ( BaseSchema , ) class LineStringSchema ( BaseSchema ): type = Str ( required = True , validate = OneOf ( [ LINE_STRING ], error = 'Invalid line string type' ) ) coordinates = List ( List ( Number (), required = True ), required = True , ) Variables LINE_STRING Classes LineStringSchema class LineStringSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'} Attributes Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class LineStringSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ LINE_STRING ] , error = 'Invalid line string type' ) ) coordinates = List ( List ( Number (), required = True ), required = True , ) Ancestors (in MRO) hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING coordinates error_messages opts type Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"Line String"},{"location":"reference/hielen3/geje/line_string/#module-hielen3gejeline_string","text":"View Source from marshmallow.fields import ( List , Str , Number ) from marshmallow.validate import ( OneOf , ) from .object_type import ( LINE_STRING , ) from ._base import ( BaseSchema , ) class LineStringSchema ( BaseSchema ): type = Str ( required = True , validate = OneOf ( [ LINE_STRING ], error = 'Invalid line string type' ) ) coordinates = List ( List ( Number (), required = True ), required = True , )","title":"Module hielen3.geje.line_string"},{"location":"reference/hielen3/geje/line_string/#variables","text":"LINE_STRING","title":"Variables"},{"location":"reference/hielen3/geje/line_string/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/geje/line_string/#linestringschema","text":"class LineStringSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'}","title":"LineStringSchema"},{"location":"reference/hielen3/geje/line_string/#attributes","text":"Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class LineStringSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ LINE_STRING ] , error = 'Invalid line string type' ) ) coordinates = List ( List ( Number (), required = True ), required = True , )","title":"Attributes"},{"location":"reference/hielen3/geje/line_string/#ancestors-in-mro","text":"hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/geje/line_string/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING coordinates error_messages opts type","title":"Class variables"},{"location":"reference/hielen3/geje/line_string/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/geje/line_string/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/geje/line_string/#instance-variables","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen3/geje/line_string/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/geje/line_string/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/geje/line_string/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/geje/line_string/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/geje/line_string/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/geje/line_string/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/geje/line_string/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/geje/line_string/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/geje/line_string/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/geje/multi_line_string/","text":"Module hielen3.geje.multi_line_string View Source from marshmallow.fields import ( List , Number , Str , ) from marshmallow.validate import ( OneOf , ) from .object_type import ( MULTI_LINE_STRING , ) from ._base import ( BaseSchema , ) class MultiLineStringSchema ( BaseSchema ): type = Str ( required = True , validate = OneOf ( [ MULTI_LINE_STRING ], error = 'Invalid multi line string string type' ) ) coordinates = List ( List ( List ( Number (), required = True ), required = True ), required = True , ) Variables MULTI_LINE_STRING Classes MultiLineStringSchema class MultiLineStringSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'} Attributes Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class MultiLineStringSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ MULTI_LINE_STRING ] , error = 'Invalid multi line string string type' ) ) coordinates = List ( List ( List ( Number (), required = True ), required = True ), required = True , ) Ancestors (in MRO) hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING coordinates error_messages opts type Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"Multi Line String"},{"location":"reference/hielen3/geje/multi_line_string/#module-hielen3gejemulti_line_string","text":"View Source from marshmallow.fields import ( List , Number , Str , ) from marshmallow.validate import ( OneOf , ) from .object_type import ( MULTI_LINE_STRING , ) from ._base import ( BaseSchema , ) class MultiLineStringSchema ( BaseSchema ): type = Str ( required = True , validate = OneOf ( [ MULTI_LINE_STRING ], error = 'Invalid multi line string string type' ) ) coordinates = List ( List ( List ( Number (), required = True ), required = True ), required = True , )","title":"Module hielen3.geje.multi_line_string"},{"location":"reference/hielen3/geje/multi_line_string/#variables","text":"MULTI_LINE_STRING","title":"Variables"},{"location":"reference/hielen3/geje/multi_line_string/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/geje/multi_line_string/#multilinestringschema","text":"class MultiLineStringSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'}","title":"MultiLineStringSchema"},{"location":"reference/hielen3/geje/multi_line_string/#attributes","text":"Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class MultiLineStringSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ MULTI_LINE_STRING ] , error = 'Invalid multi line string string type' ) ) coordinates = List ( List ( List ( Number (), required = True ), required = True ), required = True , )","title":"Attributes"},{"location":"reference/hielen3/geje/multi_line_string/#ancestors-in-mro","text":"hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/geje/multi_line_string/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING coordinates error_messages opts type","title":"Class variables"},{"location":"reference/hielen3/geje/multi_line_string/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/geje/multi_line_string/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/geje/multi_line_string/#instance-variables","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen3/geje/multi_line_string/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/geje/multi_line_string/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/geje/multi_line_string/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/geje/multi_line_string/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/geje/multi_line_string/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/geje/multi_line_string/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/geje/multi_line_string/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/geje/multi_line_string/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/geje/multi_line_string/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/geje/multi_point/","text":"Module hielen3.geje.multi_point View Source from marshmallow.fields import ( List , Number , Str , ) from marshmallow.validate import ( OneOf , ) from .object_type import ( MULTI_POINT , ) from ._base import ( BaseSchema , ) class MultiPointSchema ( BaseSchema ): type = Str ( required = True , validate = OneOf ( [ MULTI_POINT ], error = 'Invalid multi point type' ) ) coordinates = List ( List ( Number (), required = True ), required = True ) Variables MULTI_POINT Classes MultiPointSchema class MultiPointSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'} Attributes Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class MultiPointSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ MULTI_POINT ] , error = 'Invalid multi point type' ) ) coordinates = List ( List ( Number (), required = True ), required = True ) Ancestors (in MRO) hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING coordinates error_messages opts type Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"Multi Point"},{"location":"reference/hielen3/geje/multi_point/#module-hielen3gejemulti_point","text":"View Source from marshmallow.fields import ( List , Number , Str , ) from marshmallow.validate import ( OneOf , ) from .object_type import ( MULTI_POINT , ) from ._base import ( BaseSchema , ) class MultiPointSchema ( BaseSchema ): type = Str ( required = True , validate = OneOf ( [ MULTI_POINT ], error = 'Invalid multi point type' ) ) coordinates = List ( List ( Number (), required = True ), required = True )","title":"Module hielen3.geje.multi_point"},{"location":"reference/hielen3/geje/multi_point/#variables","text":"MULTI_POINT","title":"Variables"},{"location":"reference/hielen3/geje/multi_point/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/geje/multi_point/#multipointschema","text":"class MultiPointSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'}","title":"MultiPointSchema"},{"location":"reference/hielen3/geje/multi_point/#attributes","text":"Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class MultiPointSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ MULTI_POINT ] , error = 'Invalid multi point type' ) ) coordinates = List ( List ( Number (), required = True ), required = True )","title":"Attributes"},{"location":"reference/hielen3/geje/multi_point/#ancestors-in-mro","text":"hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/geje/multi_point/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING coordinates error_messages opts type","title":"Class variables"},{"location":"reference/hielen3/geje/multi_point/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/geje/multi_point/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/geje/multi_point/#instance-variables","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen3/geje/multi_point/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/geje/multi_point/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/geje/multi_point/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/geje/multi_point/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/geje/multi_point/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/geje/multi_point/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/geje/multi_point/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/geje/multi_point/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/geje/multi_point/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/geje/multi_polygon/","text":"Module hielen3.geje.multi_polygon View Source from marshmallow.fields import ( List , Number , Str , ) from marshmallow.validate import ( OneOf , ) from .object_type import ( MULTI_POLYGON , ) from ._base import ( BaseSchema , ) class MultiPolygonSchema ( BaseSchema ): type = Str ( required = True , validate = OneOf ( [ MULTI_POLYGON ], error = 'Invalid multi polygon type' ) ) coordinates = List ( List ( List ( List ( Number (), required = True ), required = True ), required = True , ), required = True , ) Variables MULTI_POLYGON Classes MultiPolygonSchema class MultiPolygonSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'} Attributes Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class MultiPolygonSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ MULTI_POLYGON ] , error = 'Invalid multi polygon type' ) ) coordinates = List ( List ( List ( List ( Number (), required = True ), required = True ), required = True , ), required = True , ) Ancestors (in MRO) hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING coordinates error_messages opts type Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"Multi Polygon"},{"location":"reference/hielen3/geje/multi_polygon/#module-hielen3gejemulti_polygon","text":"View Source from marshmallow.fields import ( List , Number , Str , ) from marshmallow.validate import ( OneOf , ) from .object_type import ( MULTI_POLYGON , ) from ._base import ( BaseSchema , ) class MultiPolygonSchema ( BaseSchema ): type = Str ( required = True , validate = OneOf ( [ MULTI_POLYGON ], error = 'Invalid multi polygon type' ) ) coordinates = List ( List ( List ( List ( Number (), required = True ), required = True ), required = True , ), required = True , )","title":"Module hielen3.geje.multi_polygon"},{"location":"reference/hielen3/geje/multi_polygon/#variables","text":"MULTI_POLYGON","title":"Variables"},{"location":"reference/hielen3/geje/multi_polygon/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/geje/multi_polygon/#multipolygonschema","text":"class MultiPolygonSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'}","title":"MultiPolygonSchema"},{"location":"reference/hielen3/geje/multi_polygon/#attributes","text":"Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class MultiPolygonSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ MULTI_POLYGON ] , error = 'Invalid multi polygon type' ) ) coordinates = List ( List ( List ( List ( Number (), required = True ), required = True ), required = True , ), required = True , )","title":"Attributes"},{"location":"reference/hielen3/geje/multi_polygon/#ancestors-in-mro","text":"hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/geje/multi_polygon/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING coordinates error_messages opts type","title":"Class variables"},{"location":"reference/hielen3/geje/multi_polygon/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/geje/multi_polygon/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/geje/multi_polygon/#instance-variables","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen3/geje/multi_polygon/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/geje/multi_polygon/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/geje/multi_polygon/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/geje/multi_polygon/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/geje/multi_polygon/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/geje/multi_polygon/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/geje/multi_polygon/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/geje/multi_polygon/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/geje/multi_polygon/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/geje/object_type/","text":"Module hielen3.geje.object_type View Source from enum import Enum \"\"\" https://www.rfc-editor.org/rfc/rfc7946.html#section-1.4 \"\"\" POINT = 'Point' MULTI_POINT = 'MultiPoint' LINE_STRING = 'LineString' MULTI_LINE_STRING = 'MultiLineString' POLYGON = 'Polygon' MULTI_POLYGON = 'MultiPolygon' GEOMETRY_COLLECTION = 'GeometryCollection' class GeometryType ( Enum ): \"\"\" Inside this document, the term \"geometry type\" refers to seven case-sensitive strings: \"Point\", \"MultiPoint\", \"LineString\", \"MultiLineString\", \"Polygon\", \"MultiPolygon\", and \"GeometryCollection\". \"\"\" point = POINT multi_point = MULTI_POINT line_string = LINE_STRING multi_line_string = MULTI_LINE_STRING polygon = POLYGON multi_polygon = MULTI_POLYGON geometry_collection = GEOMETRY_COLLECTION FEATURE = 'Feature' FEATURE_COLLECTION = 'FeatureCollection' class GeoJSONType ( Enum ): \"\"\" As another shorthand notation, the term \"GeoJSON types\" refers to nine case-sensitive strings: \"Feature\", \"FeatureCollection\", and the geometry types listed above. \"\"\" point = POINT multi_point = MULTI_POINT line_string = LINE_STRING multi_line_string = MULTI_LINE_STRING polygon = POLYGON multi_polygon = MULTI_POLYGON geometry_collection = GEOMETRY_COLLECTION feature = FEATURE feature_collection = FEATURE_COLLECTION Variables FEATURE FEATURE_COLLECTION GEOMETRY_COLLECTION LINE_STRING MULTI_LINE_STRING MULTI_POINT MULTI_POLYGON POINT POLYGON Classes GeoJSONType class GeoJSONType ( / , * args , ** kwargs ) As another shorthand notation, the term \"GeoJSON types\" refers to nine case-sensitive strings: \"Feature\", \"FeatureCollection\", and the geometry types listed above. View Source class GeoJSONType ( Enum ): \"\"\" As another shorthand notation, the term \" GeoJSON types \" refers to nine case-sensitive strings: \" Feature \", \" FeatureCollection \", and the geometry types listed above. \"\"\" point = POINT multi_point = MULTI_POINT line_string = LINE_STRING multi_line_string = MULTI_LINE_STRING polygon = POLYGON multi_polygon = MULTI_POLYGON geometry_collection = GEOMETRY_COLLECTION feature = FEATURE feature_collection = FEATURE_COLLECTION Ancestors (in MRO) enum.Enum Class variables feature feature_collection geometry_collection line_string multi_line_string multi_point multi_polygon name point polygon value GeometryType class GeometryType ( / , * args , ** kwargs ) Inside this document, the term \"geometry type\" refers to seven case-sensitive strings: \"Point\", \"MultiPoint\", \"LineString\", \"MultiLineString\", \"Polygon\", \"MultiPolygon\", and \"GeometryCollection\". View Source class GeometryType ( Enum ): \"\"\" Inside this document, the term \" geometry type \" refers to seven case-sensitive strings: \" Point \", \" MultiPoint \", \" LineString \", \" MultiLineString \", \" Polygon \", \" MultiPolygon \", and \" GeometryCollection \". \"\"\" point = POINT multi_point = MULTI_POINT line_string = LINE_STRING multi_line_string = MULTI_LINE_STRING polygon = POLYGON multi_polygon = MULTI_POLYGON geometry_collection = GEOMETRY_COLLECTION Ancestors (in MRO) enum.Enum Class variables geometry_collection line_string multi_line_string multi_point multi_polygon name point polygon value","title":"Object Type"},{"location":"reference/hielen3/geje/object_type/#module-hielen3gejeobject_type","text":"View Source from enum import Enum \"\"\" https://www.rfc-editor.org/rfc/rfc7946.html#section-1.4 \"\"\" POINT = 'Point' MULTI_POINT = 'MultiPoint' LINE_STRING = 'LineString' MULTI_LINE_STRING = 'MultiLineString' POLYGON = 'Polygon' MULTI_POLYGON = 'MultiPolygon' GEOMETRY_COLLECTION = 'GeometryCollection' class GeometryType ( Enum ): \"\"\" Inside this document, the term \"geometry type\" refers to seven case-sensitive strings: \"Point\", \"MultiPoint\", \"LineString\", \"MultiLineString\", \"Polygon\", \"MultiPolygon\", and \"GeometryCollection\". \"\"\" point = POINT multi_point = MULTI_POINT line_string = LINE_STRING multi_line_string = MULTI_LINE_STRING polygon = POLYGON multi_polygon = MULTI_POLYGON geometry_collection = GEOMETRY_COLLECTION FEATURE = 'Feature' FEATURE_COLLECTION = 'FeatureCollection' class GeoJSONType ( Enum ): \"\"\" As another shorthand notation, the term \"GeoJSON types\" refers to nine case-sensitive strings: \"Feature\", \"FeatureCollection\", and the geometry types listed above. \"\"\" point = POINT multi_point = MULTI_POINT line_string = LINE_STRING multi_line_string = MULTI_LINE_STRING polygon = POLYGON multi_polygon = MULTI_POLYGON geometry_collection = GEOMETRY_COLLECTION feature = FEATURE feature_collection = FEATURE_COLLECTION","title":"Module hielen3.geje.object_type"},{"location":"reference/hielen3/geje/object_type/#variables","text":"FEATURE FEATURE_COLLECTION GEOMETRY_COLLECTION LINE_STRING MULTI_LINE_STRING MULTI_POINT MULTI_POLYGON POINT POLYGON","title":"Variables"},{"location":"reference/hielen3/geje/object_type/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/geje/object_type/#geojsontype","text":"class GeoJSONType ( / , * args , ** kwargs ) As another shorthand notation, the term \"GeoJSON types\" refers to nine case-sensitive strings: \"Feature\", \"FeatureCollection\", and the geometry types listed above. View Source class GeoJSONType ( Enum ): \"\"\" As another shorthand notation, the term \" GeoJSON types \" refers to nine case-sensitive strings: \" Feature \", \" FeatureCollection \", and the geometry types listed above. \"\"\" point = POINT multi_point = MULTI_POINT line_string = LINE_STRING multi_line_string = MULTI_LINE_STRING polygon = POLYGON multi_polygon = MULTI_POLYGON geometry_collection = GEOMETRY_COLLECTION feature = FEATURE feature_collection = FEATURE_COLLECTION","title":"GeoJSONType"},{"location":"reference/hielen3/geje/object_type/#ancestors-in-mro","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/geje/object_type/#class-variables","text":"feature feature_collection geometry_collection line_string multi_line_string multi_point multi_polygon name point polygon value","title":"Class variables"},{"location":"reference/hielen3/geje/object_type/#geometrytype","text":"class GeometryType ( / , * args , ** kwargs ) Inside this document, the term \"geometry type\" refers to seven case-sensitive strings: \"Point\", \"MultiPoint\", \"LineString\", \"MultiLineString\", \"Polygon\", \"MultiPolygon\", and \"GeometryCollection\". View Source class GeometryType ( Enum ): \"\"\" Inside this document, the term \" geometry type \" refers to seven case-sensitive strings: \" Point \", \" MultiPoint \", \" LineString \", \" MultiLineString \", \" Polygon \", \" MultiPolygon \", and \" GeometryCollection \". \"\"\" point = POINT multi_point = MULTI_POINT line_string = LINE_STRING multi_line_string = MULTI_LINE_STRING polygon = POLYGON multi_polygon = MULTI_POLYGON geometry_collection = GEOMETRY_COLLECTION","title":"GeometryType"},{"location":"reference/hielen3/geje/object_type/#ancestors-in-mro_1","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/geje/object_type/#class-variables_1","text":"geometry_collection line_string multi_line_string multi_point multi_polygon name point polygon value","title":"Class variables"},{"location":"reference/hielen3/geje/point/","text":"Module hielen3.geje.point View Source from marshmallow.fields import ( List , Str , Number ) from marshmallow.validate import ( OneOf , ) from .object_type import ( POINT , ) from ._base import ( BaseSchema , ) class PointSchema ( BaseSchema ): type = Str ( required = True , validate = OneOf ( [ POINT ], error = 'Invalid point type' ) ) coordinates = List ( Number (), required = True ) Variables POINT Classes PointSchema class PointSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'} Attributes Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class PointSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ POINT ] , error = 'Invalid point type' ) ) coordinates = List ( Number (), required = True ) Ancestors (in MRO) hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING coordinates error_messages opts type Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"Point"},{"location":"reference/hielen3/geje/point/#module-hielen3gejepoint","text":"View Source from marshmallow.fields import ( List , Str , Number ) from marshmallow.validate import ( OneOf , ) from .object_type import ( POINT , ) from ._base import ( BaseSchema , ) class PointSchema ( BaseSchema ): type = Str ( required = True , validate = OneOf ( [ POINT ], error = 'Invalid point type' ) ) coordinates = List ( Number (), required = True )","title":"Module hielen3.geje.point"},{"location":"reference/hielen3/geje/point/#variables","text":"POINT","title":"Variables"},{"location":"reference/hielen3/geje/point/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/geje/point/#pointschema","text":"class PointSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'}","title":"PointSchema"},{"location":"reference/hielen3/geje/point/#attributes","text":"Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class PointSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ POINT ] , error = 'Invalid point type' ) ) coordinates = List ( Number (), required = True )","title":"Attributes"},{"location":"reference/hielen3/geje/point/#ancestors-in-mro","text":"hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/geje/point/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING coordinates error_messages opts type","title":"Class variables"},{"location":"reference/hielen3/geje/point/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/geje/point/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/geje/point/#instance-variables","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen3/geje/point/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/geje/point/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/geje/point/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/geje/point/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/geje/point/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/geje/point/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/geje/point/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/geje/point/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/geje/point/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/geje/polygon/","text":"Module hielen3.geje.polygon View Source from marshmallow.fields import ( List , Str , Number ) from marshmallow.validate import ( OneOf , ) from .object_type import ( POLYGON , ) from ._base import ( BaseSchema , ) class PolygonSchema ( BaseSchema ): type = Str ( required = True , validate = OneOf ( [ POLYGON ], error = 'Invalid polygon type' ) ) coordinates = List ( List ( List ( Number (), required = True ), required = True ), required = True , ) Variables POLYGON Classes PolygonSchema class PolygonSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'} Attributes Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class PolygonSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ POLYGON ] , error = 'Invalid polygon type' ) ) coordinates = List ( List ( List ( Number (), required = True ), required = True ), required = True , ) Ancestors (in MRO) hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING coordinates error_messages opts type Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"Polygon"},{"location":"reference/hielen3/geje/polygon/#module-hielen3gejepolygon","text":"View Source from marshmallow.fields import ( List , Str , Number ) from marshmallow.validate import ( OneOf , ) from .object_type import ( POLYGON , ) from ._base import ( BaseSchema , ) class PolygonSchema ( BaseSchema ): type = Str ( required = True , validate = OneOf ( [ POLYGON ], error = 'Invalid polygon type' ) ) coordinates = List ( List ( List ( Number (), required = True ), required = True ), required = True , )","title":"Module hielen3.geje.polygon"},{"location":"reference/hielen3/geje/polygon/#variables","text":"POLYGON","title":"Variables"},{"location":"reference/hielen3/geje/polygon/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/geje/polygon/#polygonschema","text":"class PolygonSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'}","title":"PolygonSchema"},{"location":"reference/hielen3/geje/polygon/#attributes","text":"Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class PolygonSchema ( BaseSchema ) : type = Str ( required = True , validate = OneOf ( [ POLYGON ] , error = 'Invalid polygon type' ) ) coordinates = List ( List ( List ( Number (), required = True ), required = True ), required = True , )","title":"Attributes"},{"location":"reference/hielen3/geje/polygon/#ancestors-in-mro","text":"hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/geje/polygon/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING coordinates error_messages opts type","title":"Class variables"},{"location":"reference/hielen3/geje/polygon/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/geje/polygon/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/geje/polygon/#instance-variables","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen3/geje/polygon/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/geje/polygon/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/geje/polygon/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/geje/polygon/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/geje/polygon/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/geje/polygon/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/geje/polygon/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/geje/polygon/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/geje/polygon/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/geje/property/","text":"Module hielen3.geje.property View Source from ._base import BaseSchema class PropertiesSchema ( BaseSchema ): pass Classes PropertiesSchema class PropertiesSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'} Attributes Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class PropertiesSchema ( BaseSchema ): pass Ancestors (in MRO) hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages opts Static methods from_dict def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass load def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None validate def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"Property"},{"location":"reference/hielen3/geje/property/#module-hielen3gejeproperty","text":"View Source from ._base import BaseSchema class PropertiesSchema ( BaseSchema ): pass","title":"Module hielen3.geje.property"},{"location":"reference/hielen3/geje/property/#classes","text":"","title":"Classes"},{"location":"reference/hielen3/geje/property/#propertiesschema","text":"class PropertiesSchema ( * , only : 'types.StrSequenceOrSet | None' = None , exclude : 'types.StrSequenceOrSet' = (), many : 'bool' = False , context : 'dict | None' = None , load_only : 'types.StrSequenceOrSet' = (), dump_only : 'types.StrSequenceOrSet' = (), partial : 'bool | types.StrSequenceOrSet' = False , unknown : 'str | None' = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'}","title":"PropertiesSchema"},{"location":"reference/hielen3/geje/property/#attributes","text":"Name Type Description Default only None Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. None exclude None Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. None many None Should be set to True if obj is a collection so that the object will be serialized to a list. None context None Optional context passed to :class: fields.Method and :class: fields.Function fields. None load_only None Fields to skip during serialization (write-only fields) None dump_only None Fields to skip during deserialization (read-only fields) None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. None View Source class PropertiesSchema ( BaseSchema ): pass","title":"Attributes"},{"location":"reference/hielen3/geje/property/#ancestors-in-mro","text":"hielen3.geje._base.BaseSchema marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen3/geje/property/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages opts","title":"Class variables"},{"location":"reference/hielen3/geje/property/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen3/geje/property/#from_dict","text":"def from_dict ( fields : 'dict[str, ma_fields.Field | type]' , * , name : 'str' = 'GeneratedSchema' ) -> 'type' Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. Parameters: Name Type Description Default fields dict Dictionary mapping field names to field instances. None name str Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 None View Source @classmethod def from_dict ( cls , fields : dict [ str , ma_fields . Field | type ], * , name : str = \"GeneratedSchema\" , ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen3/geje/property/#instance-variables","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen3/geje/property/#methods","text":"","title":"Methods"},{"location":"reference/hielen3/geje/property/#dump","text":"def dump ( self , obj : 'typing.Any' , * , many : 'bool | None' = None ) Serialize an object to native Python data types according to this Schema's fields. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : bool | None = None ) : \" \"\" Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: Serialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\" \" many = self . many if many is None else bool ( many ) if self . _has_processors ( PRE_DUMP ) : processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ) : result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen3/geje/property/#dumps","text":"def dumps ( self , obj : 'typing.Any' , * args , many : 'bool | None' = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. Parameters: Name Type Description Default obj None The object to serialize. None many None Whether to serialize obj as a collection. If None , the value for self.many is used. None Returns: Type Description None A json string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : bool | None = None , ** kwargs ) : \" \"\" Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\" \" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen3/geje/property/#get_attribute","text":"def get_attribute ( self , obj : 'typing.Any' , attr : 'str' , default : 'typing.Any' ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ) : \" \"\" Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\" \" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen3/geje/property/#handle_error","text":"def handle_error ( self , error : 'ValidationError' , data : 'typing.Any' , * , many : 'bool' , ** kwargs ) Custom error handler function for the schema. Parameters: Name Type Description Default error None The ValidationError raised during (de)serialization. None data None The original input data. None many None Value of many on dump or load. None partial None Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. None View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ) : \" \"\" Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\" \" pass","title":"handle_error"},{"location":"reference/hielen3/geje/property/#load","text":"def load ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None ) Deserialize a data structure to an object defined by this Schema's fields. Parameters: Name Type Description Default data None The data to deserialize. None many None Whether to deserialize data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ) : \" \"\" Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen3/geje/property/#loads","text":"def loads ( self , json_data : 'str' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None , unknown : 'str | None' = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. Parameters: Name Type Description Default json_data None A JSON string of the data to deserialize. None many None Whether to deserialize obj as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None unknown None Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. None Returns: Type Description None Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , unknown : str | None = None , ** kwargs , ) : \" \"\" Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\" \" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen3/geje/property/#on_bind_field","text":"def on_bind_field ( self , field_name : 'str' , field_obj : 'ma_fields.Field' ) -> 'None' Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \" \"\" Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\" \" return None","title":"on_bind_field"},{"location":"reference/hielen3/geje/property/#validate","text":"def validate ( self , data : 'typing.Mapping[str, typing.Any] | typing.Iterable[typing.Mapping[str, typing.Any]]' , * , many : 'bool | None' = None , partial : 'bool | types.StrSequenceOrSet | None' = None ) -> 'dict[str, list[str]]' Validate data against the schema, returning a dictionary of validation errors. Parameters: Name Type Description Default data None The data to validate. None many None Whether to validate data as a collection. If None , the value for self.many is used. None partial None Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. None Returns: Type Description None A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : ( typing . Mapping [ str , typing . Any ] | typing . Iterable [ typing . Mapping [ str , typing . Any ]] ), * , many : bool | None = None , partial : bool | types . StrSequenceOrSet | None = None , ) -> dict [ str , list [ str ]] : \" \"\" Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\" \" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]] , exc . messages ) return {}","title":"validate"},{"location":"reference/hielen3/tools/","text":"Module hielen3.tools Sub-modules hielen3.tools.calc hielen3.tools.hls_facility hielen3.tools.hls_facility_good hielen3.tools.hls_facility_new hielen3.tools.hls_facility_old","title":"Index"},{"location":"reference/hielen3/tools/#module-hielen3tools","text":"","title":"Module hielen3.tools"},{"location":"reference/hielen3/tools/#sub-modules","text":"hielen3.tools.calc hielen3.tools.hls_facility hielen3.tools.hls_facility_good hielen3.tools.hls_facility_new hielen3.tools.hls_facility_old","title":"Sub-modules"},{"location":"reference/hielen3/tools/calc/","text":"Module hielen3.tools.calc View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 #!/usr/bin/env python # coding=utf-8 __name__ = \"hielen3.series.calc\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"hub for hielen calculations\" __license__ = \"MIT\" __uri__ = \"\" from pandas import Series , Timedelta , DataFrame from numpy import sin , radians , mean , std , nan #### CUSTOM LIBRARY #### def poly_trans ( S0 , ** kwargs ): def _parse ( k , w ): k = k . replace ( \"E\" , \"\" ) . replace ( \"e\" , \"\" ) return f \" { w } *S0** { k } \" operator = \"+\" . join ( _parse ( * x ) for x in kwargs . items () if x [ 0 ][ 0 ] in [ \"E\" , \"e\" ]) return eval ( operator ) def poly_trans2 ( S0 , * args ): if args . __len__ () > 0 : __res__ = args [ 0 ] * S0 ** 0 else : return S0 try : for i in range ( 1 , args . __len__ ()): try : __res__ += args [ i ] * S0 ** i except Exception : pass except Exception : pass return __res__ def slope ( S0 , unit = \"\u00b0\" , radius = 1 ): if unit == \"\u00b0\" : S0 = radians ( S0 ) unit = \"rad\" if unit == \"rad\" : S0 = sin ( S0 ) return S0 * radius def aligned ( func ): def wrap_align ( left , right ): try : left = left . copy () right = right . copy () try : left . columns = list ( range ( len ( left . columns ))) except AttributeError : left . name = 0 try : right . columns = list ( range ( len ( right . columns ))) except AttributeError : right . name = 0 left , right = left . align ( right , axis = 0 , copy = False ) mask = left . notna ()[ 0 ] right = right . fillna ( method = \"pad\" ) return func ( left [ mask ], right [ mask ]) except Exception as e : return func ( left , right ) return wrap_align @aligned def reference ( s_main , s_ref ): pass @aligned def add ( left , right ): try : right = right . fillna ( 0 ) except Exception as e : pass return left + right def sub ( left , right ): return add ( left , - 1 * right ) @aligned def mult ( left , right ): try : right = right . fillna ( 0 ) except Exception as e : pass return left * right def filter ( b , sigma = 3 , window = 50 , center = False , min_periods = 1 ): d = abs ( b - b . rolling ( window = window , center = center , min_periods = min_periods ) . apply ( mean )) stdv = abs ( b . rolling ( window = window , center = center , min_periods = min_periods ) . apply ( std )) return b [ d < sigma * stdv ] def threshold ( S0 , limit = 0 , how = '<' , action = 'clean' ): \"\"\" action: ['clean','drop','signal'] \"\"\" out = eval ( f \"S0 { how } { limit } \" ) if action == 'signal' : return out if action == 'drop' : S1 = S0 [ out ] . copy () return S1 if action == 'clean' : S1 = S0 . copy () S1 [ out ] = nan return S1 def instant_velocity ( S0 , time_unit_denom = 'hours' ): if not isinstance ( time_unit_denom , Timedelta ): time_unit_denom = Timedelta ( f \"1 { time_unit_denom } \" ) time_unit_denom = time_unit_denom . total_seconds () timestoman = Series ( S0 . index . values , index = S0 . index , dtype = 'datetime64[ns]' ) seconds = ( timestoman - timestoman . shift ( 1 )) . apply ( lambda x : x . total_seconds ()) return ( S0 / seconds * time_unit_denom ) . replace ( nan , 0 ) def int_or_str ( value ): try : return int ( value ) except ValueError : return value VERSION = tuple ( map ( int_or_str , __version__ . split ( \".\" ))) __all__ = [ \"poly_trans\" , \"add\" , \"sub\" , \"slope\" , \"filter\" , \"instant_velocity\" ] # coding: utf-8 Functions add def add ( left , right ) View Source def wrap_align ( left , right ) : try : left = left . copy () right = right . copy () try : left . columns = list ( range ( len ( left . columns ))) except AttributeError : left . name = 0 try : right . columns = list ( range ( len ( right . columns ))) except AttributeError : right . name = 0 left , right = left . align ( right , axis = 0 , copy = False ) mask = left . notna () [ 0 ] right = right . fillna ( method = \"pad\" ) return func ( left [ mask ] , right [ mask ] ) except Exception as e : return func ( left , right ) filter def filter ( b , sigma = 3 , window = 50 , center = False , min_periods = 1 ) View Source def filter ( b , sigma = 3 , window = 50 , center = False , min_periods = 1 ) : d = abs ( b - b . rolling ( window = window , center = center , min_periods = min_periods ) . apply ( mean )) stdv = abs ( b . rolling ( window = window , center = center , min_periods = min_periods ) . apply ( std )) return b [ d < sigma * stdv ] instant_velocity def instant_velocity ( S0 , time_unit_denom = 'hours' ) View Source def instant_velocity ( S0 , time_unit_denom = 'hours' ) : if not isinstance ( time_unit_denom , Timedelta ) : time_unit_denom = Timedelta ( f \"1 {time_unit_denom}\" ) time_unit_denom = time_unit_denom . total_seconds () timestoman = Series ( S0 . index . values , index = S0 . index , dtype = 'datetime64[ns]' ) seconds = ( timestoman - timestoman . shift ( 1 )). apply ( lambda x : x . total_seconds ()) return ( S0 / seconds * time_unit_denom ). replace ( nan , 0 ) poly_trans def poly_trans ( S0 , ** kwargs ) View Source def poly_trans ( S0 , ** kwargs ) : def _parse ( k , w ) : k = k . replace ( \"E\" , \"\" ) . replace ( \"e\" , \"\" ) return f \"{w}*S0**{k}\" operator = \"+\" . join ( _parse ( * x ) for x in kwargs . items () if x [ 0 ][ 0 ] in [ \"E\" , \"e\" ] ) return eval ( operator ) slope def slope ( S0 , unit = '\u00b0' , radius = 1 ) View Source def slope ( S0 , unit = \"\u00b0\" , radius = 1 ) : if unit == \"\u00b0\" : S0 = radians ( S0 ) unit = \"rad\" if unit == \"rad\" : S0 = sin ( S0 ) return S0 * radius sub def sub ( left , right ) View Source def sub ( left , right ) : return add ( left , - 1 * right )","title":"Calc"},{"location":"reference/hielen3/tools/calc/#module-hielen3toolscalc","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 #!/usr/bin/env python # coding=utf-8 __name__ = \"hielen3.series.calc\" __version__ = \"0.0.1\" __author__ = \"Alessandro Modesti\" __email__ = \"it@img-srl.com\" __description__ = \"hub for hielen calculations\" __license__ = \"MIT\" __uri__ = \"\" from pandas import Series , Timedelta , DataFrame from numpy import sin , radians , mean , std , nan #### CUSTOM LIBRARY #### def poly_trans ( S0 , ** kwargs ): def _parse ( k , w ): k = k . replace ( \"E\" , \"\" ) . replace ( \"e\" , \"\" ) return f \" { w } *S0** { k } \" operator = \"+\" . join ( _parse ( * x ) for x in kwargs . items () if x [ 0 ][ 0 ] in [ \"E\" , \"e\" ]) return eval ( operator ) def poly_trans2 ( S0 , * args ): if args . __len__ () > 0 : __res__ = args [ 0 ] * S0 ** 0 else : return S0 try : for i in range ( 1 , args . __len__ ()): try : __res__ += args [ i ] * S0 ** i except Exception : pass except Exception : pass return __res__ def slope ( S0 , unit = \"\u00b0\" , radius = 1 ): if unit == \"\u00b0\" : S0 = radians ( S0 ) unit = \"rad\" if unit == \"rad\" : S0 = sin ( S0 ) return S0 * radius def aligned ( func ): def wrap_align ( left , right ): try : left = left . copy () right = right . copy () try : left . columns = list ( range ( len ( left . columns ))) except AttributeError : left . name = 0 try : right . columns = list ( range ( len ( right . columns ))) except AttributeError : right . name = 0 left , right = left . align ( right , axis = 0 , copy = False ) mask = left . notna ()[ 0 ] right = right . fillna ( method = \"pad\" ) return func ( left [ mask ], right [ mask ]) except Exception as e : return func ( left , right ) return wrap_align @aligned def reference ( s_main , s_ref ): pass @aligned def add ( left , right ): try : right = right . fillna ( 0 ) except Exception as e : pass return left + right def sub ( left , right ): return add ( left , - 1 * right ) @aligned def mult ( left , right ): try : right = right . fillna ( 0 ) except Exception as e : pass return left * right def filter ( b , sigma = 3 , window = 50 , center = False , min_periods = 1 ): d = abs ( b - b . rolling ( window = window , center = center , min_periods = min_periods ) . apply ( mean )) stdv = abs ( b . rolling ( window = window , center = center , min_periods = min_periods ) . apply ( std )) return b [ d < sigma * stdv ] def threshold ( S0 , limit = 0 , how = '<' , action = 'clean' ): \"\"\" action: ['clean','drop','signal'] \"\"\" out = eval ( f \"S0 { how } { limit } \" ) if action == 'signal' : return out if action == 'drop' : S1 = S0 [ out ] . copy () return S1 if action == 'clean' : S1 = S0 . copy () S1 [ out ] = nan return S1 def instant_velocity ( S0 , time_unit_denom = 'hours' ): if not isinstance ( time_unit_denom , Timedelta ): time_unit_denom = Timedelta ( f \"1 { time_unit_denom } \" ) time_unit_denom = time_unit_denom . total_seconds () timestoman = Series ( S0 . index . values , index = S0 . index , dtype = 'datetime64[ns]' ) seconds = ( timestoman - timestoman . shift ( 1 )) . apply ( lambda x : x . total_seconds ()) return ( S0 / seconds * time_unit_denom ) . replace ( nan , 0 ) def int_or_str ( value ): try : return int ( value ) except ValueError : return value VERSION = tuple ( map ( int_or_str , __version__ . split ( \".\" ))) __all__ = [ \"poly_trans\" , \"add\" , \"sub\" , \"slope\" , \"filter\" , \"instant_velocity\" ] # coding: utf-8","title":"Module hielen3.tools.calc"},{"location":"reference/hielen3/tools/calc/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/tools/calc/#add","text":"def add ( left , right ) View Source def wrap_align ( left , right ) : try : left = left . copy () right = right . copy () try : left . columns = list ( range ( len ( left . columns ))) except AttributeError : left . name = 0 try : right . columns = list ( range ( len ( right . columns ))) except AttributeError : right . name = 0 left , right = left . align ( right , axis = 0 , copy = False ) mask = left . notna () [ 0 ] right = right . fillna ( method = \"pad\" ) return func ( left [ mask ] , right [ mask ] ) except Exception as e : return func ( left , right )","title":"add"},{"location":"reference/hielen3/tools/calc/#filter","text":"def filter ( b , sigma = 3 , window = 50 , center = False , min_periods = 1 ) View Source def filter ( b , sigma = 3 , window = 50 , center = False , min_periods = 1 ) : d = abs ( b - b . rolling ( window = window , center = center , min_periods = min_periods ) . apply ( mean )) stdv = abs ( b . rolling ( window = window , center = center , min_periods = min_periods ) . apply ( std )) return b [ d < sigma * stdv ]","title":"filter"},{"location":"reference/hielen3/tools/calc/#instant_velocity","text":"def instant_velocity ( S0 , time_unit_denom = 'hours' ) View Source def instant_velocity ( S0 , time_unit_denom = 'hours' ) : if not isinstance ( time_unit_denom , Timedelta ) : time_unit_denom = Timedelta ( f \"1 {time_unit_denom}\" ) time_unit_denom = time_unit_denom . total_seconds () timestoman = Series ( S0 . index . values , index = S0 . index , dtype = 'datetime64[ns]' ) seconds = ( timestoman - timestoman . shift ( 1 )). apply ( lambda x : x . total_seconds ()) return ( S0 / seconds * time_unit_denom ). replace ( nan , 0 )","title":"instant_velocity"},{"location":"reference/hielen3/tools/calc/#poly_trans","text":"def poly_trans ( S0 , ** kwargs ) View Source def poly_trans ( S0 , ** kwargs ) : def _parse ( k , w ) : k = k . replace ( \"E\" , \"\" ) . replace ( \"e\" , \"\" ) return f \"{w}*S0**{k}\" operator = \"+\" . join ( _parse ( * x ) for x in kwargs . items () if x [ 0 ][ 0 ] in [ \"E\" , \"e\" ] ) return eval ( operator )","title":"poly_trans"},{"location":"reference/hielen3/tools/calc/#slope","text":"def slope ( S0 , unit = '\u00b0' , radius = 1 ) View Source def slope ( S0 , unit = \"\u00b0\" , radius = 1 ) : if unit == \"\u00b0\" : S0 = radians ( S0 ) unit = \"rad\" if unit == \"rad\" : S0 = sin ( S0 ) return S0 * radius","title":"slope"},{"location":"reference/hielen3/tools/calc/#sub","text":"def sub ( left , right ) View Source def sub ( left , right ) : return add ( left , - 1 * right )","title":"sub"},{"location":"reference/hielen3/tools/hls_facility/","text":"Module hielen3.tools.hls_facility View Source # coding: utf-8 import boto3 from boto3 import Session from pycognito import Cognito import requests from time import sleep from random import random from hielen3 import db , conf from hielen3.utils import uuid , dataframe2jsonizabledict from numpy import datetime64 , timedelta64 import json from threading import Thread def manage_stream ( resource , timeout = 10 , times = 20 , destroytime = 120 ): u = Cognito ( ** conf [ \"aws\" ][ \"pool\" ]) u . authenticate ( conf [ \"aws\" ][ \"pwd\" ]) headers = { \"Authorization\" : u . id_token } url_creds = \"https://api.wsn-cloud.com/api/portal/get_stream_viewer_creds\" res = requests . get ( url = url_creds , headers = headers ) try : if res . status_code in [ 200 , 409 ]: creds = res . json () creds = { 'aws_access_key_id' : creds [ 'access_id' ], 'aws_secret_access_key' : creds [ 'secret_key' ], \"region_name\" : \"eu-west-1\" } url_cmmnd = \"https://api.wsn-cloud.com/api/portal/post_command\" data = { \"wsn_sn\" : resource , \"command_code\" : 8 , \"command_args\" :[ \"1\" ]} res = requests . post ( url = url_cmmnd , json = data , headers = headers ) session = Session ( ** creds ) else : raise Exception ( 'wrong code' ) endpoint = session . client ( 'kinesisvideo' ) . get_data_endpoint ( StreamName = f 'stream- { resource } ' , APIName = 'GET_HLS_STREAMING_SESSION_URL' )[ 'DataEndpoint' ] client_kvac = session . client ( 'kinesis-video-archived-media' , endpoint_url = endpoint ) except Exception as e : db [ 'resources_queues' ][ resource , uuid ()] = { \"status\" : \"GONE\" , \"timestamp\" : str ( datetime64 ( \"now\" )), \"url\" : None } return req = { \"StreamName\" : f \"stream- { resource } \" , \"PlaybackMode\" : \"LIVE\" , \"HLSFragmentSelector\" : { \"FragmentSelectorType\" : \"PRODUCER_TIMESTAMP\" }, \"ContainerFormat\" : \"FRAGMENTED_MP4\" , \"DiscontinuityMode\" : \"ALWAYS\" , \"DisplayFragmentTimestamp\" : \"ALWAYS\" , } for i in range ( times ): print ( f \"resource: { resource } , time: { timeout * i } secs\" ) try : out = dataframe2jsonizabledict ( db [ 'resources_queues' ][ resource ]) out [ \"status\" ] = \"AVAILABLE\" out [ \"timestamp\" ] = str ( datetime64 ( \"now\" )) except KeyError : return try : out [ \"url\" ] = client_kvac . get_hls_streaming_session_url ( ** req )[ 'HLSStreamingSessionURL' ] db [ 'resources_queues' ][ resource ] = out try : sleep ( destroytime ) except Exception : pass finally : out [ \"status\" ] = \"GONE\" print ( out [ \"status\" ]) db [ 'resources_queues' ][ resource ] = out return except KeyError as e : return except Exception as e : out [ \"status\" ] = \"PENDING\" print ( out [ \"status\" ]) db [ 'resources_queues' ][ resource ] = out print ( out [ \"status\" ]) sleep ( timeout ) try : out = dataframe2jsonizabledict ( db [ 'resources_queues' ][ resource ]) out [ \"status\" ] = \"TIMEOUT\" print ( out [ \"status\" ]) db [ 'resources_queues' ][ resource ] = out except KeyError : pass def start_stream ( resource = None ): out = {} if resource is None : raise KeyError ( 'No resource' ) try : out = dataframe2jsonizabledict ( db [ 'resources_queues' ][ resource ]) except KeyError as e : out = None nowtime = datetime64 ( \"now\" ) #if out is None or out['status'] in [\"TIMEOUT\",\"GONE\",\"INIT\"]: try : if out [ 'status' ] in [ \"TIMEOUT\" , \"GONE\" ]: raise Exception if ( nowtime - datetime64 ( out [ \"timestamp\" ]) ) < timedelta64 ( 1200 ): return out except Exception as e : pass try : db [ 'resources_queues' ] . pop ([ out [ 'resource' ], out [ 'queue' ]]) except KeyError : pass except TypeError : pass try : db [ 'resources_queues' ][ resource , uuid ()] = { \"status\" : \"INIT\" , \"timestamp\" : str ( nowtime ), \"url\" : None } out = dataframe2jsonizabledict ( db [ 'resources_queues' ][ resource ]) Thread ( target = manage_stream , args = ( resource ,), daemon = True ) . start () except Exception as e : pass return out def get_stream ( queue ): out = {} outcode = 200 if queue is None : outcode = 400 else : try : out = db [ 'resources_queues' ][:, queue ] except KeyError as e : outcode = 404 return out , outcode Variables conf db Functions get_stream def get_stream ( queue ) View Source def get_stream ( queue ) : out = {} outcode = 200 if queue is None : outcode = 400 else : try : out = db [ 'resources_queues' ][:, queue ] except KeyError as e : outcode = 404 return out , outcode manage_stream def manage_stream ( resource , timeout = 10 , times = 20 , destroytime = 120 ) View Source def manage_stream ( resource , timeout = 10 , times = 20 , destroytime = 120 ) : u = Cognito ( ** conf [ \"aws\" ][ \"pool\" ] ) u . authenticate ( conf [ \"aws\" ][ \"pwd\" ] ) headers = { \"Authorization\" : u . id_token } url_creds = \"https://api.wsn-cloud.com/api/portal/get_stream_viewer_creds\" res = requests . get ( url = url_creds , headers = headers ) try : if res . status_code in [ 200, 409 ] : creds = res . json () creds = { 'aws_access_key_id' : creds [ 'access_id' ] , 'aws_secret_access_key' : creds [ 'secret_key' ] , \"region_name\" : \"eu-west-1\" } url_cmmnd = \"https://api.wsn-cloud.com/api/portal/post_command\" data = { \"wsn_sn\" : resource , \"command_code\" : 8 , \"command_args\" : [ \"1\" ] } res = requests . post ( url = url_cmmnd , json = data , headers = headers ) session = Session ( ** creds ) else : raise Exception ( 'wrong code' ) endpoint = session . client ( 'kinesisvideo' ). get_data_endpoint ( StreamName = f 'stream-{resource}' , APIName = 'GET_HLS_STREAMING_SESSION_URL' ) [ 'DataEndpoint' ] client_kvac = session . client ( 'kinesis-video-archived-media' , endpoint_url = endpoint ) except Exception as e : db [ 'resources_queues' ][ resource,uuid() ]= { \"status\" : \"GONE\" , \"timestamp\" : str ( datetime64 ( \"now\" )), \"url\" : None } return req = { \"StreamName\" : f \"stream-{resource}\" , \"PlaybackMode\" : \"LIVE\" , \"HLSFragmentSelector\" : { \"FragmentSelectorType\" : \"PRODUCER_TIMESTAMP\" } , \"ContainerFormat\" : \"FRAGMENTED_MP4\" , \"DiscontinuityMode\" : \"ALWAYS\" , \"DisplayFragmentTimestamp\" : \"ALWAYS\" , } for i in range ( times ) : print ( f \"resource: {resource}, time: {timeout*i} secs\" ) try : out = dataframe2jsonizabledict ( db [ 'resources_queues' ][ resource ] ) out [ \"status\" ]= \"AVAILABLE\" out [ \"timestamp\" ]= str ( datetime64 ( \"now\" )) except KeyError : return try : out [ \"url\" ]= client_kvac . get_hls_streaming_session_url ( ** req ) [ 'HLSStreamingSessionURL' ] db [ 'resources_queues' ][ resource ]= out try : sleep ( destroytime ) except Exception : pass finally : out [ \"status\" ]= \"GONE\" print ( out [ \"status\" ] ) db [ 'resources_queues' ][ resource ]= out return except KeyError as e : return except Exception as e : out [ \"status\" ]= \"PENDING\" print ( out [ \"status\" ] ) db [ 'resources_queues' ][ resource ]= out print ( out [ \"status\" ] ) sleep ( timeout ) try : out = dataframe2jsonizabledict ( db [ 'resources_queues' ][ resource ] ) out [ \"status\" ]= \"TIMEOUT\" print ( out [ \"status\" ] ) db [ 'resources_queues' ][ resource ]= out except KeyError : pass random def random ( ) random() -> x in the interval [0, 1). start_stream def start_stream ( resource = None ) View Source def start_stream ( resource = None ) : out = {} if resource is None : raise KeyError ( 'No resource' ) try : out = dataframe2jsonizabledict ( db [ 'resources_queues' ][ resource ] ) except KeyError as e : out = None nowtime = datetime64 ( \"now\" ) #if out is None or out [ 'status' ] in [ \"TIMEOUT\",\"GONE\",\"INIT\" ] : try : if out [ 'status' ] in [ \"TIMEOUT\",\"GONE\" ] : raise Exception if ( nowtime - datetime64 ( out [ \"timestamp\" ] ) ) < timedelta64 ( 1200 ) : return out except Exception as e : pass try : db [ 'resources_queues' ] . pop ( [ out['resource' ] , out [ 'queue' ] ] ) except KeyError : pass except TypeError : pass try : db [ 'resources_queues' ][ resource,uuid() ]= { \"status\" : \"INIT\" , \"timestamp\" : str ( nowtime ), \"url\" : None } out = dataframe2jsonizabledict ( db [ 'resources_queues' ][ resource ] ) Thread ( target = manage_stream , args = ( resource ,), daemon = True ). start () except Exception as e : pass return out","title":"Hls Facility"},{"location":"reference/hielen3/tools/hls_facility/#module-hielen3toolshls_facility","text":"View Source # coding: utf-8 import boto3 from boto3 import Session from pycognito import Cognito import requests from time import sleep from random import random from hielen3 import db , conf from hielen3.utils import uuid , dataframe2jsonizabledict from numpy import datetime64 , timedelta64 import json from threading import Thread def manage_stream ( resource , timeout = 10 , times = 20 , destroytime = 120 ): u = Cognito ( ** conf [ \"aws\" ][ \"pool\" ]) u . authenticate ( conf [ \"aws\" ][ \"pwd\" ]) headers = { \"Authorization\" : u . id_token } url_creds = \"https://api.wsn-cloud.com/api/portal/get_stream_viewer_creds\" res = requests . get ( url = url_creds , headers = headers ) try : if res . status_code in [ 200 , 409 ]: creds = res . json () creds = { 'aws_access_key_id' : creds [ 'access_id' ], 'aws_secret_access_key' : creds [ 'secret_key' ], \"region_name\" : \"eu-west-1\" } url_cmmnd = \"https://api.wsn-cloud.com/api/portal/post_command\" data = { \"wsn_sn\" : resource , \"command_code\" : 8 , \"command_args\" :[ \"1\" ]} res = requests . post ( url = url_cmmnd , json = data , headers = headers ) session = Session ( ** creds ) else : raise Exception ( 'wrong code' ) endpoint = session . client ( 'kinesisvideo' ) . get_data_endpoint ( StreamName = f 'stream- { resource } ' , APIName = 'GET_HLS_STREAMING_SESSION_URL' )[ 'DataEndpoint' ] client_kvac = session . client ( 'kinesis-video-archived-media' , endpoint_url = endpoint ) except Exception as e : db [ 'resources_queues' ][ resource , uuid ()] = { \"status\" : \"GONE\" , \"timestamp\" : str ( datetime64 ( \"now\" )), \"url\" : None } return req = { \"StreamName\" : f \"stream- { resource } \" , \"PlaybackMode\" : \"LIVE\" , \"HLSFragmentSelector\" : { \"FragmentSelectorType\" : \"PRODUCER_TIMESTAMP\" }, \"ContainerFormat\" : \"FRAGMENTED_MP4\" , \"DiscontinuityMode\" : \"ALWAYS\" , \"DisplayFragmentTimestamp\" : \"ALWAYS\" , } for i in range ( times ): print ( f \"resource: { resource } , time: { timeout * i } secs\" ) try : out = dataframe2jsonizabledict ( db [ 'resources_queues' ][ resource ]) out [ \"status\" ] = \"AVAILABLE\" out [ \"timestamp\" ] = str ( datetime64 ( \"now\" )) except KeyError : return try : out [ \"url\" ] = client_kvac . get_hls_streaming_session_url ( ** req )[ 'HLSStreamingSessionURL' ] db [ 'resources_queues' ][ resource ] = out try : sleep ( destroytime ) except Exception : pass finally : out [ \"status\" ] = \"GONE\" print ( out [ \"status\" ]) db [ 'resources_queues' ][ resource ] = out return except KeyError as e : return except Exception as e : out [ \"status\" ] = \"PENDING\" print ( out [ \"status\" ]) db [ 'resources_queues' ][ resource ] = out print ( out [ \"status\" ]) sleep ( timeout ) try : out = dataframe2jsonizabledict ( db [ 'resources_queues' ][ resource ]) out [ \"status\" ] = \"TIMEOUT\" print ( out [ \"status\" ]) db [ 'resources_queues' ][ resource ] = out except KeyError : pass def start_stream ( resource = None ): out = {} if resource is None : raise KeyError ( 'No resource' ) try : out = dataframe2jsonizabledict ( db [ 'resources_queues' ][ resource ]) except KeyError as e : out = None nowtime = datetime64 ( \"now\" ) #if out is None or out['status'] in [\"TIMEOUT\",\"GONE\",\"INIT\"]: try : if out [ 'status' ] in [ \"TIMEOUT\" , \"GONE\" ]: raise Exception if ( nowtime - datetime64 ( out [ \"timestamp\" ]) ) < timedelta64 ( 1200 ): return out except Exception as e : pass try : db [ 'resources_queues' ] . pop ([ out [ 'resource' ], out [ 'queue' ]]) except KeyError : pass except TypeError : pass try : db [ 'resources_queues' ][ resource , uuid ()] = { \"status\" : \"INIT\" , \"timestamp\" : str ( nowtime ), \"url\" : None } out = dataframe2jsonizabledict ( db [ 'resources_queues' ][ resource ]) Thread ( target = manage_stream , args = ( resource ,), daemon = True ) . start () except Exception as e : pass return out def get_stream ( queue ): out = {} outcode = 200 if queue is None : outcode = 400 else : try : out = db [ 'resources_queues' ][:, queue ] except KeyError as e : outcode = 404 return out , outcode","title":"Module hielen3.tools.hls_facility"},{"location":"reference/hielen3/tools/hls_facility/#variables","text":"conf db","title":"Variables"},{"location":"reference/hielen3/tools/hls_facility/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/tools/hls_facility/#get_stream","text":"def get_stream ( queue ) View Source def get_stream ( queue ) : out = {} outcode = 200 if queue is None : outcode = 400 else : try : out = db [ 'resources_queues' ][:, queue ] except KeyError as e : outcode = 404 return out , outcode","title":"get_stream"},{"location":"reference/hielen3/tools/hls_facility/#manage_stream","text":"def manage_stream ( resource , timeout = 10 , times = 20 , destroytime = 120 ) View Source def manage_stream ( resource , timeout = 10 , times = 20 , destroytime = 120 ) : u = Cognito ( ** conf [ \"aws\" ][ \"pool\" ] ) u . authenticate ( conf [ \"aws\" ][ \"pwd\" ] ) headers = { \"Authorization\" : u . id_token } url_creds = \"https://api.wsn-cloud.com/api/portal/get_stream_viewer_creds\" res = requests . get ( url = url_creds , headers = headers ) try : if res . status_code in [ 200, 409 ] : creds = res . json () creds = { 'aws_access_key_id' : creds [ 'access_id' ] , 'aws_secret_access_key' : creds [ 'secret_key' ] , \"region_name\" : \"eu-west-1\" } url_cmmnd = \"https://api.wsn-cloud.com/api/portal/post_command\" data = { \"wsn_sn\" : resource , \"command_code\" : 8 , \"command_args\" : [ \"1\" ] } res = requests . post ( url = url_cmmnd , json = data , headers = headers ) session = Session ( ** creds ) else : raise Exception ( 'wrong code' ) endpoint = session . client ( 'kinesisvideo' ). get_data_endpoint ( StreamName = f 'stream-{resource}' , APIName = 'GET_HLS_STREAMING_SESSION_URL' ) [ 'DataEndpoint' ] client_kvac = session . client ( 'kinesis-video-archived-media' , endpoint_url = endpoint ) except Exception as e : db [ 'resources_queues' ][ resource,uuid() ]= { \"status\" : \"GONE\" , \"timestamp\" : str ( datetime64 ( \"now\" )), \"url\" : None } return req = { \"StreamName\" : f \"stream-{resource}\" , \"PlaybackMode\" : \"LIVE\" , \"HLSFragmentSelector\" : { \"FragmentSelectorType\" : \"PRODUCER_TIMESTAMP\" } , \"ContainerFormat\" : \"FRAGMENTED_MP4\" , \"DiscontinuityMode\" : \"ALWAYS\" , \"DisplayFragmentTimestamp\" : \"ALWAYS\" , } for i in range ( times ) : print ( f \"resource: {resource}, time: {timeout*i} secs\" ) try : out = dataframe2jsonizabledict ( db [ 'resources_queues' ][ resource ] ) out [ \"status\" ]= \"AVAILABLE\" out [ \"timestamp\" ]= str ( datetime64 ( \"now\" )) except KeyError : return try : out [ \"url\" ]= client_kvac . get_hls_streaming_session_url ( ** req ) [ 'HLSStreamingSessionURL' ] db [ 'resources_queues' ][ resource ]= out try : sleep ( destroytime ) except Exception : pass finally : out [ \"status\" ]= \"GONE\" print ( out [ \"status\" ] ) db [ 'resources_queues' ][ resource ]= out return except KeyError as e : return except Exception as e : out [ \"status\" ]= \"PENDING\" print ( out [ \"status\" ] ) db [ 'resources_queues' ][ resource ]= out print ( out [ \"status\" ] ) sleep ( timeout ) try : out = dataframe2jsonizabledict ( db [ 'resources_queues' ][ resource ] ) out [ \"status\" ]= \"TIMEOUT\" print ( out [ \"status\" ] ) db [ 'resources_queues' ][ resource ]= out except KeyError : pass","title":"manage_stream"},{"location":"reference/hielen3/tools/hls_facility/#random","text":"def random ( ) random() -> x in the interval [0, 1).","title":"random"},{"location":"reference/hielen3/tools/hls_facility/#start_stream","text":"def start_stream ( resource = None ) View Source def start_stream ( resource = None ) : out = {} if resource is None : raise KeyError ( 'No resource' ) try : out = dataframe2jsonizabledict ( db [ 'resources_queues' ][ resource ] ) except KeyError as e : out = None nowtime = datetime64 ( \"now\" ) #if out is None or out [ 'status' ] in [ \"TIMEOUT\",\"GONE\",\"INIT\" ] : try : if out [ 'status' ] in [ \"TIMEOUT\",\"GONE\" ] : raise Exception if ( nowtime - datetime64 ( out [ \"timestamp\" ] ) ) < timedelta64 ( 1200 ) : return out except Exception as e : pass try : db [ 'resources_queues' ] . pop ( [ out['resource' ] , out [ 'queue' ] ] ) except KeyError : pass except TypeError : pass try : db [ 'resources_queues' ][ resource,uuid() ]= { \"status\" : \"INIT\" , \"timestamp\" : str ( nowtime ), \"url\" : None } out = dataframe2jsonizabledict ( db [ 'resources_queues' ][ resource ] ) Thread ( target = manage_stream , args = ( resource ,), daemon = True ). start () except Exception as e : pass return out","title":"start_stream"},{"location":"reference/hielen3/tools/hls_facility_good/","text":"Module hielen3.tools.hls_facility_good View Source # coding: utf-8 import boto3 from boto3 import Session from pycognito import Cognito import requests from time import sleep from random import random from hielen3 import db , conf from hielen3.utils import uuid from datetime import datetime , timedelta import json from threading import Thread resources = [ \"21C04004\" , \"22D01001\" , \"22D01002\" , \"22D01003\" , \"22D01005\" , \"22D01006\" , \"22D01009\" , \"22D01011\" , \"22D01012\" , \"22D01015\" , \"22D01016\" , \"22D01017\" , \"22D01018\" , \"22D01019\" ] def __parse_out__ ( out ): try : return json . loads ( out . to_json ( orient = 'records' ))[ 0 ] except Exception as e : return {} def manage_stream ( resource , creds , timeout = 10 , times = 20 , destroytime = 120 ): #creds_=conf[\"aws\"][\"options\"] #creds.update(creds_) session = Session ( ** creds ) try : endpoint = session . client ( 'kinesisvideo' ) . get_data_endpoint ( StreamName = f 'stream- { resource } ' , APIName = 'GET_HLS_STREAMING_SESSION_URL' )[ 'DataEndpoint' ] client_kvac = session . client ( 'kinesis-video-archived-media' , endpoint_url = endpoint ) except Exception as e : db [ 'resources_queues' ][ resource , uuid ()] = { \"status\" : \"GONE\" , \"timestamp\" : str ( datetime . now ()), \"url\" : None } return req = { \"StreamName\" : f \"stream- { resource } \" , \"PlaybackMode\" : \"LIVE\" , \"HLSFragmentSelector\" : { \"FragmentSelectorType\" : \"PRODUCER_TIMESTAMP\" }, \"ContainerFormat\" : \"FRAGMENTED_MP4\" , \"DiscontinuityMode\" : \"ALWAYS\" , \"DisplayFragmentTimestamp\" : \"ALWAYS\" , } for i in range ( times ): print ( f \"resource: { resource } , time: { timeout * i } secs\" ) try : out = __parse_out__ ( db [ 'resources_queues' ][ resource ]) out [ \"status\" ] = \"AVAILABLE\" except KeyError : return try : out [ \"url\" ] = client_kvac . get_hls_streaming_session_url ( ** req )[ 'HLSStreamingSessionURL' ] db [ 'resources_queues' ][ resource ] = out try : sleep ( destroytime ) except Exception : pass finally : out [ \"status\" ] = \"GONE\" print ( out [ \"status\" ]) db [ 'resources_queues' ][ resource ] = out return \"\"\" try: while True: sleep(destroytime) print(client_kvac.get_hls_streaming_session_url(**req)['HLSStreamingSessionURL']) except Exception as e: out[\"status\"]=\"GONE\" print (out[\"status\"]) db['resources_queues'][resource]=out return \"\"\" except KeyError as e : return except Exception as e : out [ \"status\" ] = \"PENDING\" print ( out [ \"status\" ]) db [ 'resources_queues' ][ resource ] = out print ( out [ \"status\" ]) sleep ( timeout ) try : out = __parse_out__ ( db [ 'resources_queues' ][ resource ]) out [ \"status\" ] = \"TIMEOUT\" print ( out [ \"status\" ]) db [ 'resources_queues' ][ resource ] = out except KeyError : pass def start_stream ( resource = None ): out = {} outcode = 200 if resource is None : resource = resources [ int ( random () * 100 ) % resources . __len__ ()] try : out = __parse_out__ ( db [ 'resources_queues' ][ resource ]) except KeyError as e : out = None if out is None or out [ 'status' ] in [ \"TIMEOUT\" , \"GONE\" ]: try : db [ 'resources_queues' ] . pop ([ out [ 'resource' ], out [ 'queue' ]]) except KeyError : pass except TypeError : pass u = Cognito ( ** conf [ \"aws\" ][ \"pool\" ]) u . authenticate ( conf [ \"aws\" ][ \"pwd\" ]) headers = { \"Authorization\" : u . id_token } url_creds = \"https://api.wsn-cloud.com/api/portal/get_stream_viewer_creds\" res = requests . get ( url = url_creds , headers = headers ) creds = res . json () creds = { 'aws_access_key_id' : creds [ 'access_id' ], 'aws_secret_access_key' : creds [ 'secret_key' ], \"region_name\" : \"eu-west-1\" } url_cmmnd = \"https://api.wsn-cloud.com/api/portal/post_command\" data = { \"wsn_sn\" : resource , \"command_code\" : 8 , \"command_args\" :[ \"1\" ]} res = requests . post ( url = url_cmmnd , json = data , headers = headers ) #print (res.__dict__) if res . status_code in [ 200 , 409 ]: db [ 'resources_queues' ][ resource , uuid ()] = { \"status\" : \"INIT\" , \"timestamp\" : str ( datetime . now ()), \"url\" : None } out = __parse_out__ ( db [ 'resources_queues' ][ resource ]) Thread ( target = manage_stream , args = ( resource , creds ), daemon = True ) . start () outcode = res . status_code return out , outcode def get_stream ( queue ): out = {} outcode = 200 if queue is None : outcode = 400 else : try : out = db [ 'resources_queues' ][:, queue ] except KeyError as e : outcode = 404 return __parse_out__ ( out ), outcode Variables conf db resources Functions get_stream def get_stream ( queue ) View Source def get_stream ( queue ) : out = {} outcode = 200 if queue is None : outcode = 400 else : try : out = db [ 'resources_queues' ][:, queue ] except KeyError as e : outcode = 404 return __parse_out__ ( out ) , outcode manage_stream def manage_stream ( resource , creds , timeout = 10 , times = 20 , destroytime = 120 ) View Source def manage_stream ( resource , creds , timeout = 10 , times = 20 , destroytime = 120 ) : #creds_ = conf [ \"aws\" ][ \"options\" ] #creds . update ( creds_ ) session = Session ( ** creds ) try : endpoint = session . client ( 'kinesisvideo' ). get_data_endpoint ( StreamName = f 'stream-{resource}' , APIName = 'GET_HLS_STREAMING_SESSION_URL' ) [ 'DataEndpoint' ] client_kvac = session . client ( 'kinesis-video-archived-media' , endpoint_url = endpoint ) except Exception as e : db [ 'resources_queues' ][ resource,uuid() ]= { \"status\" : \"GONE\" , \"timestamp\" : str ( datetime . now ()), \"url\" : None } return req = { \"StreamName\" : f \"stream-{resource}\" , \"PlaybackMode\" : \"LIVE\" , \"HLSFragmentSelector\" : { \"FragmentSelectorType\" : \"PRODUCER_TIMESTAMP\" } , \"ContainerFormat\" : \"FRAGMENTED_MP4\" , \"DiscontinuityMode\" : \"ALWAYS\" , \"DisplayFragmentTimestamp\" : \"ALWAYS\" , } for i in range ( times ) : print ( f \"resource: {resource}, time: {timeout*i} secs\" ) try : out = __parse_out__ ( db [ 'resources_queues' ][ resource ] ) out [ \"status\" ]= \"AVAILABLE\" except KeyError : return try : out [ \"url\" ]= client_kvac . get_hls_streaming_session_url ( ** req ) [ 'HLSStreamingSessionURL' ] db [ 'resources_queues' ][ resource ]= out try : sleep ( destroytime ) except Exception : pass finally : out [ \"status\" ]= \"GONE\" print ( out [ \"status\" ] ) db [ 'resources_queues' ][ resource ]= out return \"\"\" try: while True: sleep(destroytime) print(client_kvac.get_hls_streaming_session_url(**req)['HLSStreamingSessionURL']) except Exception as e: out[\" status \"]=\" GONE \" print (out[\" status \"]) db['resources_queues'][resource]=out return \"\"\" except KeyError as e : return except Exception as e : out [ \"status\" ]= \"PENDING\" print ( out [ \"status\" ] ) db [ 'resources_queues' ][ resource ]= out print ( out [ \"status\" ] ) sleep ( timeout ) try : out = __parse_out__ ( db [ 'resources_queues' ][ resource ] ) out [ \"status\" ]= \"TIMEOUT\" print ( out [ \"status\" ] ) db [ 'resources_queues' ][ resource ]= out except KeyError : pass random def random ( ) random() -> x in the interval [0, 1). start_stream def start_stream ( resource = None ) View Source def start_stream ( resource = None ) : out = {} outcode = 200 if resource is None : resource = resources [ int(random()*100)%resources.__len__() ] try : out = __parse_out__ ( db [ 'resources_queues' ][ resource ] ) except KeyError as e : out = None if out is None or out [ 'status' ] in [ \"TIMEOUT\",\"GONE\" ] : try : db [ 'resources_queues' ] . pop ( [ out['resource' ] , out [ 'queue' ] ] ) except KeyError : pass except TypeError : pass u = Cognito ( ** conf [ \"aws\" ][ \"pool\" ] ) u . authenticate ( conf [ \"aws\" ][ \"pwd\" ] ) headers = { \"Authorization\" : u . id_token } url_creds = \"https://api.wsn-cloud.com/api/portal/get_stream_viewer_creds\" res = requests . get ( url = url_creds , headers = headers ) creds = res . json () creds = { 'aws_access_key_id' : creds [ 'access_id' ] , 'aws_secret_access_key' : creds [ 'secret_key' ] , \"region_name\" : \"eu-west-1\" } url_cmmnd = \"https://api.wsn-cloud.com/api/portal/post_command\" data = { \"wsn_sn\" : resource , \"command_code\" : 8 , \"command_args\" : [ \"1\" ] } res = requests . post ( url = url_cmmnd , json = data , headers = headers ) #print ( res . __dict__ ) if res . status_code in [ 200, 409 ] : db [ 'resources_queues' ][ resource,uuid() ]= { \"status\" : \"INIT\" , \"timestamp\" : str ( datetime . now ()), \"url\" : None } out = __parse_out__ ( db [ 'resources_queues' ][ resource ] ) Thread ( target = manage_stream , args = ( resource , creds ), daemon = True ). start () outcode = res . status_code return out , outcode","title":"Hls Facility Good"},{"location":"reference/hielen3/tools/hls_facility_good/#module-hielen3toolshls_facility_good","text":"View Source # coding: utf-8 import boto3 from boto3 import Session from pycognito import Cognito import requests from time import sleep from random import random from hielen3 import db , conf from hielen3.utils import uuid from datetime import datetime , timedelta import json from threading import Thread resources = [ \"21C04004\" , \"22D01001\" , \"22D01002\" , \"22D01003\" , \"22D01005\" , \"22D01006\" , \"22D01009\" , \"22D01011\" , \"22D01012\" , \"22D01015\" , \"22D01016\" , \"22D01017\" , \"22D01018\" , \"22D01019\" ] def __parse_out__ ( out ): try : return json . loads ( out . to_json ( orient = 'records' ))[ 0 ] except Exception as e : return {} def manage_stream ( resource , creds , timeout = 10 , times = 20 , destroytime = 120 ): #creds_=conf[\"aws\"][\"options\"] #creds.update(creds_) session = Session ( ** creds ) try : endpoint = session . client ( 'kinesisvideo' ) . get_data_endpoint ( StreamName = f 'stream- { resource } ' , APIName = 'GET_HLS_STREAMING_SESSION_URL' )[ 'DataEndpoint' ] client_kvac = session . client ( 'kinesis-video-archived-media' , endpoint_url = endpoint ) except Exception as e : db [ 'resources_queues' ][ resource , uuid ()] = { \"status\" : \"GONE\" , \"timestamp\" : str ( datetime . now ()), \"url\" : None } return req = { \"StreamName\" : f \"stream- { resource } \" , \"PlaybackMode\" : \"LIVE\" , \"HLSFragmentSelector\" : { \"FragmentSelectorType\" : \"PRODUCER_TIMESTAMP\" }, \"ContainerFormat\" : \"FRAGMENTED_MP4\" , \"DiscontinuityMode\" : \"ALWAYS\" , \"DisplayFragmentTimestamp\" : \"ALWAYS\" , } for i in range ( times ): print ( f \"resource: { resource } , time: { timeout * i } secs\" ) try : out = __parse_out__ ( db [ 'resources_queues' ][ resource ]) out [ \"status\" ] = \"AVAILABLE\" except KeyError : return try : out [ \"url\" ] = client_kvac . get_hls_streaming_session_url ( ** req )[ 'HLSStreamingSessionURL' ] db [ 'resources_queues' ][ resource ] = out try : sleep ( destroytime ) except Exception : pass finally : out [ \"status\" ] = \"GONE\" print ( out [ \"status\" ]) db [ 'resources_queues' ][ resource ] = out return \"\"\" try: while True: sleep(destroytime) print(client_kvac.get_hls_streaming_session_url(**req)['HLSStreamingSessionURL']) except Exception as e: out[\"status\"]=\"GONE\" print (out[\"status\"]) db['resources_queues'][resource]=out return \"\"\" except KeyError as e : return except Exception as e : out [ \"status\" ] = \"PENDING\" print ( out [ \"status\" ]) db [ 'resources_queues' ][ resource ] = out print ( out [ \"status\" ]) sleep ( timeout ) try : out = __parse_out__ ( db [ 'resources_queues' ][ resource ]) out [ \"status\" ] = \"TIMEOUT\" print ( out [ \"status\" ]) db [ 'resources_queues' ][ resource ] = out except KeyError : pass def start_stream ( resource = None ): out = {} outcode = 200 if resource is None : resource = resources [ int ( random () * 100 ) % resources . __len__ ()] try : out = __parse_out__ ( db [ 'resources_queues' ][ resource ]) except KeyError as e : out = None if out is None or out [ 'status' ] in [ \"TIMEOUT\" , \"GONE\" ]: try : db [ 'resources_queues' ] . pop ([ out [ 'resource' ], out [ 'queue' ]]) except KeyError : pass except TypeError : pass u = Cognito ( ** conf [ \"aws\" ][ \"pool\" ]) u . authenticate ( conf [ \"aws\" ][ \"pwd\" ]) headers = { \"Authorization\" : u . id_token } url_creds = \"https://api.wsn-cloud.com/api/portal/get_stream_viewer_creds\" res = requests . get ( url = url_creds , headers = headers ) creds = res . json () creds = { 'aws_access_key_id' : creds [ 'access_id' ], 'aws_secret_access_key' : creds [ 'secret_key' ], \"region_name\" : \"eu-west-1\" } url_cmmnd = \"https://api.wsn-cloud.com/api/portal/post_command\" data = { \"wsn_sn\" : resource , \"command_code\" : 8 , \"command_args\" :[ \"1\" ]} res = requests . post ( url = url_cmmnd , json = data , headers = headers ) #print (res.__dict__) if res . status_code in [ 200 , 409 ]: db [ 'resources_queues' ][ resource , uuid ()] = { \"status\" : \"INIT\" , \"timestamp\" : str ( datetime . now ()), \"url\" : None } out = __parse_out__ ( db [ 'resources_queues' ][ resource ]) Thread ( target = manage_stream , args = ( resource , creds ), daemon = True ) . start () outcode = res . status_code return out , outcode def get_stream ( queue ): out = {} outcode = 200 if queue is None : outcode = 400 else : try : out = db [ 'resources_queues' ][:, queue ] except KeyError as e : outcode = 404 return __parse_out__ ( out ), outcode","title":"Module hielen3.tools.hls_facility_good"},{"location":"reference/hielen3/tools/hls_facility_good/#variables","text":"conf db resources","title":"Variables"},{"location":"reference/hielen3/tools/hls_facility_good/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/tools/hls_facility_good/#get_stream","text":"def get_stream ( queue ) View Source def get_stream ( queue ) : out = {} outcode = 200 if queue is None : outcode = 400 else : try : out = db [ 'resources_queues' ][:, queue ] except KeyError as e : outcode = 404 return __parse_out__ ( out ) , outcode","title":"get_stream"},{"location":"reference/hielen3/tools/hls_facility_good/#manage_stream","text":"def manage_stream ( resource , creds , timeout = 10 , times = 20 , destroytime = 120 ) View Source def manage_stream ( resource , creds , timeout = 10 , times = 20 , destroytime = 120 ) : #creds_ = conf [ \"aws\" ][ \"options\" ] #creds . update ( creds_ ) session = Session ( ** creds ) try : endpoint = session . client ( 'kinesisvideo' ). get_data_endpoint ( StreamName = f 'stream-{resource}' , APIName = 'GET_HLS_STREAMING_SESSION_URL' ) [ 'DataEndpoint' ] client_kvac = session . client ( 'kinesis-video-archived-media' , endpoint_url = endpoint ) except Exception as e : db [ 'resources_queues' ][ resource,uuid() ]= { \"status\" : \"GONE\" , \"timestamp\" : str ( datetime . now ()), \"url\" : None } return req = { \"StreamName\" : f \"stream-{resource}\" , \"PlaybackMode\" : \"LIVE\" , \"HLSFragmentSelector\" : { \"FragmentSelectorType\" : \"PRODUCER_TIMESTAMP\" } , \"ContainerFormat\" : \"FRAGMENTED_MP4\" , \"DiscontinuityMode\" : \"ALWAYS\" , \"DisplayFragmentTimestamp\" : \"ALWAYS\" , } for i in range ( times ) : print ( f \"resource: {resource}, time: {timeout*i} secs\" ) try : out = __parse_out__ ( db [ 'resources_queues' ][ resource ] ) out [ \"status\" ]= \"AVAILABLE\" except KeyError : return try : out [ \"url\" ]= client_kvac . get_hls_streaming_session_url ( ** req ) [ 'HLSStreamingSessionURL' ] db [ 'resources_queues' ][ resource ]= out try : sleep ( destroytime ) except Exception : pass finally : out [ \"status\" ]= \"GONE\" print ( out [ \"status\" ] ) db [ 'resources_queues' ][ resource ]= out return \"\"\" try: while True: sleep(destroytime) print(client_kvac.get_hls_streaming_session_url(**req)['HLSStreamingSessionURL']) except Exception as e: out[\" status \"]=\" GONE \" print (out[\" status \"]) db['resources_queues'][resource]=out return \"\"\" except KeyError as e : return except Exception as e : out [ \"status\" ]= \"PENDING\" print ( out [ \"status\" ] ) db [ 'resources_queues' ][ resource ]= out print ( out [ \"status\" ] ) sleep ( timeout ) try : out = __parse_out__ ( db [ 'resources_queues' ][ resource ] ) out [ \"status\" ]= \"TIMEOUT\" print ( out [ \"status\" ] ) db [ 'resources_queues' ][ resource ]= out except KeyError : pass","title":"manage_stream"},{"location":"reference/hielen3/tools/hls_facility_good/#random","text":"def random ( ) random() -> x in the interval [0, 1).","title":"random"},{"location":"reference/hielen3/tools/hls_facility_good/#start_stream","text":"def start_stream ( resource = None ) View Source def start_stream ( resource = None ) : out = {} outcode = 200 if resource is None : resource = resources [ int(random()*100)%resources.__len__() ] try : out = __parse_out__ ( db [ 'resources_queues' ][ resource ] ) except KeyError as e : out = None if out is None or out [ 'status' ] in [ \"TIMEOUT\",\"GONE\" ] : try : db [ 'resources_queues' ] . pop ( [ out['resource' ] , out [ 'queue' ] ] ) except KeyError : pass except TypeError : pass u = Cognito ( ** conf [ \"aws\" ][ \"pool\" ] ) u . authenticate ( conf [ \"aws\" ][ \"pwd\" ] ) headers = { \"Authorization\" : u . id_token } url_creds = \"https://api.wsn-cloud.com/api/portal/get_stream_viewer_creds\" res = requests . get ( url = url_creds , headers = headers ) creds = res . json () creds = { 'aws_access_key_id' : creds [ 'access_id' ] , 'aws_secret_access_key' : creds [ 'secret_key' ] , \"region_name\" : \"eu-west-1\" } url_cmmnd = \"https://api.wsn-cloud.com/api/portal/post_command\" data = { \"wsn_sn\" : resource , \"command_code\" : 8 , \"command_args\" : [ \"1\" ] } res = requests . post ( url = url_cmmnd , json = data , headers = headers ) #print ( res . __dict__ ) if res . status_code in [ 200, 409 ] : db [ 'resources_queues' ][ resource,uuid() ]= { \"status\" : \"INIT\" , \"timestamp\" : str ( datetime . now ()), \"url\" : None } out = __parse_out__ ( db [ 'resources_queues' ][ resource ] ) Thread ( target = manage_stream , args = ( resource , creds ), daemon = True ). start () outcode = res . status_code return out , outcode","title":"start_stream"},{"location":"reference/hielen3/tools/hls_facility_new/","text":"Module hielen3.tools.hls_facility_new View Source # coding: utf-8 import boto3 from boto3 import Session from pycognito import Cognito import requests from time import sleep from random import random #from hielen3 import db,conf #from hielen3.utils import uuid, dataframe2jsonizabledict from numpy import datetime64 , timedelta64 import json from threading import Thread conf = { \"apppath\" : \"/home/fantamodeman/SVILUPPOandTESTING/python_sandbox/dev/modules/hielen3/src\" , \"host\" : \"localhost\" , \"db_maria_connection\" :{ \"dialect\" : \"mariadb\" , \"usr\" : \"editor\" , \"pwd\" : \"rincostocastico\" , \"host\" : \"127.0.0.1\" , \"port\" : 13231 , \"db\" : \"geoframe\" }, \"aws\" :{ \"options\" :{ \"aws_access_key_id\" : \"AKIAQRBSYFZF3U5FZDEL\" , \"aws_secret_access_key\" : \"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\" , \"region_name\" : \"eu-west-1\" }, \"pool\" :{ \"user_pool_id\" : \"eu-west-1_A6bkbncVk\" , \"client_id\" : \"5cfm2ro7dscjkkglac3mti24vl\" , \"username\" : \"digregorio@img-srl.com\" }, \"pwd\" : \"Kaos.6969\" }, \"server_time_offset\" : 1 } def manage_stream ( resource , timeout = 10 , times = 20 , destroytime = 120 ): u = Cognito ( ** conf [ \"aws\" ][ \"pool\" ]) u . authenticate ( conf [ \"aws\" ][ \"pwd\" ]) headers = { \"Authorization\" : u . id_token } url_creds = \"https://api.wsn-cloud.com/api/portal/get_stream_viewer_creds\" res = requests . get ( url = url_creds , headers = headers ) try : if res . status_code in [ 200 , 409 ]: creds = res . json () creds = { 'aws_access_key_id' : creds [ 'access_id' ], 'aws_secret_access_key' : creds [ 'secret_key' ], \"region_name\" : \"eu-west-1\" } url_cmmnd = \"https://api.wsn-cloud.com/api/portal/post_command\" data = { \"wsn_sn\" : resource , \"command_code\" : 8 , \"command_args\" :[ \"1\" ]} res = requests . post ( url = url_cmmnd , json = data , headers = headers ) session = Session ( ** creds ) else : raise Exception ( 'wrong code' ) endpoint = session . client ( 'kinesisvideo' ) . get_data_endpoint ( StreamName = f 'stream- { resource } ' , APIName = 'GET_HLS_STREAMING_SESSION_URL' )[ 'DataEndpoint' ] client_kvac = session . client ( 'kinesis-video-archived-media' , endpoint_url = endpoint ) except Exception as e : db [ 'resources_queues' ][ resource , uuid ()] = { \"status\" : \"GONE\" , \"timestamp\" : str ( datetime64 ( \"now\" )), \"url\" : None } return req = { \"StreamName\" : f \"stream- { resource } \" , \"PlaybackMode\" : \"LIVE\" , \"HLSFragmentSelector\" : { \"FragmentSelectorType\" : \"PRODUCER_TIMESTAMP\" }, \"ContainerFormat\" : \"FRAGMENTED_MP4\" , \"DiscontinuityMode\" : \"ALWAYS\" , \"DisplayFragmentTimestamp\" : \"ALWAYS\" , } for i in range ( times ): print ( f \"resource: { resource } , time: { timeout * i } secs\" ) try : out = dataframe2jsonizabledict ( db [ 'resources_queues' ][ resource ]) out [ \"status\" ] = \"AVAILABLE\" out [ \"timestamp\" ] = str ( datetime64 ( \"now\" )) except KeyError : return try : out [ \"url\" ] = client_kvac . get_hls_streaming_session_url ( ** req )[ 'HLSStreamingSessionURL' ] db [ 'resources_queues' ][ resource ] = out try : sleep ( destroytime ) except Exception : pass finally : out [ \"status\" ] = \"GONE\" print ( out [ \"status\" ]) db [ 'resources_queues' ][ resource ] = out return except KeyError as e : return except Exception as e : out [ \"status\" ] = \"PENDING\" print ( out [ \"status\" ]) db [ 'resources_queues' ][ resource ] = out print ( out [ \"status\" ]) sleep ( timeout ) try : out = dataframe2jsonizabledict ( db [ 'resources_queues' ][ resource ]) out [ \"status\" ] = \"TIMEOUT\" print ( out [ \"status\" ]) db [ 'resources_queues' ][ resource ] = out except KeyError : pass def start_stream ( resource = None ): out = {} if resource is None : raise KeyError ( 'No resource' ) try : out = dataframe2jsonizabledict ( db [ 'resources_queues' ][ resource ]) except KeyError as e : out = None nowtime = datetime64 ( \"now\" ) #if out is None or out['status'] in [\"TIMEOUT\",\"GONE\",\"INIT\"]: try : if out [ 'status' ] in [ \"TIMEOUT\" , \"GONE\" ]: raise Exception if ( nowtime - datetime64 ( out [ \"timestamp\" ]) ) < timedelta64 ( 1200 ): return out except Exception as e : pass try : db [ 'resources_queues' ] . pop ([ out [ 'resource' ], out [ 'queue' ]]) except KeyError : pass except TypeError : pass try : db [ 'resources_queues' ][ resource , uuid ()] = { \"status\" : \"INIT\" , \"timestamp\" : str ( nowtime ), \"url\" : None } out = dataframe2jsonizabledict ( db [ 'resources_queues' ][ resource ]) Thread ( target = manage_stream , args = ( resource ,), daemon = True ) . start () except Exception as e : pass return out def get_stream ( queue ): out = {} outcode = 200 if queue is None : outcode = 400 else : try : out = db [ 'resources_queues' ][:, queue ] except KeyError as e : outcode = 404 return out , outcode Variables conf Functions get_stream def get_stream ( queue ) View Source def get_stream ( queue ) : out = {} outcode = 200 if queue is None : outcode = 400 else : try : out = db [ 'resources_queues' ][:, queue ] except KeyError as e : outcode = 404 return out , outcode manage_stream def manage_stream ( resource , timeout = 10 , times = 20 , destroytime = 120 ) View Source def manage_stream ( resource , timeout = 10 , times = 20 , destroytime = 120 ) : u = Cognito ( ** conf [ \"aws\" ][ \"pool\" ] ) u . authenticate ( conf [ \"aws\" ][ \"pwd\" ] ) headers = { \"Authorization\" : u . id_token } url_creds = \"https://api.wsn-cloud.com/api/portal/get_stream_viewer_creds\" res = requests . get ( url = url_creds , headers = headers ) try : if res . status_code in [ 200, 409 ] : creds = res . json () creds = { 'aws_access_key_id' : creds [ 'access_id' ] , 'aws_secret_access_key' : creds [ 'secret_key' ] , \"region_name\" : \"eu-west-1\" } url_cmmnd = \"https://api.wsn-cloud.com/api/portal/post_command\" data = { \"wsn_sn\" : resource , \"command_code\" : 8 , \"command_args\" : [ \"1\" ] } res = requests . post ( url = url_cmmnd , json = data , headers = headers ) session = Session ( ** creds ) else : raise Exception ( 'wrong code' ) endpoint = session . client ( 'kinesisvideo' ). get_data_endpoint ( StreamName = f 'stream-{resource}' , APIName = 'GET_HLS_STREAMING_SESSION_URL' ) [ 'DataEndpoint' ] client_kvac = session . client ( 'kinesis-video-archived-media' , endpoint_url = endpoint ) except Exception as e : db [ 'resources_queues' ][ resource,uuid() ]= { \"status\" : \"GONE\" , \"timestamp\" : str ( datetime64 ( \"now\" )), \"url\" : None } return req = { \"StreamName\" : f \"stream-{resource}\" , \"PlaybackMode\" : \"LIVE\" , \"HLSFragmentSelector\" : { \"FragmentSelectorType\" : \"PRODUCER_TIMESTAMP\" } , \"ContainerFormat\" : \"FRAGMENTED_MP4\" , \"DiscontinuityMode\" : \"ALWAYS\" , \"DisplayFragmentTimestamp\" : \"ALWAYS\" , } for i in range ( times ) : print ( f \"resource: {resource}, time: {timeout*i} secs\" ) try : out = dataframe2jsonizabledict ( db [ 'resources_queues' ][ resource ] ) out [ \"status\" ]= \"AVAILABLE\" out [ \"timestamp\" ]= str ( datetime64 ( \"now\" )) except KeyError : return try : out [ \"url\" ]= client_kvac . get_hls_streaming_session_url ( ** req ) [ 'HLSStreamingSessionURL' ] db [ 'resources_queues' ][ resource ]= out try : sleep ( destroytime ) except Exception : pass finally : out [ \"status\" ]= \"GONE\" print ( out [ \"status\" ] ) db [ 'resources_queues' ][ resource ]= out return except KeyError as e : return except Exception as e : out [ \"status\" ]= \"PENDING\" print ( out [ \"status\" ] ) db [ 'resources_queues' ][ resource ]= out print ( out [ \"status\" ] ) sleep ( timeout ) try : out = dataframe2jsonizabledict ( db [ 'resources_queues' ][ resource ] ) out [ \"status\" ]= \"TIMEOUT\" print ( out [ \"status\" ] ) db [ 'resources_queues' ][ resource ]= out except KeyError : pass random def random ( ) random() -> x in the interval [0, 1). start_stream def start_stream ( resource = None ) View Source def start_stream ( resource = None ) : out = {} if resource is None : raise KeyError ( 'No resource' ) try : out = dataframe2jsonizabledict ( db [ 'resources_queues' ][ resource ] ) except KeyError as e : out = None nowtime = datetime64 ( \"now\" ) #if out is None or out [ 'status' ] in [ \"TIMEOUT\",\"GONE\",\"INIT\" ] : try : if out [ 'status' ] in [ \"TIMEOUT\",\"GONE\" ] : raise Exception if ( nowtime - datetime64 ( out [ \"timestamp\" ] ) ) < timedelta64 ( 1200 ) : return out except Exception as e : pass try : db [ 'resources_queues' ] . pop ( [ out['resource' ] , out [ 'queue' ] ] ) except KeyError : pass except TypeError : pass try : db [ 'resources_queues' ][ resource,uuid() ]= { \"status\" : \"INIT\" , \"timestamp\" : str ( nowtime ), \"url\" : None } out = dataframe2jsonizabledict ( db [ 'resources_queues' ][ resource ] ) Thread ( target = manage_stream , args = ( resource ,), daemon = True ). start () except Exception as e : pass return out","title":"Hls Facility New"},{"location":"reference/hielen3/tools/hls_facility_new/#module-hielen3toolshls_facility_new","text":"View Source # coding: utf-8 import boto3 from boto3 import Session from pycognito import Cognito import requests from time import sleep from random import random #from hielen3 import db,conf #from hielen3.utils import uuid, dataframe2jsonizabledict from numpy import datetime64 , timedelta64 import json from threading import Thread conf = { \"apppath\" : \"/home/fantamodeman/SVILUPPOandTESTING/python_sandbox/dev/modules/hielen3/src\" , \"host\" : \"localhost\" , \"db_maria_connection\" :{ \"dialect\" : \"mariadb\" , \"usr\" : \"editor\" , \"pwd\" : \"rincostocastico\" , \"host\" : \"127.0.0.1\" , \"port\" : 13231 , \"db\" : \"geoframe\" }, \"aws\" :{ \"options\" :{ \"aws_access_key_id\" : \"AKIAQRBSYFZF3U5FZDEL\" , \"aws_secret_access_key\" : \"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\" , \"region_name\" : \"eu-west-1\" }, \"pool\" :{ \"user_pool_id\" : \"eu-west-1_A6bkbncVk\" , \"client_id\" : \"5cfm2ro7dscjkkglac3mti24vl\" , \"username\" : \"digregorio@img-srl.com\" }, \"pwd\" : \"Kaos.6969\" }, \"server_time_offset\" : 1 } def manage_stream ( resource , timeout = 10 , times = 20 , destroytime = 120 ): u = Cognito ( ** conf [ \"aws\" ][ \"pool\" ]) u . authenticate ( conf [ \"aws\" ][ \"pwd\" ]) headers = { \"Authorization\" : u . id_token } url_creds = \"https://api.wsn-cloud.com/api/portal/get_stream_viewer_creds\" res = requests . get ( url = url_creds , headers = headers ) try : if res . status_code in [ 200 , 409 ]: creds = res . json () creds = { 'aws_access_key_id' : creds [ 'access_id' ], 'aws_secret_access_key' : creds [ 'secret_key' ], \"region_name\" : \"eu-west-1\" } url_cmmnd = \"https://api.wsn-cloud.com/api/portal/post_command\" data = { \"wsn_sn\" : resource , \"command_code\" : 8 , \"command_args\" :[ \"1\" ]} res = requests . post ( url = url_cmmnd , json = data , headers = headers ) session = Session ( ** creds ) else : raise Exception ( 'wrong code' ) endpoint = session . client ( 'kinesisvideo' ) . get_data_endpoint ( StreamName = f 'stream- { resource } ' , APIName = 'GET_HLS_STREAMING_SESSION_URL' )[ 'DataEndpoint' ] client_kvac = session . client ( 'kinesis-video-archived-media' , endpoint_url = endpoint ) except Exception as e : db [ 'resources_queues' ][ resource , uuid ()] = { \"status\" : \"GONE\" , \"timestamp\" : str ( datetime64 ( \"now\" )), \"url\" : None } return req = { \"StreamName\" : f \"stream- { resource } \" , \"PlaybackMode\" : \"LIVE\" , \"HLSFragmentSelector\" : { \"FragmentSelectorType\" : \"PRODUCER_TIMESTAMP\" }, \"ContainerFormat\" : \"FRAGMENTED_MP4\" , \"DiscontinuityMode\" : \"ALWAYS\" , \"DisplayFragmentTimestamp\" : \"ALWAYS\" , } for i in range ( times ): print ( f \"resource: { resource } , time: { timeout * i } secs\" ) try : out = dataframe2jsonizabledict ( db [ 'resources_queues' ][ resource ]) out [ \"status\" ] = \"AVAILABLE\" out [ \"timestamp\" ] = str ( datetime64 ( \"now\" )) except KeyError : return try : out [ \"url\" ] = client_kvac . get_hls_streaming_session_url ( ** req )[ 'HLSStreamingSessionURL' ] db [ 'resources_queues' ][ resource ] = out try : sleep ( destroytime ) except Exception : pass finally : out [ \"status\" ] = \"GONE\" print ( out [ \"status\" ]) db [ 'resources_queues' ][ resource ] = out return except KeyError as e : return except Exception as e : out [ \"status\" ] = \"PENDING\" print ( out [ \"status\" ]) db [ 'resources_queues' ][ resource ] = out print ( out [ \"status\" ]) sleep ( timeout ) try : out = dataframe2jsonizabledict ( db [ 'resources_queues' ][ resource ]) out [ \"status\" ] = \"TIMEOUT\" print ( out [ \"status\" ]) db [ 'resources_queues' ][ resource ] = out except KeyError : pass def start_stream ( resource = None ): out = {} if resource is None : raise KeyError ( 'No resource' ) try : out = dataframe2jsonizabledict ( db [ 'resources_queues' ][ resource ]) except KeyError as e : out = None nowtime = datetime64 ( \"now\" ) #if out is None or out['status'] in [\"TIMEOUT\",\"GONE\",\"INIT\"]: try : if out [ 'status' ] in [ \"TIMEOUT\" , \"GONE\" ]: raise Exception if ( nowtime - datetime64 ( out [ \"timestamp\" ]) ) < timedelta64 ( 1200 ): return out except Exception as e : pass try : db [ 'resources_queues' ] . pop ([ out [ 'resource' ], out [ 'queue' ]]) except KeyError : pass except TypeError : pass try : db [ 'resources_queues' ][ resource , uuid ()] = { \"status\" : \"INIT\" , \"timestamp\" : str ( nowtime ), \"url\" : None } out = dataframe2jsonizabledict ( db [ 'resources_queues' ][ resource ]) Thread ( target = manage_stream , args = ( resource ,), daemon = True ) . start () except Exception as e : pass return out def get_stream ( queue ): out = {} outcode = 200 if queue is None : outcode = 400 else : try : out = db [ 'resources_queues' ][:, queue ] except KeyError as e : outcode = 404 return out , outcode","title":"Module hielen3.tools.hls_facility_new"},{"location":"reference/hielen3/tools/hls_facility_new/#variables","text":"conf","title":"Variables"},{"location":"reference/hielen3/tools/hls_facility_new/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/tools/hls_facility_new/#get_stream","text":"def get_stream ( queue ) View Source def get_stream ( queue ) : out = {} outcode = 200 if queue is None : outcode = 400 else : try : out = db [ 'resources_queues' ][:, queue ] except KeyError as e : outcode = 404 return out , outcode","title":"get_stream"},{"location":"reference/hielen3/tools/hls_facility_new/#manage_stream","text":"def manage_stream ( resource , timeout = 10 , times = 20 , destroytime = 120 ) View Source def manage_stream ( resource , timeout = 10 , times = 20 , destroytime = 120 ) : u = Cognito ( ** conf [ \"aws\" ][ \"pool\" ] ) u . authenticate ( conf [ \"aws\" ][ \"pwd\" ] ) headers = { \"Authorization\" : u . id_token } url_creds = \"https://api.wsn-cloud.com/api/portal/get_stream_viewer_creds\" res = requests . get ( url = url_creds , headers = headers ) try : if res . status_code in [ 200, 409 ] : creds = res . json () creds = { 'aws_access_key_id' : creds [ 'access_id' ] , 'aws_secret_access_key' : creds [ 'secret_key' ] , \"region_name\" : \"eu-west-1\" } url_cmmnd = \"https://api.wsn-cloud.com/api/portal/post_command\" data = { \"wsn_sn\" : resource , \"command_code\" : 8 , \"command_args\" : [ \"1\" ] } res = requests . post ( url = url_cmmnd , json = data , headers = headers ) session = Session ( ** creds ) else : raise Exception ( 'wrong code' ) endpoint = session . client ( 'kinesisvideo' ). get_data_endpoint ( StreamName = f 'stream-{resource}' , APIName = 'GET_HLS_STREAMING_SESSION_URL' ) [ 'DataEndpoint' ] client_kvac = session . client ( 'kinesis-video-archived-media' , endpoint_url = endpoint ) except Exception as e : db [ 'resources_queues' ][ resource,uuid() ]= { \"status\" : \"GONE\" , \"timestamp\" : str ( datetime64 ( \"now\" )), \"url\" : None } return req = { \"StreamName\" : f \"stream-{resource}\" , \"PlaybackMode\" : \"LIVE\" , \"HLSFragmentSelector\" : { \"FragmentSelectorType\" : \"PRODUCER_TIMESTAMP\" } , \"ContainerFormat\" : \"FRAGMENTED_MP4\" , \"DiscontinuityMode\" : \"ALWAYS\" , \"DisplayFragmentTimestamp\" : \"ALWAYS\" , } for i in range ( times ) : print ( f \"resource: {resource}, time: {timeout*i} secs\" ) try : out = dataframe2jsonizabledict ( db [ 'resources_queues' ][ resource ] ) out [ \"status\" ]= \"AVAILABLE\" out [ \"timestamp\" ]= str ( datetime64 ( \"now\" )) except KeyError : return try : out [ \"url\" ]= client_kvac . get_hls_streaming_session_url ( ** req ) [ 'HLSStreamingSessionURL' ] db [ 'resources_queues' ][ resource ]= out try : sleep ( destroytime ) except Exception : pass finally : out [ \"status\" ]= \"GONE\" print ( out [ \"status\" ] ) db [ 'resources_queues' ][ resource ]= out return except KeyError as e : return except Exception as e : out [ \"status\" ]= \"PENDING\" print ( out [ \"status\" ] ) db [ 'resources_queues' ][ resource ]= out print ( out [ \"status\" ] ) sleep ( timeout ) try : out = dataframe2jsonizabledict ( db [ 'resources_queues' ][ resource ] ) out [ \"status\" ]= \"TIMEOUT\" print ( out [ \"status\" ] ) db [ 'resources_queues' ][ resource ]= out except KeyError : pass","title":"manage_stream"},{"location":"reference/hielen3/tools/hls_facility_new/#random","text":"def random ( ) random() -> x in the interval [0, 1).","title":"random"},{"location":"reference/hielen3/tools/hls_facility_new/#start_stream","text":"def start_stream ( resource = None ) View Source def start_stream ( resource = None ) : out = {} if resource is None : raise KeyError ( 'No resource' ) try : out = dataframe2jsonizabledict ( db [ 'resources_queues' ][ resource ] ) except KeyError as e : out = None nowtime = datetime64 ( \"now\" ) #if out is None or out [ 'status' ] in [ \"TIMEOUT\",\"GONE\",\"INIT\" ] : try : if out [ 'status' ] in [ \"TIMEOUT\",\"GONE\" ] : raise Exception if ( nowtime - datetime64 ( out [ \"timestamp\" ] ) ) < timedelta64 ( 1200 ) : return out except Exception as e : pass try : db [ 'resources_queues' ] . pop ( [ out['resource' ] , out [ 'queue' ] ] ) except KeyError : pass except TypeError : pass try : db [ 'resources_queues' ][ resource,uuid() ]= { \"status\" : \"INIT\" , \"timestamp\" : str ( nowtime ), \"url\" : None } out = dataframe2jsonizabledict ( db [ 'resources_queues' ][ resource ] ) Thread ( target = manage_stream , args = ( resource ,), daemon = True ). start () except Exception as e : pass return out","title":"start_stream"},{"location":"reference/hielen3/tools/hls_facility_old/","text":"Module hielen3.tools.hls_facility_old View Source # coding: utf-8 import boto3 from boto3 import Session from pycognito import Cognito import requests from time import sleep from random import random from hielen3 import db , conf from hielen3.utils import uuid from datetime import datetime , timedelta import json from threading import Thread resources = [ \"21C04004\" , \"22D01001\" , \"22D01002\" , \"22D01003\" , \"22D01005\" , \"22D01006\" , \"22D01009\" , \"22D01011\" , \"22D01012\" , \"22D01015\" , \"22D01016\" , \"22D01017\" , \"22D01018\" , \"22D01019\" ] def __parse_out__ ( out ): try : return json . loads ( out . to_json ( orient = 'records' ))[ 0 ] except Exception as e : return {} def manage_stream ( resource , timeout = 10 , times = 20 , destroytime = 300 ): session = Session ( ** conf [ \"aws\" ][ \"options\" ]) try : endpoint = session . client ( 'kinesisvideo' ) . get_data_endpoint ( StreamName = f 'stream- { resource } ' , APIName = 'GET_HLS_STREAMING_SESSION_URL' )[ 'DataEndpoint' ] client_kvac = session . client ( 'kinesis-video-archived-media' , endpoint_url = endpoint ) except Exception : return req = { \"StreamName\" : f \"stream- { resource } \" , \"PlaybackMode\" : \"LIVE\" , \"HLSFragmentSelector\" : { \"FragmentSelectorType\" : \"PRODUCER_TIMESTAMP\" }, \"ContainerFormat\" : \"FRAGMENTED_MP4\" , \"DiscontinuityMode\" : \"ALWAYS\" , \"DisplayFragmentTimestamp\" : \"ALWAYS\" , } for i in range ( times ): print ( f \"resource: { resource } , time: { timeout * i } secs\" ) try : out = __parse_out__ ( db [ 'resources_queues' ][ resource ]) out [ \"status\" ] = \"AVAILABLE\" except KeyError : return try : out [ \"url\" ] = client_kvac . get_hls_streaming_session_url ( ** req )[ 'HLSStreamingSessionURL' ] db [ 'resources_queues' ][ resource ] = out try : sleep ( destroytime ) except Exception : pass finally : out [ \"status\" ] = \"GONE\" print ( out [ \"status\" ]) db [ 'resources_queues' ][ resource ] = out return \"\"\" try: while True: sleep(destroytime) print(client_kvac.get_hls_streaming_session_url(**req)['HLSStreamingSessionURL']) except Exception as e: out[\"status\"]=\"GONE\" print (out[\"status\"]) db['resources_queues'][resource]=out return \"\"\" except KeyError as e : return except Exception as e : out [ \"status\" ] = \"PENDING\" print ( out [ \"status\" ]) db [ 'resources_queues' ][ resource ] = out print ( out [ \"status\" ]) sleep ( timeout ) try : out = __parse_out__ ( db [ 'resources_queues' ][ resource ]) out [ \"status\" ] = \"TIMEOUT\" print ( out [ \"status\" ]) db [ 'resources_queues' ][ resource ] = out except KeyError : pass def start_stream ( resource = None ): out = {} outcode = 200 if resource is None : resource = resources [ int ( random () * 100 ) % resources . __len__ ()] u = Cognito ( ** conf [ \"aws\" ][ \"pool\" ]) u . authenticate ( conf [ \"aws\" ][ \"pwd\" ]) url = \"https://api.wsn-cloud.com/api/portal/post_command\" data = { \"wsn_sn\" : resource , \"command_code\" : 8 , \"command_args\" :[ \"1\" ]} headers = { \"Authorization\" : u . id_token } res = requests . post ( url = url , json = data , headers = headers ) print ( res . __dict__ ) if res . status_code in [ 200 , 409 ]: try : out = __parse_out__ ( db [ 'resources_queues' ][ resource ]) if out [ 'status' ] in [ \"TIMEOUT\" , \"GONE\" ]: db [ 'resources_queues' ] . pop ([ out [ 'resource' ], out [ 'queue' ]]) raise KeyError () except KeyError as e : db [ 'resources_queues' ][ resource , uuid ()] = { \"status\" : \"INIT\" , \"timestamp\" : str ( datetime . now ()), \"url\" : None } out = db [ 'resources_queues' ][ resource ] Thread ( target = manage_stream , args = ( resource ,), daemon = True ) . start () else : outcode = 404 return __parse_out__ ( out ), outcode def get_stream ( queue ): out = {} outcode = 200 if queue is None : outcode = 400 else : try : out = db [ 'resources_queues' ][:, queue ] except KeyError as e : outcode = 404 return __parse_out__ ( out ), outcode Variables conf db resources Functions get_stream def get_stream ( queue ) View Source def get_stream ( queue ) : out = {} outcode = 200 if queue is None : outcode = 400 else : try : out = db [ 'resources_queues' ][:, queue ] except KeyError as e : outcode = 404 return __parse_out__ ( out ) , outcode manage_stream def manage_stream ( resource , timeout = 10 , times = 20 , destroytime = 300 ) View Source def manage_stream ( resource , timeout = 10 , times = 20 , destroytime = 300 ) : session = Session ( ** conf [ \"aws\" ][ \"options\" ] ) try : endpoint = session . client ( 'kinesisvideo' ). get_data_endpoint ( StreamName = f 'stream-{resource}' , APIName = 'GET_HLS_STREAMING_SESSION_URL' ) [ 'DataEndpoint' ] client_kvac = session . client ( 'kinesis-video-archived-media' , endpoint_url = endpoint ) except Exception : return req = { \"StreamName\" : f \"stream-{resource}\" , \"PlaybackMode\" : \"LIVE\" , \"HLSFragmentSelector\" : { \"FragmentSelectorType\" : \"PRODUCER_TIMESTAMP\" } , \"ContainerFormat\" : \"FRAGMENTED_MP4\" , \"DiscontinuityMode\" : \"ALWAYS\" , \"DisplayFragmentTimestamp\" : \"ALWAYS\" , } for i in range ( times ) : print ( f \"resource: {resource}, time: {timeout*i} secs\" ) try : out = __parse_out__ ( db [ 'resources_queues' ][ resource ] ) out [ \"status\" ]= \"AVAILABLE\" except KeyError : return try : out [ \"url\" ]= client_kvac . get_hls_streaming_session_url ( ** req ) [ 'HLSStreamingSessionURL' ] db [ 'resources_queues' ][ resource ]= out try : sleep ( destroytime ) except Exception : pass finally : out [ \"status\" ]= \"GONE\" print ( out [ \"status\" ] ) db [ 'resources_queues' ][ resource ]= out return \"\"\" try: while True: sleep(destroytime) print(client_kvac.get_hls_streaming_session_url(**req)['HLSStreamingSessionURL']) except Exception as e: out[\" status \"]=\" GONE \" print (out[\" status \"]) db['resources_queues'][resource]=out return \"\"\" except KeyError as e : return except Exception as e : out [ \"status\" ]= \"PENDING\" print ( out [ \"status\" ] ) db [ 'resources_queues' ][ resource ]= out print ( out [ \"status\" ] ) sleep ( timeout ) try : out = __parse_out__ ( db [ 'resources_queues' ][ resource ] ) out [ \"status\" ]= \"TIMEOUT\" print ( out [ \"status\" ] ) db [ 'resources_queues' ][ resource ]= out except KeyError : pass random def random ( ) random() -> x in the interval [0, 1). start_stream def start_stream ( resource = None ) View Source def start_stream ( resource = None ) : out = {} outcode = 200 if resource is None : resource = resources [ int(random()*100)%resources.__len__() ] u = Cognito ( ** conf [ \"aws\" ][ \"pool\" ] ) u . authenticate ( conf [ \"aws\" ][ \"pwd\" ] ) url = \"https://api.wsn-cloud.com/api/portal/post_command\" data = { \"wsn_sn\" : resource , \"command_code\" : 8 , \"command_args\" : [ \"1\" ] } headers = { \"Authorization\" : u . id_token } res = requests . post ( url = url , json = data , headers = headers ) print ( res . __dict__ ) if res . status_code in [ 200, 409 ] : try : out = __parse_out__ ( db [ 'resources_queues' ][ resource ] ) if out [ 'status' ] in [ \"TIMEOUT\",\"GONE\" ] : db [ 'resources_queues' ] . pop ( [ out['resource' ] , out [ 'queue' ] ] ) raise KeyError () except KeyError as e : db [ 'resources_queues' ][ resource,uuid() ]= { \"status\" : \"INIT\" , \"timestamp\" : str ( datetime . now ()), \"url\" : None } out = db [ 'resources_queues' ][ resource ] Thread ( target = manage_stream , args = ( resource ,), daemon = True ). start () else : outcode = 404 return __parse_out__ ( out ), outcode","title":"Hls Facility Old"},{"location":"reference/hielen3/tools/hls_facility_old/#module-hielen3toolshls_facility_old","text":"View Source # coding: utf-8 import boto3 from boto3 import Session from pycognito import Cognito import requests from time import sleep from random import random from hielen3 import db , conf from hielen3.utils import uuid from datetime import datetime , timedelta import json from threading import Thread resources = [ \"21C04004\" , \"22D01001\" , \"22D01002\" , \"22D01003\" , \"22D01005\" , \"22D01006\" , \"22D01009\" , \"22D01011\" , \"22D01012\" , \"22D01015\" , \"22D01016\" , \"22D01017\" , \"22D01018\" , \"22D01019\" ] def __parse_out__ ( out ): try : return json . loads ( out . to_json ( orient = 'records' ))[ 0 ] except Exception as e : return {} def manage_stream ( resource , timeout = 10 , times = 20 , destroytime = 300 ): session = Session ( ** conf [ \"aws\" ][ \"options\" ]) try : endpoint = session . client ( 'kinesisvideo' ) . get_data_endpoint ( StreamName = f 'stream- { resource } ' , APIName = 'GET_HLS_STREAMING_SESSION_URL' )[ 'DataEndpoint' ] client_kvac = session . client ( 'kinesis-video-archived-media' , endpoint_url = endpoint ) except Exception : return req = { \"StreamName\" : f \"stream- { resource } \" , \"PlaybackMode\" : \"LIVE\" , \"HLSFragmentSelector\" : { \"FragmentSelectorType\" : \"PRODUCER_TIMESTAMP\" }, \"ContainerFormat\" : \"FRAGMENTED_MP4\" , \"DiscontinuityMode\" : \"ALWAYS\" , \"DisplayFragmentTimestamp\" : \"ALWAYS\" , } for i in range ( times ): print ( f \"resource: { resource } , time: { timeout * i } secs\" ) try : out = __parse_out__ ( db [ 'resources_queues' ][ resource ]) out [ \"status\" ] = \"AVAILABLE\" except KeyError : return try : out [ \"url\" ] = client_kvac . get_hls_streaming_session_url ( ** req )[ 'HLSStreamingSessionURL' ] db [ 'resources_queues' ][ resource ] = out try : sleep ( destroytime ) except Exception : pass finally : out [ \"status\" ] = \"GONE\" print ( out [ \"status\" ]) db [ 'resources_queues' ][ resource ] = out return \"\"\" try: while True: sleep(destroytime) print(client_kvac.get_hls_streaming_session_url(**req)['HLSStreamingSessionURL']) except Exception as e: out[\"status\"]=\"GONE\" print (out[\"status\"]) db['resources_queues'][resource]=out return \"\"\" except KeyError as e : return except Exception as e : out [ \"status\" ] = \"PENDING\" print ( out [ \"status\" ]) db [ 'resources_queues' ][ resource ] = out print ( out [ \"status\" ]) sleep ( timeout ) try : out = __parse_out__ ( db [ 'resources_queues' ][ resource ]) out [ \"status\" ] = \"TIMEOUT\" print ( out [ \"status\" ]) db [ 'resources_queues' ][ resource ] = out except KeyError : pass def start_stream ( resource = None ): out = {} outcode = 200 if resource is None : resource = resources [ int ( random () * 100 ) % resources . __len__ ()] u = Cognito ( ** conf [ \"aws\" ][ \"pool\" ]) u . authenticate ( conf [ \"aws\" ][ \"pwd\" ]) url = \"https://api.wsn-cloud.com/api/portal/post_command\" data = { \"wsn_sn\" : resource , \"command_code\" : 8 , \"command_args\" :[ \"1\" ]} headers = { \"Authorization\" : u . id_token } res = requests . post ( url = url , json = data , headers = headers ) print ( res . __dict__ ) if res . status_code in [ 200 , 409 ]: try : out = __parse_out__ ( db [ 'resources_queues' ][ resource ]) if out [ 'status' ] in [ \"TIMEOUT\" , \"GONE\" ]: db [ 'resources_queues' ] . pop ([ out [ 'resource' ], out [ 'queue' ]]) raise KeyError () except KeyError as e : db [ 'resources_queues' ][ resource , uuid ()] = { \"status\" : \"INIT\" , \"timestamp\" : str ( datetime . now ()), \"url\" : None } out = db [ 'resources_queues' ][ resource ] Thread ( target = manage_stream , args = ( resource ,), daemon = True ) . start () else : outcode = 404 return __parse_out__ ( out ), outcode def get_stream ( queue ): out = {} outcode = 200 if queue is None : outcode = 400 else : try : out = db [ 'resources_queues' ][:, queue ] except KeyError as e : outcode = 404 return __parse_out__ ( out ), outcode","title":"Module hielen3.tools.hls_facility_old"},{"location":"reference/hielen3/tools/hls_facility_old/#variables","text":"conf db resources","title":"Variables"},{"location":"reference/hielen3/tools/hls_facility_old/#functions","text":"","title":"Functions"},{"location":"reference/hielen3/tools/hls_facility_old/#get_stream","text":"def get_stream ( queue ) View Source def get_stream ( queue ) : out = {} outcode = 200 if queue is None : outcode = 400 else : try : out = db [ 'resources_queues' ][:, queue ] except KeyError as e : outcode = 404 return __parse_out__ ( out ) , outcode","title":"get_stream"},{"location":"reference/hielen3/tools/hls_facility_old/#manage_stream","text":"def manage_stream ( resource , timeout = 10 , times = 20 , destroytime = 300 ) View Source def manage_stream ( resource , timeout = 10 , times = 20 , destroytime = 300 ) : session = Session ( ** conf [ \"aws\" ][ \"options\" ] ) try : endpoint = session . client ( 'kinesisvideo' ). get_data_endpoint ( StreamName = f 'stream-{resource}' , APIName = 'GET_HLS_STREAMING_SESSION_URL' ) [ 'DataEndpoint' ] client_kvac = session . client ( 'kinesis-video-archived-media' , endpoint_url = endpoint ) except Exception : return req = { \"StreamName\" : f \"stream-{resource}\" , \"PlaybackMode\" : \"LIVE\" , \"HLSFragmentSelector\" : { \"FragmentSelectorType\" : \"PRODUCER_TIMESTAMP\" } , \"ContainerFormat\" : \"FRAGMENTED_MP4\" , \"DiscontinuityMode\" : \"ALWAYS\" , \"DisplayFragmentTimestamp\" : \"ALWAYS\" , } for i in range ( times ) : print ( f \"resource: {resource}, time: {timeout*i} secs\" ) try : out = __parse_out__ ( db [ 'resources_queues' ][ resource ] ) out [ \"status\" ]= \"AVAILABLE\" except KeyError : return try : out [ \"url\" ]= client_kvac . get_hls_streaming_session_url ( ** req ) [ 'HLSStreamingSessionURL' ] db [ 'resources_queues' ][ resource ]= out try : sleep ( destroytime ) except Exception : pass finally : out [ \"status\" ]= \"GONE\" print ( out [ \"status\" ] ) db [ 'resources_queues' ][ resource ]= out return \"\"\" try: while True: sleep(destroytime) print(client_kvac.get_hls_streaming_session_url(**req)['HLSStreamingSessionURL']) except Exception as e: out[\" status \"]=\" GONE \" print (out[\" status \"]) db['resources_queues'][resource]=out return \"\"\" except KeyError as e : return except Exception as e : out [ \"status\" ]= \"PENDING\" print ( out [ \"status\" ] ) db [ 'resources_queues' ][ resource ]= out print ( out [ \"status\" ] ) sleep ( timeout ) try : out = __parse_out__ ( db [ 'resources_queues' ][ resource ] ) out [ \"status\" ]= \"TIMEOUT\" print ( out [ \"status\" ] ) db [ 'resources_queues' ][ resource ]= out except KeyError : pass","title":"manage_stream"},{"location":"reference/hielen3/tools/hls_facility_old/#random","text":"def random ( ) random() -> x in the interval [0, 1).","title":"random"},{"location":"reference/hielen3/tools/hls_facility_old/#start_stream","text":"def start_stream ( resource = None ) View Source def start_stream ( resource = None ) : out = {} outcode = 200 if resource is None : resource = resources [ int(random()*100)%resources.__len__() ] u = Cognito ( ** conf [ \"aws\" ][ \"pool\" ] ) u . authenticate ( conf [ \"aws\" ][ \"pwd\" ] ) url = \"https://api.wsn-cloud.com/api/portal/post_command\" data = { \"wsn_sn\" : resource , \"command_code\" : 8 , \"command_args\" : [ \"1\" ] } headers = { \"Authorization\" : u . id_token } res = requests . post ( url = url , json = data , headers = headers ) print ( res . __dict__ ) if res . status_code in [ 200, 409 ] : try : out = __parse_out__ ( db [ 'resources_queues' ][ resource ] ) if out [ 'status' ] in [ \"TIMEOUT\",\"GONE\" ] : db [ 'resources_queues' ] . pop ( [ out['resource' ] , out [ 'queue' ] ] ) raise KeyError () except KeyError as e : db [ 'resources_queues' ][ resource,uuid() ]= { \"status\" : \"INIT\" , \"timestamp\" : str ( datetime . now ()), \"url\" : None } out = db [ 'resources_queues' ][ resource ] Thread ( target = manage_stream , args = ( resource ,), daemon = True ). start () else : outcode = 404 return __parse_out__ ( out ), outcode","title":"start_stream"}]}