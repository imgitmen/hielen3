{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"HIELEN Prototipazione degli elementi prototypes Api dedicata alle tipologie di elementi e alle azioni (di input) specifiche. Le azioni sono statiche, nel senso che devono essere approntate in modo programmatico. Attualmente sono: config feed Ci\u00f2 che \u00e8 dinaminco \u00e8 il modo in cui le singole tipologie implementano queste azioni. Questa api serve a conoscere i campi da presentare in front-end all'utente per comporre la maschera di azione. POST {uri}/prototypes GET {uri}/prototypes GET {uri}/prototypes/{type} GET {uri}/prototypes/{type}/forms GET {uri}/prototypes/{type}/forms/{form} tutte le UI create in questo modo saranno aperte su uno specifico elemento del sistema il cui codice \u00e8 noto. Il submit della form invier\u00e0 le informazioni ad una url di questo genere: {uri}/actions/{el}/{action} con un mimetype di tipo multipart/form-data Manipolazione elenco elementi elements Api dedicata agli elementi del sistema: il succo della faccenda. Considerazione: gli elementi sono oggetti che producono \"elaborazioni\" nel tempo con un caratteristico grado dimensionale (dato, mappe, nuvole). E' sempre possibile \"proiettare\" una \"elaborazione\" con grado maggiore su una di grado inferiore. Cos\u00ec da una nuvola pu\u00f2 generare mappe e dalla nuvola o dalle mappe possono essere estratte delle serie storiche. nota 1 : Nelle api di input/output non viene mai specificato il tipo dell'elemento. Questo perch\u00e8: 1. Ad ogni elemento DEVE corrispondere Uno ed Un solo tipo. Questa non \u00e8 una restrizione troppo forzata perch\u00e8 \u00e8 sempre possibile definiere elementi nuovi spazialmente coincidenti. 2. Per il motivo precedente il back-end \u00e8 sempre in grado di recuperare il tipo dell'elemento. nota 2 : La \"mappa degli strumenti\" pu\u00f2 essere considerata essa stessa un elemento di tipo mappa... POST {uri}/elements/ GET {uri}/elements/ GET {uri}/elements/{el} DELETE {uri}/elements/{el} PUT {uri}/elements/{el} Interrogazione elementi: operazioni di output L'interrogazione pu\u00f2 riguardare pi\u00f9 di un elemento contemporaneamente ed \u00e8 rivolta in questo modo: sitema --> utente Per questo motivo la struttura della richiesta prevede di specificare prima l'azione ( base , timeline , series , map , cloud ) e poi eventualmente l'elemento. nota 1 : non tutte queste api saranno disponibili per tutti gli elementi. Per ogni elemento sar\u00e0 noto l'elenco a disposizone tramite backend (presumibilemnte attraverso GET {uri}/elements/[{el}]) series GET {uri}/data GET {uri}/data/{el} GET {uri}/data/{el}/{param} bases GET {uri}/bases GET {uri}/bases/{el} timelines GET {uri}/timelines GET {uri}/timelines/{el} maps GET {uri}/maps/[/z/x/y] GET {uri}/maps/{el}/[z/x/y] clouds GET {uri}/clouds GET {uri}/clouds/{el} Azioni sugli elementi: operazioni di input In questo caso le azioni servono a modificare lo stato di un elemento: sistema <-- utente la richiesta viene composta specificando necessariamente l'elemento prima dell'azione. nota 1 : queste trovano riscontro nell'endpoint forms dell'api prototypes. actions Le due azioni attualemente previste sono: config POST {uri}/actions/{el}/config GET {uri}/actions/{el}/config PUT {uri}/actions/{el}/config feed POST {uri}/actions/{el}/feed GET {uri}/actions/{el}/feed PUT {uri}/actions/{el}/feed/{time}","title":"Home"},{"location":"#hielen","text":"","title":"HIELEN"},{"location":"#prototipazione-degli-elementi","text":"","title":"Prototipazione degli elementi"},{"location":"#prototypes","text":"Api dedicata alle tipologie di elementi e alle azioni (di input) specifiche. Le azioni sono statiche, nel senso che devono essere approntate in modo programmatico. Attualmente sono: config feed Ci\u00f2 che \u00e8 dinaminco \u00e8 il modo in cui le singole tipologie implementano queste azioni. Questa api serve a conoscere i campi da presentare in front-end all'utente per comporre la maschera di azione. POST {uri}/prototypes GET {uri}/prototypes GET {uri}/prototypes/{type} GET {uri}/prototypes/{type}/forms GET {uri}/prototypes/{type}/forms/{form} tutte le UI create in questo modo saranno aperte su uno specifico elemento del sistema il cui codice \u00e8 noto. Il submit della form invier\u00e0 le informazioni ad una url di questo genere: {uri}/actions/{el}/{action} con un mimetype di tipo multipart/form-data","title":"prototypes"},{"location":"#manipolazione-elenco-elementi","text":"","title":"Manipolazione elenco elementi"},{"location":"#elements","text":"Api dedicata agli elementi del sistema: il succo della faccenda. Considerazione: gli elementi sono oggetti che producono \"elaborazioni\" nel tempo con un caratteristico grado dimensionale (dato, mappe, nuvole). E' sempre possibile \"proiettare\" una \"elaborazione\" con grado maggiore su una di grado inferiore. Cos\u00ec da una nuvola pu\u00f2 generare mappe e dalla nuvola o dalle mappe possono essere estratte delle serie storiche. nota 1 : Nelle api di input/output non viene mai specificato il tipo dell'elemento. Questo perch\u00e8: 1. Ad ogni elemento DEVE corrispondere Uno ed Un solo tipo. Questa non \u00e8 una restrizione troppo forzata perch\u00e8 \u00e8 sempre possibile definiere elementi nuovi spazialmente coincidenti. 2. Per il motivo precedente il back-end \u00e8 sempre in grado di recuperare il tipo dell'elemento. nota 2 : La \"mappa degli strumenti\" pu\u00f2 essere considerata essa stessa un elemento di tipo mappa... POST {uri}/elements/ GET {uri}/elements/ GET {uri}/elements/{el} DELETE {uri}/elements/{el} PUT {uri}/elements/{el}","title":"elements"},{"location":"#interrogazione-elementi-operazioni-di-output","text":"L'interrogazione pu\u00f2 riguardare pi\u00f9 di un elemento contemporaneamente ed \u00e8 rivolta in questo modo: sitema --> utente Per questo motivo la struttura della richiesta prevede di specificare prima l'azione ( base , timeline , series , map , cloud ) e poi eventualmente l'elemento. nota 1 : non tutte queste api saranno disponibili per tutti gli elementi. Per ogni elemento sar\u00e0 noto l'elenco a disposizone tramite backend (presumibilemnte attraverso GET {uri}/elements/[{el}])","title":"Interrogazione elementi: operazioni di output"},{"location":"#series","text":"GET {uri}/data GET {uri}/data/{el} GET {uri}/data/{el}/{param}","title":"series"},{"location":"#bases","text":"GET {uri}/bases GET {uri}/bases/{el}","title":"bases"},{"location":"#timelines","text":"GET {uri}/timelines GET {uri}/timelines/{el}","title":"timelines"},{"location":"#maps","text":"GET {uri}/maps/[/z/x/y] GET {uri}/maps/{el}/[z/x/y]","title":"maps"},{"location":"#clouds","text":"GET {uri}/clouds GET {uri}/clouds/{el}","title":"clouds"},{"location":"#azioni-sugli-elementi-operazioni-di-input","text":"In questo caso le azioni servono a modificare lo stato di un elemento: sistema <-- utente la richiesta viene composta specificando necessariamente l'elemento prima dell'azione. nota 1 : queste trovano riscontro nell'endpoint forms dell'api prototypes.","title":"Azioni sugli elementi: operazioni di input"},{"location":"#actions","text":"Le due azioni attualemente previste sono: config POST {uri}/actions/{el}/config GET {uri}/actions/{el}/config PUT {uri}/actions/{el}/config feed POST {uri}/actions/{el}/feed GET {uri}/actions/{el}/feed PUT {uri}/actions/{el}/feed/{time}","title":"actions"},{"location":"CHANGELOG/","text":"CHANGELOG 2.0.3 November 11 2020 Modificata api POST /elements/ : la variabile element \u00e8 descritta dalla Classe hielen2.api.data.ElementSchema e validata. In paricolare \u00e8 stato introdotto l'attibuto context Modifcata api GET /data/ : la variabile datamap \u00e8 descritta dalla Classe hielen2.api.data.DataMapSchema e validata. Introdotta la classe hielen2.utils.JsonValidable, per la validazione e documentazione automatica dei parametri delle api (JSON Schema descrition) corretti bug minori in hielen2.datalink 2.0.2 November 6 2020 L'interfaccia DB \u00e8 ora thread safe!!! (almeno per il dummy json db) Implementata la documentazione automatica delle api Implementate le api POST ../elements e DELETE ../elements L'uscita per tutte le api element (e per tutte le api con risposta json in generale), seguir\u00e0 questo schema: { \"meta\": { \"data_type\": \"DELETE /elements/ciao\", \"response\": \"ok\" \"message\": \"\", }, \"data\":{ ... } } L'api ../series diventa ../data e cambia il suo comportamento: la variabile di tipo json datamap si aspetta il campo series invece di parameters . In questo campo devono essere inseriti i codici delle serie e non pi\u00f9 il costrutto \"codice_elemento:parametro_elemento\". I codici delle serie si possono recuperarare dall'api ../elements (vedi Nota successiva) L'api ../elements cambia la sua risposta e per ogni parametro nella lista parameters degli elementi viene agiunto il codice della serie di riferimento che pu\u00f2 essere fornito senza modifiche a data : { \"series\":<seriescode>, \"name\":<seriesname>, \"um\":<seriesunit> }","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"","title":"CHANGELOG"},{"location":"CHANGELOG/#203-november-11-2020","text":"Modificata api POST /elements/ : la variabile element \u00e8 descritta dalla Classe hielen2.api.data.ElementSchema e validata. In paricolare \u00e8 stato introdotto l'attibuto context Modifcata api GET /data/ : la variabile datamap \u00e8 descritta dalla Classe hielen2.api.data.DataMapSchema e validata. Introdotta la classe hielen2.utils.JsonValidable, per la validazione e documentazione automatica dei parametri delle api (JSON Schema descrition) corretti bug minori in hielen2.datalink","title":"2.0.3 November 11 2020"},{"location":"CHANGELOG/#202-november-6-2020","text":"L'interfaccia DB \u00e8 ora thread safe!!! (almeno per il dummy json db) Implementata la documentazione automatica delle api Implementate le api POST ../elements e DELETE ../elements L'uscita per tutte le api element (e per tutte le api con risposta json in generale), seguir\u00e0 questo schema: { \"meta\": { \"data_type\": \"DELETE /elements/ciao\", \"response\": \"ok\" \"message\": \"\", }, \"data\":{ ... } } L'api ../series diventa ../data e cambia il suo comportamento: la variabile di tipo json datamap si aspetta il campo series invece di parameters . In questo campo devono essere inseriti i codici delle serie e non pi\u00f9 il costrutto \"codice_elemento:parametro_elemento\". I codici delle serie si possono recuperarare dall'api ../elements (vedi Nota successiva) L'api ../elements cambia la sua risposta e per ogni parametro nella lista parameters degli elementi viene agiunto il codice della serie di riferimento che pu\u00f2 essere fornito senza modifiche a data : { \"series\":<seriescode>, \"name\":<seriesname>, \"um\":<seriesunit> }","title":"2.0.2 November 6 2020"},{"location":"TODO/","text":"scrivere il TODO :-)","title":"TODO"},{"location":"docs/API%20Reference/data/","text":"Data /data/ GET params : datamap : JSON Schema [{ timeto : str|bytes, series : [str|bytes], timefrom : str|bytes}] content_type : Basic text / string value result : format : Supports any of the following formats: Free form UTF-8 text, JSON (Javascript Serialized Object Notation) content_type : text/plain; charset=utf-8, application/json; charset=utf-8 description : if isinstance (datamap,list): datamap=','.join(datamap) try: loaded=json.loads(datamap) except json.JSONDecodeError as e: out = ResponseFormatter(status=falcon.HTTP_BAD_REQUEST) out.message=str(e) response = out.format(response=response,request=request) return /data/{el}/ GET params : el : Basic text / string value par : Basic text / string value timefrom : Basic text / string value timeto : Basic text / string value content_type : Basic text / string value result : format : Supports any of the following formats: Free form UTF-8 text, JSON (Javascript Serialized Object Notation) content_type : text/plain; charset=utf-8, application/json; charset=utf-8 /data/{el}/{par} GET params : el : Basic text / string value par : Basic text / string value timefrom : Basic text / string value timeto : Basic text / string value content_type : Basic text / string value result : format : Supports any of the following formats: Free form UTF-8 text, JSON (Javascript Serialized Object Notation) content_type : text/plain; charset=utf-8, application/json; charset=utf-8","title":"Data"},{"location":"docs/API%20Reference/data/#data","text":"","title":"Data"},{"location":"docs/API%20Reference/data/#data_1","text":"","title":"/data/"},{"location":"docs/API%20Reference/data/#get","text":"params : datamap : JSON Schema [{ timeto : str|bytes, series : [str|bytes], timefrom : str|bytes}] content_type : Basic text / string value result : format : Supports any of the following formats: Free form UTF-8 text, JSON (Javascript Serialized Object Notation) content_type : text/plain; charset=utf-8, application/json; charset=utf-8 description : if isinstance (datamap,list): datamap=','.join(datamap) try: loaded=json.loads(datamap) except json.JSONDecodeError as e: out = ResponseFormatter(status=falcon.HTTP_BAD_REQUEST) out.message=str(e) response = out.format(response=response,request=request) return","title":"GET"},{"location":"docs/API%20Reference/data/#datael","text":"","title":"/data/{el}/"},{"location":"docs/API%20Reference/data/#get_1","text":"params : el : Basic text / string value par : Basic text / string value timefrom : Basic text / string value timeto : Basic text / string value content_type : Basic text / string value result : format : Supports any of the following formats: Free form UTF-8 text, JSON (Javascript Serialized Object Notation) content_type : text/plain; charset=utf-8, application/json; charset=utf-8","title":"GET"},{"location":"docs/API%20Reference/data/#dataelpar","text":"","title":"/data/{el}/{par}"},{"location":"docs/API%20Reference/data/#get_2","text":"params : el : Basic text / string value par : Basic text / string value timefrom : Basic text / string value timeto : Basic text / string value content_type : Basic text / string value result : format : Supports any of the following formats: Free form UTF-8 text, JSON (Javascript Serialized Object Notation) content_type : text/plain; charset=utf-8, application/json; charset=utf-8","title":"GET"},{"location":"docs/API%20Reference/elements/","text":"Elements /elements/ POST params : element : JSON Schema { description : str|bytes, style : str|bytes, geom : str|bytes, label : str|bytes, status : str|bytes, prototype : str|bytes, context : str|bytes, uuid : str|bytes} result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Api di creazione degli elementi. Ogni elemento deve avere il suo codice univoco uuid e il suo prototipo prototype . Il prototipo dell'elemento forisce informazioni per l'inizializazione della struttura. Possibili risposte: 409 Conflict : Nel caso in cui il codice fornito esista gi\u00e0. 404 Not Found : Nel caso in cui il prototipo richiesto non esista. 201 Created : Nel caso in cui l'elemento venga creato correttamente. GET params : elist : Basic text / string value context : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 /elements/{uuid} GET params : uuid : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 DELETE params : uuid : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8","title":"Elements"},{"location":"docs/API%20Reference/elements/#elements","text":"","title":"Elements"},{"location":"docs/API%20Reference/elements/#elements_1","text":"","title":"/elements/"},{"location":"docs/API%20Reference/elements/#post","text":"params : element : JSON Schema { description : str|bytes, style : str|bytes, geom : str|bytes, label : str|bytes, status : str|bytes, prototype : str|bytes, context : str|bytes, uuid : str|bytes} result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 description : Api di creazione degli elementi. Ogni elemento deve avere il suo codice univoco uuid e il suo prototipo prototype . Il prototipo dell'elemento forisce informazioni per l'inizializazione della struttura. Possibili risposte: 409 Conflict : Nel caso in cui il codice fornito esista gi\u00e0. 404 Not Found : Nel caso in cui il prototipo richiesto non esista. 201 Created : Nel caso in cui l'elemento venga creato correttamente.","title":"POST"},{"location":"docs/API%20Reference/elements/#get","text":"params : elist : Basic text / string value context : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8","title":"GET"},{"location":"docs/API%20Reference/elements/#elementsuuid","text":"","title":"/elements/{uuid}"},{"location":"docs/API%20Reference/elements/#get_1","text":"params : uuid : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8","title":"GET"},{"location":"docs/API%20Reference/elements/#delete","text":"params : uuid : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8","title":"DELETE"},{"location":"docs/API%20Reference/prototypes/","text":"Prototypes /prototypes/ POST params : prototype : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 GET result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 /prototypes/{prototype} GET params : prototype : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 /prototypes/{prototype}/forms GET params : prototype : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 /prototypes/{prototype}/forms/{form} GET params : prototype : Basic text / string value form : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8 /prototypes/{prototype}/struct GET params : prototype : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8","title":"Prototypes"},{"location":"docs/API%20Reference/prototypes/#prototypes","text":"","title":"Prototypes"},{"location":"docs/API%20Reference/prototypes/#prototypes_1","text":"","title":"/prototypes/"},{"location":"docs/API%20Reference/prototypes/#post","text":"params : prototype : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8","title":"POST"},{"location":"docs/API%20Reference/prototypes/#get","text":"result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8","title":"GET"},{"location":"docs/API%20Reference/prototypes/#prototypesprototype","text":"","title":"/prototypes/{prototype}"},{"location":"docs/API%20Reference/prototypes/#get_1","text":"params : prototype : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8","title":"GET"},{"location":"docs/API%20Reference/prototypes/#prototypesprototypeforms","text":"","title":"/prototypes/{prototype}/forms"},{"location":"docs/API%20Reference/prototypes/#get_2","text":"params : prototype : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8","title":"GET"},{"location":"docs/API%20Reference/prototypes/#prototypesprototypeformsform","text":"","title":"/prototypes/{prototype}/forms/{form}"},{"location":"docs/API%20Reference/prototypes/#get_3","text":"params : prototype : Basic text / string value form : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8","title":"GET"},{"location":"docs/API%20Reference/prototypes/#prototypesprototypestruct","text":"","title":"/prototypes/{prototype}/struct"},{"location":"docs/API%20Reference/prototypes/#get_4","text":"params : prototype : Basic text / string value result : format : JSON (Javascript Serialized Object Notation) content_type : application/json; charset=utf-8","title":"GET"},{"location":"reference/hielen2/","text":"Module hielen2 View Source # coding=utf-8 __name__ = 'hielen2' __version__ = '2.0.3' __author__ = 'Alessandro Modesti' __email__ = 'it@img-srl.com' __description__ = 'Multidimention Hierarichical Elaboration Engine' __license__ = 'MIT' __uri__ = '' import warnings from .datalink import dbinit #, cacheinit from .utils import loadjsonfile conf = loadjsonfile ( './conf/hielen.json' ) db = dbinit ( conf ) def int_or_str ( value ): try : return int ( value ) except ValueError : return value VERSION = tuple ( map ( int_or_str , __version__ . split ( '.' ))) __all__ = [ 'api' , 'conf' , 'db' , ] Sub-modules hielen2.api hielen2.data hielen2.datalink hielen2.utils Variables conf db","title":"Index"},{"location":"reference/hielen2/#module-hielen2","text":"View Source # coding=utf-8 __name__ = 'hielen2' __version__ = '2.0.3' __author__ = 'Alessandro Modesti' __email__ = 'it@img-srl.com' __description__ = 'Multidimention Hierarichical Elaboration Engine' __license__ = 'MIT' __uri__ = '' import warnings from .datalink import dbinit #, cacheinit from .utils import loadjsonfile conf = loadjsonfile ( './conf/hielen.json' ) db = dbinit ( conf ) def int_or_str ( value ): try : return int ( value ) except ValueError : return value VERSION = tuple ( map ( int_or_str , __version__ . split ( '.' ))) __all__ = [ 'api' , 'conf' , 'db' , ]","title":"Module hielen2"},{"location":"reference/hielen2/#sub-modules","text":"hielen2.api hielen2.data hielen2.datalink hielen2.utils","title":"Sub-modules"},{"location":"reference/hielen2/#variables","text":"conf db","title":"Variables"},{"location":"reference/hielen2/datalink/","text":"Module hielen2.datalink View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 #!/usr/bin/env python # coding=utf-8 from pandas import DataFrame , read_json from abc import ABC , abstractmethod from hielen2.utils import loadjsonfile , savejsonfile , newinstanceof , hashfile from filelock import Timeout , FileLock from numpy import nan def dbinit ( conf ): conf [ 'substs' ] return { k : newinstanceof ( w [ 'klass' ], w [ 'connection' ] . format ( ** conf [ 'substs' ])) for k , w in conf [ 'db' ] . items () } class DB ( ABC ): @abstractmethod def __init__ ( self , connection ): pass @abstractmethod def __getitem__ ( self , key ): pass @abstractmethod def __setitem__ ( self , key , value ): pass @abstractmethod def pop ( self , key ): pass class JsonDB ( DB ): def __init__ ( self , connection , timeout = 10 ): self . jsonfile = connection self . lock = FileLock ( f \" { connection } .lock\" , timeout = 10 ) self . md5file = f \" { connection } .md5\" self . md5 = None self . __chk_and_reload_jsondb ( force = True ) def __chk_and_reload_jsondb ( self , force = False ): ''' Needs to check for json-database file changes in a thread safe way!! ''' md5 = None error = None try : self . lock . acquire () try : with open ( force and '' or self . md5file ) as o : md5 = o . read () if not md5 == self . md5 : self . md5 = md5 self . db = read_json ( self . jsonfile ) except FileNotFoundError as e : ## refershing hash self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , 'w' ) as o : o . write ( self . md5 ) self . db = read_json ( self . jsonfile ) finally : self . lock . release () except Timeout : pass def save ( self ): try : self . lock . acquire () try : self . db . to_json ( self . jsonfile ) self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , 'w' ) as o : o . write ( self . md5 ) finally : self . lock . release () except Timeout as e : #Just to remind Timout error here raise e def __write_jsondb ( self , key , value ): ''' Needs to lock for writing json-database ''' item = None error = None try : self . lock . acquire () try : self . __chk_and_reload_jsondb () if value is None : #Request to remove key, raises KeyError item = self . db [ key ] . to_dict () self . db = self . db . drop ( key , axis = 1 ) else : #Request to insert key, raises ValueError value [ 'uuid' ] = key value = DataFrame ([ value ]) . T value . columns = [ key ] self . db = self . db . join ( value , how = 'left' ) self . db [ key ] . replace ({ nan : None }, inplace = True ) item = self . db [ key ] . to_dict () self . save () except KeyError : error = KeyError ( f 'key { key } to remove does not exist' ) except ValueError : error = ValueError ( f 'key { key } to insert exists' ) finally : self . lock . release () except Timeout as e : error = e if error is not None : raise error return item def __getitem__ ( self , key = None ): self . __chk_and_reload_jsondb () if isinstance ( key , list ): try : key = list ( filter ( None , key )) except TypeError : pass if key is None : return self . db . to_dict () return self . db [ key ] . to_dict () def pop ( self , key ): return self . __write_jsondb ( key , None ) def __setitem__ ( self , key = None , value = None ): self . __write_jsondb ( key , value ) class JsonCache ( DB ): def __init__ ( self , connection ): self . cache = read_json ( connection , convert_dates = False ) . set_index ([ 'uuid' , 'timestamp' ])[ 'value' ] . sort_index () self . filename = connection def __getitem__ ( self , key ): return self . cache [ key ] def __setitem__ ( self , key , value ): pass def pop ( self , key ): pass def save ( self ): self . cache . reset_index () . to_json ( self . filename , orient = 'records' ) Variables nan Functions dbinit def dbinit ( conf ) View Source def dbinit ( conf ): conf [ 'substs' ] return { k : newinstanceof ( w [ 'klass' ], w [ 'connection' ]. format ( ** conf [ 'substs' ])) for k , w in conf [ 'db' ]. items () } Classes DB class DB ( connection ) Helper class that provides a standard way to create an ABC using inheritance. View Source class DB ( ABC ) : @abstractmethod def __init__ ( self , connection ) : pass @abstractmethod def __getitem__ ( self , key ) : pass @abstractmethod def __setitem__ ( self , key , value ) : pass @abstractmethod def pop ( self , key ) : pass Ancestors (in MRO) abc.ABC Descendants hielen2.datalink.JsonDB hielen2.datalink.JsonCache Methods pop def pop ( self , key ) View Source @abstractmethod def pop ( self , key ) : pass JsonCache class JsonCache ( connection ) Helper class that provides a standard way to create an ABC using inheritance. View Source class JsonCache ( DB ) : def __init__ ( self , connection ) : self . cache = read_json ( connection , convert_dates = False ). set_index ( [ 'uuid','timestamp' ] ) [ 'value' ] . sort_index () self . filename = connection def __getitem__ ( self , key ) : return self . cache [ key ] def __setitem__ ( self , key , value ) : pass def pop ( self , key ) : pass def save ( self ) : self . cache . reset_index (). to_json ( self . filename , orient = 'records' ) Ancestors (in MRO) hielen2.datalink.DB abc.ABC Methods pop def pop ( self , key ) View Source def pop ( self , key ): pass save def save ( self ) View Source def save ( self ): self . cache . reset_index (). to_json ( self . filename , orient = 'records' ) JsonDB class JsonDB ( connection , timeout = 10 ) Helper class that provides a standard way to create an ABC using inheritance. View Source class JsonDB ( DB ) : def __init__ ( self , connection , timeout = 10 ) : self . jsonfile = connection self . lock = FileLock ( f \"{connection}.lock\" , timeout = 10 ) self . md5file = f \"{connection}.md5\" self . md5 = None self . __chk_and_reload_jsondb ( force = True ) def __chk_and_reload_jsondb ( self , force = False ) : ''' Needs to check for json-database file changes in a thread safe way!! ''' md5 = None error = None try : self . lock . acquire () try : with open ( force and '' or self . md5file ) as o : md5 = o . read () if not md5 == self . md5 : self . md5 = md5 self . db = read_json ( self . jsonfile ) except FileNotFoundError as e : ## refershing hash self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , 'w' ) as o : o . write ( self . md5 ) self . db = read_json ( self . jsonfile ) finally : self . lock . release () except Timeout : pass def save ( self ) : try : self . lock . acquire () try : self . db . to_json ( self . jsonfile ) self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , 'w' ) as o : o . write ( self . md5 ) finally : self . lock . release () except Timeout as e : #Just to remind Timout error here raise e def __write_jsondb ( self , key , value ) : ''' Needs to lock for writing json-database ''' item = None error = None try : self . lock . acquire () try : self . __chk_and_reload_jsondb () if value is None : #Request to remove key , raises KeyError item = self . db [ key ] . to_dict () self . db = self . db . drop ( key , axis = 1 ) else : #Request to insert key , raises ValueError value [ 'uuid' ]= key value = DataFrame ( [ value ] ). T value . columns =[ key ] self . db = self . db . join ( value , how = 'left' ) self . db [ key ] . replace ( { nan : None } , inplace = True ) item = self . db [ key ] . to_dict () self . save () except KeyError : error = KeyError ( f 'key {key} to remove does not exist' ) except ValueError : error = ValueError ( f 'key {key} to insert exists' ) finally : self . lock . release () except Timeout as e : error = e if error is not None : raise error return item def __getitem__ ( self , key = None ) : self . __chk_and_reload_jsondb () if isinstance ( key , list ) : try : key = list ( filter ( None , key )) except TypeError : pass if key is None : return self . db . to_dict () return self . db [ key ] . to_dict () def pop ( self , key ) : return self . __write_jsondb ( key , None ) def __setitem__ ( self , key = None , value = None ) : self . __write_jsondb ( key , value ) Ancestors (in MRO) hielen2.datalink.DB abc.ABC Methods pop def pop ( self , key ) View Source def pop ( self , key ): return self . __write_jsondb ( key , None ) save def save ( self ) View Source def save ( self ): try : self . lock . acquire () try : self . db . to_json ( self . jsonfile ) self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , 'w' ) as o : o . write ( self . md5 ) finally : self . lock . release () except Timeout as e : # Just to remind Timout error here raise e","title":"Datalink"},{"location":"reference/hielen2/datalink/#module-hielen2datalink","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 #!/usr/bin/env python # coding=utf-8 from pandas import DataFrame , read_json from abc import ABC , abstractmethod from hielen2.utils import loadjsonfile , savejsonfile , newinstanceof , hashfile from filelock import Timeout , FileLock from numpy import nan def dbinit ( conf ): conf [ 'substs' ] return { k : newinstanceof ( w [ 'klass' ], w [ 'connection' ] . format ( ** conf [ 'substs' ])) for k , w in conf [ 'db' ] . items () } class DB ( ABC ): @abstractmethod def __init__ ( self , connection ): pass @abstractmethod def __getitem__ ( self , key ): pass @abstractmethod def __setitem__ ( self , key , value ): pass @abstractmethod def pop ( self , key ): pass class JsonDB ( DB ): def __init__ ( self , connection , timeout = 10 ): self . jsonfile = connection self . lock = FileLock ( f \" { connection } .lock\" , timeout = 10 ) self . md5file = f \" { connection } .md5\" self . md5 = None self . __chk_and_reload_jsondb ( force = True ) def __chk_and_reload_jsondb ( self , force = False ): ''' Needs to check for json-database file changes in a thread safe way!! ''' md5 = None error = None try : self . lock . acquire () try : with open ( force and '' or self . md5file ) as o : md5 = o . read () if not md5 == self . md5 : self . md5 = md5 self . db = read_json ( self . jsonfile ) except FileNotFoundError as e : ## refershing hash self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , 'w' ) as o : o . write ( self . md5 ) self . db = read_json ( self . jsonfile ) finally : self . lock . release () except Timeout : pass def save ( self ): try : self . lock . acquire () try : self . db . to_json ( self . jsonfile ) self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , 'w' ) as o : o . write ( self . md5 ) finally : self . lock . release () except Timeout as e : #Just to remind Timout error here raise e def __write_jsondb ( self , key , value ): ''' Needs to lock for writing json-database ''' item = None error = None try : self . lock . acquire () try : self . __chk_and_reload_jsondb () if value is None : #Request to remove key, raises KeyError item = self . db [ key ] . to_dict () self . db = self . db . drop ( key , axis = 1 ) else : #Request to insert key, raises ValueError value [ 'uuid' ] = key value = DataFrame ([ value ]) . T value . columns = [ key ] self . db = self . db . join ( value , how = 'left' ) self . db [ key ] . replace ({ nan : None }, inplace = True ) item = self . db [ key ] . to_dict () self . save () except KeyError : error = KeyError ( f 'key { key } to remove does not exist' ) except ValueError : error = ValueError ( f 'key { key } to insert exists' ) finally : self . lock . release () except Timeout as e : error = e if error is not None : raise error return item def __getitem__ ( self , key = None ): self . __chk_and_reload_jsondb () if isinstance ( key , list ): try : key = list ( filter ( None , key )) except TypeError : pass if key is None : return self . db . to_dict () return self . db [ key ] . to_dict () def pop ( self , key ): return self . __write_jsondb ( key , None ) def __setitem__ ( self , key = None , value = None ): self . __write_jsondb ( key , value ) class JsonCache ( DB ): def __init__ ( self , connection ): self . cache = read_json ( connection , convert_dates = False ) . set_index ([ 'uuid' , 'timestamp' ])[ 'value' ] . sort_index () self . filename = connection def __getitem__ ( self , key ): return self . cache [ key ] def __setitem__ ( self , key , value ): pass def pop ( self , key ): pass def save ( self ): self . cache . reset_index () . to_json ( self . filename , orient = 'records' )","title":"Module hielen2.datalink"},{"location":"reference/hielen2/datalink/#variables","text":"nan","title":"Variables"},{"location":"reference/hielen2/datalink/#functions","text":"","title":"Functions"},{"location":"reference/hielen2/datalink/#dbinit","text":"def dbinit ( conf ) View Source def dbinit ( conf ): conf [ 'substs' ] return { k : newinstanceof ( w [ 'klass' ], w [ 'connection' ]. format ( ** conf [ 'substs' ])) for k , w in conf [ 'db' ]. items () }","title":"dbinit"},{"location":"reference/hielen2/datalink/#classes","text":"","title":"Classes"},{"location":"reference/hielen2/datalink/#db","text":"class DB ( connection ) Helper class that provides a standard way to create an ABC using inheritance. View Source class DB ( ABC ) : @abstractmethod def __init__ ( self , connection ) : pass @abstractmethod def __getitem__ ( self , key ) : pass @abstractmethod def __setitem__ ( self , key , value ) : pass @abstractmethod def pop ( self , key ) : pass","title":"DB"},{"location":"reference/hielen2/datalink/#ancestors-in-mro","text":"abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen2/datalink/#descendants","text":"hielen2.datalink.JsonDB hielen2.datalink.JsonCache","title":"Descendants"},{"location":"reference/hielen2/datalink/#methods","text":"","title":"Methods"},{"location":"reference/hielen2/datalink/#pop","text":"def pop ( self , key ) View Source @abstractmethod def pop ( self , key ) : pass","title":"pop"},{"location":"reference/hielen2/datalink/#jsoncache","text":"class JsonCache ( connection ) Helper class that provides a standard way to create an ABC using inheritance. View Source class JsonCache ( DB ) : def __init__ ( self , connection ) : self . cache = read_json ( connection , convert_dates = False ). set_index ( [ 'uuid','timestamp' ] ) [ 'value' ] . sort_index () self . filename = connection def __getitem__ ( self , key ) : return self . cache [ key ] def __setitem__ ( self , key , value ) : pass def pop ( self , key ) : pass def save ( self ) : self . cache . reset_index (). to_json ( self . filename , orient = 'records' )","title":"JsonCache"},{"location":"reference/hielen2/datalink/#ancestors-in-mro_1","text":"hielen2.datalink.DB abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen2/datalink/#methods_1","text":"","title":"Methods"},{"location":"reference/hielen2/datalink/#pop_1","text":"def pop ( self , key ) View Source def pop ( self , key ): pass","title":"pop"},{"location":"reference/hielen2/datalink/#save","text":"def save ( self ) View Source def save ( self ): self . cache . reset_index (). to_json ( self . filename , orient = 'records' )","title":"save"},{"location":"reference/hielen2/datalink/#jsondb","text":"class JsonDB ( connection , timeout = 10 ) Helper class that provides a standard way to create an ABC using inheritance. View Source class JsonDB ( DB ) : def __init__ ( self , connection , timeout = 10 ) : self . jsonfile = connection self . lock = FileLock ( f \"{connection}.lock\" , timeout = 10 ) self . md5file = f \"{connection}.md5\" self . md5 = None self . __chk_and_reload_jsondb ( force = True ) def __chk_and_reload_jsondb ( self , force = False ) : ''' Needs to check for json-database file changes in a thread safe way!! ''' md5 = None error = None try : self . lock . acquire () try : with open ( force and '' or self . md5file ) as o : md5 = o . read () if not md5 == self . md5 : self . md5 = md5 self . db = read_json ( self . jsonfile ) except FileNotFoundError as e : ## refershing hash self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , 'w' ) as o : o . write ( self . md5 ) self . db = read_json ( self . jsonfile ) finally : self . lock . release () except Timeout : pass def save ( self ) : try : self . lock . acquire () try : self . db . to_json ( self . jsonfile ) self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , 'w' ) as o : o . write ( self . md5 ) finally : self . lock . release () except Timeout as e : #Just to remind Timout error here raise e def __write_jsondb ( self , key , value ) : ''' Needs to lock for writing json-database ''' item = None error = None try : self . lock . acquire () try : self . __chk_and_reload_jsondb () if value is None : #Request to remove key , raises KeyError item = self . db [ key ] . to_dict () self . db = self . db . drop ( key , axis = 1 ) else : #Request to insert key , raises ValueError value [ 'uuid' ]= key value = DataFrame ( [ value ] ). T value . columns =[ key ] self . db = self . db . join ( value , how = 'left' ) self . db [ key ] . replace ( { nan : None } , inplace = True ) item = self . db [ key ] . to_dict () self . save () except KeyError : error = KeyError ( f 'key {key} to remove does not exist' ) except ValueError : error = ValueError ( f 'key {key} to insert exists' ) finally : self . lock . release () except Timeout as e : error = e if error is not None : raise error return item def __getitem__ ( self , key = None ) : self . __chk_and_reload_jsondb () if isinstance ( key , list ) : try : key = list ( filter ( None , key )) except TypeError : pass if key is None : return self . db . to_dict () return self . db [ key ] . to_dict () def pop ( self , key ) : return self . __write_jsondb ( key , None ) def __setitem__ ( self , key = None , value = None ) : self . __write_jsondb ( key , value )","title":"JsonDB"},{"location":"reference/hielen2/datalink/#ancestors-in-mro_2","text":"hielen2.datalink.DB abc.ABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen2/datalink/#methods_2","text":"","title":"Methods"},{"location":"reference/hielen2/datalink/#pop_2","text":"def pop ( self , key ) View Source def pop ( self , key ): return self . __write_jsondb ( key , None )","title":"pop"},{"location":"reference/hielen2/datalink/#save_1","text":"def save ( self ) View Source def save ( self ): try : self . lock . acquire () try : self . db . to_json ( self . jsonfile ) self . md5 = hashfile ( self . jsonfile ) with open ( self . md5file , 'w' ) as o : o . write ( self . md5 ) finally : self . lock . release () except Timeout as e : # Just to remind Timout error here raise e","title":"save"},{"location":"reference/hielen2/utils/","text":"Module hielen2.utils View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 #!/usr/bin/env python # coding=utf-8 from datetime import datetime from re import split , sub , findall from time import mktime import json from importlib import import_module from falcon import HTTPNotAcceptable from hashlib import md5 from marshmallow import Schema , fields def hug_output_format_conten_type ( handlers = [], error = 'The requested format does not match any of those allowed' , ctpar = 'content_type' ): \"\"\"Returns a different handler depending on the input param ctpar If none match and no default is given falcon.HTTPNotAcceptable(error) is raised \"\"\" try : default = handlers [ 0 ] except Exception : default = None handlers = { h . content_type : h for h in handlers } def requested_output_type ( request = None ): try : par = request . _params [ ctpar ] handler = None for k , h in handlers . items (): if par . split ( ';' )[ 0 ] == k . split ( ';' )[ 0 ]: handler = h break except Exception : if default is not None : handler = default if handler is None : raise HTTPNotAcceptable ( error ) return handler def output_type ( data , request , response ): handler = requested_output_type ( request ) response . content_type = handler . content_type return handler ( data , request = request , response = response ) output_type . __doc__ = \"Supports any of the following formats: {0} \" . format ( \", \" . join ( function . __doc__ for function in handlers . values ())) output_type . content_type = \", \" . join ( handlers . keys ()) output_type . requested = requested_output_type return output_type def newinstanceof ( klass , * args , ** kwargs ): klass_ar = klass . split ( '.' ) module = '.' . join ( klass_ar [: - 1 ]) klass = klass_ar [ - 1 ] return getattr ( import_module ( module ), klass )( * args , ** kwargs ) def ut2isot ( u = None ): u = u or 1 return str ( datetime . fromtimestamp ( u )) def isot2ut ( t = None ): t = t or \"1970-01-01T01:00:01.00000Z\" dt = datetime ( * map ( int , split ( '[^\\d]' , sub ( '[^\\d]$' , '' , t )))) return int ( mktime ( dt . timetuple ())) def loadjsonfile ( filename ): with open ( filename ) as jf : return json . load ( jf ) def savejsonfile ( filename , struct ): with open ( filename , 'w' ) as jf : json . dump ( struct , jf ) def eprint ( * args , fname = 'error' , ** kwargs ): with open ( fname , 'a' ) as f : print ( * args , file = f , ** kwargs ) def hashfile ( filename ): BLOCKSIZE = 65536 hasher = md5 () with open ( filename , 'rb' ) as afile : buf = afile . read ( BLOCKSIZE ) while len ( buf ) > 0 : hasher . update ( buf ) buf = afile . read ( BLOCKSIZE ) return hasher . hexdigest () class JsonValidable (): \"\"\" JSON Validator class. It is initailzed with a marshmallow.Schema instance. When __call__ function is invoked, \\ uses marshmallow facilities to validate the json and raise errors. Once initalized, changes __doc__ in order to descibe the json accepted. \"\"\" def __field_doc__ ( self , field ): required = field . required and \"!\" or \"\" allow_none = not field . allow_none and \"!\" or \"\" try : types = \"|\" . join ( self . TYPE_MAPPING [ field . __class__ ]) except KeyError : if field . __class__ is fields . List : f , required , allow_none = self . __field_doc__ ( field . inner ) types = f \"[ { f } ]\" elif field . __class__ is fields . Dict : kf , required , allow_none = self . __field_doc__ ( field . key_field ) vf , required , allow_none = self . __field_doc__ ( field . value_field ) types = f \" {{ { kf } , { vf } }} \" else : types = \"\" return ( types , required , allow_none ) def __schema_doc__ ( self ): flds = [] for n , f in self . schema . fields . items (): types , required , allow_none = self . __field_doc__ ( f ) #TODO formattare required e allow_none #flds.append( f\"**{n}**{required}{allow_none}: {types}\") flds . append ( f \"** { n } **: { types } \" ) fields = \", \" . join ( flds ) fields = f \" {{ { fields } }} \" if self . schema . many : fields = f \"[ { fields } ]\" return f \"JSON Schema { fields } \" def __init__ ( self , schema ): self . schema = schema self . TYPE_MAPPING = {} for k , w in self . schema . TYPE_MAPPING . items (): try : self . TYPE_MAPPING [ w ] . append ( findall ( r \"'(.*)'\" , str ( k ))[ 0 ]) except KeyError : self . TYPE_MAPPING [ w ] = [ findall ( r \"'(.*)'\" , str ( k ))[ 0 ]] self . __doc__ = str ( self . __schema_doc__ ()) def __call__ ( self , value ): if type ( value ) is list : # If Falcon is set to comma-separate entries, this segment joins them again. fixed_value = \",\" . join ( value ) else : fixed_value = value return self . schema . loads ( fixed_value ) Functions eprint def eprint ( * args , fname = 'error' , ** kwargs ) View Source def eprint ( * args , fname = 'error' , ** kwargs ): with open ( fname , 'a' ) as f : print ( * args , file = f , ** kwargs ) hashfile def hashfile ( filename ) View Source def hashfile ( filename ): BLOCKSIZE = 65536 hasher = md5 () with open ( filename , 'rb' ) as afile : buf = afile . read ( BLOCKSIZE ) while len ( buf ) > 0 : hasher . update ( buf ) buf = afile . read ( BLOCKSIZE ) return hasher . hexdigest () hug_output_format_conten_type def hug_output_format_conten_type ( handlers = [], error = 'The requested format does not match any of those allowed' , ctpar = 'content_type' ) Returns a different handler depending on the input param ctpar If none match and no default is given falcon.HTTPNotAcceptable(error) is raised View Source def hug_output_format_conten_type ( handlers = [] , error = 'The requested format does not match any of those allowed' , ctpar = 'content_type' ) : \"\"\"Returns a different handler depending on the input param ctpar If none match and no default is given falcon.HTTPNotAcceptable(error) is raised \"\"\" try : default = handlers [ 0 ] except Exception : default = None handlers = { h . content_type : h for h in handlers } def requested_output_type ( request = None ) : try : par = request . _params [ ctpar ] handler = None for k , h in handlers . items () : if par . split ( ';' ) [ 0 ] == k . split ( ';' ) [ 0 ] : handler = h break except Exception : if default is not None : handler = default if handler is None : raise HTTPNotAcceptable ( error ) return handler def output_type ( data , request , response ) : handler = requested_output_type ( request ) response . content_type = handler . content_type return handler ( data , request = request , response = response ) output_type . __doc__ = \"Supports any of the following formats: {0}\" . format ( \", \" . join ( function . __doc__ for function in handlers . values ())) output_type . content_type = \", \" . join ( handlers . keys ()) output_type . requested = requested_output_type return output_type isot2ut def isot2ut ( t = None ) View Source def isot2ut ( t = None ): t = t or \"1970-01-01T01:00:01.00000Z\" dt = datetime ( * map ( int , split ( '[^\\d]' , sub ( '[^\\d]$' , '' , t )))) return int ( mktime ( dt . timetuple ())) loadjsonfile def loadjsonfile ( filename ) View Source def loadjsonfile ( filename ): with open ( filename ) as jf : return json . load ( jf ) newinstanceof def newinstanceof ( klass , * args , ** kwargs ) View Source def newinstanceof ( klass , * args , **kwargs ) : klass_ar = klass . split ( '.' ) module='.' . join ( klass_ar [:- 1 ]) klass = klass_ar [ - 1 ] return getattr ( import_module ( module ), klass )( * args , **kwargs ) savejsonfile def savejsonfile ( filename , struct ) View Source def savejsonfile ( filename , struct ): with open ( filename , 'w' ) as jf : json . dump ( struct , jf ) ut2isot def ut2isot ( u = None ) View Source def ut2isot ( u = None ): u = u or 1 return str ( datetime . fromtimestamp ( u )) Classes JsonValidable class JsonValidable ( schema ) JSON Validator class. It is initailzed with a marshmallow.Schema instance. When call function is invoked, uses marshmallow facilities to validate the json and raise errors. Once initalized, changes doc in order to descibe the json accepted. View Source class JsonValidable () : \"\"\" JSON Validator class. It is initailzed with a marshmallow.Schema instance. When __call__ function is invoked, \\ uses marshmallow facilities to validate the json and raise errors. Once initalized, changes __doc__ in order to descibe the json accepted. \"\"\" def __field_doc__ ( self , field ) : required = field . required and \"!\" or \"\" allow_none = not field . allow_none and \"!\" or \"\" try : types = \"|\" . join ( self . TYPE_MAPPING [ field.__class__ ] ) except KeyError : if field . __class__ is fields . List : f , required , allow_none = self . __field_doc__ ( field . inner ) types = f \"[{f}]\" elif field . __class__ is fields . Dict : kf , required , allow_none = self . __field_doc__ ( field . key_field ) vf , required , allow_none = self . __field_doc__ ( field . value_field ) types = f \"{{{kf},{vf}}}\" else : types = \"\" return ( types , required , allow_none ) def __schema_doc__ ( self ) : flds = [] for n , f in self . schema . fields . items () : types , required , allow_none = self . __field_doc__ ( f ) #TODO formattare required e allow_none #flds . append ( f \"**{n}**{required}{allow_none}: {types}\" ) flds . append ( f \"**{n}**: {types}\" ) fields = \", \" . join ( flds ) fields = f \"{{{fields}}}\" if self . schema . many : fields = f \"[{fields}]\" return f \"JSON Schema {fields}\" def __init__ ( self , schema ) : self . schema = schema self . TYPE_MAPPING = {} for k , w in self . schema . TYPE_MAPPING . items () : try : self . TYPE_MAPPING [ w ] . append ( findall ( r \"'(.*)'\" , str ( k )) [ 0 ] ) except KeyError : self . TYPE_MAPPING [ w ]=[ findall(r\"'(.*)'\",str(k))[0 ] ] self . __doc__ = str ( self . __schema_doc__ ()) def __call__ ( self , value ) : if type ( value ) is list : # If Falcon is set to comma - separate entries , this segment joins them again . fixed_value = \",\" . join ( value ) else : fixed_value = value return self . schema . loads ( fixed_value )","title":"Utils"},{"location":"reference/hielen2/utils/#module-hielen2utils","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 #!/usr/bin/env python # coding=utf-8 from datetime import datetime from re import split , sub , findall from time import mktime import json from importlib import import_module from falcon import HTTPNotAcceptable from hashlib import md5 from marshmallow import Schema , fields def hug_output_format_conten_type ( handlers = [], error = 'The requested format does not match any of those allowed' , ctpar = 'content_type' ): \"\"\"Returns a different handler depending on the input param ctpar If none match and no default is given falcon.HTTPNotAcceptable(error) is raised \"\"\" try : default = handlers [ 0 ] except Exception : default = None handlers = { h . content_type : h for h in handlers } def requested_output_type ( request = None ): try : par = request . _params [ ctpar ] handler = None for k , h in handlers . items (): if par . split ( ';' )[ 0 ] == k . split ( ';' )[ 0 ]: handler = h break except Exception : if default is not None : handler = default if handler is None : raise HTTPNotAcceptable ( error ) return handler def output_type ( data , request , response ): handler = requested_output_type ( request ) response . content_type = handler . content_type return handler ( data , request = request , response = response ) output_type . __doc__ = \"Supports any of the following formats: {0} \" . format ( \", \" . join ( function . __doc__ for function in handlers . values ())) output_type . content_type = \", \" . join ( handlers . keys ()) output_type . requested = requested_output_type return output_type def newinstanceof ( klass , * args , ** kwargs ): klass_ar = klass . split ( '.' ) module = '.' . join ( klass_ar [: - 1 ]) klass = klass_ar [ - 1 ] return getattr ( import_module ( module ), klass )( * args , ** kwargs ) def ut2isot ( u = None ): u = u or 1 return str ( datetime . fromtimestamp ( u )) def isot2ut ( t = None ): t = t or \"1970-01-01T01:00:01.00000Z\" dt = datetime ( * map ( int , split ( '[^\\d]' , sub ( '[^\\d]$' , '' , t )))) return int ( mktime ( dt . timetuple ())) def loadjsonfile ( filename ): with open ( filename ) as jf : return json . load ( jf ) def savejsonfile ( filename , struct ): with open ( filename , 'w' ) as jf : json . dump ( struct , jf ) def eprint ( * args , fname = 'error' , ** kwargs ): with open ( fname , 'a' ) as f : print ( * args , file = f , ** kwargs ) def hashfile ( filename ): BLOCKSIZE = 65536 hasher = md5 () with open ( filename , 'rb' ) as afile : buf = afile . read ( BLOCKSIZE ) while len ( buf ) > 0 : hasher . update ( buf ) buf = afile . read ( BLOCKSIZE ) return hasher . hexdigest () class JsonValidable (): \"\"\" JSON Validator class. It is initailzed with a marshmallow.Schema instance. When __call__ function is invoked, \\ uses marshmallow facilities to validate the json and raise errors. Once initalized, changes __doc__ in order to descibe the json accepted. \"\"\" def __field_doc__ ( self , field ): required = field . required and \"!\" or \"\" allow_none = not field . allow_none and \"!\" or \"\" try : types = \"|\" . join ( self . TYPE_MAPPING [ field . __class__ ]) except KeyError : if field . __class__ is fields . List : f , required , allow_none = self . __field_doc__ ( field . inner ) types = f \"[ { f } ]\" elif field . __class__ is fields . Dict : kf , required , allow_none = self . __field_doc__ ( field . key_field ) vf , required , allow_none = self . __field_doc__ ( field . value_field ) types = f \" {{ { kf } , { vf } }} \" else : types = \"\" return ( types , required , allow_none ) def __schema_doc__ ( self ): flds = [] for n , f in self . schema . fields . items (): types , required , allow_none = self . __field_doc__ ( f ) #TODO formattare required e allow_none #flds.append( f\"**{n}**{required}{allow_none}: {types}\") flds . append ( f \"** { n } **: { types } \" ) fields = \", \" . join ( flds ) fields = f \" {{ { fields } }} \" if self . schema . many : fields = f \"[ { fields } ]\" return f \"JSON Schema { fields } \" def __init__ ( self , schema ): self . schema = schema self . TYPE_MAPPING = {} for k , w in self . schema . TYPE_MAPPING . items (): try : self . TYPE_MAPPING [ w ] . append ( findall ( r \"'(.*)'\" , str ( k ))[ 0 ]) except KeyError : self . TYPE_MAPPING [ w ] = [ findall ( r \"'(.*)'\" , str ( k ))[ 0 ]] self . __doc__ = str ( self . __schema_doc__ ()) def __call__ ( self , value ): if type ( value ) is list : # If Falcon is set to comma-separate entries, this segment joins them again. fixed_value = \",\" . join ( value ) else : fixed_value = value return self . schema . loads ( fixed_value )","title":"Module hielen2.utils"},{"location":"reference/hielen2/utils/#functions","text":"","title":"Functions"},{"location":"reference/hielen2/utils/#eprint","text":"def eprint ( * args , fname = 'error' , ** kwargs ) View Source def eprint ( * args , fname = 'error' , ** kwargs ): with open ( fname , 'a' ) as f : print ( * args , file = f , ** kwargs )","title":"eprint"},{"location":"reference/hielen2/utils/#hashfile","text":"def hashfile ( filename ) View Source def hashfile ( filename ): BLOCKSIZE = 65536 hasher = md5 () with open ( filename , 'rb' ) as afile : buf = afile . read ( BLOCKSIZE ) while len ( buf ) > 0 : hasher . update ( buf ) buf = afile . read ( BLOCKSIZE ) return hasher . hexdigest ()","title":"hashfile"},{"location":"reference/hielen2/utils/#hug_output_format_conten_type","text":"def hug_output_format_conten_type ( handlers = [], error = 'The requested format does not match any of those allowed' , ctpar = 'content_type' ) Returns a different handler depending on the input param ctpar If none match and no default is given falcon.HTTPNotAcceptable(error) is raised View Source def hug_output_format_conten_type ( handlers = [] , error = 'The requested format does not match any of those allowed' , ctpar = 'content_type' ) : \"\"\"Returns a different handler depending on the input param ctpar If none match and no default is given falcon.HTTPNotAcceptable(error) is raised \"\"\" try : default = handlers [ 0 ] except Exception : default = None handlers = { h . content_type : h for h in handlers } def requested_output_type ( request = None ) : try : par = request . _params [ ctpar ] handler = None for k , h in handlers . items () : if par . split ( ';' ) [ 0 ] == k . split ( ';' ) [ 0 ] : handler = h break except Exception : if default is not None : handler = default if handler is None : raise HTTPNotAcceptable ( error ) return handler def output_type ( data , request , response ) : handler = requested_output_type ( request ) response . content_type = handler . content_type return handler ( data , request = request , response = response ) output_type . __doc__ = \"Supports any of the following formats: {0}\" . format ( \", \" . join ( function . __doc__ for function in handlers . values ())) output_type . content_type = \", \" . join ( handlers . keys ()) output_type . requested = requested_output_type return output_type","title":"hug_output_format_conten_type"},{"location":"reference/hielen2/utils/#isot2ut","text":"def isot2ut ( t = None ) View Source def isot2ut ( t = None ): t = t or \"1970-01-01T01:00:01.00000Z\" dt = datetime ( * map ( int , split ( '[^\\d]' , sub ( '[^\\d]$' , '' , t )))) return int ( mktime ( dt . timetuple ()))","title":"isot2ut"},{"location":"reference/hielen2/utils/#loadjsonfile","text":"def loadjsonfile ( filename ) View Source def loadjsonfile ( filename ): with open ( filename ) as jf : return json . load ( jf )","title":"loadjsonfile"},{"location":"reference/hielen2/utils/#newinstanceof","text":"def newinstanceof ( klass , * args , ** kwargs ) View Source def newinstanceof ( klass , * args , **kwargs ) : klass_ar = klass . split ( '.' ) module='.' . join ( klass_ar [:- 1 ]) klass = klass_ar [ - 1 ] return getattr ( import_module ( module ), klass )( * args , **kwargs )","title":"newinstanceof"},{"location":"reference/hielen2/utils/#savejsonfile","text":"def savejsonfile ( filename , struct ) View Source def savejsonfile ( filename , struct ): with open ( filename , 'w' ) as jf : json . dump ( struct , jf )","title":"savejsonfile"},{"location":"reference/hielen2/utils/#ut2isot","text":"def ut2isot ( u = None ) View Source def ut2isot ( u = None ): u = u or 1 return str ( datetime . fromtimestamp ( u ))","title":"ut2isot"},{"location":"reference/hielen2/utils/#classes","text":"","title":"Classes"},{"location":"reference/hielen2/utils/#jsonvalidable","text":"class JsonValidable ( schema ) JSON Validator class. It is initailzed with a marshmallow.Schema instance. When call function is invoked, uses marshmallow facilities to validate the json and raise errors. Once initalized, changes doc in order to descibe the json accepted. View Source class JsonValidable () : \"\"\" JSON Validator class. It is initailzed with a marshmallow.Schema instance. When __call__ function is invoked, \\ uses marshmallow facilities to validate the json and raise errors. Once initalized, changes __doc__ in order to descibe the json accepted. \"\"\" def __field_doc__ ( self , field ) : required = field . required and \"!\" or \"\" allow_none = not field . allow_none and \"!\" or \"\" try : types = \"|\" . join ( self . TYPE_MAPPING [ field.__class__ ] ) except KeyError : if field . __class__ is fields . List : f , required , allow_none = self . __field_doc__ ( field . inner ) types = f \"[{f}]\" elif field . __class__ is fields . Dict : kf , required , allow_none = self . __field_doc__ ( field . key_field ) vf , required , allow_none = self . __field_doc__ ( field . value_field ) types = f \"{{{kf},{vf}}}\" else : types = \"\" return ( types , required , allow_none ) def __schema_doc__ ( self ) : flds = [] for n , f in self . schema . fields . items () : types , required , allow_none = self . __field_doc__ ( f ) #TODO formattare required e allow_none #flds . append ( f \"**{n}**{required}{allow_none}: {types}\" ) flds . append ( f \"**{n}**: {types}\" ) fields = \", \" . join ( flds ) fields = f \"{{{fields}}}\" if self . schema . many : fields = f \"[{fields}]\" return f \"JSON Schema {fields}\" def __init__ ( self , schema ) : self . schema = schema self . TYPE_MAPPING = {} for k , w in self . schema . TYPE_MAPPING . items () : try : self . TYPE_MAPPING [ w ] . append ( findall ( r \"'(.*)'\" , str ( k )) [ 0 ] ) except KeyError : self . TYPE_MAPPING [ w ]=[ findall(r\"'(.*)'\",str(k))[0 ] ] self . __doc__ = str ( self . __schema_doc__ ()) def __call__ ( self , value ) : if type ( value ) is list : # If Falcon is set to comma - separate entries , this segment joins them again . fixed_value = \",\" . join ( value ) else : fixed_value = value return self . schema . loads ( fixed_value )","title":"JsonValidable"},{"location":"reference/hielen2/api/","text":"Module hielen2.api Sub-modules hielen2.api.data hielen2.api.elements hielen2.api.glob hielen2.api.prototypes","title":"Index"},{"location":"reference/hielen2/api/#module-hielen2api","text":"","title":"Module hielen2.api"},{"location":"reference/hielen2/api/#sub-modules","text":"hielen2.api.data hielen2.api.elements hielen2.api.glob hielen2.api.prototypes","title":"Sub-modules"},{"location":"reference/hielen2/api/data/","text":"Module hielen2.api.data View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 #!/usr/bin/env python # coding=utf-8 import hug import falcon import json from marshmallow import Schema , fields from numpy import nan , unique from pandas import DataFrame , to_datetime from hielen2 import db from hielen2.data.data_access_layer import Series from hielen2.utils import hug_output_format_conten_type , JsonValidable from himada.api import ResponseFormatter import asyncio data_out_handler = hug_output_format_conten_type ([ hug . output_format . text , hug . output_format . json ]) CSV = \"text/plain; charset=utf-8\" JSON = \"application/json; charset=utf-8\" class DataMapSchema ( Schema ): \"\"\" \"\"\" timefrom = fields . Str ( default = None , required = False ) timeto = fields . Str ( default = None , reuired = False ) series = fields . List ( fields . Str , default = []) ####### API DATATABLE ####### @hug . get ( '/' , examples = '' , output = data_out_handler ) def tabular_data ( datamap : JsonValidable ( DataMapSchema ( many = True )), content_type = None , request = None , response = None ): \"\"\" if isinstance (datamap,list): datamap=','.join(datamap) try: loaded=json.loads(datamap) except json.JSONDecodeError as e: out = ResponseFormatter(status=falcon.HTTP_BAD_REQUEST) out.message=str(e) response = out.format(response=response,request=request) return \"\"\" series = {} for s in datamap : try : timefrom = s [ 'timefrom' ] except KeyError : timefrom = None try : timeto = s [ 'timeto' ] except KeyError : timeto = None for p in s [ 'series' ]: if p not in series . keys (): series [ p ] = [] try : series [ p ] . append ( Series ( p ) . thdata ( timefrom = timefrom , timeto = timeto ) ) except KeyError as e : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = str ( e ) + \" not found\" response = out . format ( response = response , request = request ) return out = DataFrame () for param , sers in series . items (): ser = None for r in sers : s = r . result () if ser is None : ser = s else : ser = ser . append ( s ) . sort_index () idx = unique ( ser . index . values , return_index = True )[ 1 ] ser = ser . iloc [ idx ] ser . columns = [ param ] out = out . join ( ser , how = 'outer' ) out . index . name = 'timestamp' requested = data_out_handler . requested ( request ) . content_type if ( requested == CSV ): return hug . types . text ( out . to_csv ()) if ( requested == JSON ): return hug . types . json ( out . to_json ( orient = 'table' )) @hug . get ( '/ {el} /' , output = data_out_handler ) def tabular_data_el ( el , par = None , timefrom = None , timeto = None , content_type = None , request = None , response = None ): try : element = db [ 'elements' ][ el ] except KeyError : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = str ( el ) + \" not found\" response = out . format ( response = response , request = request ) return try : if par is None : parameters = [ f \" { element [ 'uuid' ] } : { e } \" for e in element [ 'parameters' ] . keys () ] else : parameters = [ f \" { element [ 'uuid' ] } : { par } \" ] except KeyError as e : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = str ( e ) + \" not found\" response = out . format ( response = response , request = request ) return datamap = dict ( parameters = parameters ) if timefrom is not None : datamap [ 'timefrom' ] = timefrom if timeto is not None : datamap [ 'timeto' ] = timeto return tabular_data ( datamap = json . dumps ([ datamap ]), request = request , response = response ) @hug . get ( '/ {el} / {par} ' , output = data_out_handler ) def tabular_data_par ( el = None , par = None , timefrom = None , timeto = None , content_type = None , request = None , response = None ): return tabular_data_el ( el = el , par = par , timefrom = timefrom , timeto = timeto , request = request , response = response ) Variables CSV JSON db nan Functions data_out_handler def data_out_handler ( data , request , response ) Supports any of the following formats: Free form UTF-8 text, JSON (Javascript Serialized Object Notation) View Source def output_type ( data , request , response ): handler = requested_output_type ( request ) response . content_type = handler . content_type return handler ( data , request = request , response = response ) tabular_data def tabular_data ( datamap : < hielen2 . utils . JsonValidable object at 0x7f77d8ff5d60 > , content_type = None , request = None , response = None ) if isinstance (datamap,list): datamap=','.join(datamap) try: loaded=json.loads(datamap) except json.JSONDecodeError as e: out = ResponseFormatter(status=falcon.HTTP_BAD_REQUEST) out.message=str(e) response = out.format(response=response,request=request) return View Source @hug . get ( '/' , examples = '' , output = data_out_handler ) def tabular_data ( datamap : JsonValidable ( DataMapSchema ( many = True )), content_type = None , request = None , response = None ) : \"\"\" if isinstance (datamap,list): datamap=','.join(datamap) try: loaded=json.loads(datamap) except json.JSONDecodeError as e: out = ResponseFormatter(status=falcon.HTTP_BAD_REQUEST) out.message=str(e) response = out.format(response=response,request=request) return \"\"\" series = {} for s in datamap : try : timefrom = s [ 'timefrom' ] except KeyError : timefrom = None try : timeto = s [ 'timeto' ] except KeyError : timeto = None for p in s [ 'series' ] : if p not in series . keys () : series [ p ]= [] try : series [ p ] . append ( Series ( p ). thdata ( timefrom = timefrom , timeto = timeto ) ) except KeyError as e : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = str ( e ) + \" not found\" response = out . format ( response = response , request = request ) return out = DataFrame () for param , sers in series . items () : ser = None for r in sers : s = r . result () if ser is None : ser = s else : ser = ser . append ( s ). sort_index () idx = unique ( ser . index . values , return_index = True ) [ 1 ] ser = ser . iloc [ idx ] ser . columns =[ param ] out = out . join ( ser , how = 'outer' ) out . index . name = 'timestamp' requested = data_out_handler . requested ( request ). content_type if ( requested == CSV ) : return hug . types . text ( out . to_csv ()) if ( requested == JSON ) : return hug . types . json ( out . to_json ( orient = 'table' )) tabular_data_el def tabular_data_el ( el , par = None , timefrom = None , timeto = None , content_type = None , request = None , response = None ) View Source @hug . get ( '/{el}/' , output = data_out_handler ) def tabular_data_el ( el , par = None , timefrom = None , timeto = None , content_type = None , request = None , response = None ) : try : element = db [ 'elements' ][ el ] except KeyError : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = str ( el ) + \" not found\" response = out . format ( response = response , request = request ) return try : if par is None : parameters =[ f\"{element['uuid' ] }:{ e } \" for e in element['parameters'].keys() ] else: parameters=[ f\" { element [ 'uuid' ] }:{ par } \" ] except KeyError as e: out = ResponseFormatter(status=falcon.HTTP_NOT_FOUND) out.message=str(e) + \" not found \" response = out . format ( response = response , request = request ) return datamap = dict ( parameters = parameters ) if timefrom is not None : datamap [ 'timefrom' ]= timefrom if timeto is not None : datamap [ 'timeto' ]= timeto return tabular_data ( datamap = json . dumps ( [ datamap ] ), request = request , response = response ) tabular_data_par def tabular_data_par ( el = None , par = None , timefrom = None , timeto = None , content_type = None , request = None , response = None ) View Source @hug . get ( '/{el}/{par}' , output = data_out_handler ) def tabular_data_par ( el = None , par = None , timefrom = None , timeto = None , content_type = None , request = None , response = None ) : return tabular_data_el ( el = el , par = par , timefrom = timefrom , timeto = timeto , request = request , response = response ) Classes DataMapSchema class DataMapSchema ( * , only : Union [ Sequence [ str ], Set [ str ], NoneType ] = None , exclude : Union [ Sequence [ str ], Set [ str ]] = (), many : bool = False , context : Union [ Dict , NoneType ] = None , load_only : Union [ Sequence [ str ], Set [ str ]] = (), dump_only : Union [ Sequence [ str ], Set [ str ]] = (), partial : Union [ bool , Sequence [ str ], Set [ str ]] = False , unknown : Union [ str , NoneType ] = None ) View Source class DataMapSchema ( Schema ): \"\"\" \"\"\" timefrom = fields . Str ( default = None , required = False ) timeto = fields . Str ( default = None , reuired = False ) series = fields . List ( fields . Str , default =[]) Ancestors (in MRO) marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING error_messages opts series timefrom timeto Static methods from_dict def from_dict ( fields : Dict [ str , Union [ marshmallow . fields . Field , type ]], * , name : str = 'GeneratedSchema' ) -> type Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 View Source @classmethod def from_dict ( cls , fields : typing . Dict [ str , typing . Union [ ma_fields . Field , type ]], * , name : str = \"GeneratedSchema\" ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : Any , * , many : Union [ bool , NoneType ] = None ) Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : typing . Optional [ bool ] = None ): \"\"\"Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\"\" many = self . many if many is None else bool ( many ) if many and is_iterable_but_not_string ( obj ): obj = list ( obj ) if self . _has_processors ( PRE_DUMP ): processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ): result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : Any , * args , many : Union [ bool , NoneType ] = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A json string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : typing . Optional [ bool ] = None , ** kwargs ): \"\"\"Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\"\" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : Any , attr : str , default : Any ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ): \"\"\"Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\"\" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : marshmallow . exceptions . ValidationError , data : Any , * , many : bool , ** kwargs ) Custom error handler function for the schema. :param error: The ValidationError raised during (de)serialization. :param data: The original input data. :param many: Value of many on dump or load. :param partial: Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ): \"\"\"Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\"\" pass load def load ( self , data : Union [ Mapping [ str , Any ], Iterable [ Mapping [ str , Any ]]], * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None ) Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : typing . Union [ typing . Mapping [ str , typing . Any ], typing . Iterable [ typing . Mapping [ str , typing . Any ]], ], * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None ): \"\"\"Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : str , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize obj as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None , ** kwargs ): \"\"\"Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : str , field_obj : marshmallow . fields . Field ) -> None Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \"\"\"Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\"\" return None validate def validate ( self , data : Mapping , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None ) -> Dict [ str , List [ str ]] Validate data against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : typing . Mapping , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None ) -> typing . Dict [ str , typing . List [ str ]]: \"\"\"Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\"\" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]], exc . messages ) return {}","title":"Data"},{"location":"reference/hielen2/api/data/#module-hielen2apidata","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 #!/usr/bin/env python # coding=utf-8 import hug import falcon import json from marshmallow import Schema , fields from numpy import nan , unique from pandas import DataFrame , to_datetime from hielen2 import db from hielen2.data.data_access_layer import Series from hielen2.utils import hug_output_format_conten_type , JsonValidable from himada.api import ResponseFormatter import asyncio data_out_handler = hug_output_format_conten_type ([ hug . output_format . text , hug . output_format . json ]) CSV = \"text/plain; charset=utf-8\" JSON = \"application/json; charset=utf-8\" class DataMapSchema ( Schema ): \"\"\" \"\"\" timefrom = fields . Str ( default = None , required = False ) timeto = fields . Str ( default = None , reuired = False ) series = fields . List ( fields . Str , default = []) ####### API DATATABLE ####### @hug . get ( '/' , examples = '' , output = data_out_handler ) def tabular_data ( datamap : JsonValidable ( DataMapSchema ( many = True )), content_type = None , request = None , response = None ): \"\"\" if isinstance (datamap,list): datamap=','.join(datamap) try: loaded=json.loads(datamap) except json.JSONDecodeError as e: out = ResponseFormatter(status=falcon.HTTP_BAD_REQUEST) out.message=str(e) response = out.format(response=response,request=request) return \"\"\" series = {} for s in datamap : try : timefrom = s [ 'timefrom' ] except KeyError : timefrom = None try : timeto = s [ 'timeto' ] except KeyError : timeto = None for p in s [ 'series' ]: if p not in series . keys (): series [ p ] = [] try : series [ p ] . append ( Series ( p ) . thdata ( timefrom = timefrom , timeto = timeto ) ) except KeyError as e : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = str ( e ) + \" not found\" response = out . format ( response = response , request = request ) return out = DataFrame () for param , sers in series . items (): ser = None for r in sers : s = r . result () if ser is None : ser = s else : ser = ser . append ( s ) . sort_index () idx = unique ( ser . index . values , return_index = True )[ 1 ] ser = ser . iloc [ idx ] ser . columns = [ param ] out = out . join ( ser , how = 'outer' ) out . index . name = 'timestamp' requested = data_out_handler . requested ( request ) . content_type if ( requested == CSV ): return hug . types . text ( out . to_csv ()) if ( requested == JSON ): return hug . types . json ( out . to_json ( orient = 'table' )) @hug . get ( '/ {el} /' , output = data_out_handler ) def tabular_data_el ( el , par = None , timefrom = None , timeto = None , content_type = None , request = None , response = None ): try : element = db [ 'elements' ][ el ] except KeyError : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = str ( el ) + \" not found\" response = out . format ( response = response , request = request ) return try : if par is None : parameters = [ f \" { element [ 'uuid' ] } : { e } \" for e in element [ 'parameters' ] . keys () ] else : parameters = [ f \" { element [ 'uuid' ] } : { par } \" ] except KeyError as e : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = str ( e ) + \" not found\" response = out . format ( response = response , request = request ) return datamap = dict ( parameters = parameters ) if timefrom is not None : datamap [ 'timefrom' ] = timefrom if timeto is not None : datamap [ 'timeto' ] = timeto return tabular_data ( datamap = json . dumps ([ datamap ]), request = request , response = response ) @hug . get ( '/ {el} / {par} ' , output = data_out_handler ) def tabular_data_par ( el = None , par = None , timefrom = None , timeto = None , content_type = None , request = None , response = None ): return tabular_data_el ( el = el , par = par , timefrom = timefrom , timeto = timeto , request = request , response = response )","title":"Module hielen2.api.data"},{"location":"reference/hielen2/api/data/#variables","text":"CSV JSON db nan","title":"Variables"},{"location":"reference/hielen2/api/data/#functions","text":"","title":"Functions"},{"location":"reference/hielen2/api/data/#data_out_handler","text":"def data_out_handler ( data , request , response ) Supports any of the following formats: Free form UTF-8 text, JSON (Javascript Serialized Object Notation) View Source def output_type ( data , request , response ): handler = requested_output_type ( request ) response . content_type = handler . content_type return handler ( data , request = request , response = response )","title":"data_out_handler"},{"location":"reference/hielen2/api/data/#tabular_data","text":"def tabular_data ( datamap : < hielen2 . utils . JsonValidable object at 0x7f77d8ff5d60 > , content_type = None , request = None , response = None ) if isinstance (datamap,list): datamap=','.join(datamap) try: loaded=json.loads(datamap) except json.JSONDecodeError as e: out = ResponseFormatter(status=falcon.HTTP_BAD_REQUEST) out.message=str(e) response = out.format(response=response,request=request) return View Source @hug . get ( '/' , examples = '' , output = data_out_handler ) def tabular_data ( datamap : JsonValidable ( DataMapSchema ( many = True )), content_type = None , request = None , response = None ) : \"\"\" if isinstance (datamap,list): datamap=','.join(datamap) try: loaded=json.loads(datamap) except json.JSONDecodeError as e: out = ResponseFormatter(status=falcon.HTTP_BAD_REQUEST) out.message=str(e) response = out.format(response=response,request=request) return \"\"\" series = {} for s in datamap : try : timefrom = s [ 'timefrom' ] except KeyError : timefrom = None try : timeto = s [ 'timeto' ] except KeyError : timeto = None for p in s [ 'series' ] : if p not in series . keys () : series [ p ]= [] try : series [ p ] . append ( Series ( p ). thdata ( timefrom = timefrom , timeto = timeto ) ) except KeyError as e : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = str ( e ) + \" not found\" response = out . format ( response = response , request = request ) return out = DataFrame () for param , sers in series . items () : ser = None for r in sers : s = r . result () if ser is None : ser = s else : ser = ser . append ( s ). sort_index () idx = unique ( ser . index . values , return_index = True ) [ 1 ] ser = ser . iloc [ idx ] ser . columns =[ param ] out = out . join ( ser , how = 'outer' ) out . index . name = 'timestamp' requested = data_out_handler . requested ( request ). content_type if ( requested == CSV ) : return hug . types . text ( out . to_csv ()) if ( requested == JSON ) : return hug . types . json ( out . to_json ( orient = 'table' ))","title":"tabular_data"},{"location":"reference/hielen2/api/data/#tabular_data_el","text":"def tabular_data_el ( el , par = None , timefrom = None , timeto = None , content_type = None , request = None , response = None ) View Source @hug . get ( '/{el}/' , output = data_out_handler ) def tabular_data_el ( el , par = None , timefrom = None , timeto = None , content_type = None , request = None , response = None ) : try : element = db [ 'elements' ][ el ] except KeyError : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = str ( el ) + \" not found\" response = out . format ( response = response , request = request ) return try : if par is None : parameters =[ f\"{element['uuid' ] }:{ e } \" for e in element['parameters'].keys() ] else: parameters=[ f\" { element [ 'uuid' ] }:{ par } \" ] except KeyError as e: out = ResponseFormatter(status=falcon.HTTP_NOT_FOUND) out.message=str(e) + \" not found \" response = out . format ( response = response , request = request ) return datamap = dict ( parameters = parameters ) if timefrom is not None : datamap [ 'timefrom' ]= timefrom if timeto is not None : datamap [ 'timeto' ]= timeto return tabular_data ( datamap = json . dumps ( [ datamap ] ), request = request , response = response )","title":"tabular_data_el"},{"location":"reference/hielen2/api/data/#tabular_data_par","text":"def tabular_data_par ( el = None , par = None , timefrom = None , timeto = None , content_type = None , request = None , response = None ) View Source @hug . get ( '/{el}/{par}' , output = data_out_handler ) def tabular_data_par ( el = None , par = None , timefrom = None , timeto = None , content_type = None , request = None , response = None ) : return tabular_data_el ( el = el , par = par , timefrom = timefrom , timeto = timeto , request = request , response = response )","title":"tabular_data_par"},{"location":"reference/hielen2/api/data/#classes","text":"","title":"Classes"},{"location":"reference/hielen2/api/data/#datamapschema","text":"class DataMapSchema ( * , only : Union [ Sequence [ str ], Set [ str ], NoneType ] = None , exclude : Union [ Sequence [ str ], Set [ str ]] = (), many : bool = False , context : Union [ Dict , NoneType ] = None , load_only : Union [ Sequence [ str ], Set [ str ]] = (), dump_only : Union [ Sequence [ str ], Set [ str ]] = (), partial : Union [ bool , Sequence [ str ], Set [ str ]] = False , unknown : Union [ str , NoneType ] = None ) View Source class DataMapSchema ( Schema ): \"\"\" \"\"\" timefrom = fields . Str ( default = None , required = False ) timeto = fields . Str ( default = None , reuired = False ) series = fields . List ( fields . Str , default =[])","title":"DataMapSchema"},{"location":"reference/hielen2/api/data/#ancestors-in-mro","text":"marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen2/api/data/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING error_messages opts series timefrom timeto","title":"Class variables"},{"location":"reference/hielen2/api/data/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen2/api/data/#from_dict","text":"def from_dict ( fields : Dict [ str , Union [ marshmallow . fields . Field , type ]], * , name : str = 'GeneratedSchema' ) -> type Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 View Source @classmethod def from_dict ( cls , fields : typing . Dict [ str , typing . Union [ ma_fields . Field , type ]], * , name : str = \"GeneratedSchema\" ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen2/api/data/#instance-variables","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen2/api/data/#methods","text":"","title":"Methods"},{"location":"reference/hielen2/api/data/#dump","text":"def dump ( self , obj : Any , * , many : Union [ bool , NoneType ] = None ) Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : typing . Optional [ bool ] = None ): \"\"\"Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\"\" many = self . many if many is None else bool ( many ) if many and is_iterable_but_not_string ( obj ): obj = list ( obj ) if self . _has_processors ( PRE_DUMP ): processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ): result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen2/api/data/#dumps","text":"def dumps ( self , obj : Any , * args , many : Union [ bool , NoneType ] = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A json string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : typing . Optional [ bool ] = None , ** kwargs ): \"\"\"Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\"\" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen2/api/data/#get_attribute","text":"def get_attribute ( self , obj : Any , attr : str , default : Any ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ): \"\"\"Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\"\" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen2/api/data/#handle_error","text":"def handle_error ( self , error : marshmallow . exceptions . ValidationError , data : Any , * , many : bool , ** kwargs ) Custom error handler function for the schema. :param error: The ValidationError raised during (de)serialization. :param data: The original input data. :param many: Value of many on dump or load. :param partial: Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ): \"\"\"Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\"\" pass","title":"handle_error"},{"location":"reference/hielen2/api/data/#load","text":"def load ( self , data : Union [ Mapping [ str , Any ], Iterable [ Mapping [ str , Any ]]], * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None ) Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : typing . Union [ typing . Mapping [ str , typing . Any ], typing . Iterable [ typing . Mapping [ str , typing . Any ]], ], * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None ): \"\"\"Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen2/api/data/#loads","text":"def loads ( self , json_data : str , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize obj as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None , ** kwargs ): \"\"\"Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen2/api/data/#on_bind_field","text":"def on_bind_field ( self , field_name : str , field_obj : marshmallow . fields . Field ) -> None Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \"\"\"Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\"\" return None","title":"on_bind_field"},{"location":"reference/hielen2/api/data/#validate","text":"def validate ( self , data : Mapping , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None ) -> Dict [ str , List [ str ]] Validate data against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : typing . Mapping , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None ) -> typing . Dict [ str , typing . List [ str ]]: \"\"\"Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\"\" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]], exc . messages ) return {}","title":"validate"},{"location":"reference/hielen2/api/elements/","text":"Module hielen2.api.elements View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 #!/usr/bin/env python # coding=utf-8 import hug import falcon from hielen2 import db from hielen2.utils import JsonValidable from marshmallow import Schema , fields from himada.api import ResponseFormatter class ElementSchema ( Schema ): uuid = fields . Str ( required = True , allow_none = False ) prototype = fields . Str ( required = True , allow_none = False ) context = fields . Str ( default = None ) label = fields . Str ( default = None ) description = fields . Str ( default = None ) style = fields . Str ( default = None ) status = fields . Str ( default = None ) geom = fields . Str ( default = None ) @hug . post ( '/' ) #def create_elements(uuid,prototype,label=None,descritpion=None,context=None,geom=None,request=None,response=None) def create_elements ( element : JsonValidable ( ElementSchema ()), request = None , response = None ): ''' **Api di creazione degli elementi.** Ogni elemento deve avere il suo codice univoco `uuid` e il suo prototipo `prototype`. Il prototipo \\ dell'elemento forisce informazioni per l'inizializazione della struttura. Possibili risposte: - _409 Conflict_: Nel caso in cui il codice fornito esista gi\u00e0. - _404 Not Found_: Nel caso in cui il prototipo richiesto non esista. - _201 Created_: Nel caso in cui l'elemento venga creato correttamente. ''' out = ResponseFormatter ( status = falcon . HTTP_CREATED ) try : prototype = element . pop ( 'prototype' ) element . update ( db [ 'elements_proto' ][ prototype ][ 'struct' ] ) element [ 'parameters' ] = { k : None for k in element [ 'parameters' ] . keys ()} db [ 'elements' ][ element [ 'uuid' ]] = element out . message = element except KeyError as e : out . message = f \"prototype ' { prototype } ' not found.\" out . status = falcon . HTTP_NOT_FOUND except ValueError as e : out . message = f \"element ' { element [ 'uuid' ] } ' exists\" out . status = falcon . HTTP_CONFLICT response = out . format ( response = response , request = request ) return def elinfo ( el ): if el is None : return None info = { k : w for k , w in el . items () if k not in ( 'uuid' ,) } info [ 'parameters' ] = [] try : for e in el [ 'parameters' ] . items (): if e [ 1 ] is not None : info [ 'parameters' ] . append ( { 'series' : e [ 1 ], 'name' : e [ 0 ], 'unit' : db [ 'series' ][ e [ 1 ]][ 'mu' ] } ) except AttributeError : pass return info @hug . get ( '/' , examples = '' ) def elements_info ( elist = None , context = None , request = None , response = None ): out = ResponseFormatter () out . data = { k : elinfo ( w ) for k , w in db [ 'elements' ][ elist ] . items () if context is None or w [ 'context' ] == context } response = out . format ( response = response , request = request ) return @hug . get ( '/ {uuid} ' ) def element_info ( uuid , request = None , response = None ): out = ResponseFormatter () try : out . data = db [ 'elements' ][ uuid ] except KeyError as e : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = f \"element ' { uuid } ' not found\" response = out . format ( response = response , request = request ) return @hug . delete ( '/ {uuid} ' ) def element_delete ( uuid , request = None , response = None ): out = ResponseFormatter () try : out . data = db [ 'elements' ] . pop ( uuid ) except KeyError as e : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = f \"element ' { uuid } ' not found\" response = out . format ( response = response , request = request ) return Variables db Functions create_elements def create_elements ( element : < hielen2 . utils . JsonValidable object at 0x7f77d8f83340 > , request = None , response = None ) Api di creazione degli elementi. Ogni elemento deve avere il suo codice univoco uuid e il suo prototipo prototype . Il prototipo dell'elemento forisce informazioni per l'inizializazione della struttura. Possibili risposte: 409 Conflict : Nel caso in cui il codice fornito esista gi\u00e0. 404 Not Found : Nel caso in cui il prototipo richiesto non esista. 201 Created : Nel caso in cui l'elemento venga creato correttamente. View Source @ hug . post ( '/' ) #def create_elements(uuid,prototype,label=None,descritpion=None,context=None,geom=None,request=None,response=None) def create_elements ( element : JsonValidable ( ElementSchema ()), request = None , response = None ): ''' **Api di creazione degli elementi.** Ogni elemento deve avere il suo codice univoco `uuid` e il suo prototipo `prototype`. Il prototipo \\ dell' elemento forisce informazioni per l 'inizializazione della struttura. Possibili risposte: - _409 Conflict_: Nel caso in cui il codice fornito esista gi\u00e0. - _404 Not Found_: Nel caso in cui il prototipo richiesto non esista. - _201 Created_: Nel caso in cui l' elemento venga creato correttamente . ''' out = ResponseFormatter(status=falcon.HTTP_CREATED) try: prototype=element.pop(' prototype ') element.update( db[' elements_proto '][prototype][' struct '] ) element[' parameters ']={ k:None for k in element[' parameters '].keys()} db[' elements '][element[' uuid ']]=element out.message=element except KeyError as e: out.message=f\"prototype ' { prototype } ' not found.\" out.status=falcon.HTTP_NOT_FOUND except ValueError as e: out.message=f\"element ' { element [ 'uuid' ] }' exists \" out . status = falcon . HTTP_CONFLICT response = out . format ( response = response , request = request ) return element_delete def element_delete ( uuid , request = None , response = None ) View Source @hug . delete ( '/{uuid}' ) def element_delete ( uuid , request = None , response = None ) : out = ResponseFormatter () try : out . data = db [ 'elements' ] . pop ( uuid ) except KeyError as e : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = f \"element '{uuid}' not found\" response = out . format ( response = response , request = request ) return element_info def element_info ( uuid , request = None , response = None ) View Source @hug . get ( '/{uuid}' ) def element_info ( uuid , request = None , response = None ) : out = ResponseFormatter () try : out . data = db [ 'elements' ][ uuid ] except KeyError as e : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = f \"element '{uuid}' not found\" response = out . format ( response = response , request = request ) return elements_info def elements_info ( elist = None , context = None , request = None , response = None ) View Source @hug . get ( '/' , examples = '' ) def elements_info ( elist = None , context = None , request = None , response = None ) : out = ResponseFormatter () out . data = { k : elinfo ( w ) for k , w in db [ 'elements' ][ elist ] . items () if context is None or w [ 'context' ]== context } response = out . format ( response = response , request = request ) return elinfo def elinfo ( el ) View Source def elinfo ( el ): if el is None : return None info = { k : w for k , w in el . items () if k not in ( 'uuid' ,) } info [ 'parameters' ] = [] try : for e in el [ 'parameters' ]. items (): if e [ 1 ] is not None : info [ 'parameters' ]. append ( { 'series' : e [ 1 ], 'name' : e [ 0 ], 'unit' : db [ 'series' ][ e [ 1 ]][ 'mu' ] } ) except AttributeError : pass return info Classes ElementSchema class ElementSchema ( * , only : Union [ Sequence [ str ], Set [ str ], NoneType ] = None , exclude : Union [ Sequence [ str ], Set [ str ]] = (), many : bool = False , context : Union [ Dict , NoneType ] = None , load_only : Union [ Sequence [ str ], Set [ str ]] = (), dump_only : Union [ Sequence [ str ], Set [ str ]] = (), partial : Union [ bool , Sequence [ str ], Set [ str ]] = False , unknown : Union [ str , NoneType ] = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'} :param only: Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. :param exclude: Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. :param many: Should be set to True if obj is a collection so that the object will be serialized to a list. :param context: Optional context passed to :class: fields.Method and :class: fields.Function fields. :param load_only: Fields to skip during serialization (write-only fields) :param dump_only: Fields to skip during deserialization (read-only fields) :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. View Source class ElementSchema ( Schema ): uuid = fields . Str ( required = True , allow_none = False ) prototype = fields . Str ( required = True , allow_none = False ) context = fields . Str ( default = None ) label = fields . Str ( default = None ) description = fields . Str ( default = None ) style = fields . Str ( default = None ) status = fields . Str ( default = None ) geom = fields . Str ( default = None ) Ancestors (in MRO) marshmallow.schema.Schema marshmallow.base.SchemaABC Class variables Meta OPTIONS_CLASS TYPE_MAPPING context description error_messages geom label opts prototype status style uuid Static methods from_dict def from_dict ( fields : Dict [ str , Union [ marshmallow . fields . Field , type ]], * , name : str = 'GeneratedSchema' ) -> type Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 View Source @classmethod def from_dict ( cls , fields : typing . Dict [ str , typing . Union [ ma_fields . Field , type ]], * , name : str = \"GeneratedSchema\" ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls Instance variables dict_class set_class Methods dump def dump ( self , obj : Any , * , many : Union [ bool , NoneType ] = None ) Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : typing . Optional [ bool ] = None ): \"\"\"Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\"\" many = self . many if many is None else bool ( many ) if many and is_iterable_but_not_string ( obj ): obj = list ( obj ) if self . _has_processors ( PRE_DUMP ): processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ): result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result dumps def dumps ( self , obj : Any , * args , many : Union [ bool , NoneType ] = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A json string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : typing . Optional [ bool ] = None , ** kwargs ): \"\"\"Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\"\" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs ) get_attribute def get_attribute ( self , obj : Any , attr : str , default : Any ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ): \"\"\"Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\"\" return get_value ( obj , attr , default ) handle_error def handle_error ( self , error : marshmallow . exceptions . ValidationError , data : Any , * , many : bool , ** kwargs ) Custom error handler function for the schema. :param error: The ValidationError raised during (de)serialization. :param data: The original input data. :param many: Value of many on dump or load. :param partial: Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ): \"\"\"Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\"\" pass load def load ( self , data : Union [ Mapping [ str , Any ], Iterable [ Mapping [ str , Any ]]], * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None ) Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : typing . Union [ typing . Mapping [ str , typing . Any ], typing . Iterable [ typing . Mapping [ str , typing . Any ]], ], * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None ): \"\"\"Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True ) loads def loads ( self , json_data : str , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize obj as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None , ** kwargs ): \"\"\"Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown ) on_bind_field def on_bind_field ( self , field_name : str , field_obj : marshmallow . fields . Field ) -> None Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \"\"\"Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\"\" return None validate def validate ( self , data : Mapping , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None ) -> Dict [ str , List [ str ]] Validate data against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : typing . Mapping , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None ) -> typing . Dict [ str , typing . List [ str ]]: \"\"\"Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\"\" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]], exc . messages ) return {}","title":"Elements"},{"location":"reference/hielen2/api/elements/#module-hielen2apielements","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 #!/usr/bin/env python # coding=utf-8 import hug import falcon from hielen2 import db from hielen2.utils import JsonValidable from marshmallow import Schema , fields from himada.api import ResponseFormatter class ElementSchema ( Schema ): uuid = fields . Str ( required = True , allow_none = False ) prototype = fields . Str ( required = True , allow_none = False ) context = fields . Str ( default = None ) label = fields . Str ( default = None ) description = fields . Str ( default = None ) style = fields . Str ( default = None ) status = fields . Str ( default = None ) geom = fields . Str ( default = None ) @hug . post ( '/' ) #def create_elements(uuid,prototype,label=None,descritpion=None,context=None,geom=None,request=None,response=None) def create_elements ( element : JsonValidable ( ElementSchema ()), request = None , response = None ): ''' **Api di creazione degli elementi.** Ogni elemento deve avere il suo codice univoco `uuid` e il suo prototipo `prototype`. Il prototipo \\ dell'elemento forisce informazioni per l'inizializazione della struttura. Possibili risposte: - _409 Conflict_: Nel caso in cui il codice fornito esista gi\u00e0. - _404 Not Found_: Nel caso in cui il prototipo richiesto non esista. - _201 Created_: Nel caso in cui l'elemento venga creato correttamente. ''' out = ResponseFormatter ( status = falcon . HTTP_CREATED ) try : prototype = element . pop ( 'prototype' ) element . update ( db [ 'elements_proto' ][ prototype ][ 'struct' ] ) element [ 'parameters' ] = { k : None for k in element [ 'parameters' ] . keys ()} db [ 'elements' ][ element [ 'uuid' ]] = element out . message = element except KeyError as e : out . message = f \"prototype ' { prototype } ' not found.\" out . status = falcon . HTTP_NOT_FOUND except ValueError as e : out . message = f \"element ' { element [ 'uuid' ] } ' exists\" out . status = falcon . HTTP_CONFLICT response = out . format ( response = response , request = request ) return def elinfo ( el ): if el is None : return None info = { k : w for k , w in el . items () if k not in ( 'uuid' ,) } info [ 'parameters' ] = [] try : for e in el [ 'parameters' ] . items (): if e [ 1 ] is not None : info [ 'parameters' ] . append ( { 'series' : e [ 1 ], 'name' : e [ 0 ], 'unit' : db [ 'series' ][ e [ 1 ]][ 'mu' ] } ) except AttributeError : pass return info @hug . get ( '/' , examples = '' ) def elements_info ( elist = None , context = None , request = None , response = None ): out = ResponseFormatter () out . data = { k : elinfo ( w ) for k , w in db [ 'elements' ][ elist ] . items () if context is None or w [ 'context' ] == context } response = out . format ( response = response , request = request ) return @hug . get ( '/ {uuid} ' ) def element_info ( uuid , request = None , response = None ): out = ResponseFormatter () try : out . data = db [ 'elements' ][ uuid ] except KeyError as e : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = f \"element ' { uuid } ' not found\" response = out . format ( response = response , request = request ) return @hug . delete ( '/ {uuid} ' ) def element_delete ( uuid , request = None , response = None ): out = ResponseFormatter () try : out . data = db [ 'elements' ] . pop ( uuid ) except KeyError as e : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = f \"element ' { uuid } ' not found\" response = out . format ( response = response , request = request ) return","title":"Module hielen2.api.elements"},{"location":"reference/hielen2/api/elements/#variables","text":"db","title":"Variables"},{"location":"reference/hielen2/api/elements/#functions","text":"","title":"Functions"},{"location":"reference/hielen2/api/elements/#create_elements","text":"def create_elements ( element : < hielen2 . utils . JsonValidable object at 0x7f77d8f83340 > , request = None , response = None ) Api di creazione degli elementi. Ogni elemento deve avere il suo codice univoco uuid e il suo prototipo prototype . Il prototipo dell'elemento forisce informazioni per l'inizializazione della struttura. Possibili risposte: 409 Conflict : Nel caso in cui il codice fornito esista gi\u00e0. 404 Not Found : Nel caso in cui il prototipo richiesto non esista. 201 Created : Nel caso in cui l'elemento venga creato correttamente. View Source @ hug . post ( '/' ) #def create_elements(uuid,prototype,label=None,descritpion=None,context=None,geom=None,request=None,response=None) def create_elements ( element : JsonValidable ( ElementSchema ()), request = None , response = None ): ''' **Api di creazione degli elementi.** Ogni elemento deve avere il suo codice univoco `uuid` e il suo prototipo `prototype`. Il prototipo \\ dell' elemento forisce informazioni per l 'inizializazione della struttura. Possibili risposte: - _409 Conflict_: Nel caso in cui il codice fornito esista gi\u00e0. - _404 Not Found_: Nel caso in cui il prototipo richiesto non esista. - _201 Created_: Nel caso in cui l' elemento venga creato correttamente . ''' out = ResponseFormatter(status=falcon.HTTP_CREATED) try: prototype=element.pop(' prototype ') element.update( db[' elements_proto '][prototype][' struct '] ) element[' parameters ']={ k:None for k in element[' parameters '].keys()} db[' elements '][element[' uuid ']]=element out.message=element except KeyError as e: out.message=f\"prototype ' { prototype } ' not found.\" out.status=falcon.HTTP_NOT_FOUND except ValueError as e: out.message=f\"element ' { element [ 'uuid' ] }' exists \" out . status = falcon . HTTP_CONFLICT response = out . format ( response = response , request = request ) return","title":"create_elements"},{"location":"reference/hielen2/api/elements/#element_delete","text":"def element_delete ( uuid , request = None , response = None ) View Source @hug . delete ( '/{uuid}' ) def element_delete ( uuid , request = None , response = None ) : out = ResponseFormatter () try : out . data = db [ 'elements' ] . pop ( uuid ) except KeyError as e : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = f \"element '{uuid}' not found\" response = out . format ( response = response , request = request ) return","title":"element_delete"},{"location":"reference/hielen2/api/elements/#element_info","text":"def element_info ( uuid , request = None , response = None ) View Source @hug . get ( '/{uuid}' ) def element_info ( uuid , request = None , response = None ) : out = ResponseFormatter () try : out . data = db [ 'elements' ][ uuid ] except KeyError as e : out = ResponseFormatter ( status = falcon . HTTP_NOT_FOUND ) out . message = f \"element '{uuid}' not found\" response = out . format ( response = response , request = request ) return","title":"element_info"},{"location":"reference/hielen2/api/elements/#elements_info","text":"def elements_info ( elist = None , context = None , request = None , response = None ) View Source @hug . get ( '/' , examples = '' ) def elements_info ( elist = None , context = None , request = None , response = None ) : out = ResponseFormatter () out . data = { k : elinfo ( w ) for k , w in db [ 'elements' ][ elist ] . items () if context is None or w [ 'context' ]== context } response = out . format ( response = response , request = request ) return","title":"elements_info"},{"location":"reference/hielen2/api/elements/#elinfo","text":"def elinfo ( el ) View Source def elinfo ( el ): if el is None : return None info = { k : w for k , w in el . items () if k not in ( 'uuid' ,) } info [ 'parameters' ] = [] try : for e in el [ 'parameters' ]. items (): if e [ 1 ] is not None : info [ 'parameters' ]. append ( { 'series' : e [ 1 ], 'name' : e [ 0 ], 'unit' : db [ 'series' ][ e [ 1 ]][ 'mu' ] } ) except AttributeError : pass return info","title":"elinfo"},{"location":"reference/hielen2/api/elements/#classes","text":"","title":"Classes"},{"location":"reference/hielen2/api/elements/#elementschema","text":"class ElementSchema ( * , only : Union [ Sequence [ str ], Set [ str ], NoneType ] = None , exclude : Union [ Sequence [ str ], Set [ str ]] = (), many : bool = False , context : Union [ Dict , NoneType ] = None , load_only : Union [ Sequence [ str ], Set [ str ]] = (), dump_only : Union [ Sequence [ str ], Set [ str ]] = (), partial : Union [ bool , Sequence [ str ], Set [ str ]] = False , unknown : Union [ str , NoneType ] = None ) Base schema class with which to define custom schemas. Example usage: .. code-block:: python import datetime as dt from dataclasses import dataclass from marshmallow import Schema , fields @dataclass class Album : title : str release_date : dt . date class AlbumSchema ( Schema ): title = fields . Str () release_date = fields . Date () album = Album ( \"Beggars Banquet\" , dt . date ( 1968 , 12 , 6 )) schema = AlbumSchema () data = schema . dump ( album ) data # {'release_date': '1968-12-06', 'title': 'Beggars Banquet'} :param only: Whitelist of the declared fields to select when instantiating the Schema. If None, all fields are used. Nested fields can be represented with dot delimiters. :param exclude: Blacklist of the declared fields to exclude when instantiating the Schema. If a field appears in both only and exclude , it is not used. Nested fields can be represented with dot delimiters. :param many: Should be set to True if obj is a collection so that the object will be serialized to a list. :param context: Optional context passed to :class: fields.Method and :class: fields.Function fields. :param load_only: Fields to skip during serialization (write-only fields) :param dump_only: Fields to skip during deserialization (read-only fields) :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . .. versionchanged:: 3.0.0 prefix parameter removed. .. versionchanged:: 2.0.0 __validators__ , __preprocessors__ , and __data_handlers__ are removed in favor of marshmallow.decorators.validates_schema , marshmallow.decorators.pre_load and marshmallow.decorators.post_dump . __accessor__ and __error_handler__ are deprecated. Implement the handle_error and get_attribute methods instead. View Source class ElementSchema ( Schema ): uuid = fields . Str ( required = True , allow_none = False ) prototype = fields . Str ( required = True , allow_none = False ) context = fields . Str ( default = None ) label = fields . Str ( default = None ) description = fields . Str ( default = None ) style = fields . Str ( default = None ) status = fields . Str ( default = None ) geom = fields . Str ( default = None )","title":"ElementSchema"},{"location":"reference/hielen2/api/elements/#ancestors-in-mro","text":"marshmallow.schema.Schema marshmallow.base.SchemaABC","title":"Ancestors (in MRO)"},{"location":"reference/hielen2/api/elements/#class-variables","text":"Meta OPTIONS_CLASS TYPE_MAPPING context description error_messages geom label opts prototype status style uuid","title":"Class variables"},{"location":"reference/hielen2/api/elements/#static-methods","text":"","title":"Static methods"},{"location":"reference/hielen2/api/elements/#from_dict","text":"def from_dict ( fields : Dict [ str , Union [ marshmallow . fields . Field , type ]], * , name : str = 'GeneratedSchema' ) -> type Generate a Schema class given a dictionary of fields. .. code-block:: python from marshmallow import Schema , fields PersonSchema = Schema . from_dict ({ \"name\" : fields . Str ()}) print ( PersonSchema () . load ({ \"name\" : \"David\" })) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in Nested fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the repr for the class. .. versionadded:: 3.0.0 View Source @classmethod def from_dict ( cls , fields : typing . Dict [ str , typing . Union [ ma_fields . Field , type ]], * , name : str = \"GeneratedSchema\" ) -> type : \"\"\"Generate a `Schema` class given a dictionary of fields. .. code-block:: python from marshmallow import Schema, fields PersonSchema = Schema.from_dict({\"name\": fields.Str()}) print(PersonSchema().load({\"name\": \"David\"})) # => {'name': 'David'} Generated schemas are not added to the class registry and therefore cannot be referred to by name in `Nested` fields. :param dict fields: Dictionary mapping field names to field instances. :param str name: Optional name for the class, which will appear in the ``repr`` for the class. .. versionadded:: 3.0.0 \"\"\" attrs = fields . copy () attrs [ \"Meta\" ] = type ( \"GeneratedMeta\" , ( getattr ( cls , \"Meta\" , object ),), { \"register\" : False } ) schema_cls = type ( name , ( cls ,), attrs ) return schema_cls","title":"from_dict"},{"location":"reference/hielen2/api/elements/#instance-variables","text":"dict_class set_class","title":"Instance variables"},{"location":"reference/hielen2/api/elements/#methods","text":"","title":"Methods"},{"location":"reference/hielen2/api/elements/#dump","text":"def dump ( self , obj : Any , * , many : Union [ bool , NoneType ] = None ) Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. View Source def dump ( self , obj : typing . Any , * , many : typing . Optional [ bool ] = None ): \"\"\"Serialize an object to native Python data types according to this Schema's fields. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A dict of serialized data :rtype: dict .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. .. versionchanged:: 3.0.0rc9 Validation no longer occurs upon serialization. \"\"\" many = self . many if many is None else bool ( many ) if many and is_iterable_but_not_string ( obj ): obj = list ( obj ) if self . _has_processors ( PRE_DUMP ): processed_obj = self . _invoke_dump_processors ( PRE_DUMP , obj , many = many , original_data = obj ) else : processed_obj = obj result = self . _serialize ( processed_obj , many = many ) if self . _has_processors ( POST_DUMP ): result = self . _invoke_dump_processors ( POST_DUMP , result , many = many , original_data = obj ) return result","title":"dump"},{"location":"reference/hielen2/api/elements/#dumps","text":"def dumps ( self , obj : Any , * args , many : Union [ bool , NoneType ] = None , ** kwargs ) Same as :meth: dump , except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize obj as a collection. If None , the value for self.many is used. :return: A json string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if obj is invalid. View Source def dumps ( self , obj : typing . Any , * args , many : typing . Optional [ bool ] = None , ** kwargs ): \"\"\"Same as :meth:`dump`, except return a JSON-encoded string. :param obj: The object to serialize. :param many: Whether to serialize `obj` as a collection. If `None`, the value for `self.many` is used. :return: A ``json`` string :rtype: str .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the serialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if ``obj`` is invalid. \"\"\" serialized = self . dump ( obj , many = many ) return self . opts . render_module . dumps ( serialized , * args , ** kwargs )","title":"dumps"},{"location":"reference/hielen2/api/elements/#get_attribute","text":"def get_attribute ( self , obj : Any , attr : str , default : Any ) Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of obj and attr . View Source def get_attribute ( self , obj : typing . Any , attr : str , default : typing . Any ): \"\"\"Defines how to pull values from an object to serialize. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0a1 Changed position of ``obj`` and ``attr``. \"\"\" return get_value ( obj , attr , default )","title":"get_attribute"},{"location":"reference/hielen2/api/elements/#handle_error","text":"def handle_error ( self , error : marshmallow . exceptions . ValidationError , data : Any , * , many : bool , ** kwargs ) Custom error handler function for the schema. :param error: The ValidationError raised during (de)serialization. :param data: The original input data. :param many: Value of many on dump or load. :param partial: Value of partial on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives many and partial (on deserialization) as keyword arguments. View Source def handle_error ( self , error : ValidationError , data : typing . Any , * , many : bool , ** kwargs ): \"\"\"Custom error handler function for the schema. :param error: The `ValidationError` raised during (de)serialization. :param data: The original input data. :param many: Value of ``many`` on dump or load. :param partial: Value of ``partial`` on load. .. versionadded:: 2.0.0 .. versionchanged:: 3.0.0rc9 Receives `many` and `partial` (on deserialization) as keyword arguments. \"\"\" pass","title":"handle_error"},{"location":"reference/hielen2/api/elements/#load","text":"def load ( self , data : Union [ Mapping [ str , Any ], Iterable [ Mapping [ str , Any ]]], * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None ) Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def load ( self , data : typing . Union [ typing . Mapping [ str , typing . Any ], typing . Iterable [ typing . Mapping [ str , typing . Any ]], ], * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None ): \"\"\"Deserialize a data structure to an object defined by this Schema's fields. :param data: The data to deserialize. :param many: Whether to deserialize `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" return self . _do_load ( data , many = many , partial = partial , unknown = unknown , postprocess = True )","title":"load"},{"location":"reference/hielen2/api/elements/#loads","text":"def loads ( self , json_data : str , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None , unknown : Union [ str , NoneType ] = None , ** kwargs ) Same as :meth: load , except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize obj as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use EXCLUDE , INCLUDE or RAISE . If None , the value for self.unknown is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a (data, errors) duple. A :exc: ValidationError <marshmallow.exceptions.ValidationError> is raised if invalid data are passed. View Source def loads ( self , json_data : str , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None , unknown : typing . Optional [ str ] = None , ** kwargs ): \"\"\"Same as :meth:`load`, except it takes a JSON string as input. :param json_data: A JSON string of the data to deserialize. :param many: Whether to deserialize `obj` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :param unknown: Whether to exclude, include, or raise an error for unknown fields in the data. Use `EXCLUDE`, `INCLUDE` or `RAISE`. If `None`, the value for `self.unknown` is used. :return: Deserialized data .. versionadded:: 1.0.0 .. versionchanged:: 3.0.0b7 This method returns the deserialized data rather than a ``(data, errors)`` duple. A :exc:`ValidationError <marshmallow.exceptions.ValidationError>` is raised if invalid data are passed. \"\"\" data = self . opts . render_module . loads ( json_data , ** kwargs ) return self . load ( data , many = many , partial = partial , unknown = unknown )","title":"loads"},{"location":"reference/hielen2/api/elements/#on_bind_field","text":"def on_bind_field ( self , field_name : str , field_obj : marshmallow . fields . Field ) -> None Hook to modify a field when it is bound to the Schema . No-op by default. View Source def on_bind_field ( self , field_name : str , field_obj : ma_fields . Field ) -> None : \"\"\"Hook to modify a field when it is bound to the `Schema`. No-op by default. \"\"\" return None","title":"on_bind_field"},{"location":"reference/hielen2/api/elements/#validate","text":"def validate ( self , data : Mapping , * , many : Union [ bool , NoneType ] = None , partial : Union [ bool , Sequence [ str ], Set [ str ], NoneType ] = None ) -> Dict [ str , List [ str ]] Validate data against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate data as a collection. If None , the value for self.many is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to Nested fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 View Source def validate ( self , data : typing . Mapping , * , many : typing . Optional [ bool ] = None , partial : typing . Optional [ typing . Union [ bool , types . StrSequenceOrSet ]] = None ) -> typing . Dict [ str , typing . List [ str ]]: \"\"\"Validate `data` against the schema, returning a dictionary of validation errors. :param data: The data to validate. :param many: Whether to validate `data` as a collection. If `None`, the value for `self.many` is used. :param partial: Whether to ignore missing fields and not require any fields declared. Propagates down to ``Nested`` fields as well. If its value is an iterable, only missing fields listed in that iterable will be ignored. Use dot delimiters to specify nested fields. :return: A dictionary of validation errors. .. versionadded:: 1.1.0 \"\"\" try : self . _do_load ( data , many = many , partial = partial , postprocess = False ) except ValidationError as exc : return typing . cast ( typing . Dict [ str , typing . List [ str ]], exc . messages ) return {}","title":"validate"},{"location":"reference/hielen2/api/glob/","text":"Module hielen2.api.glob View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #!/usr/bin/env python # coding=utf-8 import hug from . import elements , prototypes , data import falcon ''' @hug.not_found() def not_found(): return {'error': { 'status': falcon.status.HTTP_NOT_FOUND, 'description': 'URL is invalid.', }} api = hug.get(on_invalid=hug.redirect.not_found) ''' @hug . extend_api ( '/prototypes' ) def protoman (): ''' Prototypes manager ''' return [ prototypes ] @hug . extend_api ( '/elements' ) def elemman (): ''' Elements manager ''' return [ elements ] @hug . extend_api ( '/data' ) def dataman (): ''' Series manager ''' return [ data ] Functions dataman def dataman ( ) Series manager View Source @hug . extend_api ( '/data' ) def dataman () : ''' Series manager ''' return [ data ] elemman def elemman ( ) Elements manager View Source @hug . extend_api ( '/elements' ) def elemman () : ''' Elements manager ''' return [ elements ] protoman def protoman ( ) Prototypes manager View Source @hug . extend_api ( '/prototypes' ) def protoman () : ''' Prototypes manager ''' return [ prototypes ]","title":"Glob"},{"location":"reference/hielen2/api/glob/#module-hielen2apiglob","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #!/usr/bin/env python # coding=utf-8 import hug from . import elements , prototypes , data import falcon ''' @hug.not_found() def not_found(): return {'error': { 'status': falcon.status.HTTP_NOT_FOUND, 'description': 'URL is invalid.', }} api = hug.get(on_invalid=hug.redirect.not_found) ''' @hug . extend_api ( '/prototypes' ) def protoman (): ''' Prototypes manager ''' return [ prototypes ] @hug . extend_api ( '/elements' ) def elemman (): ''' Elements manager ''' return [ elements ] @hug . extend_api ( '/data' ) def dataman (): ''' Series manager ''' return [ data ]","title":"Module hielen2.api.glob"},{"location":"reference/hielen2/api/glob/#functions","text":"","title":"Functions"},{"location":"reference/hielen2/api/glob/#dataman","text":"def dataman ( ) Series manager View Source @hug . extend_api ( '/data' ) def dataman () : ''' Series manager ''' return [ data ]","title":"dataman"},{"location":"reference/hielen2/api/glob/#elemman","text":"def elemman ( ) Elements manager View Source @hug . extend_api ( '/elements' ) def elemman () : ''' Elements manager ''' return [ elements ]","title":"elemman"},{"location":"reference/hielen2/api/glob/#protoman","text":"def protoman ( ) Prototypes manager View Source @hug . extend_api ( '/prototypes' ) def protoman () : ''' Prototypes manager ''' return [ prototypes ]","title":"protoman"},{"location":"reference/hielen2/api/prototypes/","text":"Module hielen2.api.prototypes View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 #!/usr/bin/env python # coding=utf-8 import hug import falcon from hielen2 import db from himada.api import ResponseFormatter @hug . post ( '/' ) def new_protptype ( prototype , request = None , response = None ): return \"not yet implemented\" @hug . get ( '/' , examples = '/' ) def prototypes ( request = None , response = None ): out = ResponseFormatter () try : out . data = db [ 'elements_proto' ][ None ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) @hug . get ( '/ {prototype} ' , examples = '' ) def protptype ( prototype , request = None , response = None ): out = ResponseFormatter () try : out . data = db [ 'elements_proto' ][ prototype ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) @hug . get ( '/ {prototype} /forms' , examples = '' ) def prototype_forms ( prototype , request = None , response = None ): out = ResponseFormatter () try : out . data = db [ 'elements_proto' ][ prototype ][ 'forms' ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) @hug . get ( '/ {prototype} /forms/ {form} ' , examples = '' ) def prototype_form ( prototype , form , request = None , response = None ): out = ResponseFormatter () try : out . data = db [ 'elements_proto' ][ prototype ][ 'forms' ][ form ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) @hug . get ( '/ {prototype} /struct' , examples = '' ) def prototype_struct ( prototype , request = None , response = None ): out = ResponseFormatter () try : out . data = db [ 'elements_proto' ][ prototype ][ 'struct' ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) Variables db Functions new_protptype def new_protptype ( prototype , request = None , response = None ) View Source @hug . post ( '/' ) def new_protptype ( prototype , request = None , response = None ) : return \"not yet implemented\" prototype_form def prototype_form ( prototype , form , request = None , response = None ) View Source @hug . get ( '/{prototype}/forms/{form}' , examples = '' ) def prototype_form ( prototype , form , request = None , response = None ) : out = ResponseFormatter () try : out . data = db [ 'elements_proto' ][ prototype ][ 'forms' ][ form ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) prototype_forms def prototype_forms ( prototype , request = None , response = None ) View Source @hug . get ( '/{prototype}/forms' , examples = '' ) def prototype_forms ( prototype , request = None , response = None ) : out = ResponseFormatter () try : out . data = db [ 'elements_proto' ][ prototype ][ 'forms' ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) prototype_struct def prototype_struct ( prototype , request = None , response = None ) View Source @hug . get ( '/{prototype}/struct' , examples = '' ) def prototype_struct ( prototype , request = None , response = None ) : out = ResponseFormatter () try : out . data = db [ 'elements_proto' ][ prototype ][ 'struct' ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) prototypes def prototypes ( request = None , response = None ) View Source @hug . get ( '/' , examples = '/' ) def prototypes ( request = None , response = None ) : out = ResponseFormatter () try : out . data = db [ 'elements_proto' ][ None ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) protptype def protptype ( prototype , request = None , response = None ) View Source @hug . get ( '/{prototype}' , examples = '' ) def protptype ( prototype , request = None , response = None ) : out = ResponseFormatter () try : out . data = db [ 'elements_proto' ][ prototype ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request )","title":"Prototypes"},{"location":"reference/hielen2/api/prototypes/#module-hielen2apiprototypes","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 #!/usr/bin/env python # coding=utf-8 import hug import falcon from hielen2 import db from himada.api import ResponseFormatter @hug . post ( '/' ) def new_protptype ( prototype , request = None , response = None ): return \"not yet implemented\" @hug . get ( '/' , examples = '/' ) def prototypes ( request = None , response = None ): out = ResponseFormatter () try : out . data = db [ 'elements_proto' ][ None ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) @hug . get ( '/ {prototype} ' , examples = '' ) def protptype ( prototype , request = None , response = None ): out = ResponseFormatter () try : out . data = db [ 'elements_proto' ][ prototype ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) @hug . get ( '/ {prototype} /forms' , examples = '' ) def prototype_forms ( prototype , request = None , response = None ): out = ResponseFormatter () try : out . data = db [ 'elements_proto' ][ prototype ][ 'forms' ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) @hug . get ( '/ {prototype} /forms/ {form} ' , examples = '' ) def prototype_form ( prototype , form , request = None , response = None ): out = ResponseFormatter () try : out . data = db [ 'elements_proto' ][ prototype ][ 'forms' ][ form ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request ) @hug . get ( '/ {prototype} /struct' , examples = '' ) def prototype_struct ( prototype , request = None , response = None ): out = ResponseFormatter () try : out . data = db [ 'elements_proto' ][ prototype ][ 'struct' ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request )","title":"Module hielen2.api.prototypes"},{"location":"reference/hielen2/api/prototypes/#variables","text":"db","title":"Variables"},{"location":"reference/hielen2/api/prototypes/#functions","text":"","title":"Functions"},{"location":"reference/hielen2/api/prototypes/#new_protptype","text":"def new_protptype ( prototype , request = None , response = None ) View Source @hug . post ( '/' ) def new_protptype ( prototype , request = None , response = None ) : return \"not yet implemented\"","title":"new_protptype"},{"location":"reference/hielen2/api/prototypes/#prototype_form","text":"def prototype_form ( prototype , form , request = None , response = None ) View Source @hug . get ( '/{prototype}/forms/{form}' , examples = '' ) def prototype_form ( prototype , form , request = None , response = None ) : out = ResponseFormatter () try : out . data = db [ 'elements_proto' ][ prototype ][ 'forms' ][ form ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request )","title":"prototype_form"},{"location":"reference/hielen2/api/prototypes/#prototype_forms","text":"def prototype_forms ( prototype , request = None , response = None ) View Source @hug . get ( '/{prototype}/forms' , examples = '' ) def prototype_forms ( prototype , request = None , response = None ) : out = ResponseFormatter () try : out . data = db [ 'elements_proto' ][ prototype ][ 'forms' ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request )","title":"prototype_forms"},{"location":"reference/hielen2/api/prototypes/#prototype_struct","text":"def prototype_struct ( prototype , request = None , response = None ) View Source @hug . get ( '/{prototype}/struct' , examples = '' ) def prototype_struct ( prototype , request = None , response = None ) : out = ResponseFormatter () try : out . data = db [ 'elements_proto' ][ prototype ][ 'struct' ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request )","title":"prototype_struct"},{"location":"reference/hielen2/api/prototypes/#prototypes","text":"def prototypes ( request = None , response = None ) View Source @hug . get ( '/' , examples = '/' ) def prototypes ( request = None , response = None ) : out = ResponseFormatter () try : out . data = db [ 'elements_proto' ][ None ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request )","title":"prototypes"},{"location":"reference/hielen2/api/prototypes/#protptype","text":"def protptype ( prototype , request = None , response = None ) View Source @hug . get ( '/{prototype}' , examples = '' ) def protptype ( prototype , request = None , response = None ) : out = ResponseFormatter () try : out . data = db [ 'elements_proto' ][ prototype ] except KeyError as e : out . status = out . status = falcon . HTTP_NOT_FOUND out . message = str ( e ) response = out . format ( response = response , request = request )","title":"protptype"},{"location":"reference/hielen2/data/","text":"Module hielen2.data Sub-modules hielen2.data.calculation hielen2.data.data_access_layer hielen2.data.sources","title":"Index"},{"location":"reference/hielen2/data/#module-hielen2data","text":"","title":"Module hielen2.data"},{"location":"reference/hielen2/data/#sub-modules","text":"hielen2.data.calculation hielen2.data.data_access_layer hielen2.data.sources","title":"Sub-modules"},{"location":"reference/hielen2/data/calculation/","text":"Module hielen2.data.calculation View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 #!/usr/bin/env python # coding=utf-8 __name__ = 'hielen2.series.calculation' __version__ = '0.0.1' __author__ = 'Alessandro Modesti' __email__ = 'it@img-srl.com' __description__ = 'hub for hielen calculations' __license__ = 'MIT' __uri__ = '' from pandas import DataFrame , Series import math import numpy as np #### CUSTOM LIBRARY #### def poly_trans ( S0 , ** kwargs ): def _parse ( k , w ): k = k . replace ( 'E' , '' ) return f ' { w } *S0** { k } ' operator = '+' . join ( _parse ( * x ) for x in kwargs . items () if x [ 0 ][ 0 ] in [ 'E' , 'e' ]) return eval ( operator ) def slope ( S0 , unit , radius ): if unit == '\u00b0' : S0 = S0 [ 0 ] . apply ( lambda x : math . sin ( math . radians ( x ))) return S0 * radius def aligned ( func ): def wrap_align ( left , right ): left = left . copy () right = right . copy () try : left . columns = list ( range ( len ( left . columns ))) except AttributeError : left . name = 0 try : right . columns = list ( range ( len ( right . columns ))) except AttributeError : right . name = 0 left , right = left . align ( right , axis = 0 , copy = False ) mask = left . notna ()[ 0 ] right = right . fillna ( method = 'pad' ) return func ( left [ mask ], right [ mask ]) return wrap_align @aligned def add ( left , right ): right = right . fillna ( 0 ) return left + right @aligned def sub ( left , right ): right = right . fillna ( 0 ) return left - right def filter ( b ): d = abs ( b - b . rolling ( window = 50 , center = True , min_periods = 1 ) . apply ( np . mean )) std = abs ( b . rolling ( window = 50 , center = True , min_periods = 1 ) . apply ( np . std )) return b [ d < 3 * std ] def int_or_str ( value ): try : return int ( value ) except ValueError : return value VERSION = tuple ( map ( int_or_str , __version__ . split ( '.' ))) __all__ = [ 'poly_trans' , 'add' , 'sub' , 'slope' ] Functions add def add ( left , right ) View Source def wrap_align ( left , right ) : left = left . copy () right = right . copy () try : left . columns = list ( range ( len ( left . columns ))) except AttributeError : left . name = 0 try : right . columns = list ( range ( len ( right . columns ))) except AttributeError : right . name = 0 left , right = left . align ( right , axis = 0 , copy = False ) mask = left . notna () [ 0 ] right = right . fillna ( method = 'pad' ) return func ( left [ mask ] , right [ mask ] ) poly_trans def poly_trans ( S0 , ** kwargs ) View Source def poly_trans ( S0 , ** kwargs ): def _parse ( k , w ): k = k . replace ( 'E' , '' ) return f '{w}*S0**{k}' operator = '+' . join ( _parse ( * x ) for x in kwargs . items () if x [ 0 ][ 0 ] in [ 'E' , 'e' ]) return eval ( operator ) slope def slope ( S0 , unit , radius ) View Source def slope ( S0 , unit , radius ): if unit == '\u00b0' : S0 = S0 [ 0 ]. apply ( lambda x : math . sin ( math . radians ( x ))) return S0 * radius sub def sub ( left , right ) View Source def wrap_align ( left , right ) : left = left . copy () right = right . copy () try : left . columns = list ( range ( len ( left . columns ))) except AttributeError : left . name = 0 try : right . columns = list ( range ( len ( right . columns ))) except AttributeError : right . name = 0 left , right = left . align ( right , axis = 0 , copy = False ) mask = left . notna () [ 0 ] right = right . fillna ( method = 'pad' ) return func ( left [ mask ] , right [ mask ] )","title":"Calculation"},{"location":"reference/hielen2/data/calculation/#module-hielen2datacalculation","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 #!/usr/bin/env python # coding=utf-8 __name__ = 'hielen2.series.calculation' __version__ = '0.0.1' __author__ = 'Alessandro Modesti' __email__ = 'it@img-srl.com' __description__ = 'hub for hielen calculations' __license__ = 'MIT' __uri__ = '' from pandas import DataFrame , Series import math import numpy as np #### CUSTOM LIBRARY #### def poly_trans ( S0 , ** kwargs ): def _parse ( k , w ): k = k . replace ( 'E' , '' ) return f ' { w } *S0** { k } ' operator = '+' . join ( _parse ( * x ) for x in kwargs . items () if x [ 0 ][ 0 ] in [ 'E' , 'e' ]) return eval ( operator ) def slope ( S0 , unit , radius ): if unit == '\u00b0' : S0 = S0 [ 0 ] . apply ( lambda x : math . sin ( math . radians ( x ))) return S0 * radius def aligned ( func ): def wrap_align ( left , right ): left = left . copy () right = right . copy () try : left . columns = list ( range ( len ( left . columns ))) except AttributeError : left . name = 0 try : right . columns = list ( range ( len ( right . columns ))) except AttributeError : right . name = 0 left , right = left . align ( right , axis = 0 , copy = False ) mask = left . notna ()[ 0 ] right = right . fillna ( method = 'pad' ) return func ( left [ mask ], right [ mask ]) return wrap_align @aligned def add ( left , right ): right = right . fillna ( 0 ) return left + right @aligned def sub ( left , right ): right = right . fillna ( 0 ) return left - right def filter ( b ): d = abs ( b - b . rolling ( window = 50 , center = True , min_periods = 1 ) . apply ( np . mean )) std = abs ( b . rolling ( window = 50 , center = True , min_periods = 1 ) . apply ( np . std )) return b [ d < 3 * std ] def int_or_str ( value ): try : return int ( value ) except ValueError : return value VERSION = tuple ( map ( int_or_str , __version__ . split ( '.' ))) __all__ = [ 'poly_trans' , 'add' , 'sub' , 'slope' ]","title":"Module hielen2.data.calculation"},{"location":"reference/hielen2/data/calculation/#functions","text":"","title":"Functions"},{"location":"reference/hielen2/data/calculation/#add","text":"def add ( left , right ) View Source def wrap_align ( left , right ) : left = left . copy () right = right . copy () try : left . columns = list ( range ( len ( left . columns ))) except AttributeError : left . name = 0 try : right . columns = list ( range ( len ( right . columns ))) except AttributeError : right . name = 0 left , right = left . align ( right , axis = 0 , copy = False ) mask = left . notna () [ 0 ] right = right . fillna ( method = 'pad' ) return func ( left [ mask ] , right [ mask ] )","title":"add"},{"location":"reference/hielen2/data/calculation/#poly_trans","text":"def poly_trans ( S0 , ** kwargs ) View Source def poly_trans ( S0 , ** kwargs ): def _parse ( k , w ): k = k . replace ( 'E' , '' ) return f '{w}*S0**{k}' operator = '+' . join ( _parse ( * x ) for x in kwargs . items () if x [ 0 ][ 0 ] in [ 'E' , 'e' ]) return eval ( operator )","title":"poly_trans"},{"location":"reference/hielen2/data/calculation/#slope","text":"def slope ( S0 , unit , radius ) View Source def slope ( S0 , unit , radius ): if unit == '\u00b0' : S0 = S0 [ 0 ]. apply ( lambda x : math . sin ( math . radians ( x ))) return S0 * radius","title":"slope"},{"location":"reference/hielen2/data/calculation/#sub","text":"def sub ( left , right ) View Source def wrap_align ( left , right ) : left = left . copy () right = right . copy () try : left . columns = list ( range ( len ( left . columns ))) except AttributeError : left . name = 0 try : right . columns = list ( range ( len ( right . columns ))) except AttributeError : right . name = 0 left , right = left . align ( right , axis = 0 , copy = False ) mask = left . notna () [ 0 ] right = right . fillna ( method = 'pad' ) return func ( left [ mask ] , right [ mask ] )","title":"sub"},{"location":"reference/hielen2/data/data_access_layer/","text":"Module hielen2.data.data_access_layer View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 #!/usr/bin/env python # coding=utf-8 from pandas import DataFrame from time import time from concurrent.futures import ThreadPoolExecutor from functools import wraps from numpy import nan , unique from importlib import import_module from hielen2 import db from hielen2.utils import isot2ut , ut2isot def _threadpool ( f ): @wraps ( f ) def wrap ( * args , ** kwargs ): return ThreadPoolExecutor () . submit ( f , * args , ** kwargs ) return wrap class Series (): def __init__ ( self , code ): series_info = db [ 'series' ][ code ] self . __dict__ . update ( series_info ) geninfo = dict (( k , w ) for k , w in series_info . items () if k in ( \"modules\" , \"operator\" , \"operands\" ) ) self . generator = Generator ( ** geninfo ) @_threadpool def thdata ( self , timefrom = None , timeto = None , * args , ** kwargs ): return self . data ( timefrom , timeto ) def data ( self , timefrom = None , timeto = None ): if timefrom is not None : if self . first is not None : timefrom = max ( self . first , timefrom ) else : timefrom = self . first if timeto is not None : if self . last is not None : timeto = min ( self . last , timeto ) else : timeto = self . last try : out = db [ 'datacache' ][ self . code ] . to_frame () if timefrom is not None and out . index . max () < timefrom : out = out . tail ( 1 ) else : out = out [ timefrom : timeto ] except KeyError : out = DataFrame () timefrom2 = out . index . max () if timefrom2 is nan : timefrom2 = timefrom else : #timefrom2 = max(isot2ut(timefrom2),isot2ut(timefrom) or 1) timefrom2 = max ( isot2ut ( timefrom2 ), isot2ut ( timefrom ) or 1 ) timefrom2 = ut2isot ( timefrom2 ) gen = self . generator . _generate ( timefrom = timefrom2 , timeto = timeto ) try : gen = gen . to_frame () except AttributeError : pass gen . columns = list ( range ( gen . columns . __len__ ())) out = out . append ( gen ) . sort_index () idx = unique ( out . index . values , return_index = True )[ 1 ] out = out . iloc [ idx ] out . index . name = 'timestamp' return out class Generator : def __init__ ( self , modules = None , operator = None , operands = None ): self . operator = operator or 'DataFrame()' self . modules = {} if not modules is None : for k , m in modules . items (): self . operator = self . operator . replace ( k , f 'self.modules[ { k !r} ]' ) self . modules [ k ] = import_module ( m ) self . operands = {} if operands is not None : self . operands = dict ( Generator . _parse_operand ( * op ) for op in operands . items () ) def _parse_operand ( key , value ): ''' trying to extract a series ''' try : return ( key , Series ( value )) except KeyError : pass ''' trying to extract element attribute ''' try : v = value . split ( '.' ) assert ( v . __len__ () == 2 ) return ( key , db [ 'elements' ][ v [ 0 ]][ v [ 1 ]]) except Exception : pass ''' giving up. It should be a scalar. return it ''' return ( key , value ) def _generate ( self , timefrom , timeto ): operands = dict ( timefrom = timefrom , timeto = timeto ) operands . update ( { k : w for k , w in self . operands . items () if not isinstance ( w , Series ) }) runners = { k : w . thdata ( timefrom , timeto ) for k , w in self . operands . items () if isinstance ( w , Series ) } operands . update ( { k : w . result () for k , w in runners . items () } ) #operands.update( { k:w.data(timefrom,timeto) for k,w in self.operands.items() if isinstance(w,Series) } ) #print('OPERANDI',operands) #print('OPERATORE', self.operator) return eval ( self . operator ) Variables db nan Classes Generator class Generator ( modules = None , operator = None , operands = None ) View Source class Generator : def __init__ ( self , modules = None , operator = None , operands = None ) : self . operator = operator or 'DataFrame()' self . modules = {} if not modules is None : for k , m in modules . items () : self . operator = self . operator . replace ( k , f 'self.modules[{k!r}]' ) self . modules [ k ]= import_module ( m ) self . operands = {} if operands is not None : self . operands = dict ( Generator . _parse_operand ( * op ) for op in operands . items () ) def _parse_operand ( key , value ) : ''' trying to extract a series ''' try : return ( key , Series ( value )) except KeyError : pass ''' trying to extract element attribute ''' try : v = value . split ( '.' ) assert ( v . __len__ () == 2 ) return ( key , db [ 'elements' ][ v[0 ] ] [ v[1 ] ] ) except Exception : pass ''' giving up. It should be a scalar. return it ''' return ( key , value ) def _generate ( self , timefrom , timeto ) : operands = dict ( timefrom = timefrom , timeto = timeto ) operands . update ( { k : w for k , w in self . operands . items () if not isinstance ( w , Series ) } ) runners = { k : w . thdata ( timefrom , timeto ) for k , w in self . operands . items () if isinstance ( w , Series ) } operands . update ( { k : w . result () for k , w in runners . items () } ) #operands . update ( { k : w . data ( timefrom , timeto ) for k , w in self . operands . items () if isinstance ( w , Series ) } ) #print ( 'OPERANDI' , operands ) #print ( 'OPERATORE' , self . operator ) return eval ( self . operator ) Series class Series ( code ) View Source class Series () : def __init__ ( self , code ) : series_info = db [ 'series' ][ code ] self . __dict__ . update ( series_info ) geninfo = dict (( k , w ) for k , w in series_info . items () if k in ( \"modules\" , \"operator\" , \"operands\" ) ) self . generator = Generator ( ** geninfo ) @_threadpool def thdata ( self , timefrom = None , timeto = None , * args , ** kwargs ) : return self . data ( timefrom , timeto ) def data ( self , timefrom = None , timeto = None ) : if timefrom is not None : if self . first is not None : timefrom = max ( self . first , timefrom ) else : timefrom = self . first if timeto is not None : if self . last is not None : timeto = min ( self . last , timeto ) else : timeto = self . last try : out = db [ 'datacache' ][ self.code ] . to_frame () if timefrom is not None and out . index . max () < timefrom : out = out . tail ( 1 ) else : out = out [ timefrom:timeto ] except KeyError : out = DataFrame () timefrom2 = out . index . max () if timefrom2 is nan : timefrom2 = timefrom else : #timefrom2 = max ( isot2ut ( timefrom2 ), isot2ut ( timefrom ) or 1 ) timefrom2 = max ( isot2ut ( timefrom2 ), isot2ut ( timefrom ) or 1 ) timefrom2 = ut2isot ( timefrom2 ) gen = self . generator . _generate ( timefrom = timefrom2 , timeto = timeto ) try : gen = gen . to_frame () except AttributeError : pass gen . columns = list ( range ( gen . columns . __len__ ())) out = out . append ( gen ). sort_index () idx = unique ( out . index . values , return_index = True ) [ 1 ] out = out . iloc [ idx ] out . index . name = 'timestamp' return out Methods data def data ( self , timefrom = None , timeto = None ) View Source def data ( self , timefrom = None , timeto = None ): if timefrom is not None : if self . first is not None : timefrom = max ( self . first , timefrom ) else : timefrom = self . first if timeto is not None : if self . last is not None : timeto = min ( self . last , timeto ) else : timeto = self . last try : out = db [ 'datacache' ][ self . code ]. to_frame () if timefrom is not None and out . index . max () < timefrom : out = out . tail ( 1 ) else : out = out [ timefrom : timeto ] except KeyError : out = DataFrame () timefrom2 = out . index . max () if timefrom2 is nan : timefrom2 = timefrom else : # timefrom2 = max ( isot2ut ( timefrom2 ), isot2ut ( timefrom ) or 1 ) timefrom2 = max ( isot2ut ( timefrom2 ), isot2ut ( timefrom ) or 1 ) timefrom2 = ut2isot ( timefrom2 ) gen = self . generator . _generate ( timefrom = timefrom2 , timeto = timeto ) try : gen = gen . to_frame () except AttributeError : pass gen . columns = list ( range ( gen . columns . __len__ ())) out = out . append ( gen ). sort_index () idx = unique ( out . index . values , return_index = True )[ 1 ] out = out . iloc [ idx ] out . index . name = 'timestamp' return out thdata def thdata ( self , timefrom = None , timeto = None , * args , ** kwargs ) View Source @_threadpool def thdata ( self , timefrom = None , timeto = None , * args , ** kwargs ) : return self . data ( timefrom , timeto )","title":"Data Access Layer"},{"location":"reference/hielen2/data/data_access_layer/#module-hielen2datadata_access_layer","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 #!/usr/bin/env python # coding=utf-8 from pandas import DataFrame from time import time from concurrent.futures import ThreadPoolExecutor from functools import wraps from numpy import nan , unique from importlib import import_module from hielen2 import db from hielen2.utils import isot2ut , ut2isot def _threadpool ( f ): @wraps ( f ) def wrap ( * args , ** kwargs ): return ThreadPoolExecutor () . submit ( f , * args , ** kwargs ) return wrap class Series (): def __init__ ( self , code ): series_info = db [ 'series' ][ code ] self . __dict__ . update ( series_info ) geninfo = dict (( k , w ) for k , w in series_info . items () if k in ( \"modules\" , \"operator\" , \"operands\" ) ) self . generator = Generator ( ** geninfo ) @_threadpool def thdata ( self , timefrom = None , timeto = None , * args , ** kwargs ): return self . data ( timefrom , timeto ) def data ( self , timefrom = None , timeto = None ): if timefrom is not None : if self . first is not None : timefrom = max ( self . first , timefrom ) else : timefrom = self . first if timeto is not None : if self . last is not None : timeto = min ( self . last , timeto ) else : timeto = self . last try : out = db [ 'datacache' ][ self . code ] . to_frame () if timefrom is not None and out . index . max () < timefrom : out = out . tail ( 1 ) else : out = out [ timefrom : timeto ] except KeyError : out = DataFrame () timefrom2 = out . index . max () if timefrom2 is nan : timefrom2 = timefrom else : #timefrom2 = max(isot2ut(timefrom2),isot2ut(timefrom) or 1) timefrom2 = max ( isot2ut ( timefrom2 ), isot2ut ( timefrom ) or 1 ) timefrom2 = ut2isot ( timefrom2 ) gen = self . generator . _generate ( timefrom = timefrom2 , timeto = timeto ) try : gen = gen . to_frame () except AttributeError : pass gen . columns = list ( range ( gen . columns . __len__ ())) out = out . append ( gen ) . sort_index () idx = unique ( out . index . values , return_index = True )[ 1 ] out = out . iloc [ idx ] out . index . name = 'timestamp' return out class Generator : def __init__ ( self , modules = None , operator = None , operands = None ): self . operator = operator or 'DataFrame()' self . modules = {} if not modules is None : for k , m in modules . items (): self . operator = self . operator . replace ( k , f 'self.modules[ { k !r} ]' ) self . modules [ k ] = import_module ( m ) self . operands = {} if operands is not None : self . operands = dict ( Generator . _parse_operand ( * op ) for op in operands . items () ) def _parse_operand ( key , value ): ''' trying to extract a series ''' try : return ( key , Series ( value )) except KeyError : pass ''' trying to extract element attribute ''' try : v = value . split ( '.' ) assert ( v . __len__ () == 2 ) return ( key , db [ 'elements' ][ v [ 0 ]][ v [ 1 ]]) except Exception : pass ''' giving up. It should be a scalar. return it ''' return ( key , value ) def _generate ( self , timefrom , timeto ): operands = dict ( timefrom = timefrom , timeto = timeto ) operands . update ( { k : w for k , w in self . operands . items () if not isinstance ( w , Series ) }) runners = { k : w . thdata ( timefrom , timeto ) for k , w in self . operands . items () if isinstance ( w , Series ) } operands . update ( { k : w . result () for k , w in runners . items () } ) #operands.update( { k:w.data(timefrom,timeto) for k,w in self.operands.items() if isinstance(w,Series) } ) #print('OPERANDI',operands) #print('OPERATORE', self.operator) return eval ( self . operator )","title":"Module hielen2.data.data_access_layer"},{"location":"reference/hielen2/data/data_access_layer/#variables","text":"db nan","title":"Variables"},{"location":"reference/hielen2/data/data_access_layer/#classes","text":"","title":"Classes"},{"location":"reference/hielen2/data/data_access_layer/#generator","text":"class Generator ( modules = None , operator = None , operands = None ) View Source class Generator : def __init__ ( self , modules = None , operator = None , operands = None ) : self . operator = operator or 'DataFrame()' self . modules = {} if not modules is None : for k , m in modules . items () : self . operator = self . operator . replace ( k , f 'self.modules[{k!r}]' ) self . modules [ k ]= import_module ( m ) self . operands = {} if operands is not None : self . operands = dict ( Generator . _parse_operand ( * op ) for op in operands . items () ) def _parse_operand ( key , value ) : ''' trying to extract a series ''' try : return ( key , Series ( value )) except KeyError : pass ''' trying to extract element attribute ''' try : v = value . split ( '.' ) assert ( v . __len__ () == 2 ) return ( key , db [ 'elements' ][ v[0 ] ] [ v[1 ] ] ) except Exception : pass ''' giving up. It should be a scalar. return it ''' return ( key , value ) def _generate ( self , timefrom , timeto ) : operands = dict ( timefrom = timefrom , timeto = timeto ) operands . update ( { k : w for k , w in self . operands . items () if not isinstance ( w , Series ) } ) runners = { k : w . thdata ( timefrom , timeto ) for k , w in self . operands . items () if isinstance ( w , Series ) } operands . update ( { k : w . result () for k , w in runners . items () } ) #operands . update ( { k : w . data ( timefrom , timeto ) for k , w in self . operands . items () if isinstance ( w , Series ) } ) #print ( 'OPERANDI' , operands ) #print ( 'OPERATORE' , self . operator ) return eval ( self . operator )","title":"Generator"},{"location":"reference/hielen2/data/data_access_layer/#series","text":"class Series ( code ) View Source class Series () : def __init__ ( self , code ) : series_info = db [ 'series' ][ code ] self . __dict__ . update ( series_info ) geninfo = dict (( k , w ) for k , w in series_info . items () if k in ( \"modules\" , \"operator\" , \"operands\" ) ) self . generator = Generator ( ** geninfo ) @_threadpool def thdata ( self , timefrom = None , timeto = None , * args , ** kwargs ) : return self . data ( timefrom , timeto ) def data ( self , timefrom = None , timeto = None ) : if timefrom is not None : if self . first is not None : timefrom = max ( self . first , timefrom ) else : timefrom = self . first if timeto is not None : if self . last is not None : timeto = min ( self . last , timeto ) else : timeto = self . last try : out = db [ 'datacache' ][ self.code ] . to_frame () if timefrom is not None and out . index . max () < timefrom : out = out . tail ( 1 ) else : out = out [ timefrom:timeto ] except KeyError : out = DataFrame () timefrom2 = out . index . max () if timefrom2 is nan : timefrom2 = timefrom else : #timefrom2 = max ( isot2ut ( timefrom2 ), isot2ut ( timefrom ) or 1 ) timefrom2 = max ( isot2ut ( timefrom2 ), isot2ut ( timefrom ) or 1 ) timefrom2 = ut2isot ( timefrom2 ) gen = self . generator . _generate ( timefrom = timefrom2 , timeto = timeto ) try : gen = gen . to_frame () except AttributeError : pass gen . columns = list ( range ( gen . columns . __len__ ())) out = out . append ( gen ). sort_index () idx = unique ( out . index . values , return_index = True ) [ 1 ] out = out . iloc [ idx ] out . index . name = 'timestamp' return out","title":"Series"},{"location":"reference/hielen2/data/data_access_layer/#methods","text":"","title":"Methods"},{"location":"reference/hielen2/data/data_access_layer/#data","text":"def data ( self , timefrom = None , timeto = None ) View Source def data ( self , timefrom = None , timeto = None ): if timefrom is not None : if self . first is not None : timefrom = max ( self . first , timefrom ) else : timefrom = self . first if timeto is not None : if self . last is not None : timeto = min ( self . last , timeto ) else : timeto = self . last try : out = db [ 'datacache' ][ self . code ]. to_frame () if timefrom is not None and out . index . max () < timefrom : out = out . tail ( 1 ) else : out = out [ timefrom : timeto ] except KeyError : out = DataFrame () timefrom2 = out . index . max () if timefrom2 is nan : timefrom2 = timefrom else : # timefrom2 = max ( isot2ut ( timefrom2 ), isot2ut ( timefrom ) or 1 ) timefrom2 = max ( isot2ut ( timefrom2 ), isot2ut ( timefrom ) or 1 ) timefrom2 = ut2isot ( timefrom2 ) gen = self . generator . _generate ( timefrom = timefrom2 , timeto = timeto ) try : gen = gen . to_frame () except AttributeError : pass gen . columns = list ( range ( gen . columns . __len__ ())) out = out . append ( gen ). sort_index () idx = unique ( out . index . values , return_index = True )[ 1 ] out = out . iloc [ idx ] out . index . name = 'timestamp' return out","title":"data"},{"location":"reference/hielen2/data/data_access_layer/#thdata","text":"def thdata ( self , timefrom = None , timeto = None , * args , ** kwargs ) View Source @_threadpool def thdata ( self , timefrom = None , timeto = None , * args , ** kwargs ) : return self . data ( timefrom , timeto )","title":"thdata"},{"location":"reference/hielen2/data/sources/","text":"Module hielen2.data.sources Sub-modules hielen2.data.sources.csv hielen2.data.sources.smori hielen2.data.sources.winecap","title":"Index"},{"location":"reference/hielen2/data/sources/#module-hielen2datasources","text":"","title":"Module hielen2.data.sources"},{"location":"reference/hielen2/data/sources/#sub-modules","text":"hielen2.data.sources.csv hielen2.data.sources.smori hielen2.data.sources.winecap","title":"Sub-modules"},{"location":"reference/hielen2/data/sources/csv/","text":"Module hielen2.data.sources.csv View Source # coding: utf-8 from pandas import DataFrame , Series , to_datetime , read_csv import json import requests def get_ch ( path = './incomes' , restype = None , resource = None , filename = 'last_load.csv' , column = None , timefrom = None , timeto = None ): return GWO ( path , restype , filename ) . getDataSeries ( resource = resource , column = column , timefrom = timefrom , timeto = timeto ) class GWO (): def __init__ ( self , path = './incomes' , restype = None , filename = 'last_load.csv' ): self . path = path self . restype = restype self . filename = filename def getDataSeries ( self , resource = None , column = None , timefrom = None , timeto = None ): out = read_csv ( f \"{self.path}/{self.restype}/{resource}/{self.filename}\" , header = None , index_col = [ 0 ])[ column ] #out.index=to_datetime(out.index) out = out . loc [ timefrom : timeto ] return out Functions get_ch def get_ch ( path = './incomes' , restype = None , resource = None , filename = 'last_load.csv' , column = None , timefrom = None , timeto = None ) View Source def get_ch ( path = './incomes' , restype = None , resource = None , filename = 'last_load.csv' , column = None , timefrom = None , timeto = None ): return GWO ( path , restype , filename ). getDataSeries ( resource = resource , column = column , timefrom = timefrom , timeto = timeto ) Classes GWO class GWO ( path = './incomes' , restype = None , filename = 'last_load.csv' ) View Source class GWO () : def __init__ ( self , path = './incomes' , restype = None , filename = 'last_load.csv' ) : self . path = path self . restype = restype self . filename = filename def getDataSeries ( self , resource = None , column = None , timefrom = None , timeto = None ) : out = read_csv ( f \"{self.path}/{self.restype}/{resource}/{self.filename}\" , header = None , index_col =[ 0 ] ) [ column ] #out . index = to_datetime ( out . index ) out = out . loc [ timefrom:timeto ] return out Methods getDataSeries def getDataSeries ( self , resource = None , column = None , timefrom = None , timeto = None ) View Source def getDataSeries ( self , resource = None , column = None , timefrom = None , timeto = None ) : out = read_csv ( f \"{self.path}/{self.restype}/{resource}/{self.filename}\" , header = None , index_col =[ 0 ] ) [ column ] #out . index = to_datetime ( out . index ) out = out . loc [ timefrom:timeto ] return out","title":"Csv"},{"location":"reference/hielen2/data/sources/csv/#module-hielen2datasourcescsv","text":"View Source # coding: utf-8 from pandas import DataFrame , Series , to_datetime , read_csv import json import requests def get_ch ( path = './incomes' , restype = None , resource = None , filename = 'last_load.csv' , column = None , timefrom = None , timeto = None ): return GWO ( path , restype , filename ) . getDataSeries ( resource = resource , column = column , timefrom = timefrom , timeto = timeto ) class GWO (): def __init__ ( self , path = './incomes' , restype = None , filename = 'last_load.csv' ): self . path = path self . restype = restype self . filename = filename def getDataSeries ( self , resource = None , column = None , timefrom = None , timeto = None ): out = read_csv ( f \"{self.path}/{self.restype}/{resource}/{self.filename}\" , header = None , index_col = [ 0 ])[ column ] #out.index=to_datetime(out.index) out = out . loc [ timefrom : timeto ] return out","title":"Module hielen2.data.sources.csv"},{"location":"reference/hielen2/data/sources/csv/#functions","text":"","title":"Functions"},{"location":"reference/hielen2/data/sources/csv/#get_ch","text":"def get_ch ( path = './incomes' , restype = None , resource = None , filename = 'last_load.csv' , column = None , timefrom = None , timeto = None ) View Source def get_ch ( path = './incomes' , restype = None , resource = None , filename = 'last_load.csv' , column = None , timefrom = None , timeto = None ): return GWO ( path , restype , filename ). getDataSeries ( resource = resource , column = column , timefrom = timefrom , timeto = timeto )","title":"get_ch"},{"location":"reference/hielen2/data/sources/csv/#classes","text":"","title":"Classes"},{"location":"reference/hielen2/data/sources/csv/#gwo","text":"class GWO ( path = './incomes' , restype = None , filename = 'last_load.csv' ) View Source class GWO () : def __init__ ( self , path = './incomes' , restype = None , filename = 'last_load.csv' ) : self . path = path self . restype = restype self . filename = filename def getDataSeries ( self , resource = None , column = None , timefrom = None , timeto = None ) : out = read_csv ( f \"{self.path}/{self.restype}/{resource}/{self.filename}\" , header = None , index_col =[ 0 ] ) [ column ] #out . index = to_datetime ( out . index ) out = out . loc [ timefrom:timeto ] return out","title":"GWO"},{"location":"reference/hielen2/data/sources/csv/#methods","text":"","title":"Methods"},{"location":"reference/hielen2/data/sources/csv/#getdataseries","text":"def getDataSeries ( self , resource = None , column = None , timefrom = None , timeto = None ) View Source def getDataSeries ( self , resource = None , column = None , timefrom = None , timeto = None ) : out = read_csv ( f \"{self.path}/{self.restype}/{resource}/{self.filename}\" , header = None , index_col =[ 0 ] ) [ column ] #out . index = to_datetime ( out . index ) out = out . loc [ timefrom:timeto ] return out","title":"getDataSeries"},{"location":"reference/hielen2/data/sources/smori/","text":"Module hielen2.data.sources.smori View Source # coding: utf-8 from pandas import DataFrame , Series , to_datetime import json import requests def get_ch ( sito = None , id_stazione = None , id_unita = None , id_sensore = None , aggr = 'avg' , timefrom = None , timeto = None ): return GWO () . getDataSeries ( sito = sito , stazione = id_stazione , unita = id_unita , sensore = id_sensore , aggr = 'avg' , timefrom = timefrom , timeto = timeto ) class GWO (): def __init__ ( self , uri = 'https://www.smori.it/tisma/api/v1/sensor_data.php' ): self . uri = uri def getDataSeries ( self , sito = None , stazione = None , unita = None , sensore = None , aggr = 'avg' , timefrom = None , timeto = None ): params = dict ( sito = sito , stazione = stazione , unita = unita , sensore = sensore , ) if aggr is not None : params [ 'aggr' ] = aggr if timefrom is not None : params [ 'dal' ] = timefrom if timefrom is not None : params [ 'al' ] = timeto r = requests . get ( url = self . uri , params = params ) out = DataFrame ( json . loads ( r . text )[ 'data' ]) #print (r.url) if out . empty : return out out = out . set_index ([ 'timestamp' ])[ 'valore' ] out = out . astype ( float , copy = False , errors = 'ignore' ) out . name = f \"{stazione}_{unita}_{sensore}\" out . index = to_datetime ( out . index ) return out Functions get_ch def get_ch ( sito = None , id_stazione = None , id_unita = None , id_sensore = None , aggr = 'avg' , timefrom = None , timeto = None ) View Source def get_ch ( sito = None , id_stazione = None , id_unita = None , id_sensore = None , aggr = 'avg' , timefrom = None , timeto = None ): return GWO (). getDataSeries ( sito = sito , stazione = id_stazione , unita = id_unita , sensore = id_sensore , aggr = 'avg' , timefrom = timefrom , timeto = timeto ) Classes GWO class GWO ( uri = 'https://www.smori.it/tisma/api/v1/sensor_data.php' ) View Source class GWO (): def __init__ ( self , uri = 'https://www.smori.it/tisma/api/v1/sensor_data.php' ): self . uri = uri def getDataSeries ( self , sito = None , stazione = None , unita = None , sensore = None , aggr = 'avg' , timefrom = None , timeto = None ): params = dict ( sito = sito , stazione = stazione , unita = unita , sensore = sensore , ) if aggr is not None: params [ 'aggr' ]= aggr if timefrom is not None: params [ 'dal' ]= timefrom if timefrom is not None: params [ 'al' ]= timeto r = requests . get ( url = self . uri , params = params ) out = DataFrame ( json . loads ( r . text )[ 'data' ]) #print (r.url) if out . empty: return out out = out . set_index ([ 'timestamp' ])[ 'valore' ] out = out . astype ( float , copy = False , errors = 'ignore' ) out . name = f \"{stazione}_{unita}_{sensore}\" out . index = to_datetime ( out . index ) return out Methods getDataSeries def getDataSeries ( self , sito = None , stazione = None , unita = None , sensore = None , aggr = 'avg' , timefrom = None , timeto = None ) View Source def getDataSeries ( self , sito = None , stazione = None , unita = None , sensore = None , aggr = 'avg' , timefrom = None , timeto = None ): params = dict ( sito = sito , stazione = stazione , unita = unita , sensore = sensore , ) if aggr is not None : params [ 'aggr' ] = aggr if timefrom is not None : params [ 'dal' ] = timefrom if timefrom is not None : params [ 'al' ] = timeto r = requests . get ( url = self . uri , params = params ) out = DataFrame ( json . loads ( r . text )[ 'data' ]) # print ( r . url ) if out . empty : return out out = out . set_index ([ 'timestamp' ])[ 'valore' ] out = out . astype ( float , copy = False , errors = 'ignore' ) out . name = f \"{stazione}_{unita}_{sensore}\" out . index = to_datetime ( out . index ) return out","title":"Smori"},{"location":"reference/hielen2/data/sources/smori/#module-hielen2datasourcessmori","text":"View Source # coding: utf-8 from pandas import DataFrame , Series , to_datetime import json import requests def get_ch ( sito = None , id_stazione = None , id_unita = None , id_sensore = None , aggr = 'avg' , timefrom = None , timeto = None ): return GWO () . getDataSeries ( sito = sito , stazione = id_stazione , unita = id_unita , sensore = id_sensore , aggr = 'avg' , timefrom = timefrom , timeto = timeto ) class GWO (): def __init__ ( self , uri = 'https://www.smori.it/tisma/api/v1/sensor_data.php' ): self . uri = uri def getDataSeries ( self , sito = None , stazione = None , unita = None , sensore = None , aggr = 'avg' , timefrom = None , timeto = None ): params = dict ( sito = sito , stazione = stazione , unita = unita , sensore = sensore , ) if aggr is not None : params [ 'aggr' ] = aggr if timefrom is not None : params [ 'dal' ] = timefrom if timefrom is not None : params [ 'al' ] = timeto r = requests . get ( url = self . uri , params = params ) out = DataFrame ( json . loads ( r . text )[ 'data' ]) #print (r.url) if out . empty : return out out = out . set_index ([ 'timestamp' ])[ 'valore' ] out = out . astype ( float , copy = False , errors = 'ignore' ) out . name = f \"{stazione}_{unita}_{sensore}\" out . index = to_datetime ( out . index ) return out","title":"Module hielen2.data.sources.smori"},{"location":"reference/hielen2/data/sources/smori/#functions","text":"","title":"Functions"},{"location":"reference/hielen2/data/sources/smori/#get_ch","text":"def get_ch ( sito = None , id_stazione = None , id_unita = None , id_sensore = None , aggr = 'avg' , timefrom = None , timeto = None ) View Source def get_ch ( sito = None , id_stazione = None , id_unita = None , id_sensore = None , aggr = 'avg' , timefrom = None , timeto = None ): return GWO (). getDataSeries ( sito = sito , stazione = id_stazione , unita = id_unita , sensore = id_sensore , aggr = 'avg' , timefrom = timefrom , timeto = timeto )","title":"get_ch"},{"location":"reference/hielen2/data/sources/smori/#classes","text":"","title":"Classes"},{"location":"reference/hielen2/data/sources/smori/#gwo","text":"class GWO ( uri = 'https://www.smori.it/tisma/api/v1/sensor_data.php' ) View Source class GWO (): def __init__ ( self , uri = 'https://www.smori.it/tisma/api/v1/sensor_data.php' ): self . uri = uri def getDataSeries ( self , sito = None , stazione = None , unita = None , sensore = None , aggr = 'avg' , timefrom = None , timeto = None ): params = dict ( sito = sito , stazione = stazione , unita = unita , sensore = sensore , ) if aggr is not None: params [ 'aggr' ]= aggr if timefrom is not None: params [ 'dal' ]= timefrom if timefrom is not None: params [ 'al' ]= timeto r = requests . get ( url = self . uri , params = params ) out = DataFrame ( json . loads ( r . text )[ 'data' ]) #print (r.url) if out . empty: return out out = out . set_index ([ 'timestamp' ])[ 'valore' ] out = out . astype ( float , copy = False , errors = 'ignore' ) out . name = f \"{stazione}_{unita}_{sensore}\" out . index = to_datetime ( out . index ) return out","title":"GWO"},{"location":"reference/hielen2/data/sources/smori/#methods","text":"","title":"Methods"},{"location":"reference/hielen2/data/sources/smori/#getdataseries","text":"def getDataSeries ( self , sito = None , stazione = None , unita = None , sensore = None , aggr = 'avg' , timefrom = None , timeto = None ) View Source def getDataSeries ( self , sito = None , stazione = None , unita = None , sensore = None , aggr = 'avg' , timefrom = None , timeto = None ): params = dict ( sito = sito , stazione = stazione , unita = unita , sensore = sensore , ) if aggr is not None : params [ 'aggr' ] = aggr if timefrom is not None : params [ 'dal' ] = timefrom if timefrom is not None : params [ 'al' ] = timeto r = requests . get ( url = self . uri , params = params ) out = DataFrame ( json . loads ( r . text )[ 'data' ]) # print ( r . url ) if out . empty : return out out = out . set_index ([ 'timestamp' ])[ 'valore' ] out = out . astype ( float , copy = False , errors = 'ignore' ) out . name = f \"{stazione}_{unita}_{sensore}\" out . index = to_datetime ( out . index ) return out","title":"getDataSeries"},{"location":"reference/hielen2/data/sources/winecap/","text":"Module hielen2.data.sources.winecap View Source # coding: utf-8 from pandas import DataFrame , Series , to_datetime from zeep import Client from zeep.helpers import serialize_object from concurrent.futures import ThreadPoolExecutor from functools import wraps from time import time from hielen.utils import isot2ut ''' sudo apt-get install libxml2-dev libxslt1-dev pip install lxml==4.2.5 zeep ''' #key='80d373db820fea6f8c5f57d125eb509d' key = '04a71268d386d61801824863ad7e2a5d' GWOmac = '00009DEA' def get_ch ( GW = None , LG = None , CH = None , timefrom = None , timeto = None ): return GWO ( mac = GW ) . getDataSeries ( mac = LG , ch = CH , timefrom = timefrom , timeto = timeto ) def threadpool ( f , executor = None ): @wraps ( f ) def wrap ( * args , ** kwargs ): return ThreadPoolExecutor () . submit ( f , * args , ** kwargs ) return wrap class GWO (): def __init__ ( self , key = key , mac = GWOmac , wsdl = 'http://www.winecap.it/winecapws.wsdl' ): self . key = key self . mac = mac self . client = Client ( wsdl = wsdl ) self . _gch = self . client . service . getChannelHistory self . _gsh = self . client . service . getSystemHistory self . _gsl = self . client . service . getSensorList def getSensorsList ( self ): return DataFrame ( serialize_object ( self . _gsl ( self . key , self . mac ))) def getDataSeries ( self , mac , ch , timefrom = None , timeto = None ): if not isinstance ( timefrom , int ): timefrom = isot2ut ( timefrom ) if timeto is None : timeto = int ( time ()) if not isinstance ( timeto , int ): timeto = isot2ut ( timeto ) ahead = True out = Series () while ahead : u = DataFrame ( serialize_object ( self . _gch ( self . key , self . mac , mac , ch , timefrom , timeto ))) if u . __len__ () < 1024 : ahead = False if u . __len__ () > 0 : u = u . set_index ([ 'timeStamp' ])[ 'value' ] u . index . names = [ 'timestamp' ] timefrom = u . index . max () + 1 out = out . append ( u ) out = out . sort_index () out . name = f \"{mac}_{ch}\" out . sort_index () out . index = to_datetime ( out . index , unit = 's' ) return out @threadpool def getThreadedSeries ( self , * args , ** kwargs ): return self . getDataSeries ( * args , ** kwargs ) def getDataFrame ( self , reqser = [], timefrom = None , timeto = None ): thds = [ self . getThreadedSeries ( * x , timefrom , timeto ) for x in reqser ] return [ x . result () for x in thds ] def getDataFrameSE ( self , reqser = [], timefrom = None , timeto = None ): return [ self . getDataSeries ( * x , timefrom , timeto ) for x in reqser ] Variables GWOmac key Functions get_ch def get_ch ( GW = None , LG = None , CH = None , timefrom = None , timeto = None ) View Source def get_ch ( GW = None , LG = None , CH = None , timefrom = None , timeto = None ): return GWO ( mac = GW ). getDataSeries ( mac = LG , ch = CH , timefrom = timefrom , timeto = timeto ) threadpool def threadpool ( f , executor = None ) View Source def threadpool ( f , executor = None ) : @wraps ( f ) def wrap ( * args , ** kwargs ) : return ThreadPoolExecutor (). submit ( f , * args , ** kwargs ) return wrap Classes GWO class GWO ( key = '04a71268d386d61801824863ad7e2a5d' , mac = '00009DEA' , wsdl = 'http://www.winecap.it/winecapws.wsdl' ) View Source class GWO () : def __init__ ( self , key = key , mac = GWOmac , wsdl = 'http://www.winecap.it/winecapws.wsdl' ) : self . key = key self . mac = mac self . client = Client ( wsdl = wsdl ) self . _gch = self . client . service . getChannelHistory self . _gsh = self . client . service . getSystemHistory self . _gsl = self . client . service . getSensorList def getSensorsList ( self ) : return DataFrame ( serialize_object ( self . _gsl ( self . key , self . mac ))) def getDataSeries ( self , mac , ch , timefrom = None , timeto = None ) : if not isinstance ( timefrom , int ) : timefrom = isot2ut ( timefrom ) if timeto is None : timeto = int ( time ()) if not isinstance ( timeto , int ) : timeto = isot2ut ( timeto ) ahead = True out = Series () while ahead : u = DataFrame ( serialize_object ( self . _gch ( self . key , self . mac , mac , ch , timefrom , timeto ))) if u . __len__ () < 1024 : ahead = False if u . __len__ () > 0 : u = u . set_index ( [ 'timeStamp' ] ) [ 'value' ] u . index . names =[ 'timestamp' ] timefrom = u . index . max () + 1 out = out . append ( u ) out = out . sort_index () out . name = f \"{mac}_{ch}\" out . sort_index () out . index = to_datetime ( out . index , unit = 's' ) return out @threadpool def getThreadedSeries ( self , * args , ** kwargs ) : return self . getDataSeries ( * args , ** kwargs ) def getDataFrame ( self , reqser = [] , timefrom = None , timeto = None ) : thds =[ self.getThreadedSeries(*x,timefrom,timeto) for x in reqser ] return [ x.result() for x in thds ] def getDataFrameSE ( self , reqser = [] , timefrom = None , timeto = None ) : return [ self.getDataSeries(*x,timefrom,timeto) for x in reqser ] Methods getDataFrame def getDataFrame ( self , reqser = [], timefrom = None , timeto = None ) View Source def getDataFrame ( self , reqser = [], timefrom = None , timeto = None ): thds = [ self . getThreadedSeries ( * x , timefrom , timeto ) for x in reqser ] return [ x . result () for x in thds ] getDataFrameSE def getDataFrameSE ( self , reqser = [], timefrom = None , timeto = None ) View Source def getDataFrameSE ( self , reqser = [], timefrom = None , timeto = None ): return [ self . getDataSeries ( * x , timefrom , timeto ) for x in reqser ] getDataSeries def getDataSeries ( self , mac , ch , timefrom = None , timeto = None ) View Source def getDataSeries ( self , mac , ch , timefrom = None , timeto = None ): if not isinstance ( timefrom , int ): timefrom = isot2ut ( timefrom ) if timeto is None : timeto = int ( time ()) if not isinstance ( timeto , int ): timeto = isot2ut ( timeto ) ahead = True out = Series () while ahead : u = DataFrame ( serialize_object ( self . _gch ( self . key , self . mac , mac , ch , timefrom , timeto ))) if u . __len__ () < 1024 : ahead = False if u . __len__ () > 0 : u = u . set_index ([ 'timeStamp' ])[ 'value' ] u . index . names = [ 'timestamp' ] timefrom = u . index . max () + 1 out = out . append ( u ) out = out . sort_index () out . name = f \"{mac}_{ch}\" out . sort_index () out . index = to_datetime ( out . index , unit = 's' ) return out getSensorsList def getSensorsList ( self ) View Source def getSensorsList ( self ): return DataFrame ( serialize_object ( self . _gsl ( self . key , self . mac ))) getThreadedSeries def getThreadedSeries ( self , * args , ** kwargs ) View Source @threadpool def getThreadedSeries ( self , * args , ** kwargs ) : return self . getDataSeries ( * args , ** kwargs )","title":"Winecap"},{"location":"reference/hielen2/data/sources/winecap/#module-hielen2datasourceswinecap","text":"View Source # coding: utf-8 from pandas import DataFrame , Series , to_datetime from zeep import Client from zeep.helpers import serialize_object from concurrent.futures import ThreadPoolExecutor from functools import wraps from time import time from hielen.utils import isot2ut ''' sudo apt-get install libxml2-dev libxslt1-dev pip install lxml==4.2.5 zeep ''' #key='80d373db820fea6f8c5f57d125eb509d' key = '04a71268d386d61801824863ad7e2a5d' GWOmac = '00009DEA' def get_ch ( GW = None , LG = None , CH = None , timefrom = None , timeto = None ): return GWO ( mac = GW ) . getDataSeries ( mac = LG , ch = CH , timefrom = timefrom , timeto = timeto ) def threadpool ( f , executor = None ): @wraps ( f ) def wrap ( * args , ** kwargs ): return ThreadPoolExecutor () . submit ( f , * args , ** kwargs ) return wrap class GWO (): def __init__ ( self , key = key , mac = GWOmac , wsdl = 'http://www.winecap.it/winecapws.wsdl' ): self . key = key self . mac = mac self . client = Client ( wsdl = wsdl ) self . _gch = self . client . service . getChannelHistory self . _gsh = self . client . service . getSystemHistory self . _gsl = self . client . service . getSensorList def getSensorsList ( self ): return DataFrame ( serialize_object ( self . _gsl ( self . key , self . mac ))) def getDataSeries ( self , mac , ch , timefrom = None , timeto = None ): if not isinstance ( timefrom , int ): timefrom = isot2ut ( timefrom ) if timeto is None : timeto = int ( time ()) if not isinstance ( timeto , int ): timeto = isot2ut ( timeto ) ahead = True out = Series () while ahead : u = DataFrame ( serialize_object ( self . _gch ( self . key , self . mac , mac , ch , timefrom , timeto ))) if u . __len__ () < 1024 : ahead = False if u . __len__ () > 0 : u = u . set_index ([ 'timeStamp' ])[ 'value' ] u . index . names = [ 'timestamp' ] timefrom = u . index . max () + 1 out = out . append ( u ) out = out . sort_index () out . name = f \"{mac}_{ch}\" out . sort_index () out . index = to_datetime ( out . index , unit = 's' ) return out @threadpool def getThreadedSeries ( self , * args , ** kwargs ): return self . getDataSeries ( * args , ** kwargs ) def getDataFrame ( self , reqser = [], timefrom = None , timeto = None ): thds = [ self . getThreadedSeries ( * x , timefrom , timeto ) for x in reqser ] return [ x . result () for x in thds ] def getDataFrameSE ( self , reqser = [], timefrom = None , timeto = None ): return [ self . getDataSeries ( * x , timefrom , timeto ) for x in reqser ]","title":"Module hielen2.data.sources.winecap"},{"location":"reference/hielen2/data/sources/winecap/#variables","text":"GWOmac key","title":"Variables"},{"location":"reference/hielen2/data/sources/winecap/#functions","text":"","title":"Functions"},{"location":"reference/hielen2/data/sources/winecap/#get_ch","text":"def get_ch ( GW = None , LG = None , CH = None , timefrom = None , timeto = None ) View Source def get_ch ( GW = None , LG = None , CH = None , timefrom = None , timeto = None ): return GWO ( mac = GW ). getDataSeries ( mac = LG , ch = CH , timefrom = timefrom , timeto = timeto )","title":"get_ch"},{"location":"reference/hielen2/data/sources/winecap/#threadpool","text":"def threadpool ( f , executor = None ) View Source def threadpool ( f , executor = None ) : @wraps ( f ) def wrap ( * args , ** kwargs ) : return ThreadPoolExecutor (). submit ( f , * args , ** kwargs ) return wrap","title":"threadpool"},{"location":"reference/hielen2/data/sources/winecap/#classes","text":"","title":"Classes"},{"location":"reference/hielen2/data/sources/winecap/#gwo","text":"class GWO ( key = '04a71268d386d61801824863ad7e2a5d' , mac = '00009DEA' , wsdl = 'http://www.winecap.it/winecapws.wsdl' ) View Source class GWO () : def __init__ ( self , key = key , mac = GWOmac , wsdl = 'http://www.winecap.it/winecapws.wsdl' ) : self . key = key self . mac = mac self . client = Client ( wsdl = wsdl ) self . _gch = self . client . service . getChannelHistory self . _gsh = self . client . service . getSystemHistory self . _gsl = self . client . service . getSensorList def getSensorsList ( self ) : return DataFrame ( serialize_object ( self . _gsl ( self . key , self . mac ))) def getDataSeries ( self , mac , ch , timefrom = None , timeto = None ) : if not isinstance ( timefrom , int ) : timefrom = isot2ut ( timefrom ) if timeto is None : timeto = int ( time ()) if not isinstance ( timeto , int ) : timeto = isot2ut ( timeto ) ahead = True out = Series () while ahead : u = DataFrame ( serialize_object ( self . _gch ( self . key , self . mac , mac , ch , timefrom , timeto ))) if u . __len__ () < 1024 : ahead = False if u . __len__ () > 0 : u = u . set_index ( [ 'timeStamp' ] ) [ 'value' ] u . index . names =[ 'timestamp' ] timefrom = u . index . max () + 1 out = out . append ( u ) out = out . sort_index () out . name = f \"{mac}_{ch}\" out . sort_index () out . index = to_datetime ( out . index , unit = 's' ) return out @threadpool def getThreadedSeries ( self , * args , ** kwargs ) : return self . getDataSeries ( * args , ** kwargs ) def getDataFrame ( self , reqser = [] , timefrom = None , timeto = None ) : thds =[ self.getThreadedSeries(*x,timefrom,timeto) for x in reqser ] return [ x.result() for x in thds ] def getDataFrameSE ( self , reqser = [] , timefrom = None , timeto = None ) : return [ self.getDataSeries(*x,timefrom,timeto) for x in reqser ]","title":"GWO"},{"location":"reference/hielen2/data/sources/winecap/#methods","text":"","title":"Methods"},{"location":"reference/hielen2/data/sources/winecap/#getdataframe","text":"def getDataFrame ( self , reqser = [], timefrom = None , timeto = None ) View Source def getDataFrame ( self , reqser = [], timefrom = None , timeto = None ): thds = [ self . getThreadedSeries ( * x , timefrom , timeto ) for x in reqser ] return [ x . result () for x in thds ]","title":"getDataFrame"},{"location":"reference/hielen2/data/sources/winecap/#getdataframese","text":"def getDataFrameSE ( self , reqser = [], timefrom = None , timeto = None ) View Source def getDataFrameSE ( self , reqser = [], timefrom = None , timeto = None ): return [ self . getDataSeries ( * x , timefrom , timeto ) for x in reqser ]","title":"getDataFrameSE"},{"location":"reference/hielen2/data/sources/winecap/#getdataseries","text":"def getDataSeries ( self , mac , ch , timefrom = None , timeto = None ) View Source def getDataSeries ( self , mac , ch , timefrom = None , timeto = None ): if not isinstance ( timefrom , int ): timefrom = isot2ut ( timefrom ) if timeto is None : timeto = int ( time ()) if not isinstance ( timeto , int ): timeto = isot2ut ( timeto ) ahead = True out = Series () while ahead : u = DataFrame ( serialize_object ( self . _gch ( self . key , self . mac , mac , ch , timefrom , timeto ))) if u . __len__ () < 1024 : ahead = False if u . __len__ () > 0 : u = u . set_index ([ 'timeStamp' ])[ 'value' ] u . index . names = [ 'timestamp' ] timefrom = u . index . max () + 1 out = out . append ( u ) out = out . sort_index () out . name = f \"{mac}_{ch}\" out . sort_index () out . index = to_datetime ( out . index , unit = 's' ) return out","title":"getDataSeries"},{"location":"reference/hielen2/data/sources/winecap/#getsensorslist","text":"def getSensorsList ( self ) View Source def getSensorsList ( self ): return DataFrame ( serialize_object ( self . _gsl ( self . key , self . mac )))","title":"getSensorsList"},{"location":"reference/hielen2/data/sources/winecap/#getthreadedseries","text":"def getThreadedSeries ( self , * args , ** kwargs ) View Source @threadpool def getThreadedSeries ( self , * args , ** kwargs ) : return self . getDataSeries ( * args , ** kwargs )","title":"getThreadedSeries"}]}